#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
#######################################################################################
# GEF - Multi-Architecture GDB Enhanced Features for Exploiters & Reverse-Engineers
#
# original: by @_hugsy_
# improvement: by @bata_24
# other improvements: by @XorDante
#
#######################################################################################
#
# GEF is a kick-ass set of commands for X86, ARM, MIPS, PowerPC and SPARC to
# make GDB cool again for exploit dev. It is aimed to be used mostly by exploit
# devs and reversers, to provides additional features to GDB using the Python
# API to assist during the process of dynamic analysis.
#
# GEF fully relies on GDB API and other Linux-specific sources of information
# (such as /proc/<pid>). As a consequence, some of the features might not work
# on custom or hardened systems such as GrSec.
#
# Since January 2020, GEF solely support GDB compiled with Python3 and was tested on
#   * x86-32 & x86-64
#   * arm v5,v6,v7
#   * aarch64 (armv8)
#   * mips & mips64
#   * powerpc & powerpc64
#   * sparc & sparc64
#   * riscv32 & riscv64
#   * s390x
#   * sh4
#   * m68k
#   * alpha
#   * hppa (parisc)
#   * or1k (openrisc)
#   * nios2
#   * microblaze
#   * xtensa
#   * cris
#
# For GEF with Python2 (only) support was moved to the GEF-Legacy
# (https://github.com/hugsy/gef-legacy)
#
# To start: in gdb, type `source /path/to/gef.py`
#
#######################################################################################
#
# gef24 is distributed under the MIT License (MIT)
#
# Copyright (c) 2023-2023 timetravelthree (@XorDante)
# Copyright (c) 2021-2023 bata24 (@bata_24)
#
# This is a fork of GEF (https://github.com/hugsy/gef).
# However, it is specialized for x86 / x64 / ARM / AArch64, and various
# features are added. I hope you find it useful for CTF player, reverser,
# exploit developer, and so on.
#
# Copyright (c) 2013-2023 crazy rabbidz
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
#######################################################################################
# Use this command when check by flake8
# flake8 gef.py --ignore E203,E221,E241,E261,E265,E401,E402,E501,E731
# E203: whitespace before ':'
# E221: multiple spaces before operator
# E241: multiple spaces after ','
# E261: at least two spaces before inline comment
# E265: block comment should start with '# '
# E401: multiple imports on one line
# E402: module level import not at top of file
# E501: line too long (> 79 characters)
# E731: do not assign a lambda expression, use a def
#

from __future__ import print_function, division, absolute_import
print("Loading GEF...")

import abc
import argparse
import binascii
import codecs
import collections
import configparser
import ctypes
import functools
import hashlib
import inspect
import itertools
import json
import math
import multiprocessing
import os
import platform
import re
import site
import socket
import string
import struct
import subprocess
import sys
import tempfile
import time
import traceback
import urllib.request

LEFT_ARROW = " <- "
RIGHT_ARROW = " -> "
DOWN_ARROW = "v"
HORIZONTAL_LINE = "-"
VERTICAL_LINE = "|"
BP_GLYPH = "*"
GEF_PROMPT = "gef> "
GEF_PROMPT_ON = "\001\033[1;32m\002{0:s}\001\033[0m\002".format(GEF_PROMPT)
GEF_PROMPT_OFF = "\001\033[1;31m\002{0:s}\001\033[0m\002".format(GEF_PROMPT)


def http_get(url):
    """Basic HTTP wrapper for GET request. Return the body of the page if HTTP code is OK,
    otherwise return None."""
    try:
        req = urllib.request.Request(url)
        req.add_header('Cache-Control', 'no-cache, no-store')
        http = urllib.request.urlopen(req, timeout=5)
        if http.getcode() != 200:
            return None
        return http.read()
    except Exception:
        return None


def update_gef(argv):
    """Try to update `gef` to the latest version pushed on GitHub master branch.
    Return 0 on success, 1 on failure. """
    gef_local = os.path.realpath(argv[0])
    hash_gef_local = hashlib.sha512(open(gef_local, "rb").read()).digest()
    gef_remote = "https://raw.githubusercontent.com/bata24/gef/dev/gef.py"
    gef_remote_data = http_get(gef_remote)
    if gef_remote_data is None:
        print("[-] Failed to get remote gef")
        return 1

    hash_gef_remote = hashlib.sha512(gef_remote_data).digest()
    if hash_gef_local == hash_gef_remote:
        print("[-] No update")
    else:
        with open(gef_local, "wb") as f:
            f.write(gef_remote_data)
        print("[+] Updated")
    return 0


try:
    import gdb
except ImportError:
    # if out of gdb, the only action allowed is to update gef.py
    if len(sys.argv) == 2 and sys.argv[1].lower() in ("--update", "--upgrade", "-u"):
        sys.exit(update_gef(sys.argv))
    print("[-] gef cannot run as standalone")
    sys.exit(0)

__gef__                         = None
__commands__                    = []
__functions__                   = []
__aliases__                     = []
__config__                      = {}
__watches__                     = {}
__gef_convenience_vars_index__  = 0
__context_messages__            = []
__heap_allocated_list__         = []
__heap_freed_list__             = []
__heap_uaf_watchpoints__        = []
__pie_breakpoints__             = {}
__pie_counter__                 = 1
__gef_default_main_arena__      = "main_arena"
__gef_prev_arch__               = None

DEFAULT_PAGE_ALIGN_SHIFT        = 12
DEFAULT_PAGE_SIZE               = 1 << DEFAULT_PAGE_ALIGN_SHIFT
DEFAULT_PAGE_SIZE_MASK          = ~ (DEFAULT_PAGE_SIZE - 1)
GEF_RC                          = os.getenv("GEF_RC") or os.path.join(os.getenv("HOME") or "~", ".gef.rc")
GEF_TEMP_DIR                    = os.path.join(tempfile.gettempdir(), "gef")
GEF_MAX_STRING_LENGTH           = 0x50

GDB_MIN_VERSION                 = (7, 7)
GDB_VERSION                     = tuple(map(int, re.search(r"(\d+)[^\d]+(\d+)", gdb.VERSION).groups()))

ANSI_SPLIT_RE                   = r"(\033\[[\d;]*m)"

current_elf                     = None
current_arch                    = None
libc_args_definitions           = {}
highlight_table                 = {}


def perf_enable(f):
    """Decorator wrapper to perf."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        import cProfile, pstats, io
        pr = cProfile.Profile()
        pr.enable()
        ret = f(*args, **kwargs)
        pr.disable()
        s = io.StringIO()
        #sortby = pstats.SortKey.CUMULATIVE
        sortby = pstats.SortKey.TIME
        ps = pstats.Stats(pr, stream=s).sort_stats(sortby)
        ps.print_stats(20)
        print(s.getvalue())
        return ret

    return wrapper


def perf_by_line_enable(f):
    """Decorator wrapper to perf."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        import line_profiler, io
        pr = line_profiler.LineProfiler()
        pr.add_function(f)
        pr.enable()
        ret = f(*args, **kwargs)
        pr.disable()
        s = io.StringIO()
        pr.print_stats(stream=s)
        print(s.getvalue())
        return ret

    return wrapper


def reset_gef_caches(all=False):
    """Free all caches. If an object is cached, it will have a callable attribute `cache_clear`
    which will be invoked to purge the function cache. Exceptionally, functions with names
    starting with `__` do not call `clear_cache`."""
    global __gef_default_main_arena__

    for mod in dir(sys.modules["__main__"]): # for global object
        if mod.startswith("__"): # filter
            continue
        obj = getattr(sys.modules["__main__"], mod) # get itself
        if isinstance(obj, type(sys)): # skip if module
            continue

        if hasattr(obj, "cache_clear"):
            obj.cache_clear()

        for attr in dir(obj): # for class method
            if attr.startswith("__"): # filter
                continue
            try:
                child_obj = getattr(obj, attr)
            except TypeError: # for ARM class
                continue
            if hasattr(child_obj, "cache_clear"):
                child_obj.cache_clear()

    if all:
        clear_auxv_cache()
        clear_explored_regions()

    __gef_default_main_arena__ = "main_arena"
    return


def highlight_text(text):
    """Highlight text using highlight_table { match -> color } settings.

    If RegEx is enabled it will create a match group around all items in the
    highlight_table and wrap the specified color in the highlight_table
    around those matches.

    If RegEx is disabled, split by ANSI codes and 'colorify' each match found
    within the specified string."""
    if not highlight_table:
        return text

    if get_gef_setting("highlight.regex"):
        for match, color in highlight_table.items():
            text = re.sub("(" + match + ")", Color.colorify("\\1", color), text)
        return text

    ansiSplit = re.split(ANSI_SPLIT_RE, text)

    for match, color in highlight_table.items():
        for index, val in enumerate(ansiSplit):
            found = val.find(match)
            if found > -1:
                ansiSplit[index] = val.replace(match, Color.colorify(match, color))
                break
        text = "".join(ansiSplit)
        ansiSplit = re.split(ANSI_SPLIT_RE, text)

    return "".join(ansiSplit)


def gef_print(x="", less=False, *args, **kwargs):
    """Wrapper around print(), using string buffering feature."""
    x = highlight_text(x)

    if less:
        try:
            less = which("less")
        except FileNotFoundError:
            less = False
    if less:
        _, tmp_path = tempfile.mkstemp(dir=GEF_TEMP_DIR, suffix=".txt", prefix="gef_print_")
        open(tmp_path, "wb").write(str2bytes(x))
        os.system(f"{less} -R {tmp_path}")
        os.unlink(tmp_path)
        return

    print(x, *args, **kwargs)
    return


class Color:
    """Used to colorify terminal output."""
    colors = {
        "normal"         : "\033[0m",
        "gray"           : "\033[1;30m",
        "light_gray"     : "\033[0;37m",
        "red"            : "\033[31m",
        "green"          : "\033[32m",
        "yellow"         : "\033[33m",
        "blue"           : "\033[34m",
        "pink"           : "\033[35m",
        "cyan"           : "\033[36m",
        "bold"           : "\033[1m",
        "underline"      : "\033[4m",
        "underline_off"  : "\033[24m",
        "highlight"      : "\033[3m",
        "highlight_off"  : "\033[23m",
        "blink"          : "\033[5m",
        "blink_off"      : "\033[25m",
    }

    @staticmethod
    def redify(msg):
        return Color.colorify(msg, "red")

    @staticmethod
    def greenify(msg):
        return Color.colorify(msg, "green")

    @staticmethod
    def blueify(msg):
        return Color.colorify(msg, "blue")

    @staticmethod
    def yellowify(msg):
        return Color.colorify(msg, "yellow")

    @staticmethod
    def grayify(msg):
        return Color.colorify(msg, "gray")

    @staticmethod
    def light_grayify(msg):
        return Color.colorify(msg, "light_gray")

    @staticmethod
    def pinkify(msg):
        return Color.colorify(msg, "pink")

    @staticmethod
    def cyanify(msg):
        return Color.colorify(msg, "cyan")

    @staticmethod
    def boldify(msg):
        return Color.colorify(msg, "bold")

    @staticmethod
    def underlinify(msg):
        return Color.colorify(msg, "underline")

    @staticmethod
    def highlightify(msg):
        return Color.colorify(msg, "highlight")

    @staticmethod
    def blinkify(msg):
        return Color.colorify(msg, "blink")

    @staticmethod
    def colorify(text, attrs):
        """Color text according to the given attributes."""
        if get_gef_setting("gef.disable_color") is True:
            return text

        colors = Color.colors
        msg = [colors[attr] for attr in attrs.split() if attr in colors]
        msg.append(str(text))
        if colors["highlight"] in msg:
            msg.append(colors["highlight_off"])
        if colors["underline"] in msg:
            msg.append(colors["underline_off"])
        if colors["blink"] in msg:
            msg.append(colors["blink_off"])
        msg.append(colors["normal"])
        return "".join(msg)


class Address:
    """GEF representation of memory addresses."""
    def __init__(self, *args, **kwargs):
        self.value = kwargs.get("value", 0)
        self.section = kwargs.get("section", None)
        self.info = kwargs.get("info", None)
        self.valid = kwargs.get("valid", True)
        return

    def __str__(self):
        value = format_address(self.value)
        if self.is_in_text_segment():
            code_color = get_gef_setting("theme.address_code")
            return Color.colorify(value, code_color)
        if self.is_in_heap_segment():
            heap_color = get_gef_setting("theme.address_heap")
            return Color.colorify(value, heap_color)
        if self.is_in_stack_segment():
            stack_color = get_gef_setting("theme.address_stack")
            return Color.colorify(value, stack_color)
        return value

    def is_in_text_segment(self):
        a = hasattr(self.info, "name") and ".text" in self.info.name
        b = hasattr(self.section, "is_executable") and self.section.is_executable()
        return a or b

    def is_in_stack_segment(self):
        return hasattr(self.section, "path") and "[stack]" == self.section.path

    def is_in_heap_segment(self):
        return hasattr(self.section, "path") and "[heap]" == self.section.path

    def dereference(self):
        addr = align_address(int(self.value))
        derefed = dereference(addr)
        return None if derefed is None else int(derefed)


class Permission:
    """GEF representation of Linux permission."""
    NONE    = 0
    READ    = 1
    WRITE   = 2
    EXECUTE = 4
    ALL     = READ | WRITE | EXECUTE

    def __init__(self, **kwargs):
        self.value = kwargs.get("value", 0)
        return

    def __or__(self, value):
        return self.value | value

    def __and__(self, value):
        return self.value & value

    def __xor__(self, value):
        return self.value ^ value

    def __eq__(self, value):
        return self.value == value

    def __ne__(self, value):
        return self.value != value

    def __str__(self):
        perm_str = ""
        perm_str += "r" if self & Permission.READ else "-"
        perm_str += "w" if self & Permission.WRITE else "-"
        perm_str += "x" if self & Permission.EXECUTE else "-"
        return perm_str

    @staticmethod
    def from_info_sections(*args):
        perm = Permission()
        for arg in args:
            if "READONLY" in arg:
                perm.value += Permission.READ
            if "DATA" in arg:
                perm.value += Permission.WRITE
            if "CODE" in arg:
                perm.value += Permission.EXECUTE
        return perm

    @staticmethod
    def from_process_maps(perm_str):
        perm = Permission()
        if perm_str[0] == "r":
            perm.value += Permission.READ
        if perm_str[1] == "w":
            perm.value += Permission.WRITE
        if perm_str[2] == "x":
            perm.value += Permission.EXECUTE
        return perm


class Section:
    """GEF representation of process memory sections."""
    def __init__(self, *args, **kwargs):
        self.page_start = kwargs.get("page_start")
        self.page_end = kwargs.get("page_end")
        self.offset = kwargs.get("offset", 0)
        self.permission = kwargs.get("permission")
        self.inode = kwargs.get("inode", None)
        self.path = kwargs.get("path", "")
        return

    def is_readable(self):
        v = self.permission.value
        return v and bool(v & Permission.READ)

    def is_writable(self):
        v = self.permission.value
        return v and bool(v & Permission.WRITE)

    def is_executable(self):
        v = self.permission.value
        return v and bool(v & Permission.EXECUTE)

    @property
    def size(self):
        if self.page_end is None or self.page_start is None:
            return -1
        return self.page_end - self.page_start

    @property
    def realpath(self):
        return self.path


class Elf:
    """Basic ELF parsing.
    Ref:
    - http://www.skyfree.org/linux/references/ELF_Format.pdf
    - http://refspecs.freestandards.org/elf/elfspec_ppc.pdf
    - http://refspecs.linuxfoundation.org/ELF/ppc64/PPC-elf64abi.html"""
    # e_ident[EI_MAG0:EI_MAG3]
    ELF_MAGIC                = 0x7f454c46

    # e_ident[EI_CLASS]
    ELF_CLASS_NONE           = 0
    ELF_32_BITS              = 1
    ELF_64_BITS              = 2

    # e_ident[EI_DATA]
    ELF_DATA_NONE            = 0
    LITTLE_ENDIAN            = 1
    BIG_ENDIAN               = 2

    # e_ident[EI_OSABI]
    OSABI_SYSTEMV            = 0 # UNIX System V ABI
    OSABI_HPUX               = 1 # Hewlett-Packard HP-UX
    OSABI_NETBSD             = 2 # NetBSD
    OSABI_LINUX              = 3 # GNU Linux
    OSABI_HURD               = 4 # GNU Hurd
    OSABI_86OPEN             = 5 # 86Open Common IA32 ABI
    OSABI_SOLARIS            = 6 # Sun Solaris
    OSABI_AIX                = 7 # IBM AIX
    OSABI_IRIX               = 8 # SGI Irix
    OSABI_FREEBSD            = 9 # FreeBSD
    OSABI_TRU64              = 10 # Compaq TRU64 UNIX
    OSABI_MODESTO            = 11 # Novell Modesto
    OSABI_OPENBSD            = 12 # OpenBSD
    OSABI_OPENVMS            = 13 # OpenVMS
    OSABI_NSK                = 14 # Hewlett-Packard Non-Stop Kernel
    OSABI_AROS               = 15 # Amiga Research OS
    OSABI_FENIXOS            = 16 # The FenixOS highly scalable multi-core OS
    OSABI_CLOUDABI           = 17 # Nuxi CloudABI
    OSABI_OPENVOS            = 18 # Stratus Technologies OpenVOS
    OSABI_ARM_AEABI          = 64 # ARM EABI
    OSABI_ARM                = 97 # ARM
    OSABI_STANDALONE         = 255 # Standalone (embedded) application

    # e_type
    ET_NONE                  = 0
    ET_REL                   = 1
    ET_EXEC                  = 2
    ET_DYN                   = 3
    ET_CORE                  = 4

    # e_machine
    EM_NONE                  = 0 # No machine
    EM_M32                   = 1 # AT&T WE 32100
    EM_SPARC                 = 2 # SUN SPARC
    EM_386                   = 3 # Intel 80386
    EM_68K                   = 4 # Motorola m68k family
    EM_88K                   = 5 # Motorola m88k family
    EM_IAMCU                 = 6 # Intel MCU
    EM_860                   = 7 # Intel 80860
    EM_MIPS                  = 8 # MIPS R3000 big-endian
    EM_S370                  = 9 # IBM System/370 Processor
    EM_MIPS_RS3_LE           = 10 # MIPS RS3000 Little-endian
    #                          11-14 # Reserved for future use
    EM_PARISC                = 15 # Hewlett-Packard PA-RISC
    #                          16 # Reserved for future use
    EM_VPP500                = 17 # Fujitsu VPP500
    EM_SPARC32PLUS           = 18 # Enhanced instruction set SPARC
    EM_960                   = 19 # Intel 80960
    EM_PPC                   = 20 # PowerPC
    EM_PPC64                 = 21 # 64-bit PowerPC
    EM_S390                  = 22 # IBM System/390 Processor
    EM_SPU                   = 23 # IBM SPU/SPC
    #                          24-35 # Reserved for future use
    EM_V800                  = 36 # NEC V800
    EM_FR20                  = 37 # Fujitsu FR20
    EM_RH32                  = 38 # TRW RH-32
    EM_RCE                   = 39 # Motorola RCE
    EM_ARM                   = 40 # ARM 32-bit architecture (AARCH32)
    EM_ALPHA                 = 41 # Digital Alpha
    EM_SH                    = 42 # Hitachi SH
    EM_SPARCV9               = 43 # SPARC Version 9
    EM_TRICORE               = 44 # Siemens TriCore embedded processor
    EM_ARC                   = 45 # Argonaut RISC Core, Argonaut Technologies Inc.
    EM_H8_300                = 46 # Hitachi H8/300
    EM_H8_300H               = 47 # Hitachi H8/300H
    EM_H8S                   = 48 # Hitachi H8S
    EM_H8_500                = 49 # Hitachi H8/500
    EM_IA_64                 = 50 # Intel IA-64 processor architecture
    EM_MIPS_X                = 51 # Stanford MIPS-X
    EM_COLDFIRE              = 52 # Motorola ColdFire
    EM_68HC12                = 53 # Motorola M68HC12
    EM_MMA                   = 54 # Fujitsu MMA Multimedia Accelerator
    EM_PCP                   = 55 # Siemens PCP
    EM_NCPU                  = 56 # Sony nCPU embedded RISC processor
    EM_NDR1                  = 57 # Denso NDR1 microprocessor
    EM_STARCORE              = 58 # Motorola Star*Core processor
    EM_ME16                  = 59 # Toyota ME16 processor
    EM_ST100                 = 60 # STMicroelectronics ST100 processor
    EM_TINYJ                 = 61 # Advanced Logic Corp. TinyJ embedded processor family
    EM_X86_64                = 62 # AMD x86-64 architecture
    EM_PDSP                  = 63 # Sony DSP Processor
    EM_PDP10                 = 64 # Digital Equipment Corp. PDP-10
    EM_PDP11                 = 65 # Digital Equipment Corp. PDP-11
    EM_FX66                  = 66 # Siemens FX66 microcontroller
    EM_ST9PLUS               = 67 # STMicroelectronics ST9+ 8/16 bit microcontroller
    EM_ST7                   = 68 # STMicroelectronics ST7 8-bit microcontroller
    EM_68HC16                = 69 # Motorola MC68HC16 Microcontroller
    EM_68HC11                = 70 # Motorola MC68HC11 Microcontroller
    EM_68HC08                = 71 # Motorola MC68HC08 Microcontroller
    EM_68HC05                = 72 # Motorola MC68HC05 Microcontroller
    EM_SVX                   = 73 # Silicon Graphics SVx
    EM_ST19                  = 74 # STMicroelectronics ST19 8-bit microcontroller
    EM_VAX                   = 75 # Digital VAX
    EM_CRIS                  = 76 # Axis Communications 32-bit embedded processor
    EM_JAVELIN               = 77 # Infineon Technologies 32-bit embedded processor
    EM_FIREPATH              = 78 # Element 14 64-bit DSP Processor
    EM_ZSP                   = 79 # LSI Logic 16-bit DSP Processor
    EM_MMIX                  = 80 # Donald Knuth's educational 64-bit processor
    EM_HUANY                 = 81 # Harvard University machine-independent object files
    EM_PRISM                 = 82 # SiTera Prism
    EM_AVR                   = 83 # Atmel AVR 8-bit microcontroller
    EM_FR30                  = 84 # Fujitsu FR30
    EM_D10V                  = 85 # Mitsubishi D10V
    EM_D30V                  = 86 # Mitsubishi D30V
    EM_V850                  = 87 # NEC v850
    EM_M32R                  = 88 # Mitsubishi M32R
    EM_MN10300               = 89 # Matsushita MN10300
    EM_MN10200               = 90 # Matsushita MN10200
    EM_PJ                    = 91 # picoJava
    EM_OPENRISC              = 92 # OpenRISC 32-bit embedded processor
    EM_ARC_COMPACT           = 93 # ARC International ARCompact processor (old spelling/synonym: EM_ARC_A5)
    EM_XTENSA                = 94 # Tensilica Xtensa Architecture
    EM_VIDEOCORE             = 95 # Alphamosaic VideoCore processor
    EM_TMM_GPP               = 96 # Thompson Multimedia General Purpose Processor
    EM_NS32K                 = 97 # National Semiconductor 32000 series
    EM_TPC                   = 98 # Tenor Network TPC processor
    EM_SNP1K                 = 99 # Trebia SNP 1000 processor
    EM_ST200                 = 100 # STMicroelectronics ST200 microcontroller
    EM_IP2K                  = 101 # Ubicom IP2xxx microcontroller family
    EM_MAX                   = 102 # MAX Processor
    EM_CR                    = 103 # National Semiconductor CompactRISC microprocessor
    EM_F2MC16                = 104 # Fujitsu F2MC16
    EM_MSP430                = 105 # Texas Instruments embedded microcontroller msp430
    EM_BLACKFIN              = 106 # Analog Devices Blackfin (DSP) processor
    EM_SE_C33                = 107 # S1C33 Family of Seiko Epson processors
    EM_SEP                   = 108 # Sharp embedded microprocessor
    EM_ARCA                  = 109 # Arca RISC Microprocessor
    EM_UNICORE               = 110 # Microprocessor series from PKU-Unity Ltd. and MPRC of Peking University
    EM_EXCESS                = 111 # eXcess: 16/32/64-bit configurable embedded CPU
    EM_DXP                   = 112 # Icera Semiconductor Inc. Deep Execution Processor
    EM_ALTERA_NIOS2          = 113 # Altera Nios II soft-core processor
    EM_CRX                   = 114 # National Semiconductor CompactRISC CRX microprocessor
    EM_XGATE                 = 115 # Motorola XGATE embedded processor
    EM_C166                  = 116 # Infineon C16x/XC16x processor
    EM_M16C                  = 117 # Renesas M16C series microprocessors
    EM_DSPIC30F              = 118 # Microchip Technology dsPIC30F Digital Signal Controller
    EM_CE                    = 119 # Freescale Communication Engine RISC core
    EM_M32C                  = 120 # Renesas M32C series microprocessors
    #                          121-130 # Reserved for future use
    EM_TSK3000               = 131 # Altium TSK3000 core
    EM_RS08                  = 132 # Freescale RS08 embedded processor
    EM_SHARC                 = 133 # Analog Devices SHARC family of 32-bit DSP processors
    EM_ECOG2                 = 134 # Cyan Technology eCOG2 microprocessor
    EM_SCORE7                = 135 # Sunplus S+core7 RISC processor
    EM_DSP24                 = 136 # New Japan Radio (NJR) 24-bit DSP Processor
    EM_VIDEOCORE3            = 137 # Broadcom VideoCore III processor
    EM_LATTICEMICO32         = 138 # RISC processor for Lattice FPGA architecture
    EM_SE_C17                = 139 # Seiko Epson C17 family
    EM_TI_C6000              = 140 # The Texas Instruments TMS320C6000 DSP family
    EM_TI_C2000              = 141 # The Texas Instruments TMS320C2000 DSP family
    EM_TI_C5500              = 142 # The Texas Instruments TMS320C55x DSP family
    EM_TI_ARP32              = 143 # Texas Instruments Application Specific RISC Processor, 32bit fetch
    EM_TI_PRU                = 144 # Texas Instruments Programmable Realtime Unit
    #                          145-159 # Reserved for future use
    EM_MMDSP_PLUS            = 160 # STMicroelectronics 64bit VLIW Data Signal Processor
    EM_CYPRESS_M8C           = 161 # Cypress M8C microprocessor
    EM_R32C                  = 162 # Renesas R32C series microprocessors
    EM_TRIMEDIA              = 163 # NXP Semiconductors TriMedia architecture family
    EM_QDSP6                 = 164 # QUALCOMM DSP6 Processor
    EM_8051                  = 165 # Intel 8051 and variants
    EM_STXP7X                = 166 # STMicroelectronics STxP7x family of configurable and extensible RISC processors
    EM_NDS32                 = 167 # Andes Technology compact code size embedded RISC processor family
    EM_ECOG1                 = 168 # Cyan Technology eCOG1X family
    EM_ECOG1X                = 168 # Cyan Technology eCOG1X family
    EM_MAXQ30                = 169 # Dallas Semiconductor MAXQ30 Core Micro-controllers
    EM_XIMO16                = 170 # New Japan Radio (NJR) 16-bit DSP Processor
    EM_MANIK                 = 171 # M2000 Reconfigurable RISC Microprocessor
    EM_CRAYNV2               = 172 # Cray Inc. NV2 vector architecture
    EM_RX                    = 173 # Renesas RX family
    EM_METAG                 = 174 # Imagination Technologies META processor architecture
    EM_MCST_ELBRUS           = 175 # MCST Elbrus general purpose hardware architecture
    EM_ECOG16                = 176 # Cyan Technology eCOG16 family
    EM_CR16                  = 177 # National Semiconductor CompactRISC CR16 16-bit microprocessor
    EM_ETPU                  = 178 # Freescale Extended Time Processing Unit
    EM_SLE9X                 = 179 # Infineon Technologies SLE9X core
    EM_L10M                  = 180 # Intel L10M
    EM_K10M                  = 181 # Intel K10M
    #                          182 # Reserved for future Intel use
    EM_AARCH64               = 183 # ARM 64-bit architecture (AARCH64)
    #                          184 # Reserved for future ARM use
    EM_AVR32                 = 185 # Atmel Corporation 32-bit microprocessor family
    EM_STM8                  = 186 # STMicroeletronics STM8 8-bit microcontroller
    EM_TILE64                = 187 # Tilera TILE64 multicore architecture family
    EM_TILEPRO               = 188 # Tilera TILEPro multicore architecture family
    EM_MICROBLAZE            = 189 # Xilinx MicroBlaze 32-bit RISC soft processor core
    EM_CUDA                  = 190 # NVIDIA CUDA architecture
    EM_TILEGX                = 191 # Tilera TILE-Gx multicore architecture family
    EM_CLOUDSHIELD           = 192 # CloudShield architecture family
    EM_COREA_1ST             = 193 # KIPO-KAIST Core-A 1st generation processor family
    EM_COREA_2ND             = 194 # KIPO-KAIST Core-A 2nd generation processor family
    EM_ARC_COMPACT2          = 195 # Synopsys ARCompact V2
    EM_OPEN8                 = 196 # Open8 8-bit RISC soft processor core
    EM_RL78                  = 197 # Renesas RL78 family
    EM_VIDEOCORE5            = 198 # Broadcom VideoCore V processor
    EM_78KOR                 = 199 # Renesas 78KOR family
    EM_56800EX               = 200 # Freescale 56800EX Digital Signal Controller (DSC)
    EM_BA1                   = 201 # Beyond BA1 CPU architecture
    EM_BA2                   = 202 # Beyond BA2 CPU architecture
    EM_XCORE                 = 203 # XMOS xCORE processor family
    EM_MCHP_PIC              = 204 # Microchip 8-bit PIC(r) family
    EM_INTEL205              = 205 # Reserved by Intel
    EM_INTEL206              = 206 # Reserved by Intel
    EM_INTEL207              = 207 # Reserved by Intel
    EM_INTEL208              = 208 # Reserved by Intel
    EM_INTEL209              = 209 # Reserved by Intel
    EM_KM32                  = 210 # KM211 KM32 32-bit processor
    EM_KMX32                 = 211 # KM211 KMX32 32-bit processor
    EM_KMX16                 = 212 # KM211 KMX16 16-bit processor
    EM_KMX8                  = 213 # KM211 KMX8 8-bit processor
    EM_KVARC                 = 214 # KM211 KVARC processor
    EM_CDP                   = 215 # Paneve CDP architecture family
    EM_COGE                  = 216 # Cognitive Smart Memory Processor
    EM_COOL                  = 217 # Bluechip Systems CoolEngine
    EM_NORC                  = 218 # Nanoradio Optimized RISC
    EM_CSR_KALIMBA           = 219 # CSR Kalimba architecture family
    EM_Z80                   = 220 # Zilog Z80
    EM_VISIUM                = 221 # Controls and Data Services VISIUMcore processor
    EM_FT32                  = 222 # FTDI Chip FT32 high performance 32-bit RISC architecture
    EM_MOXIE                 = 223 # Moxie processor family
    EM_AMDGPU                = 224 # AMD GPU architecture
    #                          225-242 # Reserved
    EM_RISCV                 = 243 # RISC-V
    EM_LANAI                 = 244 # Lanai 32-bit processor
    EM_BPF                   = 247 # Linux BPF -- in-kernel virtual machine
    EM_LOONGARCH             = 258 # LoongArch

    EM_AVR_UNOFFICIAL        = 0x1057 # AVR (unofficial)
    EM_MSP430_UNOFFICIAL     = 0x1059 # MSP430 (unofficial)
    EM_EPIPHANY_UNOFFICIAL   = 0x1223 # Adapteva Epiphany (unofficial)
    EM_AVR32_UNOFFICIAL      = 0x18ad # Atmel AVR32 (unofficial)
    EM_MT_UNOFFICIAL         = 0x2530 # Morpho MT (unofficial)
    EM_FR30_UNOFFICIAL       = 0x3330 # FR30 (unofficial)
    EM_OPENRISC_OLD          = 0x3426 # OpenRISC (obsolete)
    EM_C166_UNOFFICIAL       = 0x4688 # Infineon C166 (unofficial)
    EM_FRV_UNOFFICIAL        = 0x5441 # Cygnus FR-V (unofficial)
    EM_DLX_UNOFFICIAL        = 0x5aa5 # DLX (unofficial)
    EM_D10V_UNOFFICIAL       = 0x7650 # Cygnus D10V (unofficial)
    EM_D30V_UNOFFICIAL       = 0x7676 # Cygnus D30V (unofficial)
    EM_IP2K_UNOFFICIAL       = 0x8217 # Ubicom IP2xxx (unofficial)
    EM_OPENRISC_OLD2         = 0x8472 # OpenRISC (obsolete)
    EM_PPC_UNOFFICIAL        = 0x9025 # Cygnus PowerPC (unofficial)
    EM_ALPHA_UNOFFICIAL      = 0x9026 # Digital Alpha (unofficial)
    EM_M32R_UNOFFICIAL       = 0x9041 # Cygnus M32R (unofficial)
    EM_V850_UNOFFICIAL       = 0x9080 # Cygnus V859 (unofficial)
    EM_S390_OLD              = 0xa390 # IBM S/390 (obsolete)
    EM_XTENSA_UNOFFICIAL     = 0xabc7 # Old Xtensa (unofficial)
    EM_XSTORMY_UNOFFICIAL    = 0xad45 # xstormy16 (unofficial)
    EM_MICROBLAZE_UNOFFICIAL = 0xbaab # Old MicroBlaze (unofficial)
    EM_MN10300_UNOFFICIAL    = 0xbeef # Cygnus MN10300 (unofficial)
    EM_MN10200_UNOFFICIAL    = 0xdead # Cygnus MN10200 (unofficial)
    EM_MEP_UNOFFICIAL        = 0xf00d # Toshiba MeP (unofficial)
    EM_M32C_UNOFFICIAL       = 0xfeb0 # Renesas M32C (unofficial)
    EM_IQ2000_UNOFFICIAL     = 0xfeba # Vitesse IQ2000 (unofficial)
    EM_NIOS_UNOFFICIAL       = 0xfebb # NIOS (unofficial)
    EM_MOXIE_UNOFFICIAL      = 0xfeed # Moxie (unofficial)

    # e_version
    EV_NONE                  = 0
    EV_CURRENT               = 1

    # default values
    e_magic                  = ELF_MAGIC
    e_class                  = ELF_64_BITS
    e_endianness             = LITTLE_ENDIAN
    e_eiversion              = None
    e_osabi                  = None
    e_abiversion             = None
    e_pad                    = None
    e_type                   = ET_EXEC
    e_machine                = EM_X86_64
    e_version                = None
    e_entry                  = 0x00
    e_phoff                  = None
    e_shoff                  = None
    e_flags                  = None
    e_ehsize                 = None
    e_phentsize              = None
    e_phnum                  = None
    e_shentsize              = None
    e_shnum                  = None
    e_shstrndx               = None

    def __init__(self, elf="", minimalist=False):
        """Instantiate an ELF object. The default behavior is to create the object by parsing the ELF file.
        But in some cases (QEMU-stub), we may just want a simple minimal object with default values."""
        if minimalist:
            return

        if isinstance(elf, str):
            if not os.access(elf, os.R_OK):
                err("'{0}' not found/readable".format(elf))
                err("Failed to get file debug information, most of gef features will not work")
                self.e_magic = None
                return
            self.fd = open(elf, "rb")
            self.addr = None
            self.pos = 0
            self.filename = elf
        elif isinstance(elf, int):
            self.fd = None
            self.addr = elf
            self.pos = 0
            self.filename = None
        else:
            raise

        # off 0x0
        self.e_magic, self.e_class, self.e_endianness, self.e_eiversion = struct.unpack(">IBBB", self.read(7))
        # adjust endianness in bin reading
        endian = "<" if self.e_endianness == Elf.LITTLE_ENDIAN else ">"
        # off 0x7
        self.e_osabi, self.e_abiversion = struct.unpack("{}BB".format(endian), self.read(2))
        # off 0x9
        self.e_pad = self.read(7)
        # off 0x10
        self.e_type, self.e_machine, self.e_version = struct.unpack("{}HHI".format(endian), self.read(8))
        # off 0x18
        if self.e_class == Elf.ELF_64_BITS:
            # if arch 64bits
            self.e_entry, self.e_phoff, self.e_shoff = struct.unpack("{}QQQ".format(endian), self.read(24))
        else:
            # else arch 32bits
            self.e_entry, self.e_phoff, self.e_shoff = struct.unpack("{}III".format(endian), self.read(12))
        self.e_flags, self.e_ehsize, self.e_phentsize, self.e_phnum = struct.unpack("{}IHHH".format(endian), self.read(10))
        self.e_shentsize, self.e_shnum, self.e_shstrndx = struct.unpack("{}HHH".format(endian), self.read(6))
        # phdr
        self.phdrs = []
        for i in range(self.e_phnum):
            self.phdrs.append(Phdr(self, self.e_phoff + self.e_phentsize * i))
        # shdr
        self.shdrs = []
        for i in range(self.e_shnum):
            try:
                self.shdrs.append(Shdr(self, self.e_shoff + self.e_shentsize * i))
            except Exception:
                # Perspective failure. Probably it occurs when parsing ELF loaded into memory.
                # Even if the ELF is loaded, the section header is not loaded. Therefore, it is ignored.
                self.shdrs = []
                break
        else:
            # The existence of multiple SHT_NULLs is assumed to be abnormal, and an error is raised.
            if sum([x.sh_type == Shdr.SHT_NULL for x in self.shdrs]) > 1:
                self.shdrs = []

        if self.fd is not None:
            self.fd.close()
            self.fd = None
        return

    def read(self, size):
        if self.fd is not None:
            v = self.fd.read(size)
        elif self.addr is not None:
            v = read_memory(self.addr + self.pos, size)
        else:
            raise
        self.pos += size
        return v

    def seek(self, off):
        if self.fd is not None:
            self.fd.seek(off, 0)
        elif self.addr is not None:
            self.pos = off
        else:
            raise
        return

    def is_valid(self):
        return self.e_magic == Elf.ELF_MAGIC


class Phdr:
    PT_NULL          = 0
    PT_LOAD          = 1
    PT_DYNAMIC       = 2
    PT_INTERP        = 3
    PT_NOTE          = 4
    PT_SHLIB         = 5
    PT_PHDR          = 6
    PT_TLS           = 7
    #PT_LOOS          = 0x60000000
    PT_GNU_EH_FRAME  = 0x6474e550
    PT_GNU_STACK     = 0x6474e551
    PT_GNU_RELRO     = 0x6474e552
    #PT_LOSUNW        = 0x6ffffffa
    PT_SUNWBSS       = 0x6ffffffa
    PT_SUNWSTACK     = 0x6ffffffb
    #PT_HISUNW        = 0x6fffffff
    #PT_HIOS          = 0x6fffffff
    #PT_LOPROC        = 0x70000000
    #PT_HIPROC        = 0x7fffffff
    PT_MIPS_REGINFO  = 0x70000000
    PT_MIPS_RTPROC   = 0x70000001
    PT_MIPS_OPTIONS  = 0x70000002
    PT_MIPS_ABIFLAGS = 0x70000003

    PF_X             = 1
    PF_W             = 2
    PF_R             = 4

    p_type           = None
    p_flags          = None
    p_offset         = None
    p_vaddr          = None
    p_paddr          = None
    p_filesz         = None
    p_memsz          = None
    p_align          = None

    def __init__(self, elf, off):
        if elf is None:
            return None
        elf.seek(off)
        endian = "<" if elf.e_endianness == Elf.LITTLE_ENDIAN else ">"
        if elf.e_class == Elf.ELF_64_BITS:
            self.p_type, self.p_flags, self.p_offset = struct.unpack("{}IIQ".format(endian), elf.read(16))
            self.p_vaddr, self.p_paddr = struct.unpack("{}QQ".format(endian), elf.read(16))
            self.p_filesz, self.p_memsz, self.p_align = struct.unpack("{}QQQ".format(endian), elf.read(24))
        else:
            self.p_type, self.p_offset = struct.unpack("{}II".format(endian), elf.read(8))
            self.p_vaddr, self.p_paddr = struct.unpack("{}II".format(endian), elf.read(8))
            self.p_filesz, self.p_memsz, self.p_flags, self.p_align = struct.unpack("{}IIII".format(endian), elf.read(16))


class Shdr:
    SHT_NULL             = 0
    SHT_PROGBITS         = 1
    SHT_SYMTAB           = 2
    SHT_STRTAB           = 3
    SHT_RELA             = 4
    SHT_HASH             = 5
    SHT_DYNAMIC          = 6
    SHT_NOTE             = 7
    SHT_NOBITS           = 8
    SHT_REL              = 9
    SHT_SHLIB            = 10
    SHT_DYNSYM           = 11
    SHT_NUM              = 12
    SHT_INIT_ARRAY       = 14
    SHT_FINI_ARRAY       = 15
    SHT_PREINIT_ARRAY    = 16
    SHT_GROUP            = 17
    SHT_SYMTAB_SHNDX     = 18
    SHT_NUM              = 19
    #SHT_LOOS             = 0x60000000
    SHT_GNU_ATTRIBUTES   = 0x6ffffff5
    SHT_GNU_HASH         = 0x6ffffff6
    SHT_GNU_LIBLIST      = 0x6ffffff7
    SHT_CHECKSUM         = 0x6ffffff8
    #SHT_LOSUNW           = 0x6ffffffa
    SHT_SUNW_move        = 0x6ffffffa
    SHT_SUNW_COMDAT      = 0x6ffffffb
    SHT_SUNW_syminfo     = 0x6ffffffc
    SHT_GNU_verdef       = 0x6ffffffd
    SHT_GNU_verneed      = 0x6ffffffe
    SHT_GNU_versym       = 0x6fffffff
    #SHT_HISUNW           = 0x6fffffff
    #SHT_HIOS             = 0x6fffffff
    #SHT_LOPROC           = 0x70000000
    #SHT_HIPROC           = 0x7fffffff
    #SHT_LOUSER           = 0x80000000
    #SHT_HIUSER           = 0x8fffffff

    SHF_WRITE            = 1
    SHF_ALLOC            = 2
    SHF_EXECINSTR        = 4
    SHF_MERGE            = 0x10
    SHF_STRINGS          = 0x20
    SHF_INFO_LINK        = 0x40
    SHF_LINK_ORDER       = 0x80
    SHF_OS_NONCONFORMING = 0x100
    SHF_GROUP            = 0x200
    SHF_TLS              = 0x400
    SHF_COMPRESSED       = 0x800
    SHF_RELA_LIVEPATCH   = 0x00100000
    SHF_RO_AFTER_INIT    = 0x00200000
    SHF_ORDERED          = 0x40000000
    SHF_EXCLUDE          = 0x80000000

    sh_name              = None
    sh_type              = None
    sh_flags             = None
    sh_addr              = None
    sh_offset            = None
    sh_size              = None
    sh_link              = None
    sh_info              = None
    sh_addralign         = None
    sh_entsize           = None

    def __init__(self, elf, off):
        if elf is None:
            return None
        elf.seek(off)
        endian = "<" if elf.e_endianness == Elf.LITTLE_ENDIAN else ">"
        if elf.e_class == Elf.ELF_64_BITS:
            self.sh_name, self.sh_type, self.sh_flags = struct.unpack("{}IIQ".format(endian), elf.read(16))
            self.sh_addr, self.sh_offset = struct.unpack("{}QQ".format(endian), elf.read(16))
            self.sh_size, self.sh_link, self.sh_info = struct.unpack("{}QII".format(endian), elf.read(16))
            self.sh_addralign, self.sh_entsize = struct.unpack("{}QQ".format(endian), elf.read(16))
        else:
            self.sh_name, self.sh_type, self.sh_flags = struct.unpack("{}III".format(endian), elf.read(12))
            self.sh_addr, self.sh_offset = struct.unpack("{}II".format(endian), elf.read(8))
            self.sh_size, self.sh_link, self.sh_info = struct.unpack("{}III".format(endian), elf.read(12))
            self.sh_addralign, self.sh_entsize = struct.unpack("{}II".format(endian), elf.read(8))

        stroff = elf.e_shoff + elf.e_shentsize * elf.e_shstrndx

        if elf.e_class == Elf.ELF_64_BITS:
            elf.seek(stroff + 16 + 8)
            offset = struct.unpack("{}Q".format(endian), elf.read(8))[0]
        else:
            elf.seek(stroff + 12 + 4)
            offset = struct.unpack("{}I".format(endian), elf.read(4))[0]
        elf.seek(offset + self.sh_name)
        self.sh_name = ""
        while True:
            c = ord(elf.read(1))
            if c == 0:
                break
            self.sh_name += chr(c)
        return


class Instruction:
    """GEF representation of a CPU instruction."""
    def __init__(self, address, location, mnemo, operands, opcodes):
        # example:
        #   address: 0x55555555a7d0
        #   location: "" or "<main+0>"
        #   mnemo: "lea"
        #   operands: ['rcx', '[rip+0x11ee5]        # 0x55555556c69a']
        #   opcodes: b'H\x8d\r\xe5\x1e\x01\x00'
        self.address = address
        self.location = location
        self.mnemonic = mnemo
        self.operands = operands
        self.opcodes = opcodes
        return

    # Allow formatting an instruction with {:o} to show opcodes.
    # The number of bytes to display can be configured, e.g. {:4o} to only show 4 bytes of the opcodes
    def __format__(self, format_spec):
        if len(format_spec) == 0 or format_spec[-1] != "o":  # format_spec example: "4o"
            return str(self)

        # format opcode
        if format_spec == "o": # no specifed length
            opcodes_len = len(self.opcodes)
        else:
            opcodes_len = int(format_spec[:-1])
        opcodes_text = "".join("{:02x}".format(b) for b in self.opcodes) # ex:"488d0de51e0100"
        # ex1: spec:"4o", opcodes:01020304   -> 01020304
        # ex2: spec:"4o", opcodes:0102030405 -> 010203..
        if opcodes_len < len(self.opcodes):
            opcodes_text = opcodes_text[:opcodes_len * 2 - 2] + ".."

        # format location
        location = self.smartify_text(self.location)
        if not location:
            location = "<NO_SYMBOL>"
        else:
            r = re.search(r"<(.+)\+(\d+)>", location)
            if r:
                location = "<{}+{:#x}>".format(r.group(1), int(r.group(2)))

        # format operands
        operands = self.smartify_text(", ".join(self.operands))
        r = re.search(r"^(.*?)<(.+)\+(\d+)>(.*)$", operands)
        if r:
            operands = "{}<{}+{:#x}>{}".format(r.group(1), r.group(2), int(r.group(3)), r.group(4))

        # resolve symbol
        sym = ""

        # ex: call 0xXXXX
        if sym == "" and (is_x86_32() or is_x86_64() or is_arm64()) and len(self.operands) > 0:
            try:
                reference_addr = self.operands[-1].replace("#", "")
                ret = gdb_get_location_from_symbol(int(reference_addr, 0))
                if ret is None:
                    sym = ""
                elif ret[1] == 0:
                    sym = "<{}>".format(ret[0])
                else:
                    sym = "<{}+{:#x}>".format(ret[0], ret[1])
            except Exception:
                pass

        # ex: lea rax, [rip + 0xXXXX]
        if sym == "" and is_x86_64() and len(self.operands) > 0:
            try:
                m = re.match(r"\[rip \+ (0x\w+)\]", self.operands[-1])
                reference_addr = self.address + len(self.opcodes) + int(m.group(1), 0)
                ret = gdb_get_location_from_symbol(reference_addr)
                if ret is None:
                    sym = ""
                elif ret[1] == 0:
                    sym = "# {:#x} <{}>".format(reference_addr, ret[0])
                else:
                    sym = "# {:#x} <{}+{:#x}>".format(reference_addr, ret[0], ret[1])
            except Exception:
                pass

        # ex: b #0xXXXX
        if sym == "" and is_arm32() and len(self.operands) > 0:
            try:
                m = re.match(r"#(\w+)", self.operands[-1])
                ret = gdb_get_location_from_symbol(int(m.group(1), 0))
                if ret is None:
                    sym = ""
                elif ret[1] == 0:
                    sym = "<{}>".format(ret[0])
                else:
                    sym = "<{}+{:#x}>".format(ret[0], ret[1])
            except Exception:
                pass

        # ex: ldr r0, [pc, #0xXXXX]
        if sym == "" and is_arm32() and len(self.operands) > 1:
            try:
                m = re.match(r"\[pc,#(\w+)\]", ','.join(self.operands[-2:]))
                reference_addr = self.address + len(self.opcodes) + int(m.group(1), 0)
                ret = gdb_get_location_from_symbol(reference_addr)
                if ret is None:
                    sym = ""
                elif ret[1] == 0:
                    sym = "; {:#x} <{}>".format(reference_addr, ret[0])
                else:
                    sym = "; {:#x} <{}+{:#x}>".format(reference_addr, ret[0], ret[1])
            except Exception:
                pass

        # formatting
        fmt = "{:#10x} {:{:d}}   {:20}   {:6} {:s} {:s}"
        length = opcodes_len * 2
        return fmt.format(self.address, opcodes_text, length, location, self.mnemonic, operands, sym)

    def __str__(self):
        location = self.smartify_text(self.location)
        if not location:
            location = "<NO_SYMBOL>"
        operands = self.smartify_text(", ".join(self.operands))
        fmt = "{:#10x} {:20} {:6} {:s}"
        return fmt.format(self.address, location, self.mnemonic, operands)

    def is_valid(self):
        return "(bad)" not in self.mnemonic

    @staticmethod
    def smartify_text(text):
        smart_cpp_function_name = get_gef_setting("context.smart_cpp_function_name")
        if not smart_cpp_function_name:
            return text

        if text is None:
            return text

        if len(text) == 0:
            return text

        text = re.sub(r"\bstd::__1::", "", text)

        old_text = text[::]
        while True:
            text = re.sub(r"\([^(]+?\)", "__MARKER_GEF__", text)
            if text == old_text:
                break
            old_text = text[::]
        text = re.sub("__MARKER_GEF__", "(...)", text)

        if text[0] == "<":
            text_0, text = text[0], text[1:]
        else:
            text_0 = ""
        if text[-1] == ">":
            text_end, text = text[-1], text[:-1]
        else:
            text_end = ""

        while True:
            text = re.sub(r"\<[^<]+?\>", "__MARKER_GEF__", text)
            if text == old_text:
                break
            old_text = text[::]
        text = re.sub("__MARKER_GEF__", "<...>", text)
        if text_0:
            text = text_0 + text
        if text_end:
            text = text + text_end
        return text


def search_for_main_arena():
    global __gef_default_main_arena__
    malloc_hook_addr = parse_address("(void *)&__malloc_hook")

    if is_x86():
        addr = align_address_to_size(malloc_hook_addr + current_arch.ptrsize, 0x20)
    elif is_arm64():
        addr = malloc_hook_addr - current_arch.ptrsize * 2 - MallocStateStruct("*0").struct_size
    elif is_arm32():
        addr = malloc_hook_addr - current_arch.ptrsize - MallocStateStruct("*0").struct_size
    else:
        raise OSError("Cannot find main_arena for {}".format(current_arch.arch))

    __gef_default_main_arena__ = "*{:#x}".format(addr)
    return addr


class MallocStateStruct:
    """GEF representation of malloc_state from
    https://github.com/bminor/glibc/blob/glibc-2.28/malloc/malloc.c#L1658"""
    def __init__(self, addr):
        try:
            self.__addr = parse_address("&{}".format(addr))
        except gdb.error:
            self.__addr = search_for_main_arena()

        self.num_fastbins = 10
        self.num_bins = 254

        self.int_size = cached_lookup_type("int").sizeof
        self.size_t = cached_lookup_type("size_t")
        if not self.size_t:
            ptr_type = "unsigned long" if current_arch.ptrsize == 8 else "unsigned int"
            self.size_t = cached_lookup_type(ptr_type)

        # Account for separation of have_fastchunks flag into its own field
        # within the malloc_state struct in GLIBC >= 2.27
        # https://sourceware.org/git/?p=glibc.git;a=commit;h=e956075a5a2044d05ce48b905b10270ed4a63e87
        # Be aware you could see this change backported into GLIBC release branches.
        if get_libc_version() >= (2, 27):
            self.fastbin_offset = align_address_to_size(self.int_size * 3, 8)
        else:
            self.fastbin_offset = self.int_size * 2
        return

    # struct offsets
    @property
    def addr(self):
        return self.__addr

    @property
    def fastbins_addr(self):
        return self.__addr + self.fastbin_offset

    @property
    def top_addr(self):
        return self.fastbins_addr + self.num_fastbins * current_arch.ptrsize

    @property
    def last_remainder_addr(self):
        return self.top_addr + current_arch.ptrsize

    @property
    def bins_addr(self):
        return self.last_remainder_addr + current_arch.ptrsize

    @property
    def next_addr(self):
        return self.bins_addr + self.num_bins * current_arch.ptrsize + self.int_size * 4

    @property
    def next_free_addr(self):
        return self.next_addr + current_arch.ptrsize

    @property
    def system_mem_addr(self):
        return self.next_free_addr + current_arch.ptrsize * 2

    @property
    def struct_size(self):
        return self.system_mem_addr + current_arch.ptrsize * 2 - self.__addr

    # struct members
    @property
    def fastbinsY(self):
        return self.get_size_t_array(self.fastbins_addr, self.num_fastbins)

    @property
    def top(self):
        return self.get_size_t_pointer(self.top_addr)

    @property
    def last_remainder(self):
        return self.get_size_t_pointer(self.last_remainder_addr)

    @property
    def bins(self):
        return self.get_size_t_array(self.bins_addr, self.num_bins)

    @property
    def next(self):
        return self.get_size_t_pointer(self.next_addr)

    @property
    def next_free(self):
        return self.get_size_t_pointer(self.next_free_addr)

    @property
    def system_mem(self):
        return self.get_size_t(self.system_mem_addr)

    # helper methods
    def get_size_t(self, addr):
        return dereference(addr).cast(self.size_t)

    def get_size_t_pointer(self, addr):
        size_t_pointer = self.size_t.pointer()
        return dereference(addr).cast(size_t_pointer)

    def get_size_t_array(self, addr, length):
        size_t_array = self.size_t.array(length)
        return dereference(addr).cast(size_t_array)

    def __getitem__(self, item):
        return getattr(self, item)


class GlibcArena:
    """Glibc arena class
    Ref: https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1671"""
    TCACHE_MAX_BINS = 0x40

    def __init__(self, addr_string):
        self.__name = addr_string
        try:
            arena = gdb.parse_and_eval(addr_string)
            malloc_state_t = cached_lookup_type("struct malloc_state")
            self.__arena = arena.cast(malloc_state_t)
            self.__addr = int(arena.address)
            self.__size = malloc_state_t.sizeof
        except Exception:
            self.__arena = MallocStateStruct(addr_string)
            self.__addr = self.__arena.addr
            self.__size = self.__arena.struct_size

        try:
            self.top = int(self.top)
            self.last_remainder = int(self.last_remainder)
            self.n = int(self.next)
            self.nfree = int(self.next_free)
            self.sysmem = int(self.system_mem)
        except gdb.error as e:
            err("Glibc arena: {}".format(e))
        return

    def __getitem__(self, item):
        return self.__arena[item]

    def __getattr__(self, item):
        return self.__arena[item]

    def __int__(self):
        return self.__addr

    def is_main_arena(self):
        # fast path
        if self.__name == __gef_default_main_arena__:
            return True
        # slow path
        try:
            if self.__addr == get_main_arena().addr:
                return True
        except Exception:
            pass
        return False

    @property
    def addr(self):
        return self.__addr

    @property
    def name(self):
        return self.__name

    def tcachebin_addr(self, i):
        if self.heap_base is None:
            return None
        if get_libc_version() < (2, 30):
            offset = 0x10 + self.TCACHE_MAX_BINS + i * current_arch.ptrsize
        else:
            offset = 0x10 + 2 * self.TCACHE_MAX_BINS + i * current_arch.ptrsize
        return self.heap_base + offset

    def fastbin_addr(self, i):
        if hasattr(self.__arena, "fastbins_addr"):
            fastbins_addr = self.__arena.fastbins_addr
        else:
            fastbins_type = [x for x in self.__arena.type.fields() if x.name == "fastbinsY"][0]
            fastbins_addr = self.__addr + fastbins_type.bitpos // 8
        return fastbins_addr + i * current_arch.ptrsize

    def top_addr(self):
        if hasattr(self.__arena, "top_addr"):
            top_addr = self.__arena.top_addr
        else:
            top_type = [x for x in self.__arena.type.fields() if x.name == "top"][0]
            top_addr = self.__addr + top_type.bitpos // 8
        return top_addr

    def last_remainder_addr(self):
        if hasattr(self.__arena, "last_remainder_addr"):
            last_remainder_addr = self.__arena.last_remainder_addr
        else:
            last_remainder_type = [x for x in self.__arena.type.fields() if x.name == "last_remainder"][0]
            last_remainder_addr = self.__addr + last_remainder_type.bitpos // 8
        return last_remainder_addr

    def bin_addr(self, i):
        if hasattr(self.__arena, "bins_addr"):
            bins_addr = self.__arena.bins_addr
        else:
            bins_type = [x for x in self.__arena.type.fields() if x.name == "bins"][0]
            bins_addr = self.__addr + bins_type.bitpos // 8
        return bins_addr + i * current_arch.ptrsize * 2

    def next_addr(self):
        if hasattr(self.__arena, "next_addr"):
            next_addr = self.__arena.next_addr
        else:
            next_type = [x for x in self.__arena.type.fields() if x.name == "next"][0]
            next_addr = self.__addr + next_type.bitpos // 8
        return next_addr

    def next_free_addr(self):
        if hasattr(self.__arena, "next_free_addr"):
            next_free_addr = self.__arena.next_free_addr
        else:
            next_free_type = [x for x in self.__arena.type.fields() if x.name == "next_free"][0]
            next_free_addr = self.__addr + next_free_type.bitpos // 8
        return next_free_addr

    def system_mem_addr(self):
        if hasattr(self.__arena, "system_mem_addr"):
            system_mem_addr = self.__arena.system_mem_addr
        else:
            system_mem_type = [x for x in self.__arena.type.fields() if x.name == "system_mem"][0]
            system_mem_addr = self.__addr + system_mem_type.bitpos // 8
        return system_mem_addr

    # arena aligned_size
    @property
    def size(self):
        if current_arch.ptrsize == 4:
            aligned_size = (self.__size + 7) & ~0b111
        else:
            aligned_size = (self.__size + 15) & ~0b1111
        return aligned_size

    @property
    def heap_base(self):
        if self.is_main_arena():
            return HeapbaseCommand.heap_base()
        else:
            return self.addr + self.size

    def tcachebin(self, i):
        """Return head chunk in tcache[i]."""
        if self.heap_base is None:
            return None
        if get_libc_version() < (2, 30):
            offset = 0x10 + self.TCACHE_MAX_BINS + i * current_arch.ptrsize
        else:
            offset = 0x10 + 2 * self.TCACHE_MAX_BINS + i * current_arch.ptrsize
        addr = dereference(self.heap_base + offset)
        if not addr:
            return None
        return GlibcChunk(int(addr))

    def fastbin(self, i):
        """Return head chunk in fastbinsY[i]."""
        addr = int(self.fastbinsY[i])
        if addr == 0:
            return None
        return GlibcChunk(addr + 2 * current_arch.ptrsize)

    def bin(self, i):
        idx = i * 2
        fd = int(self.bins[idx])
        bw = int(self.bins[idx + 1])
        return fd, bw

    def get_next(self):
        try:
            addr_next = int(self.next)
            if addr_next == 0:
                return None
            if addr_next == get_main_arena().addr:
                return None
            next_arena = GlibcArena("*{:#x}".format(addr_next))
            str(next_arena) # check memory error
            return next_arena
        except Exception:
            return None

    def __str__(self):
        arena = Color.colorify("Arena", "bold yellow underline")
        heap_base = Color.boldify("{:#x}".format(self.heap_base))
        addr = Color.boldify("{:#x}".format(self.__addr))
        top = Color.boldify("{:#x}".format(self.top))
        last_remainder = Color.boldify("{:#x}".format(self.last_remainder))
        next_ = Color.boldify("{:#x}".format(self.n))
        next_free = Color.boldify("{:#x}".format(self.nfree))
        sysmem = Color.boldify("{:#x}".format(self.sysmem))
        fmt = "{:s}(addr={:s}, heap_base={:s}, top={:s}, last_remainder={:s}, next={:s}, next_free={:s}, system_mem={:s})"
        return fmt.format(arena, addr, heap_base, top, last_remainder, next_, next_free, sysmem)

    def tcache_list(self):
        if get_libc_version() < (2, 26):
            info("No Tcache in this version of libc")
            return {}
        if self.heap_base is None:
            return {}

        chunks_all = {}
        for i in range(self.TCACHE_MAX_BINS):
            try:
                chunk = self.tcachebin(i)
            except gdb.MemoryError:
                err("tcache[{:d}] is maybe corrupted.".format(i))
                continue
            chunks = set()
            while True:
                if chunk is None:
                    break
                if chunk.address in chunks:
                    break # loop detected
                chunks.add(chunk.address)
                next_chunk = chunk.get_fwd_ptr(True)
                if next_chunk == 0:
                    break
                if next_chunk is None:
                    err("tcache[{:d}] is maybe corrupted.".format(i))
                    break
                chunk = GlibcChunk(next_chunk)
            chunks_all[i] = chunks
        return chunks_all

    def fastbin_list(self):
        def fastbin_index(sz):
            return (sz >> 4) - 2 if SIZE_SZ == 8 else (sz >> 3) - 2

        SIZE_SZ = current_arch.ptrsize
        MAX_FAST_SIZE = (80 * SIZE_SZ // 4)
        NFASTBINS = fastbin_index(MAX_FAST_SIZE) - 1
        chunks_all = {}
        for i in range(NFASTBINS):
            try:
                chunk = self.fastbin(i)
            except gdb.MemoryError:
                err("fastbin[{:d}] is maybe corrupted.".format(i))
                continue
            chunks = set()
            while True:
                if chunk is None:
                    break
                if chunk.address in chunks:
                    break # loop detected
                chunks.add(chunk.address)
                next_chunk = chunk.get_fwd_ptr(True)
                if next_chunk == 0:
                    break
                if next_chunk is None:
                    err("fastbin[{:d}] is maybe corrupted.".format(i))
                    break
                chunk = GlibcChunk(next_chunk, from_base=True)
            chunks_all[i] = chunks
        return chunks_all

    def bin_list(self, index):
        try:
            fw, bk = self.bin(index)
        except gdb.MemoryError:
            return set() # invalid
        if bk == 0x00 and fw == 0x00:
            return set() # invalid
        head = GlibcChunk(bk, from_base=True).fwd
        if fw == head:
            return set() # no entry
        chunks = set()
        while fw != head:
            chunk = GlibcChunk(fw, from_base=True)
            if chunk.address in chunks:
                err("bins[{:d}] is corrupted (the loop exit condition of parsing is troubled)".format(index))
                break
            chunks.add(chunk.address)
            fw = chunk.fwd
            if fw is None:
                err("bins[{:d}] is corrupted (failed to get fwd)".format(index))
                break
        return chunks

    def unsortedbin_list(self):
        chunks_all = {}
        chunks_all[0] = self.bin_list(0)
        return chunks_all

    def smallbin_list(self):
        chunks_all = {}
        for i in range(1, 63):
            chunks_all[i] = self.bin_list(i)
        return chunks_all

    def largebin_list(self):
        chunks_all = {}
        for i in range(63, 126):
            chunks_all[i] = self.bin_list(i)
        return chunks_all


class GlibcChunk:
    """Glibc chunk class.
    Ref: https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/."""
    def __init__(self, addr, from_base=False):
        self.ptrsize = current_arch.ptrsize
        if from_base:
            self.chunk_base_address = addr
            self.address = addr + 2 * self.ptrsize
        else:
            self.chunk_base_address = int(addr - 2 * self.ptrsize)
            self.address = addr

        self.size_addr = int(self.address - self.ptrsize)
        self.prev_size_addr = self.chunk_base_address
        return

    def get_chunk_size(self):
        return read_int_from_memory(self.size_addr) & (~0x07)

    @property
    def size(self):
        return self.get_chunk_size()

    def get_usable_size(self):
        # https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L4537
        cursz = self.get_chunk_size()
        if cursz == 0:
            return cursz
        if self.has_m_bit():
            return cursz - 2 * self.ptrsize
        return cursz - self.ptrsize

    @property
    def usable_size(self):
        return self.get_usable_size()

    def get_prev_chunk_size(self):
        return read_int_from_memory(self.prev_size_addr)

    def get_next_chunk(self):
        try:
            addr = self.address + self.get_chunk_size()
            return GlibcChunk(addr)
        except gdb.MemoryError:
            return None

    # if free-ed functions
    def get_fwd_ptr(self, sll):
        try:
            # Not a single-linked-list (sll) or no Safe-Linking support yet
            if not sll or get_libc_version() < (2, 32):
                return read_int_from_memory(self.address)
            # Unmask ("reveal") the Safe-Linking pointer
            else:
                return read_int_from_memory(self.address) ^ (self.address >> 12)
        except gdb.MemoryError:
            return None

    @property
    def fwd(self):
        return self.get_fwd_ptr(False)

    fd = fwd # for compat

    def get_bkw_ptr(self):
        return read_int_from_memory(self.address + self.ptrsize)

    @property
    def bck(self):
        return self.get_bkw_ptr()

    bk = bck # for compat

    def get_fd_nextsize_ptr(self):
        return read_int_from_memory(self.address + self.ptrsize * 2)

    @property
    def fd_nextsize(self):
        return self.get_fd_nextsize_ptr()

    def get_bk_nextsize_ptr(self):
        return read_int_from_memory(self.address + self.ptrsize * 3)

    @property
    def bk_nextsize(self):
        return self.get_bk_nextsize_ptr()
    # endif free-ed functions

    def has_p_bit(self):
        return read_int_from_memory(self.size_addr) & 0x01

    def has_m_bit(self):
        return read_int_from_memory(self.size_addr) & 0x02

    def has_n_bit(self):
        return read_int_from_memory(self.size_addr) & 0x04

    def is_used(self):
        """Check if the current block is used by:
        - checking the M bit is true
        - or checking that next chunk PREV_INUSE flag is true"""
        if self.has_m_bit():
            return True
        next_chunk = self.get_next_chunk()
        return True if next_chunk.has_p_bit() else False

    def str_chunk_size_flag(self):
        msg = []
        if self.has_p_bit():
            msg.append("  PREV_INUSE flag: {}".format(Color.greenify("On")))
        else:
            msg.append("  PREV_INUSE flag: {}".format(Color.redify("Off")))
        if self.has_m_bit():
            msg.append("  IS_MMAPPED flag: {}".format(Color.greenify("On")))
        else:
            msg.append("  IS_MMAPPED flag: {}".format(Color.redify("Off")))
        if self.has_n_bit():
            msg.append("  NON_MAIN_ARENA flag: {}".format(Color.greenify("On")))
        else:
            msg.append("  NON_MAIN_ARENA flag: {}".format(Color.redify("Off")))
        return "\n".join(msg)

    def _str_sizes(self):
        msg = []
        failed = False

        try:
            msg.append("  Chunk size: {0:d} ({0:#x})".format(self.get_chunk_size()))
            msg.append("  Usable size: {0:d} ({0:#x})".format(self.get_usable_size()))
            failed = True
        except gdb.MemoryError:
            msg.append("  Chunk size: Cannot read at {:#x} (corrupted?)".format(self.size_addr))

        try:
            msg.append("  Previous chunk size: {0:d} ({0:#x})".format(self.get_prev_chunk_size()))
            failed = True
        except gdb.MemoryError:
            msg.append("  Previous chunk size: Cannot read at {:#x} (corrupted?)".format(self.chunk_base_address))

        if failed:
            msg.append(self.str_chunk_size_flag())

        return "\n".join(msg)

    def _str_pointers(self):
        fwd = self.address
        bkw = self.address + self.ptrsize

        msg = []
        try:
            msg.append("  Forward pointer: {0:#x}".format(self.get_fwd_ptr(False)))
        except gdb.MemoryError:
            msg.append("  Forward pointer: {0:#x} (corrupted?)".format(fwd))

        try:
            msg.append("  Backward pointer: {0:#x}".format(self.get_bkw_ptr()))
        except gdb.MemoryError:
            msg.append("  Backward pointer: {0:#x} (corrupted?)".format(bkw))

        return "\n".join(msg)

    def str_as_alloced(self):
        return self._str_sizes()

    def str_as_freed(self):
        return "{}\n\n{}".format(self._str_sizes(), self._str_pointers())

    def flags_as_string(self):
        flags = []
        if self.has_p_bit():
            flags.append(Color.colorify("PREV_INUSE", "bold red"))
        if self.has_m_bit():
            flags.append(Color.colorify("IS_MMAPPED", "bold blue"))
        if self.has_n_bit():
            flags.append(Color.colorify("NON_MAIN_ARENA", "bold yellow"))
        return "|".join(flags)

    def __str__(self):
        chunk_c = Color.colorify("Chunk", "bold yellow underline")
        size_c = Color.colorify("{:#x}".format(self.get_chunk_size()), "bold pink")
        addr = Color.boldify("{:#x}".format(int(self.chunk_base_address)))
        flags = self.flags_as_string()

        if is_valid_addr(self.fd):
            fd = Color.greenify("{:#x}".format(self.fd))
        else:
            fd = Color.redify("{:#x}".format(self.fd))

        if is_valid_addr(self.bk):
            bk = Color.greenify("{:#x}".format(self.bk))
        else:
            bk = Color.redify("{:#x}".format(self.bk))

        if is_valid_addr(self.fd_nextsize):
            fd_nextsize = Color.greenify("{:#x}".format(self.fd_nextsize))
        else:
            fd_nextsize = Color.redify("{:#x}".format(self.fd_nextsize))

        if is_valid_addr(self.bk_nextsize):
            bk_nextsize = Color.greenify("{:#x}".format(self.bk_nextsize))
        else:
            bk_nextsize = Color.redify("{:#x}".format(self.bk_nextsize))

        if (is_32bit() and self.size < 0x3f0) or (is_64bit() and self.size < 0x400):
            fmt = "{:s}(addr={:s}, size={:s}, flags={:s}, fd={:s}, bk={:s})"
            msg = fmt.format(chunk_c, addr, size_c, flags, fd, bk)
        else:
            fmt = "{:s}(addr={:s}, size={:s}, flags={:s}, fd={:s}, bk={:s}, fd_nextsize={:s}, bk_nextsize={:s})"
            msg = fmt.format(chunk_c, addr, size_c, flags, fd, bk, fd_nextsize, bk_nextsize)
        return msg

    def psprint(self):
        msg = []
        msg.append(str(self))
        if self.is_used():
            msg.append(self.str_as_alloced())
        else:
            msg.append(self.str_as_freed())
        return "\n".join(msg)


def get_libc_version():

    def get_libc_version_from_path():
        sections = get_process_maps()
        for section in sections:
            r = re.search(r"libc6?[-_](\d+)\.(\d+)\.so", section.path)
            if r:
                return tuple(int(x) for x in r.groups())
            if "libc" in section.path:
                try:
                    data = open(section.path, "rb").read()
                except OSError:
                    continue
                r = re.search(rb"glibc (\d+)\.(\d+)", data)
                if r:
                    return tuple(int(x) for x in r.groups())
        return None

    libc_assume_version = get_gef_setting("libc.assume_version")
    if libc_assume_version is not None:
        return libc_assume_version

    libc_version = get_libc_version_from_path()
    if libc_version is None:
        libc_version = (2, 35) # assume Ubuntu 22.04

    set_gef_setting("libc.assume_version", libc_version, tuple, "The value to force get_libc_version to return")
    return libc_version


def get_main_arena():
    try:
        arena = GlibcArena(__gef_default_main_arena__)
        str(arena) # check memory error
        return arena
    except Exception:
        err("Failed to get the main arena, heap commands may not work properly.")
        return None


def get_thread_arena(address):
    try:
        arena = GlibcArena("*{:#x}".format(address))
        str(arena) # check memory error
        return arena
    except Exception:
        err("Failed to get the thread arena, heap commands may not work properly.")
        return None


def titlify(text, color=None, msg_color=None):
    """Print a centered title."""
    cols = get_terminal_size()[1]
    if color is None:
        color = __config__.get("theme.default_title_line")[0]
    if msg_color is None:
        msg_color = __config__.get("theme.default_title_message")[0]

    msg = []
    if text:
        nb = (cols - len(text) - 2) // 2
        msg.append(Color.colorify("{} ".format(HORIZONTAL_LINE * nb), color))
        msg.append(Color.colorify(text, msg_color))
        msg.append(Color.colorify(" {}".format(HORIZONTAL_LINE * nb), color))
    else:
        msg.append(Color.colorify("{}".format(HORIZONTAL_LINE * cols), color))
    return "".join(msg)


def err(msg):
    gef_print("{} {}".format(Color.colorify("[!]", "bold red"), msg))
    return


def warn(msg):
    gef_print("{} {}".format(Color.colorify("[*]", "bold yellow"), msg))
    return


def ok(msg):
    gef_print("{} {}".format(Color.colorify("[+]", "bold green"), msg))
    return


def info(msg):
    gef_print("{} {}".format(Color.colorify("[+]", "bold blue"), msg))
    return


def push_context_message(level, message):
    """Push the message to be displayed the next time the context is invoked."""
    global __context_messages__
    if level not in ("error", "warn", "ok", "info"):
        err("Invalid level '{}', discarding message".format(level))
        return
    __context_messages__.append((level, message))
    return


def show_last_exception():
    """Display the last Python exception."""
    def _show_code_line(fname, idx):
        fname = os.path.expanduser(os.path.expandvars(fname))
        __data = open(fname, "r").read().splitlines()
        return __data[idx - 1] if idx < len(__data) else ""

    gef_print("")
    exc_type, exc_value, exc_traceback = sys.exc_info()

    gef_print(" Exception raised ".center(80, HORIZONTAL_LINE))
    gef_print("{}: {}".format(Color.colorify(exc_type.__name__, "bold red underline"), exc_value))
    gef_print(" Detailed stacktrace ".center(80, HORIZONTAL_LINE))

    for fs in traceback.extract_tb(exc_traceback)[::-1]:
        filename, lineno, method, code = fs

        if not code or not code.strip():
            code = _show_code_line(filename, lineno)

        filename_c = Color.yellowify(filename)
        method_c = Color.greenify(method)
        gef_print('{} File "{}", line {:d}, in {}()'.format(DOWN_ARROW, filename_c, lineno, method_c))
        gef_print("   {}    {}".format(RIGHT_ARROW, code))

    gef_print(" Last 10 GDB commands ".center(80, HORIZONTAL_LINE))
    gdb.execute("show commands")
    gef_print(" Runtime environment ".center(80, HORIZONTAL_LINE))
    gef_print("* GDB: {}".format(gdb.VERSION))
    v = sys.version_info
    gef_print("* Python: {:d}.{:d}.{:d} - {:s}".format(v.major, v.minor, v.micro, v.releaselevel))
    gef_print("* OS: {:s} - {:s} ({:s})".format(platform.system(), platform.release(), platform.machine()))

    gef_print(" lsb_release -a ".center(80, HORIZONTAL_LINE))
    try:
        lsb_release = which("lsb_release")
        gdb.execute("!{} -a".format(lsb_release))
    except FileNotFoundError as e:
        gef_print("Cannot collect additional debug information: {}".format(e))

    gef_print(HORIZONTAL_LINE * 80)
    gef_print("")
    return


def gef_pystring(x):
    """Returns a sanitized version as string of the bytes list given in input."""
    res = str(x, encoding="utf-8")
    substs = [("\n", "\\n"), ("\r", "\\r"), ("\t", "\\t"), ("\v", "\\v"), ("\b", "\\b"), ]
    for x, y in substs:
        res = res.replace(x, y)
    return res


def gef_pybytes(x):
    """Returns an immutable bytes list from the string given as input."""
    return bytes(str(x), encoding="utf-8")


def str2bytes(x):
    if isinstance(x, str):
        x = bytes([ord(xx) for xx in x])
    return x


def bytes2str(x):
    if isinstance(x, bytes):
        x = ''.join(chr(xx) for xx in x)
    return x


def slicer(data, n):
    return [data[i:i + n] for i in range(0, len(data), n)]


def slice_unpack(data, n):
    if n == 8:
        return [u64(data[i:i + 8]) for i in range(0, len(data), 8)]
    elif n == 4:
        return [u32(data[i:i + 4]) for i in range(0, len(data), 4)]
    else:
        raise


@functools.lru_cache(maxsize=None)
def which(program):
    """Locate a command on the filesystem."""
    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

    fpath = os.path.split(program)[0]
    if fpath:
        if is_exe(program):
            return program
    else:
        env_path = os.getenv("PATH")
        if env_path is None:
            env_path = "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
        for path in env_path.split(os.pathsep):
            path = path.strip('"')
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file
    raise FileNotFoundError("Missing file `{:s}`".format(program))


def style_byte(b, color=True):
    style = {
        "nonprintable": "yellow",
        "printable": "white",
        "00": "gray",
        "0a": "blue",
        "ff": "green",
    }
    sbyte = "{:02x}".format(b)
    if not color or get_gef_setting("highlight.regex"):
        return sbyte

    if sbyte in style:
        st = style[sbyte]
    elif chr(b) in (string.ascii_letters + string.digits + string.punctuation + " "):
        st = style.get("printable")
    else:
        st = style.get("nonprintable")
    if st:
        sbyte = Color.colorify(sbyte, st)
    return sbyte


def hexdump(source, length=0x10, separator=".", show_raw=False, show_symbol=True, base=0x00):
    """Return the hexdump of `src` argument.
    @param source *MUST* be of type bytes or bytearray
    @param length is the length of items per line
    @param separator is the default character to use if one byte is not printable
    @param show_raw if True, do not add the line nor the text translation
    @param base is the start address of the block being hexdump
    @return a string with the hexdump"""
    result = []
    align = get_memory_alignment() * 2 + 2 if is_alive() else 18

    for i in range(0, len(source), length):
        chunk = bytearray(source[i : i + length])
        padlen = (0x10 - len(chunk)) * 3
        hexa = " ".join([style_byte(b, color=not show_raw) for b in chunk])

        if show_raw:
            result.append(hexa)
            continue

        text = "".join([chr(b) if 0x20 <= b < 0x7F else separator for b in chunk])
        if show_symbol:
            sym = gdb_get_location_from_symbol(base + i)
            sym = "<{:s}+{:04x}>".format(*sym) if sym else ""
        else:
            sym = ""

        fmt = "{addr:#0{aw}x}{sym}   {data}{pad}   {text}"
        result.append(fmt.format(aw=align, addr=base + i, sym=" " + sym, pad=" " * padlen, data=hexa, text=text))
    return "\n".join(result)


def is_debug():
    """Check if debug mode is enabled."""
    return get_gef_setting("gef.debug") is True


context_hidden = False


def hide_context():
    global context_hidden
    context_hidden = True
    return


def unhide_context():
    global context_hidden
    context_hidden = False
    return


@functools.lru_cache(maxsize=None)
def get_gef_setting(name):
    """Read global gef settings.
    Return None if not found. A valid config setting can never return None,
    but False, 0 or ""."""
    global __config__
    setting = __config__.get(name, None)
    if not setting:
        return None
    return setting[0]


def set_gef_setting(name, value, _type=None, _desc=None):
    """Set global gef settings.
    Raise ValueError if `name` doesn't exist and `type` and `desc`
    are not provided."""
    reset_gef_caches()

    global __config__
    if name not in __config__:
        # create new setting
        if _type is None or _desc is None:
            raise ValueError("Setting '{}' is undefined, need to provide type and description".format(name))
        __config__[name] = [_type(value), _type, _desc]
        return

    # set existing setting
    func = __config__[name][1]
    __config__[name][0] = func(value)
    get_gef_setting.cache_clear()
    return


def gef_makedirs(path, mode=0o755):
    """Recursive mkdir() creation. If successful, return the absolute path of the directory created."""
    abspath = os.path.expanduser(path)
    abspath = os.path.realpath(abspath)

    if os.path.isdir(abspath):
        return abspath

    os.makedirs(abspath, mode=mode, exist_ok=True)
    return abspath


@functools.lru_cache(maxsize=512)
def gdb_get_location_from_symbol(address):
    """Retrieve the location of the `address` argument from the symbol table.
    Return a tuple with the name and offset if found, None otherwise."""
    # this is horrible, ugly hack and shitty perf...
    # find a *clean* way to get gdb.Location from an address
    name = None
    sym = gdb.execute("info symbol {:#x}".format(address), to_string=True)
    if sym.startswith("No symbol matches"):
        return None

    i = sym.find(" in section ")
    sym = sym[:i].split()
    if len(sym) >= 3 and sym[-1].isdigit():
        name = ' '.join(sym[:-2])
        offset = int(sym[-1])
    else:
        name = ' '.join(sym)
        offset = 0
    return name, offset


def get_symbol_string(addr, nosymbol_string=""):
    try:
        if isinstance(addr, str):
            addr = re.sub(r"\x1B\[([0-9]{1,2}(;[0-9]{1,2})*)?m", "", addr) # remove color
            addr = int(addr, 16)
        ret = gdb_get_location_from_symbol(addr)
    except Exception:
        return nosymbol_string
    if ret is None:
        return nosymbol_string
    sym_name, sym_offset = ret[0], ret[1]
    sym_name = Instruction.smartify_text(sym_name)
    if sym_offset == 0:
        return " <{}>".format(sym_name)
    else:
        return " <{}+{:#x}>".format(sym_name, sym_offset)


def load_capstone(f):
    """Decorator wrapper to load capstone."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        try:
            __import__("capstone")
            return f(*args, **kwargs)
        except ImportError:
            msg = "Missing `capstone` package for Python. Install with `pip install capstone`."
            raise ImportWarning(msg)

    return wrapper


def load_unicorn(f):
    """Decorator wrapper to load unicorn."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        try:
            __import__("unicorn")
            __import__("unicorn.ppc_const")
            __import__("unicorn.riscv_const")
            __import__("unicorn.s390x_const")
            return f(*args, **kwargs)
        except ImportError:
            msg = "Missing `unicorn` package for Python. Install with `pip install unicorn`."
            raise ImportWarning(msg)

    return wrapper


def load_keystone(f):
    """Decorator wrapper to load keystone."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        try:
            __import__("keystone")
            return f(*args, **kwargs)
        except ImportError:
            msg = "Missing `keystone-engine` package, install with: `pip install keystone-engine`."
            raise ImportWarning(msg)

    return wrapper


def load_ropper(f):
    """Decorator wrapper to load ropper."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        try:
            __import__("ropper")
            return f(*args, **kwargs)
        except ImportError:
            msg = "Missing `ropper` package, install with: `pip install ropper`."
            raise ImportWarning(msg)

    return wrapper


def gdb_disassemble(start_pc, **kwargs):
    """Disassemble instructions from `start_pc` (Integer). Accepts the following named parameters:
    - `end_pc` (Integer) only instructions whose start address fall in the interval from start_pc to end_pc are returned.
    - `count` (Integer) list at most this many disassembled instructions
    If `end_pc` and `count` are not provided, the function will behave as if `count=1`.
    Return an iterator of Instruction objects"""

    global __gef_prev_arch__
    try:
        arch = gdb.selected_frame().architecture()
        __gef_prev_arch__ = arch
    except Exception:
        # For unknown reasons, gdb.selected_frame() may cause an error (often occurs during kernel startup).
        # At this time arch cannot be resolved, but if it was successful before, it will be used.
        if __gef_prev_arch__ is None:
            raise
        arch = __gef_prev_arch__

    for insn in arch.disassemble(start_pc, **kwargs):
        address = insn["addr"]
        asm = insn["asm"].rstrip().split(None, 1)
        if len(asm) > 1:
            mnemo, operands = asm
            operands = [x.strip() for x in operands.split(",")]
        else:
            mnemo, operands = asm[0], []

        loc = gdb_get_location_from_symbol(address)
        location = "<{}+{}>".format(*loc) if loc else ""

        if is_arm32() and insn["addr"] & 1:
            opcodes = read_memory(insn["addr"] - 1, insn["length"])
        else:
            opcodes = read_memory(insn["addr"], insn["length"])

        yield Instruction(address, location, mnemo, operands, opcodes)


def gdb_get_nth_previous_instruction_address(addr, n):
    """Return the address (Integer) of the `n`-th instruction before `addr`."""
    # fixed-length ABI
    if current_arch.instruction_length:
        return max(0, addr - n * current_arch.instruction_length)

    # variable-length ABI
    cur_insn_addr = gef_current_instruction(addr).address

    # we try to find a good set of previous instructions by "guessing" disassembling backwards
    # the 15 comes from the longest instruction valid size
    for i in range(15 * n, 0, -1):
        try:
            insns = list(gdb_disassemble(addr - i, end_pc=cur_insn_addr))
        except gdb.MemoryError:
            # this is because we can hit an unmapped page trying to read backward
            break

        # 1. check that the disassembled instructions list size can satisfy
        if len(insns) < n + 1: # we expect the current instruction plus the n before it
            continue

        # If the list of instructions is longer than what we need, then we
        # could get lucky and already have more than what we need, so slice down
        insns = insns[-n - 1 :]

        # 2. check that the sequence ends with the current address
        if insns[-1].address != cur_insn_addr:
            continue

        # 3. check all instructions are valid
        if all(insn.is_valid() for insn in insns):
            return insns[0].address

    return None


def gdb_get_nth_next_instruction_address(addr, n):
    """Return the address (Integer) of the `n`-th instruction after `addr`."""
    # fixed-length ABI
    if current_arch.instruction_length:
        return addr + n * current_arch.instruction_length

    # variable-length ABI
    insn = list(gdb_disassemble(addr, count=n))[-1]
    return insn.address


def gef_instruction_n(addr, n):
    """Return the `n`-th instruction after `addr` as an Instruction object."""
    return list(gdb_disassemble(addr, count=n + 1))[n]


def gef_get_instruction_at(addr):
    """Return the full Instruction found at the specified address."""
    insn = next(gef_disassemble(addr, 1))
    return insn


def gef_current_instruction(addr):
    """Return the current instruction as an Instruction object."""
    return gef_instruction_n(addr, 0)


def get_insn(addr=None):
    """Wrapper of gef_current_instruction to use easy."""
    if addr is None:
        if not is_alive():
            return None
        addr = current_arch.pc
    return gef_current_instruction(addr)


def gef_next_instruction(addr):
    """Return the next instruction as an Instruction object."""
    return gef_instruction_n(addr, 1)


def get_insn_next(addr=None):
    """Wrapper of gef_next_instruction to use easy."""
    if addr is None:
        if not is_alive():
            return None
        addr = current_arch.pc
    return gef_next_instruction(addr)


def gef_disassemble(addr, nb_insn, nb_prev=0):
    """Disassemble `nb_insn` instructions after `addr` and `nb_prev` before `addr`.
    Return an iterator of Instruction objects."""
    nb_insn = max(1, nb_insn)

    if nb_prev:
        done = False
        for i in range(nb_prev):
            if done:
                break
            start_addr = gdb_get_nth_previous_instruction_address(addr, nb_prev - i)
            if not start_addr:
                continue
            try:
                for insn in gdb_disassemble(start_addr, count=nb_prev):
                    if insn.address == addr:
                        done = True
                        break
                    yield insn
                done = True
                break
            except Exception:
                pass

    for insn in gdb_disassemble(addr, count=nb_insn):
        yield insn


@load_capstone
def capstone_disassemble(location, nb_insn, **kwargs):
    """Disassemble `nb_insn` instructions after `addr` and `nb_prev` before
    `addr` using the Capstone-Engine disassembler, if available.
    Return an iterator of Instruction objects."""
    def cs_insn_to_gef_insn(cs_insn):
        sym_info = gdb_get_location_from_symbol(cs_insn.address)
        loc = "<{}+{}>".format(*sym_info) if sym_info else ""
        ops = [] + cs_insn.op_str.split(", ")
        return Instruction(cs_insn.address, loc, cs_insn.mnemonic, ops, cs_insn.bytes)

    capstone = sys.modules["capstone"]
    _arch = kwargs.get("arch", None)
    _mode = kwargs.get("mode", None)
    _endian = kwargs.get("endian", None)
    arch, mode = get_capstone_arch(arch=_arch, mode=_mode, endian=_endian)
    try:
        cs = capstone.Cs(arch, mode)
    except capstone.CsError:
        err("CsError")
        return
    cs.detail = True
    skip = int(kwargs.get("skip", 0))

    if "code" in kwargs:
        code = kwargs["code"].replace(" ", "")
        code = binascii.unhexlify(code)
        for insn in cs.disasm(code, location):
            if skip:
                skip -= 1
                continue
            nb_insn -= 1
            yield Instruction(insn.address, "", insn.mnemonic, [] + insn.op_str.split(", "), insn.bytes)
            if nb_insn == 0:
                break
        return
    else:
        pc = current_arch.pc
        nb_prev = int(kwargs.get("nb_prev", 0))
        if nb_prev > 0:
            location = gdb_get_nth_previous_instruction_address(pc, nb_prev)
            nb_insn += nb_prev

        # split raeding by page_size
        used_bytes = 0
        code = b""
        page_start = align_address_to_page(location)
        offset = location - page_start
        read_addr = location
        if is_arm32() and read_addr & 1:
            read_addr -= 1
            offset -= 1
        read_size = gef_getpagesize() - offset
        while True:
            try:
                read_data = read_memory(read_addr, read_size)
            except gdb.MemoryError:
                err("Memory read error at {:#x}-{:#x}".format(read_addr, read_addr + read_size))
                return
            code += bytes(read_data)
            for insn in cs.disasm(code, location):
                if skip:
                    skip -= 1
                    continue
                nb_insn -= 1
                used_bytes += len(insn.bytes)
                yield cs_insn_to_gef_insn(insn)
                if nb_insn == 0:
                    return
            code = code[used_bytes:] # There may be instructions placed across page boundaries.
            location += used_bytes
            used_bytes = 0
            read_addr += read_size # 1st loop is the offset size. 2nd~ loops are the page size.
            read_size = gef_getpagesize()
    return


def gef_execute_external(command, as_list=False, *args, **kwargs):
    """Execute an external command and return the result."""
    res = subprocess.check_output(command, stderr=subprocess.STDOUT, shell=kwargs.get("shell", False))
    return [gef_pystring(_) for _ in res.splitlines()] if as_list else gef_pystring(res)


def gef_execute_gdb_script(commands):
    """Execute the parameter `source` as GDB command. This is done by writing `commands` to
    a temporary file, which is then executed via GDB `source` command. The tempfile is then deleted."""
    fd, fname = tempfile.mkstemp(dir=GEF_TEMP_DIR, suffix=".gdb", prefix="gef_")
    with os.fdopen(fd, "w") as f:
        f.write(commands)
        f.flush()
    if os.access(fname, os.R_OK):
        gdb.execute("source {:s}".format(fname))
        os.unlink(fname)
    return


@functools.lru_cache(maxsize=None)
def checksec(filename):
    """Check the security property of the ELF binary. The following properties are:
    Canary, NX, PIE, RELRO, Fortify, Static, Stripped, Intel CET, RPATH/RUNPATH, and Clang CFI/SafeStack.
    Return a dict() with the different keys mentioned above, and the boolean
    associated whether the protection was found."""

    try:
        readelf = which("readelf")
        objdump = which("objdump")
    except FileNotFoundError as e:
        err("{}".format(e))
        return False

    if not os.path.exists(filename):
        return False

    cache = {}

    def __check_security_property(opt, filename, pattern):
        if (opt, filename) in cache:
            lines = cache[(opt, filename)]
        else:
            cmd = [readelf]
            cmd += opt.split()
            cmd += [filename]
            lines = gef_execute_external(cmd, as_list=True)
            cache[(opt, filename)] = lines
        for line in lines:
            if re.search(pattern, line):
                return True
        return False

    results = collections.OrderedDict()

    # Static
    results["Static"] = is_static(filename)

    # Stripped
    results["Stripped"] = is_stripped(filename)

    # Canary
    if is_stripped(filename) and is_static(filename):
        # heuristic search
        results["Canary"] = None # it means unknown
        if is_x86_64():
            proc = subprocess.Popen([objdump, "-d", filename], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            for i in range(0x10000):
                if b"%fs:0x28" in proc.stdout.readline():
                    results["Canary"] = True
                    break
            proc.kill()
        elif is_x86_32():
            proc = subprocess.Popen([objdump, "-d", filename], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            for i in range(0x10000):
                if b"%gs:0x14" in proc.stdout.readline():
                    results["Canary"] = True
                    break
            proc.kill()
    else:
        results["Canary"] = __check_security_property("-rs", filename, r"__stack_chk_fail") is True
        if not results["Canary"]: # for non-x86
            results["Canary"] = __check_security_property("-rs", filename, r"__stack_chk_guard") is True
        if not results["Canary"]: # for intel compiler
            results["Canary"] = __check_security_property("-rs", filename, r"__intel_security_cookie") is True

    # NX
    has_gnu_stack = __check_security_property("-W -l", filename, r"GNU_STACK") is True
    if has_gnu_stack:
        results["NX"] = __check_security_property("-W -l", filename, r"GNU_STACK.*RWE") is False
    else:
        results["NX"] = False

    # PIE
    results["PIE"] = __check_security_property("-h", filename, r":.*EXEC") is False

    # RELRO
    results["Partial RELRO"] = __check_security_property("-l", filename, r"GNU_RELRO") is True
    results["Full RELRO"] = results["Partial RELRO"] and __check_security_property("-d", filename, r"BIND_NOW") is True

    # Fortify
    if is_stripped(filename):
        results["Fortify"] = None # it means unknown
    elif is_static(filename):
        results["Fortify"] = __check_security_property("-rs", filename, r"__mem(cpy|move)_chk") is True
    else:
        results["Fortify"] = __check_security_property("-rs", filename, r"_chk@GLIBC") is True

    # CET
    if not is_x86():
        results["Intel CET"] = False
    elif not is_stripped(filename) and not is_static(filename):
        results["Intel CET"] = __check_security_property("-S", filename, r"\.plt\.sec") is True
    else: # static or stripped
        cmd = [objdump, "-d", "-j", ".plt", filename] # check only .plt section for speed up
        out = gef_execute_external(cmd, as_list=True)
        results["Intel CET"] = False
        for line in out:
            line = line.strip()
            if not line:
                continue
            if is_x86_64() and line.endswith("endbr64"):
                results["Intel CET"] = True
                break
            elif is_x86_32() and line.endswith("endbr32"):
                results["Intel CET"] = True
                break

    # RPATH
    results["RPATH"] = __check_security_property("-d", filename, r"\(RPATH\)") is True

    # RUNPATH
    results["RUNPATH"] = __check_security_property("-d", filename, r"\(RUNPATH\)") is True

    # Clang CFI (detected only when `-fno-sanitize-trap=all`)
    results["Clang CFI"] = __check_security_property("-s", filename, r"__ubsan_handle_cfi_") is True

    # Clang SafeStack
    results["Clang SafeStack"] = __check_security_property("-s", filename, r"__safestack_init") is True

    return results


@functools.lru_cache(maxsize=None)
def get_arch():
    """Return the binary's architecture."""
    if is_alive():
        try:
            arch = gdb.selected_frame().architecture()
            return arch.name()
        except Exception:
            # For unknown reasons, gdb.selected_frame() may cause an error (often occurs during kernel startup).
            # Resolve by moving to the slow path.
            pass

    # slow path
    arch_str = gdb.execute("show architecture", to_string=True).strip()
    if "The target architecture is set automatically (currently " in arch_str:
        arch_str = arch_str.split("(currently ", 1)[1]
        arch_str = arch_str.split(")", 1)[0]
    elif "The target architecture is set to \"auto\" (currently \"" in arch_str:
        # GDB version >= 12.x
        arch_str = arch_str.split("(currently \"", 1)[1]
        arch_str = arch_str.split("\")", 1)[0]
    elif "The target architecture is assumed to be " in arch_str:
        arch_str = arch_str.replace("The target architecture is assumed to be ", "")
    elif "The target architecture is set to " in arch_str:
        # GDB version >= 10.1
        arch_str = re.findall(r"\"(.+)\"", arch_str)[0]
    else:
        # Unknown, we throw an exception to be safe
        raise RuntimeError("Unknown architecture: {}".format(arch_str))
    return arch_str


@functools.lru_cache(maxsize=None)
def get_endian():
    """Return the binary endianness."""
    endian = gdb.execute("show endian", to_string=True).strip().lower()
    if "little endian" in endian:
        return Elf.LITTLE_ENDIAN
    if "big endian" in endian:
        return Elf.BIG_ENDIAN
    raise EnvironmentError("Invalid endianness")


@functools.lru_cache(maxsize=None)
def get_entry_point():
    """Return the binary entry point."""
    for line in gdb.execute("elf-info", to_string=True).split("\n"):
        if "Entry point" in line:
            return int(line.strip().split(" ")[-1], 16)
    for line in gdb.execute("info target", to_string=True).split("\n"):
        if "Entry point:" in line:
            return int(line.strip().split(" ")[-1], 16)
    return None


def is_pie(fpath):
    return checksec(fpath).get("PIE", False)


def is_big_endian():
    return get_endian() == Elf.BIG_ENDIAN


def is_little_endian():
    return not is_big_endian()


def flags_to_human(reg_value, value_table):
    """Return a human readable string showing the flag states."""
    flags = []
    for i in value_table:
        if reg_value & (1 << i):
            flag_str = Color.boldify(value_table[i].upper())
        else:
            flag_str = value_table[i].lower()
        flags.append(flag_str)
    return "{:#x} [{}]".format(reg_value, " ".join(flags))


class Architecture:
    """Generic metaclass for the architecture supported by GEF."""
    __metaclass__ = abc.ABCMeta

    @abc.abstractproperty
    def all_registers(self):
        pass

    @abc.abstractproperty
    def alias_registers(self):
        pass

    @abc.abstractproperty
    def instruction_length(self):
        pass

    @abc.abstractproperty
    def has_delay_slot(self):
        pass

    @abc.abstractproperty
    def has_syscall_delay_slot(self):
        pass

    @abc.abstractproperty
    def has_ret_delay_slot(self):
        pass

    @abc.abstractproperty
    def nop_insn(self):
        pass

    @abc.abstractproperty
    def infloop_insn(self):
        pass

    @abc.abstractproperty
    def trap_insn(self):
        pass

    @abc.abstractproperty
    def ret_insn(self):
        pass

    @abc.abstractproperty
    def return_register(self):
        pass

    @abc.abstractproperty
    def flag_register(self):
        pass

    @abc.abstractproperty
    def flags_table(self):
        pass

    @abc.abstractproperty
    def function_parameters(self):
        pass

    @abc.abstractmethod
    def flag_register_to_human(self, val=None):
        pass

    @abc.abstractmethod
    def is_syscall(self, insn):
        pass

    @abc.abstractmethod
    def is_call(self, insn):
        pass

    @abc.abstractmethod
    def is_jump(self, insn):
        pass

    @abc.abstractmethod
    def is_ret(self, insn):
        pass

    @abc.abstractmethod
    def is_conditional_branch(self, insn):
        pass

    @abc.abstractmethod
    def is_branch_taken(self, insn):
        pass

    @abc.abstractmethod
    def get_ra(self, insn, frame):
        pass

    @abc.abstractmethod
    def keystone_support(self):
        pass

    @abc.abstractmethod
    def capstone_support(self):
        pass

    @abc.abstractmethod
    def unicorn_support(self):
        pass

    special_registers = []

    @property
    def pc(self):
        return get_register("$pc")

    @property
    def sp(self):
        return get_register("$sp")

    @property
    def fp(self):
        return get_register("$fp")

    @property
    def ptrsize(self):
        return get_memory_alignment()

    def get_ith_parameter(self, i, in_func=True):
        if i < len(self.function_parameters):
            reg = self.function_parameters[i]
            val = get_register(reg)
            key = reg
            return key, val
        else:
            i -= len(self.function_parameters)
            sp = current_arch.sp
            sz = current_arch.ptrsize
            loc = sp + (i * sz)
            val = read_int_from_memory(loc)
            key = "[sp + {:#x}]".format(i * sz)
            return key, val

    __aliased_registers = None

    # {"$zero":"$zero/$x0", ...}
    def get_aliased_registers(self):
        if self.__aliased_registers is not None:
            return self.__aliased_registers
        self.__aliased_registers = {}
        for reg in self.all_registers:
            if self.alias_registers and reg in self.alias_registers:
                reg_str = "{:s}/{:s}".format(reg, self.alias_registers[reg])
            else:
                reg_str = reg
            self.__aliased_registers[reg] = reg_str
        return self.__aliased_registers

    __aliased_registers_max_len = None

    # max(len("$zero/$x0"), ...)
    def get_aliased_registers_name_max(self):
        if self.__aliased_registers_max_len is not None:
            return self.__aliased_regsiters_max_len
        maxlen = max([len(v) for k, v in self.get_aliased_registers().items()])
        self.__aliased_regsiters_max_len = maxlen
        return self.__aliased_regsiters_max_len


class RISCV(Architecture):
    arch = "RISCV"
    mode = "RISCV32"

    # https://msyksphinz-self.github.io/riscv-isadoc/html/index.html
    all_registers = [
        "$zero", "$ra", "$sp", "$gp", "$tp", "$t0", "$t1", "$t2",
        "$fp", "$s1", "$a0", "$a1", "$a2", "$a3", "$a4", "$a5",
        "$a6", "$a7", "$s2", "$s3", "$s4", "$s5", "$s6", "$s7",
        "$s8", "$s9", "$s10", "$s11", "$t3", "$t4", "$t5", "$t6",
        "$pc",
    ]
    alias_registers = {
        "$zero": "$x0", "$ra": "$x1", "$sp": "$x2", "$gp": "$x3",
        "$tp": "$x4/$s0", "$t0": "$x5", "$t1": "$x6", "$t2": "$x7",
        "$fp": "$x8", "$s1": "$x9", "$a0": "$x10", "$a1": "$x11",
        "$a2": "$x12", "$a3": "$x13", "$a4": "$x14", "$a5": "$x15",
        "$a6": "$x16", "$a7": "$x17", "$s2": "$x18", "$s3": "$x19",
        "$s4": "$x20", "$s5": "$x21", "$s6": "$x22", "$s7": "$x23",
        "$s8": "$x24", "$s9": "$x25", "$s10": "$x26", "$s11": "$x27",
        "$t3": "$x28", "$t4": "$x29", "$t5": "$x30", "$t6": "$x31",
    }
    flag_register = None # RISC-V has no flags register
    return_register = "$a0"
    function_parameters = ["$a0", "$a1", "$a2", "$a3", "$a4", "$a5", "$a6", "$a7"]
    syscall_register = "$a7"
    syscall_parameters = ["$a0", "$a1", "$a2", "$a3", "$a4", "$a5"]

    instruction_length = None # variable length
    has_delay_slot = False
    has_syscall_delay_slot = False
    has_ret_delay_slot = False

    keystone_support = False
    capstone_support = True
    unicorn_support = True

    nop_insn = b"\x13\x00\x00\x00" # nop
    infloop_insn = b"\x6f\x00\x00\x00" # j self
    trap_insn = b"\x73\x00\x10\x00" # ebreak
    ret_insn = b"\x67\x80\x00\x00" # ret
    syscall_insn = b"\x73\x00\x00\x00" # ecall

    def is_syscall(self, insn):
        return insn.mnemonic in ["ecall"]

    def is_call(self, insn):
        if self.is_ret(insn):
            return False
        if insn.mnemonic in ["jal", "jalr", "c.jal", "c.jalr"]:
            return True
        return False

    def is_jump(self, insn):
        if self.is_conditional_branch(insn):
            return True
        if insn.mnemonic in ["c.j", "c.jr"]:
            return True
        return False

    def is_ret(self, insn):
        mnemo = insn.mnemonic
        if mnemo == "ret":
            return True
        elif mnemo == "jalr":
            return insn.operands[:3] == ["zero", "ra", "0"]
        elif mnemo == "c.jalr":
            return insn.operands[0] == "ra"
        return False

    def is_conditional_branch(self, insn):
        branch_mnemos = [
            "beq", "bne", "blt", "bge", "bltu", "bgeu",
            "c.beqz", "c.bnez",
        ]
        return insn.mnemonic in branch_mnemos

    def is_branch_taken(self, insn):
        def long_to_twos_complement(v):
            """Convert a python long value to its two's complement."""
            if is_32bit():
                if v & 0x80000000:
                    return v - 0x100000000
            elif is_64bit():
                if v & 0x8000000000000000:
                    return v - 0x10000000000000000
            else:
                raise OSError("RISC-V: ELF file is not ELF32 or ELF64. This is not currently supported")
            return v

        mnemo = insn.mnemonic
        condition = mnemo[1:]

        if condition.endswith("z"):
            # r2 is the zero register if we are comparing to 0
            rs1 = get_register(insn.operands[0])
            rs2 = get_register("$zero")
            condition = condition[:-1]
        elif len(insn.operands) > 2:
            # r2 is populated with the second operand
            rs1 = get_register(insn.operands[0])
            rs2 = get_register(insn.operands[1])
        else:
            raise OSError("RISC-V: Failed to get rs1 and rs2 for instruction: `{}`".format(insn))

        # If the conditional operation is not unsigned, convert the python long into
        # its two's complement
        if not condition.endswith("u"):
            rs2 = long_to_twos_complement(rs2)
            rs1 = long_to_twos_complement(rs1)
        else:
            condition = condition[:-1]

        if condition == "eq":
            if rs1 == rs2:
                taken, reason = True, "{}={}".format(rs1, rs2)
            else:
                taken, reason = False, "{}!={}".format(rs1, rs2)
        elif condition == "ne":
            if rs1 != rs2:
                taken, reason = True, "{}!={}".format(rs1, rs2)
            else:
                taken, reason = False, "{}={}".format(rs1, rs2)
        elif condition == "lt":
            if rs1 < rs2:
                taken, reason = True, "{}<{}".format(rs1, rs2)
            else:
                taken, reason = False, "{}>={}".format(rs1, rs2)
        elif condition == "ge":
            if rs1 < rs2:
                taken, reason = True, "{}>={}".format(rs1, rs2)
            else:
                taken, reason = False, "{}<{}".format(rs1, rs2)
        else:
            raise OSError("RISC-V: Conditional instruction `{:s}` not supported yet".format(insn))

        return taken, reason

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = get_register("$ra")
            elif frame.older():
                ra = frame.older().pc()
        except Exception:
            pass
        return ra

    @classmethod
    def mprotect_asm_raw(cls, addr, size, perm):

        def p(x):
            return p32(int(x, 2))

        def xor(reg1, reg2, reg3):
            fmt = "0b00000_00_{:05b}_{:05b}_100_{:05b}_01100_11"
            return p(fmt.format(reg3, reg2, reg1))

        def slli(reg1, reg2, imm):
            fmt = "0b00000_{:07b}_{:05b}_001_{:05b}_00100_11"
            return p(fmt.format(imm, reg2, reg1))

        def addi(reg1, reg2, imm):
            fmt = "0b{:012b}_{:05b}_000_{:05b}_00100_11"
            return p(fmt.format(imm, reg2, reg1))

        _NR_mprotect = 226
        insns = [
            xor(10, 10, 10), # xor a0, a0, a0
            addi(10, 10, (addr >> 20) & 0xfff), # addi a0, a0, addr[31:20]
            slli(10, 10, 12), # slli a0, a0, 12
            addi(10, 10, (addr >> 8) & 0xfff), # addi a0, a0, addr[19:8]
            slli(10, 10, 8), # slli a0, a0, 8
            addi(10, 10, (addr >> 0) & 0xff), # addi a0, a0, addr[7:0]

            xor(11, 11, 11), # xor a1, a1, a1
            addi(11, 11, (size >> 20) & 0xfff), # addi a1, a1, size[31:20]
            slli(11, 11, 12), # slli a1, a1, 12
            addi(11, 11, (size >> 8) & 0xfff), # addi a1, a1, size[19:8]
            slli(11, 11, 8), # slli a1, a1, 8
            addi(11, 11, (size >> 0) & 0xff), # addi a1, a1, size[7:0]

            xor(12, 12, 12), # xor a2, a2, a2
            addi(12, 12, (perm >> 20) & 0xfff), # addi a2, a2, perm[31:20]
            slli(12, 12, 12), # slli a2, a2, 12
            addi(12, 12, (perm >> 8) & 0xfff), # addi a2, a2, perm[19:8]
            slli(12, 12, 8), # slli a2, a2, 8
            addi(12, 12, (perm >> 0) & 0xff), # addi a2, a2, perm[7:0]

            addi(17, 0, _NR_mprotect), # addi a7, zero, _NR_mprotect
            p("0b00000_00_00000_00000_000_00000_11100_11"), # ecall
        ]
        return b''.join(insns)


class RISCV64(RISCV):
    arch = "RISCV"
    mode = "RISCV64"

    @classmethod
    def mprotect_asm_raw(cls, addr, size, perm):

        def p(x):
            return p32(int(x, 2))

        def xor(reg1, reg2, reg3):
            fmt = "0b00000_00_{:05b}_{:05b}_100_{:05b}_01100_11"
            return p(fmt.format(reg3, reg2, reg1))

        def slli(reg1, reg2, imm):
            fmt = "0b00000_{:07b}_{:05b}_001_{:05b}_00100_11"
            return p(fmt.format(imm, reg2, reg1))

        def addi(reg1, reg2, imm):
            fmt = "0b{:012b}_{:05b}_000_{:05b}_00100_11"
            return p(fmt.format(imm, reg2, reg1))

        _NR_mprotect = 226
        insns = [
            xor(10, 10, 10), # xor a0, a0, a0
            addi(10, 10, (addr >> 52) & 0xfff), # addi a0, a0, addr[63:52]
            slli(10, 10, 12), # slli a0, a0, 12
            addi(10, 10, (addr >> 40) & 0xfff), # addi a0, a0, addr[51:40]
            slli(10, 10, 12), # slli a0, a0, 12
            addi(10, 10, (addr >> 28) & 0xfff), # addi a0, a0, addr[39:28]
            slli(10, 10, 12), # slli a0, a0, 12
            addi(10, 10, (addr >> 16) & 0xfff), # addi a0, a0, addr[27:16]
            slli(10, 10, 12), # slli a0, a0, 12
            addi(10, 10, (addr >> 4) & 0xfff), # addi a0, a0, addr[15:4]
            slli(10, 10, 4), # slli a0, a0, 4
            addi(10, 10, (addr >> 0) & 0xf), # addi a0, a0, addr[3:0]

            xor(11, 11, 11), # xor a1, a1, a1
            addi(11, 11, (size >> 52) & 0xfff), # addi a1, a1, size[63:52]
            slli(11, 11, 12), # slli a1, a1, 12
            addi(11, 11, (size >> 40) & 0xfff), # addi a1, a1, size[51:40]
            slli(11, 11, 12), # slli a1, a1, 12
            addi(11, 11, (size >> 28) & 0xfff), # addi a1, a1, size[39:28]
            slli(11, 11, 12), # slli a1, a1, 12
            addi(11, 11, (size >> 16) & 0xfff), # addi a1, a1, size[27:16]
            slli(11, 11, 12), # slli a1, a1, 12
            addi(11, 11, (size >> 4) & 0xfff), # addi a1, a1, size[15:4]
            slli(11, 11, 4), # slli a1, a1, 4
            addi(11, 11, (size >> 0) & 0xf), # addi a1, a1, size[3:0]

            xor(12, 12, 12), # xor a2, a2, a2
            addi(12, 12, (perm >> 52) & 0xfff), # addi a2, a2, perm[63:52]
            slli(12, 12, 12), # slli a2, a2, 12
            addi(12, 12, (perm >> 40) & 0xfff), # addi a2, a2, perm[51:40]
            slli(12, 12, 12), # slli a2, a2, 12
            addi(12, 12, (perm >> 28) & 0xfff), # addi a2, a2, perm[39:28]
            slli(12, 12, 12), # slli a2, a2, 12
            addi(12, 12, (perm >> 16) & 0xfff), # addi a2, a2, perm[27:16]
            slli(12, 12, 12), # slli a2, a2, 12
            addi(12, 12, (perm >> 4) & 0xfff), # addi a2, a2, perm[15:4]
            slli(12, 12, 4), # slli a2, a2, 4
            addi(12, 12, (perm >> 0) & 0xf), # addi a2, a2, perm[3:0]

            addi(17, 0, _NR_mprotect), # addi a7, zero, _NR_mprotect
            p("0b00000_00_00000_00000_000_00000_11100_11"), # ecall
        ]
        return b''.join(insns)


class ARM(Architecture):
    arch = "ARM"

    try:
        gdb.execute("info registers xpsr", to_string=True)
        _mode = "cortex-m"
    except Exception:
        _mode = "normal"

    if _mode == "normal":
        all_registers = [
            "$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7",
            "$r8", "$r9", "$r10", "$r11", "$r12", "$sp", "$lr", "$pc",
            "$cpsr",
        ]
        alias_registers = {
            "$sp": "$r13", "$lr": "$r14", "$pc": "$r15",
        }
        flag_register = "$cpsr"
        thumb_bit = 5
    elif _mode == "cortex-m":
        all_registers = [
            "$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7",
            "$r8", "$r9", "$r10", "$r11", "$r12", "$sp", "$lr", "$pc",
            "$xpsr",
            "$msp", "$psp", "$primask", "$basepri", "$faultmask", "$control",
        ]
        alias_registers = {
            "$sp": "$r13", "$lr": "$r14", "$pc": "$r15",
        }
        flag_register = "$xpsr"
        thumb_bit = 24
    else:
        raise

    flags_table = {
        31: "negative",
        30: "zero",
        29: "carry",
        28: "overflow",
        7: "interrupt",
        6: "fast",
        thumb_bit: "thumb",
    }
    return_register = "$r0"
    function_parameters = ["$r0", "$r1", "$r2", "$r3"]
    syscall_register = "$r7"
    syscall_parameters = ["$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6"]

    def is_thumb(self):
        """Determine if the machine is currently in THUMB mode."""
        return is_alive() and get_register(self.flag_register) & (1 << self.thumb_bit)

    @property
    def mode(self):
        if self.is_thumb():
            return "THUMB"
        else:
            return "ARM"

    @property
    def instruction_length(self):
        # Thumb instructions have variable-length (2 or 4-byte)
        if self.is_thumb():
            return None # variable length
        else:
            return 4

    has_delay_slot = False
    has_syscall_delay_slot = False
    has_ret_delay_slot = False

    keystone_support = True
    capstone_support = True
    unicorn_support = True

    # http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0041c/Caccegih.html
    @property
    def nop_insn(self):
        if self.is_thumb():
            return b"\x00\xbf" # nop
        else:
            return b"\x01\x10\xa0\xe1" # mov r1, r1

    @property
    def infloop_insn(self):
        if self.is_thumb():
            return b"\xfe\xe7" # b #0
        else:
            return b"\xfe\xff\xff\xea" # b #0

    @property
    def trap_insn(self):
        if self.is_thumb():
            return b"\x00\xbe" # bkpt #0
        else:
            return b"\x70\x00\x20\xe1" # bkpt #0

    @property
    def ret_insn(self):
        if self.is_thumb():
            return b"\xf7\x46" # mov pc, lr
        else:
            return b"\x0e\xf0\xa0\xe1" # mov pc, lr

    @property
    def syscall_insn(self):
        if self.is_thumb():
            return b"\x00\xdf" # svc 0x0
        else:
            return b"\x00\x00\x00\xef" # svc 0x0

    @property
    def pc(self):
        pc = get_register("$pc")
        if self.is_thumb():
            pc += 1
        return pc

    def is_syscall(self, insn):
        return insn.mnemonic in ["svc", "swi"]

    def is_call(self, insn):
        conditions = [
            "", "eq", "ne", "lt", "le", "gt", "ge", "vs", "vc",
            "mi", "pl", "hi", "ls", "cs", "cc", "hs", "lo", "al",
        ]
        for cc in conditions:
            if insn.mnemonic in [f"bl{cc}", f"bl{cc}.n", f"bl{cc}.w", f"blx{cc}", f"blx{cc}.n", f"blx{cc}.w"]:
                return True
        return False

    def is_jump(self, insn):
        if self.is_ret(insn):
            return False
        if self.is_conditional_branch(insn):
            return True
        if insn.mnemonic in ["b", "b.n", "b.w", "bx", "bx.n", "bx.w"]:
            return True
        if insn.mnemonic in ["mov", "mov.n", "mov.w", "ldr", "ldr.n", "ldr.w", "add", "add.n", "add.w"]:
            return insn.operands[0] == "pc"
        return False

    def is_ret(self, insn):
        load_mnemos = [
            "pop", "ldm", "ldmea", "ldmed", "ldmfa",
            "ldmfd", "ldmia", "ldmib", "ldmda", "ldmdb",
            "ldm.n", "ldmea.n", "ldmed.n", "ldmfa.n",
            "ldmfd.n", "ldmia.n", "ldmib.n", "ldmda.n", "ldmdb.n",
            "ldm.w", "ldmea.w", "ldmed.w", "ldmfa.w",
            "ldmfd.w", "ldmia.w", "ldmib.w", "ldmda.w", "ldmdb.w",
        ]
        if insn.mnemonic in load_mnemos:
            return "pc}" in "".join(insn.operands)
        if insn.mnemonic in ["b", "b.n", "b.w", "bx", "bx.n", "bx.w"]:
            return insn.operands[0] == "lr"
        if insn.mnemonic in ["mov", "mov.n", "mov.w"]:
            return insn.operands[:2] == ["pc", "lr"]
        if insn.mnemonic == "rfe":
            return True
        return False

    def is_conditional_branch(self, insn):
        conditions = [
            "eq", "ne", "lt", "le", "gt", "ge", "vs", "vc",
            "mi", "pl", "hi", "ls", "cs", "cc", "hs", "lo", "al",
        ]
        for cc in conditions:
            if insn.mnemonic in [f"b{cc}", f"b{cc}.n", f"b{cc}.w", f"bx{cc}", f"bx{cc}.n", f"bx{cc}.w"]:
                return True
        if insn.mnemonic in ["cbnz", "cbz", "tbnz", "tbz"]:
            return True
        return False

    def is_branch_taken(self, insn):
        mnemo, operands = insn.mnemonic, insn.operands
        # ref: http://www.davespace.co.uk/arm/introduction-to-arm/conditional.html
        flags = dict((self.flags_table[k], k) for k in self.flags_table)
        val = get_register(self.flag_register)
        taken, reason = False, ""

        zero = bool(val & (1 << flags["zero"]))
        negative = bool(val & (1 << flags["negative"]))
        overflow = bool(val & (1 << flags["overflow"]))
        carry = bool(val & (1 << flags["carry"]))

        if mnemo in ["cbnz", "cbz", "tbnz", "tbz"]:
            reg = operands[0]
            op = get_register(reg)
            if mnemo == "cbnz":
                if op != 0:
                    taken, reason = True, "{}!=0".format(reg)
                else:
                    taken, reason = False, "{}==0".format(reg)
            elif mnemo == "cbz":
                if op == 0:
                    taken, reason = True, "{}==0".format(reg)
                else:
                    taken, reason = False, "{}!=0".format(reg)
            elif mnemo == "tbnz":
                # operands[1] has a #, then the number
                i = int(operands[1].lstrip("#"))
                if (op & (1 << i)) != 0:
                    taken, reason = True, "{}&1<<{}!=0".format(reg, i)
                else:
                    taken, reason = False, "{}&1<<{}==0".format(reg, i)
            elif mnemo == "tbz":
                # operands[1] has a #, then the number
                i = int(operands[1].lstrip("#"))
                if (op & (1 << i)) == 0:
                    taken, reason = True, "{}&1<<{}==0".format(reg, i)
                else:
                    taken, reason = False, "{}&1<<{}!=0".format(reg, i)
        elif mnemo.endswith("eq"):
            taken, reason = zero, "Z"
        elif mnemo.endswith("ne"):
            taken, reason = not zero, "!Z"
        elif mnemo.endswith("lt"):
            taken, reason = negative != overflow, "N!=V"
        elif mnemo.endswith("le"):
            taken, reason = zero or negative != overflow, "Z || N!=V"
        elif mnemo.endswith("gt"):
            taken, reason = not zero and negative == overflow, "!Z && N==V"
        elif mnemo.endswith("ge"):
            taken, reason = negative == overflow, "N==V"
        elif mnemo.endswith("vs"):
            taken, reason = overflow, "V"
        elif mnemo.endswith("vc"):
            taken, reason = not overflow, "!V"
        elif mnemo.endswith("mi"):
            taken, reason = negative, "N"
        elif mnemo.endswith("pl"):
            taken, reason = not negative, "N==0"
        elif mnemo.endswith("hi"):
            taken, reason = carry and not zero, "C && !Z"
        elif mnemo.endswith("ls"):
            taken, reason = not carry or zero, "!C || Z"
        elif mnemo.endswith("cs") or mnemo.endswith("hs"):
            taken, reason = carry, "C"
        elif mnemo.endswith("cc") or mnemo.endswith("lo"):
            taken, reason = not carry, "!C"
        return taken, reason

    __SCR_available = None
    __mode_dic = {
        # encoding: [mode, PL]
        0b10000: ["User", 0],
        0b10001: ["FIQ", 1],
        0b10010: ["IRQ", 1],
        0b10011: ["Supervisor", 1],
        0b10110: ["Monitor", 1],
        0b10111: ["Abort", 1],
        0b11010: ["Hypervisor", 2],
        0b11011: ["Undefined", 1],
        0b11111: ["System", 1],
    }

    def flag_register_to_human(self, val=None):
        # http://www.botskool.com/user-pages/tutorials/electronics/arm-7-tutorial-part-1
        if val is None:
            reg = self.flag_register
            val = get_register(reg) & 0xffffffff

        key = val & 0b11111
        CurrentMode, CurrentPL = self.__mode_dic[key]

        if self.__SCR_available is False: # for speed up
            mode = " [Mode={:s}({:#07b},PL{:d})]".format(CurrentMode, key, CurrentPL)
        else:
            scr = get_register("$SCR")
            if scr is not None:
                self.__SCR_available = True
                secure_state = ["Secure", "Non-Secure"][scr & 1]
                mode = " [Mode={:s}({:#07b},PL{:d}),{:s}]".format(CurrentMode, key, CurrentPL, secure_state)
            else:
                self.__SCR_available = False
                mode = " [Mode={:s}({:#07b},PL{:d})]".format(CurrentMode, key, CurrentPL)
        return flags_to_human(val, self.flags_table) + mode

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                # If it's a pop, we have to peek into the stack, otherwise use lr
                if insn.mnemonic == "pop":
                    ra_addr = current_arch.sp + (len(insn.operands) - 1) * get_memory_alignment()
                    ra = to_unsigned_long(dereference(ra_addr))
                elif insn.mnemonic == "ldr":
                    return to_unsigned_long(dereference(current_arch.sp))
                else: # 'bx lr' or 'add pc, lr, #0'
                    return get_register("$lr")
            elif frame.older():
                ra = frame.older().pc()
        except Exception:
            pass
        return ra

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 125
        insns = [
            "mov r7, {:d}".format(_NR_mprotect),
            "movw r0, #{:#x}".format((addr >> 16) & 0xffff),
            "lsl r0, r0, 16",
            "orr r0, #{:#x}".format((addr >> 0) & 0xffff),
            "movw r1, #{:#x}".format((size >> 16) & 0xffff),
            "lsl r1, r1, 16",
            "orr r1, #{:#x}".format((size >> 0) & 0xffff),
            "mov r2, {:d}".format(perm),
            "svc 0",
        ]
        return "; ".join(insns)


class AARCH64(ARM):
    arch = "ARM64"
    mode = "ARM"

    all_registers = [
        "$x0", "$x1", "$x2", "$x3", "$x4", "$x5", "$x6", "$x7",
        "$x8", "$x9", "$x10", "$x11", "$x12", "$x13", "$x14", "$x15",
        "$x16", "$x17", "$x18", "$x19", "$x20", "$x21", "$x22", "$x23",
        "$x24", "$x25", "$x26", "$x27", "$x28", "$x29", "$x30", "$sp",
        "$pc", "$cpsr", "$fpsr", "$fpcr",
    ]
    alias_registers = {
        "$x30": "$lr",
    }
    flag_register = "$cpsr"
    flags_table = {
        31: "negative",
        30: "zero",
        29: "carry",
        28: "overflow",
        7: "interrupt",
        6: "fast",
    }
    return_register = "$x0"
    function_parameters = ["$x0", "$x1", "$x2", "$x3", "$x4", "$x5", "$x6", "$x7"]
    syscall_register = "$x8"
    syscall_parameters = ["$x0", "$x1", "$x2", "$x3", "$x4", "$x5"]

    nop_insn = b"\x1f\x20\x03\xd5" # nop
    infloop_insn = b"\x00\x00\x00\x14" # b #0
    trap_insn = b"\x00\x00\x20\xd4" # bkr #0
    ret_insn = b"\xc0\x03\x5f\xd6" # ret
    syscall_insn = b"\x01\x00\x00\xd4" # svc #0x0

    def is_syscall(self, insn):
        return insn.mnemonic == "svc" and insn.operands[0] == "#0x0"

    def is_call(self, insn):
        return insn.mnemonic in ["bl", "blr"]

    def is_jump(self, insn):
        if self.is_conditional_branch(insn):
            return True
        return insn.mnemonic in ["b", "br"]

    def is_ret(self, insn):
        if insn.mnemonic in ["ret", "eret"]:
            return True
        if insn.mnemonic == "ldp" and "pc" in insn.operands:
            return True
        return False

    def is_conditional_branch(self, insn):
        # https://www.element14.com/community/servlet/JiveServlet/previewBody/41836-102-1-229511/ARM.Reference_Manual.pdf
        # sect. 5.1.1
        if insn.mnemonic in ["cbnz", "cbz", "tbnz", "tbz"]:
            return True
        if insn.mnemonic.startswith("b."):
            return True
        return False

    # is_branch_taken is the same as ARM

    __SCR_EL3_available = None

    def flag_register_to_human(self, val=None):
        # http://events.linuxfoundation.org/sites/events/files/slides/KoreaLinuxForum-2014.pdf
        if val is None:
            reg = self.flag_register
            val = get_register(reg) & 0xffffffff

        if self.__SCR_EL3_available is False: # for speed up
            mode = " [EL={:d},SP={:d}]".format((val >> 2) & 0b11, val & 0b11)
        else:
            scr = get_register("$SCR_EL3")
            if scr is not None:
                self.__SCR_EL3_available = True
                secure_state = ["Secure", "Non-Secure"][scr & 1]
                mode = " [EL={:d},SP={:d},{:s}]".format((val >> 2) & 0b11, val & 0b11, secure_state)
            else:
                self.__SCR_EL3_available = False
                mode = " [EL={:d},SP={:d}]".format((val >> 2) & 0b11, val & 0b11)

        return flags_to_human(val, self.flags_table) + mode

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 226
        insns = [
            "mov x8, {:d}".format(_NR_mprotect),
            "movz x0, {:#x}".format(addr & 0xffff),
            "movk x0, {:#x}, lsl 16".format((addr >> 16) & 0xffff),
            "movk x0, {:#x}, lsl 32".format((addr >> 32) & 0xffff),
            "movk x0, {:#x}, lsl 48".format((addr >> 48) & 0xffff),
            "movz x1, {:#x}".format(size & 0xffff),
            "movk x1, {:#x}, lsl 16".format((size >> 16) & 0xffff),
            "movk x1, {:#x}, lsl 32".format((size >> 32) & 0xffff),
            "movk x1, {:#x}, lsl 48".format((size >> 48) & 0xffff),
            "mov x2, {:d}".format(perm),
            "svc 0",
        ]
        return "; ".join(insns)


class X86(Architecture):
    arch = "X86"
    mode = "32"

    gpr_registers = ["$eax", "$ebx", "$ecx", "$edx", "$esp", "$ebp", "$esi", "$edi", "$eip"]
    special_registers = ["$cs", "$ss", "$ds", "$es", "$fs", "$gs"]
    flag_register = "$eflags"
    all_registers = gpr_registers + [flag_register] + special_registers
    alias_registers = {}
    flags_table = {
        21: "identification",
        #20: "virtual_interrupt_pending",
        #19: "virtual_interrupt",
        18: "align",
        17: "virtualx86",
        16: "resume",
        #15: N/A
        14: "nested",
        #12-13: "iopl",
        11: "overflow",
        10: "direction",
        9: "interrupt",
        8: "trap",
        7: "sign",
        6: "zero",
        #5: N/A
        4: "adjust",
        #3: N/A
        2: "parity",
        #1: N/A
        0: "carry",
    }
    return_register = "$eax"
    function_parameters = ["$esp"] # but unused because x86 uses stack
    syscall_register = "$eax"
    syscall_parameters = ["$ebx", "$ecx", "$edx", "$esi", "$edi", "$ebp"]

    instruction_length = None # variable length
    has_delay_slot = False
    has_syscall_delay_slot = False
    has_ret_delay_slot = False

    keystone_support = True
    capstone_support = True
    unicorn_support = True

    nop_insn = b"\x90" # nop
    infloop_insn = b"\xeb\xfe" # jmp 0
    trap_insn = b"\xcc" # int3
    ret_insn = b"\xc3" # ret
    syscall_insn = b"\xcd\x80" # int 0x80

    def flag_register_to_human(self, val=None):
        if val is None:
            reg = self.flag_register
            val = get_register(reg) & 0xffffffff
        mode = " [Ring={:d}]".format(get_register("$cs") & 0b11)
        return flags_to_human(val, self.flags_table) + mode

    def is_syscall(self, insn):
        if insn.mnemonic in ["sysenter", "syscall"]:
            return True
        if insn.mnemonic == "int" and insn.operands[0] == "0x80":
            return True
        return False

    def is_call(self, insn):
        return insn.mnemonic in ["call", "callq"]

    def is_jump(self, insn):
        return insn.mnemonic == "jmp" or self.is_conditional_branch(insn)

    def is_ret(self, insn):
        return insn.mnemonic in ["ret", "retf", "sysret", "iret"]

    def is_conditional_branch(self, insn):
        branch_mnemos = [
            "ja", "jnbe", "jae", "jnb", "jnc", "jb", "jc", "jnae", "jbe", "jna",
            "jcxz", "jecxz", "jrcxz", "je", "jz", "jg", "jnle", "jge", "jnl",
            "jl", "jnge", "jle", "jng", "jne", "jnz", "jno", "jnp", "jpo", "jns",
            "jo", "jp", "jpe", "js",
        ]
        return insn.mnemonic in branch_mnemos

    def is_branch_taken(self, insn):
        mnemo = insn.mnemonic
        # all kudos to fG! (https://github.com/gdbinit/Gdbinit/blob/master/gdbinit#L1654)
        flags = dict((self.flags_table[k], k) for k in self.flags_table)
        val = get_register(self.flag_register)
        taken, reason = False, ""

        zero = bool(val & (1 << flags["zero"]))
        sign = bool(val & (1 << flags["sign"]))
        overflow = bool(val & (1 << flags["overflow"]))
        carry = bool(val & (1 << flags["carry"]))
        parity = bool(val & (1 << flags["parity"]))

        if mnemo in ["ja", "jnbe"]:
            taken, reason = not carry and not zero, "!C && !Z"
        elif mnemo in ["jae", "jnb", "jnc"]:
            taken, reason = not carry, "!C"
        elif mnemo in ["jb", "jc", "jnae"]:
            taken, reason = carry, "C"
        elif mnemo in ["jbe", "jna"]:
            taken, reason = carry or zero, "C || Z"
        elif mnemo in ["jcxz", "jecxz", "jrcxz"]:
            cx = get_register("$rcx") if self.mode == "64" else get_register("$ecx")
            taken, reason = cx == 0, "!$CX"
        elif mnemo in ["je", "jz"]:
            taken, reason = zero, "Z"
        elif mnemo in ["jne", "jnz"]:
            taken, reason = not zero, "!Z"
        elif mnemo in ["jg", "jnle"]:
            taken, reason = not zero and sign == overflow, "!Z && S==O"
        elif mnemo in ["jge", "jnl"]:
            taken, reason = sign == overflow, "S==O"
        elif mnemo in ["jl", "jnge"]:
            taken, reason = sign != overflow, "S!=O"
        elif mnemo in ["jle", "jng"]:
            taken, reason = zero or sign != overflow, "Z || S!=O"
        elif mnemo in ["jo"]:
            taken, reason = overflow, "O"
        elif mnemo in ["jno"]:
            taken, reason = not overflow, "!O"
        elif mnemo in ["jpe", "jp"]:
            taken, reason = parity, "P"
        elif mnemo in ["jnp", "jpo"]:
            taken, reason = not parity, "!P"
        elif mnemo in ["js"]:
            taken, reason = sign, "S"
        elif mnemo in ["jns"]:
            taken, reason = not sign, "!S"
        return taken, reason

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = to_unsigned_long(dereference(current_arch.sp))
            if frame.older():
                ra = frame.older().pc()
        except Exception:
            pass
        return ra

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 125
        insns = [
            "mov eax, {:d}".format(_NR_mprotect),
            "mov ebx, {:d}".format(addr),
            "mov ecx, {:d}".format(size),
            "mov edx, {:d}".format(perm),
            "int 0x80",
        ]
        return "; ".join(insns)

    def get_ith_parameter(self, i, in_func=True):
        if in_func:
            i += 1 # Account for RA being at the top of the stack
        sp = current_arch.sp
        sz = current_arch.ptrsize
        loc = sp + (i * sz)
        val = read_int_from_memory(loc)
        key = "[sp + {:#x}]".format(i * sz)
        return key, val


class X86_64(X86):
    arch = "X86"
    mode = "64"

    gpr_registers = [
        "$rax", "$rbx", "$rcx", "$rdx", "$rsp", "$rbp", "$rsi", "$rdi", "$rip",
        "$r8", "$r9", "$r10", "$r11", "$r12", "$r13", "$r14", "$r15",
    ]
    all_registers = gpr_registers + [X86.flag_register] + X86.special_registers
    alias_registers = {}
    return_register = "$rax"
    function_parameters = ["$rdi", "$rsi", "$rdx", "$rcx", "$r8", "$r9"]
    syscall_register = "$rax"
    syscall_parameters = ["$rdi", "$rsi", "$rdx", "$r10", "$r8", "$r9"]

    syscall_insn = b"\x0f\x05" # syscall

    def is_syscall(self, insn):
        return insn.mnemonic in ["sysenter", "syscall"]

    def get_ith_parameter(self, i, in_func=True):
        if i < len(self.function_parameters):
            reg = self.function_parameters[i]
            val = get_register(reg)
            key = reg
            return key, val
        else:
            i -= len(self.function_parameters)
            if in_func:
                i += 1 # Account for RA being at the top of the stack
            sp = current_arch.sp
            sz = current_arch.ptrsize
            loc = sp + (i * sz)
            val = read_int_from_memory(loc)
            key = "[sp + {:#x}]".format(i * sz)
            return key, val

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 10
        insns = [
            "mov rax, {:d}".format(_NR_mprotect),
            "mov rdi, {:d}".format(addr),
            "mov rsi, {:d}".format(size),
            "mov rdx, {:d}".format(perm),
            "syscall",
        ]
        return "; ".join(insns)


class PPC(Architecture):
    arch = "PPC"
    mode = "PPC32"

    all_registers = [
        "$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7",
        "$r8", "$r9", "$r10", "$r11", "$r12", "$r13", "$r14", "$r15",
        "$r16", "$r17", "$r18", "$r19", "$r20", "$r21", "$r22", "$r23",
        "$r24", "$r25", "$r26", "$r27", "$r28", "$r29", "$r30", "$r31",
        "$pc", "$msr", "$cr", "$lr", "$ctr", "$xer", "$fpscr",
    ]
    alias_registers = {"$r1": "$sp"}
    flag_register = "$cr"
    flags_table = {
        3: "negative[0]",
        2: "positive[0]",
        1: "equal[0]",
        0: "overflow[0]",
        # cr7
        31: "less[7]",
        30: "greater[7]",
        29: "equal[7]",
        28: "overflow[7]",
    }
    return_register = "$r3"
    function_parameters = ["$r3", "$r4", "$r5", "$r6", "$r7", "$r8", "$r9", "$r10"]
    syscall_register = "$r0"
    syscall_parameters = ["$r3", "$r4", "$r5", "$r6", "$r7", "$r8", "$r9"]

    instruction_length = 4
    has_delay_slot = False
    has_syscall_delay_slot = False
    has_ret_delay_slot = False

    keystone_support = True
    capstone_support = True
    unicorn_support = True

    nop_insn = b"\x00\x00\x00\x60" # nop
    infloop_insn = b"\x00\x00\x00\x48" # b #0
    trap_insn = b"\x08\x00\xe0\x7f" # trap
    ret_insn = b"\x20\x00\x80\x4e" # blr
    syscall_insn = b"\x02\x00\x00\x44" # sc

    def flag_register_to_human(self, val=None):
        # http://www.cebix.net/downloads/bebox/pem32b.pdf (% 2.1.3)
        if not val:
            reg = self.flag_register
            val = get_register(reg)
        return flags_to_human(val, self.flags_table)

    def is_syscall(self, insn):
        return insn.mnemonic in ["sc"]

    def is_call(self, insn):
        conditions = [
            "", "lt", "le", "eq", "ge", "gt", "nl",
            "ne", "ng", "so", "ns", "un", "nu",
        ]
        for cc in conditions:
            if insn.mnemonic == f"b{cc}l":
                return True
            if insn.mnemonic == f"b{cc}la":
                return True
            if insn.mnemonic == f"b{cc}ctrl":
                return True
            if insn.mnemonic == f"b{cc}lrl":
                return True
        modes = ["dz", "dnzf", "dzt", "dzf", "dnzt", "dnz"]
        for m in modes:
            if insn.mnemonic == f"b{m}l":
                return True
            if insn.mnemonic == f"b{m}la":
                return True
            if insn.mnemonic == f"b{m}lrl":
                return True
        return False

    def is_jump(self, insn):
        conditions = [
            "", "lt", "le", "eq", "ge", "gt", "nl",
            "ne", "ng", "so", "ns", "un", "nu",
        ]
        for cc in conditions:
            if insn.mnemonic == f"b{cc}":
                return True
            if insn.mnemonic == f"b{cc}a":
                return True
            if insn.mnemonic == f"b{cc}ctr":
                return True
        modes = ["dz", "dnzf", "dzt", "dzf", "dnzt", "dnz"]
        for m in modes:
            if insn.mnemonic == f"b{m}":
                return True
            if insn.mnemonic == f"b{m}a":
                return True
        return False

    def is_ret(self, insn):
        conditions = [
            "", "lt", "le", "eq", "ge", "gt", "nl",
            "ne", "ng", "so", "ns", "un", "nu",
        ]
        for cc in conditions:
            if insn.mnemonic == f"b{cc}lr":
                return True
            if insn.mnemonic == b"b{cc}lrl":
                return True
        modes = ["dz", "dnzf", "dzt", "dzf", "dnzt", "dnz"]
        for m in modes:
            if insn.mnemonic == f"b{m}lr":
                return True
            if insn.mnemonic == f"b{m}lrl":
                return True
        return False

    def is_conditional_branch(self, insn):
        branch_mnemos = [
            "beq", "bne", "ble", "blt", "bgt", "bge",
            "bdz", "bdnz", "bdzt", "bdnzt", "bdzf", "bdnzf",
        ]
        return insn.mnemonic in branch_mnemos

    def is_branch_taken(self, insn):
        mnemo = insn.mnemonic
        flags = dict((self.flags_table[k], k) for k in self.flags_table)
        val = get_register(self.flag_register)
        taken, reason = False, ""

        equal = bool(val & (1 << flags["equal[7]"]))
        less = bool(val & (1 << flags["less[7]"]))
        greater = bool(val & (1 << flags["greater[7]"]))

        if mnemo == "beq":
            taken, reason = equal, "E"
        elif mnemo == "bne":
            taken, reason = not equal, "!E"
        elif mnemo == "ble":
            taken, reason = equal or less, "E || L"
        elif mnemo == "blt":
            taken, reason = less, "L"
        elif mnemo == "bge":
            taken, reason = equal or greater, "E || G"
        elif mnemo == "bgt":
            taken, reason = greater, "G"
        # todo: bdn?z[tf]? are unsupported
        return taken, reason

    def get_ith_parameter(self, i, in_func=True):
        if i < len(self.function_parameters):
            reg = self.function_parameters[i]
            val = get_register(reg)
            key = reg
            return key, val
        else:
            i -= len(self.function_parameters)
            i += 2 # ???
            sp = current_arch.sp
            sz = current_arch.ptrsize
            loc = sp + (i * sz)
            val = read_int_from_memory(loc)
            key = "[sp + {:#x}]".format(i * sz)
            return key, val

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = get_register("$lr")
            elif frame.older():
                ra = frame.older().pc()
        except Exception:
            pass
        return ra

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        # Ref: http://www.ibm.com/developerworks/library/l-ppc/index.html
        _NR_mprotect = 125
        insns = [
            "li 3, 0",
            "ori 3, 3, {:d}".format((addr >> 16) & 0xffff),
            "slwi 3, 3, 16",
            "ori 3, 3, {:d}".format((addr >> 0) & 0xffff),
            "li 4, 0",
            "ori 4, 4, {:d}".format((size >> 16) & 0xffff),
            "slwi 4, 4, 16",
            "ori 4, 4, {:d}".format((size >> 0) & 0xffff),
            "li 5, {:d}".format(perm),
            "li 0, {:d}".format(_NR_mprotect),
            "sc",
        ]
        return ";".join(insns)


class PPC64(PPC):
    arch = "PPC"
    mode = "PPC64"

    all_registers = [
        "$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7",
        "$r8", "$r9", "$r10", "$r11", "$r12", "$r13", "$r14", "$r15",
        "$r16", "$r17", "$r18", "$r19", "$r20", "$r21", "$r22", "$r23",
        "$r24", "$r25", "$r26", "$r27", "$r28", "$r29", "$r30", "$r31",
        "$pc", "$msr", "$cr", "$lr", "$ctr", "$xer", "$fpscr", "$vscr", "$vrsave",
    ]
    syscall_paramter_list = ["$r3", "$r4", "$r5", "$r6", "$r7", "$r8"]

    unicorn_support = False

    def get_ith_parameter(self, i, in_func=True):
        if i < len(self.function_parameters):
            reg = self.function_parameters[i]
            val = get_register(reg)
            key = reg
            return key, val
        else:
            i += 4 # ???
            sp = current_arch.sp
            sz = current_arch.ptrsize
            loc = sp + (i * sz)
            val = read_int_from_memory(loc)
            key = "[sp + {:#x}]".format(i * sz)
            return key, val

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 125
        insns = [
            "li 3, 0",
            "ori 3, 3, {:d}".format((addr >> 48) & 0xffff),
            "sldi 3, 3, 16",
            "ori 3, 3, {:d}".format((addr >> 32) & 0xffff),
            "sldi 3, 3, 16",
            "ori 3, 3, {:d}".format((addr >> 16) & 0xffff),
            "sldi 3, 3, 16",
            "ori 3, 3, {:d}".format((addr >> 0) & 0xffff),
            "li 4, 0",
            "ori 4, 4, {:d}".format((size >> 48) & 0xffff),
            "sldi 4, 4, 16",
            "ori 4, 4, {:d}".format((size >> 32) & 0xffff),
            "sldi 4, 4, 16",
            "ori 4, 4, {:d}".format((size >> 16) & 0xffff),
            "sldi 4, 4, 16",
            "ori 4, 4, {:d}".format((size >> 48) & 0xffff),
            "li 5, {:d}".format(perm),
            "li 0, {:d}".format(_NR_mprotect),
            "sc",
        ]
        return ";".join(insns)


class SPARC(Architecture):
    arch = "SPARC"
    mode = "SPARC32"

    # http://www.cse.scu.edu/~atkinson/teaching/sp05/259/sparc.pdf
    all_registers = [
        "$g0", "$g1", "$g2", "$g3", "$g4", "$g5", "$g6", "$g7",
        "$o0", "$o1", "$o2", "$o3", "$o4", "$o5", "$sp", "$o7",
        "$l0", "$l1", "$l2", "$l3", "$l4", "$l5", "$l6", "$l7",
        "$i0", "$i1", "$i2", "$i3", "$i4", "$i5", "$fp", "$i7",
        "$y", "$psr", "$wim", "$tbr", "$pc", "$npc", "$fsr", "$csr",
    ]
    alias_registers = {
        "$sp": "$o6", "$fp": "$i6",
    }
    flag_register = "$psr"
    flags_table = {
        23: "negative",
        22: "zero",
        21: "overflow",
        20: "carry",
        7: "supervisor",
        5: "trap",
    }
    return_register = "$o0"
    function_parameters = ["$o0", "$o1", "$o2", "$o3", "$o4", "$o5"]
    syscall_register = "$g1"
    syscall_parameters = ["$o0", "$o1", "$o2", "$o3", "$o4", "$o5"]

    instruction_length = 4
    has_delay_slot = True
    has_syscall_delay_slot = True
    has_ret_delay_slot = True

    keystone_support = True
    capstone_support = True
    unicorn_support = True

    nop_insn = b"\x00\x00\x00\x01" # nop
    infloop_insn = b"\x00\x00\x80\x10" # b self
    trap_insn = None
    ret_insn = b"\x08\xe0\xc7\x81" # ret
    syscall_insn = b"\x10\x20\xd0\x91" # trap 0x10

    def flag_register_to_human(self, val=None):
        # http://www.gaisler.com/doc/sparcv8.pdf
        reg = self.flag_register
        if not val:
            val = get_register(reg)
        return flags_to_human(val, self.flags_table)

    def is_syscall(self, insn):
        return insn.mnemonic == "ta" and insn.operands[0] == "0x10"

    def is_call(self, insn):
        return insn.mnemonic in ["jmpl", "call"]

    def is_jump(self, insn):
        mnemo = insn.mnemonic
        return (mnemo.startswith("b") and mnemo != "btst") or mnemo.startswith("fb") or mnemo == "jmpl"

    def is_ret(self, insn):
        return insn.mnemonic in ["ret", "retl"]

    def is_conditional_branch(self, insn):
        branch_mnemos = [
            # http://moss.csc.ncsu.edu/~mueller/codeopt/codeopt00/notes/condbranch.html
            "be", "bne", "bg", "bge", "bgeu", "bgu", "bl", "ble", "blu", "bleu",
            "bneg", "bpos", "bvs", "bvc", "bcs", "bcc"
            # https://www.gaisler.com/doc/sparcv8.pdf
            "fbu", "fbg", "fbug", "fbl", "fbul", "fblg", "fbne", "fbe", "fbue", "fbge",
            "fbuge", "fble", "fbule", "fbo",
            # https://docs.oracle.com/cd/E18752_01/html/816-1681/sparcv9-30990.html
            "bpne", "bpe", "bpg", "bple", "bpge", "bpl", "bpgu", "bpleu", "bpcc", "bpcs",
            "bppos", "bpneg", "bpvc", "bpvs", "brz", "brlez", "brlz", "brnz", "brgz", "brgez",
            "fbpu", "fbpg", "fbpug", "fbpl", "fbpul", "fbplg", "fbpne", "fbpe", "fbpue", "fbpge",
            "fbpuge", "fbple", "fbpule", "fbpo",
        ]
        return insn.mnemonic in branch_mnemos

    def is_branch_taken(self, insn):
        mnemo = insn.mnemonic
        flags = dict((self.flags_table[k], k) for k in self.flags_table)
        val = get_register(self.flag_register)
        taken, reason = False, ""

        zero = bool(val & (1 << flags["zero"]))
        negative = bool(val & (1 << flags["negative"]))
        overflow = bool(val & (1 << flags["overflow"]))
        carry = bool(val & (1 << flags["carry"]))

        if mnemo in ["be", "bpe"]:
            taken, reason = zero, "Z"
        elif mnemo in ["bne", "bpne"]:
            taken, reason = not zero, "!Z"
        elif mnemo in ["bg", "bpg"]:
            taken, reason = not zero and (not negative or not overflow), "!Z && (!N || !O)"
        elif mnemo in ["bge", "bpge"]:
            taken, reason = not negative or not overflow, "!N || !O"
        elif mnemo in ["bgu", "bpgu"]:
            taken, reason = not carry and not zero, "!C && !Z"
        elif mnemo in ["bgeu"]:
            taken, reason = not carry, "!C"
        elif mnemo in ["bl", "bpl"]:
            taken, reason = negative and overflow, "N && O"
        elif mnemo in ["blu"]:
            taken, reason = carry, "C"
        elif mnemo in ["ble", "bple"]:
            taken, reason = zero or (negative or overflow), "Z || (N || O)"
        elif mnemo in ["bleu", "bpleu"]:
            taken, reason = carry or zero, "C || Z"
        elif mnemo in ["bneg", "bpneg"]:
            taken, reason = negative, "N"
        elif mnemo in ["bpos", "bppos"]:
            taken, reason = not negative, "!N"
        elif mnemo in ["bvs", "bpvs"]:
            taken, reason = overflow, "O"
        elif mnemo in ["bvc", "bpvc"]:
            taken, reason = not overflow, "!O"
        elif mnemo in ["bcs", "bpcs"]:
            taken, reason = carry, "C"
        elif mnemo in ["bcc", "bpcc"]:
            taken, reason = not carry, "!C"
        # todo: f* opcode, brn?z/br[lg]e?z are unsupported
        return taken, reason

    def get_ith_parameter(self, i, in_func=True):
        if i < len(self.function_parameters):
            reg = self.function_parameters[i]
            val = get_register(reg)
            key = reg
            return key, val
        else:
            i += 17 # ???
            sp = current_arch.sp
            sz = current_arch.ptrsize
            loc = sp + (i * sz)
            val = read_int_from_memory(loc)
            key = "[sp + {:#x}]".format(i * sz)
            return key, val

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = get_register("$o7")
            elif frame.older():
                ra = frame.older().pc()
        except Exception:
            pass
        return ra

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 74
        insns = [
            "sethi %hi({}), %o0".format(addr & 0xfffffc00),
            "or %o0, {}, %o0".format(addr & 0x000003ff),
            "sethi %hi({}), %o1".format(size & 0xfffffc00),
            "or %o1, {}, %o1".format(size & 0x000003ff),
            "mov {}, %o2".format(perm),
            "mov {}, %g1".format(_NR_mprotect),
            "ta 0x10",
            "nop", # keystone does not give nop for delay slot, needs this nop
        ]
        return "; ".join(insns)


class SPARC64(SPARC):
    arch = "SPARC"
    mode = "SPARC64"

    # http://math-atlas.sourceforge.net/devel/assembly/abi_sysV_sparc.pdf
    # https://cr.yp.to/2005-590/sparcv9.pdf
    all_registers = [
        "$g0", "$g1", "$g2", "$g3", "$g4", "$g5", "$g6", "$g7",
        "$o0", "$o1", "$o2", "$o3", "$o4", "$o5", "$sp", "$o7",
        "$l0", "$l1", "$l2", "$l3", "$l4", "$l5", "$l6", "$l7",
        "$i0", "$i1", "$i2", "$i3", "$i4", "$i5", "$fp", "$i7",
        "$pc", "$npc", "$state", "$fsr", "$fprs", "$y", "$cwp",
        "$pstate", "$asi", "$ccr",
    ]
    alias_registers = {
        "$sp": "$o6", "$fp": "$i6",
    }
    flag_register = "$state" # sparcv9.pdf, 5.1.5.1 (ccr)
    flags_table = {
        35: "negative",
        34: "zero",
        33: "overflow",
        32: "carry",
    }

    nop_insn = b"\x00\x00\x00\x01" # nop
    infloop_insn = b"\x00\x00\x80\x10" # b self
    trap_insn = None
    ret_insn = b"\x08\xe0\xc7\x81" # ret
    syscall_insn = b"\x6d\x20\xd0\x91" # trap 0x6d

    def is_syscall(self, insn):
        return insn.mnemonic == "ta" and insn.operands[0] == "0x6d"

    def get_ith_parameter(self, i, in_func=True):
        if i < len(self.function_parameters):
            reg = self.function_parameters[i]
            val = get_register(reg)
            key = reg
            return key, val
        else:
            i += 272 # ???
            sp = current_arch.sp
            sz = current_arch.ptrsize
            loc = sp + (i * sz) - 1
            val = read_int_from_memory(loc)
            key = "[sp + {:#x}]".format(i * sz - 1)
            return key, val

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 74
        insns = [
            "sethi %hi({}), %o0".format(addr & 0xfffffc00),
            "or %o0, {}, %o0".format(addr & 0x000003ff),
            "sethi %hi({}), %o1".format((addr >> 32) & 0xfffffc00),
            "or %o1, {}, %o1".format((addr >> 32) & 0x000003ff),
            "sllx %o1, 32, %o1",
            "or %o0, %o1, %o0",
            "sethi %hi({}), %o1".format(size & 0xfffffc00),
            "or %o1, {}, %o1".format(size & 0x000003ff),
            "sethi %hi({}), %o2".format((size >> 32) & 0xfffffc00),
            "or %o2, {}, %o2".format((size >> 32) & 0x000003ff),
            "sllx %o2, 32, %o2",
            "or %o1, %o2, %o1",
            "mov {}, %o2".format(perm),
            "mov {}, %g1".format(_NR_mprotect),
            "ta 0x6d",
            "nop", # keystone does not give nop for delay slot, needs this nop
        ]
        return "; ".join(insns)


class MIPS(Architecture):
    arch = "MIPS"
    mode = "MIPS32"

    # http://vhouten.home.xs4all.nl/mipsel/r3000-isa.html
    all_registers = [
        "$zero", "$at", "$v0", "$v1", "$a0", "$a1", "$a2", "$a3",
        "$t0", "$t1", "$t2", "$t3", "$t4", "$t5", "$t6", "$t7",
        "$s0", "$s1", "$s2", "$s3", "$s4", "$s5", "$s6", "$s7",
        "$t8", "$t9", "$k0", "$k1", "$gp", "$sp", "$fp", "$ra",
        "$sr", "$lo", "$hi", "$bad", "$cause", "$fsr", "$fir", "$pc",
    ]
    alias_registers = {
        "$zero": "$r0", "$at": "$r1", "$v0": "$r2", "$v1": "$r3",
        "$a0": "$r4", "$a1": "$r5", "$a2": "$r6", "$a3": "$r7",
        "$t0": "$r8", "$t1": "$r9", "$t2": "$r10", "$t3": "$r11",
        "$t4": "$r12", "$t5": "$r13", "$t6": "$r14", "$t7": "$r15",
        "$s0": "$r16", "$s1": "$r17", "$s2": "$r18", "$s3": "$r19",
        "$s4": "$r20", "$s5": "$r21", "$s6": "$r22", "$s7": "$r23",
        "$t8": "$r24", "$t9": "$r25", "$k0": "$r26", "$k1": "$r27",
        "$gp": "$r28", "$sp": "$r29", "$fp": "$s8/$r30", "$ra": "$r31",
    }
    flag_register = None # MIPS has no flags register
    return_register = "$v0"
    function_parameters = ["$a0", "$a1", "$a2", "$a3"]
    syscall_register = "$v0"
    syscall_parameters_o32 = ["$a0", "$a1", "$a2", "$a3", "$sp+0x10", "$sp+0x14", "$sp+0x18", "$sp+0x1c"]
    syscall_parameters_n32 = ["$a0", "$a1", "$a2", "$a3", "$a4", "$a5"]

    instruction_length = 4
    has_delay_slot = True
    has_syscall_delay_slot = True
    has_ret_delay_slot = True

    keystone_support = True
    capstone_support = True
    unicorn_support = True

    nop_insn = b"\x00\x00\x00\x00" # nop
    infloop_insn = b"\xff\xff\x00\x10" # b self
    trap_insn = b"\x0d\x00\x00\x00" # break
    ret_insn = b"\x08\x00\xe0\x03" # jr $ra
    syscall_insn = b"\x0c\x00\x00\x00" # syscall

    def is_syscall(self, insn):
        return insn.mnemonic in ["syscall"]

    def is_call(self, insn):
        branch_mnemos = [
            "bal", "balc", "jal", "jalr", "jalrc", "jalrc.hb",
            "bgezal", "bgezall", "bltzal", "bltzall",
        ]
        return insn.mnemonic in branch_mnemos

    def is_jump(self, insn):
        if self.is_ret(insn):
            return False
        if insn.mnemonic in ["b", "bc", "j", "jr", "jrc", "balrsc", "brsc"]:
            return True
        if self.is_conditional_branch(insn):
            return True
        return False

    def is_ret(self, insn):
        if insn.mnemonic in ["jr", "jrc"] and insn.operands[0] == "ra":
            return True
        if insn.mnemonic in ["deret", "eret", "eretnc"]:
            return True
        if insn.mnemonic in ["restore", "restore.jrc"]:
            return True
        return False

    def is_conditional_branch(self, insn):
        branch_mnemos = [
            "beq", "bne", "bgtz", "bgez", "bltz", "blez", "beqz", "bnez",
            "beql", "bnel", "bgtzl", "bgezl", "bltzl", "blezl",
            "bgezal", "bgezall", "bltzal", "bltzall",
            "bc1f", "bc1fl", "bc1t", "bc1tl", "bc2f", "bc2fl", "bc2t", "bc2tl",
            "beqc", "beqic", "beqzc",
            "bnec", "bneic", "bnezc",
            "bgec", "bgeic", "bgeiuc", "bgeuc",
            "bltc", "bltic", "bltiuc", "bltuc",
            "bbeqzc", "bbnezc",
        ]
        return insn.mnemonic in branch_mnemos

    def is_branch_taken(self, insn):
        mnemo, ops = insn.mnemonic, insn.operands
        taken, reason = False, ""

        p = lambda a: struct.pack("<I", a & 0xffffffff)
        ui = lambda a: struct.unpack("<i", a)[0]
        u2i = lambda a: ui(p(a))

        if mnemo in ["beq", "beql", "beqc"]:
            taken, reason = get_register(ops[0]) == get_register(ops[1]), "{0[0]} == {0[1]}".format(ops)
        elif mnemo in ["beqic"]:
            taken, reason = get_register(ops[0]) == int(ops[1], 0), "{0[0]} == {0[1]}".format(ops)
        elif mnemo in ["bne", "bnel", "bnec"]:
            taken, reason = get_register(ops[0]) != get_register(ops[1]), "{0[0]} != {0[1]}".format(ops)
        elif mnemo in ["bneic"]:
            taken, reason = get_register(ops[0]) != int(ops[1], 0), "{0[0]} != {0[1]}".format(ops)
        elif mnemo in ["beqz", "beqzc"]:
            taken, reason = get_register(ops[0]) == 0, "{0[0]} == 0".format(ops)
        elif mnemo in ["bnez", "bnezc"]:
            taken, reason = get_register(ops[0]) != 0, "{0[0]} != 0".format(ops)
        elif mnemo in ["bgtz", "bgtzl"]:
            taken, reason = get_register(ops[0]) > 0, "{0[0]} > 0".format(ops)
        elif mnemo in ["bgez", "bgezl"]:
            taken, reason = get_register(ops[0]) >= 0, "{0[0]} >= 0".format(ops)
        elif mnemo in ["bltz", "bltzl"]:
            taken, reason = get_register(ops[0]) < 0, "{0[0]} < 0".format(ops)
        elif mnemo in ["blez", "blezl"]:
            taken, reason = get_register(ops[0]) <= 0, "{0[0]} <= 0".format(ops)
        elif mnemo in ["bbeqzc"]:
            taken, reason = (get_register(ops[0]) >> int(ops[1], 0) & 1) == 0, "(({0[0]} >> {0[1]}) & 1) == 0".format(ops)
        elif mnemo in ["bbnezc"]:
            taken, reason = (get_register(ops[0]) >> int(ops[1], 0) & 1) == 0, "(({0[0]} >> {0[1]}) & 1) != 0".format(ops)
        elif mnemo in ["bgec"]:
            taken, reason = get_register(ops[0]) >= u2i(get_register(ops[1])), "{0[0]} >= {0[1]}".format(ops)
        elif mnemo in ["bgeic"]:
            taken, reason = get_register(ops[0]) >= u2i(int(ops[1], 0)), "{0[0]} >= {0[1]}".format(ops)
        elif mnemo in ["bgeuc"]:
            taken, reason = get_register(ops[0]) >= get_register(ops[1]), "{0[0]} >= {0[1]}".format(ops)
        elif mnemo in ["bgeiuc"]:
            taken, reason = get_register(ops[0]) >= int(ops[1], 0), "{0[0]} >= {0[1]}".format(ops)
        elif mnemo in ["bltc"]:
            taken, reason = get_register(ops[0]) < u2i(get_register(ops[1])), "{0[0]} < {0[1]}".format(ops)
        elif mnemo in ["bltic"]:
            taken, reason = get_register(ops[0]) < u2i(int(ops[1], 0)), "{0[0]} < {0[1]}".format(ops)
        elif mnemo in ["bltuc"]:
            taken, reason = get_register(ops[0]) < get_register(ops[1]), "{0[0]} < {0[1]}".format(ops)
        elif mnemo in ["bltiuc"]:
            taken, reason = get_register(ops[0]) < int(ops[1], 0), "{0[0]} < {0[1]}".format(ops)
        return taken, reason

    def get_ith_parameter(self, i, in_func=True):
        if i < len(self.function_parameters):
            reg = self.function_parameters[i]
            val = get_register(reg)
            key = reg
            return key, val
        else:
            sp = current_arch.sp
            sz = current_arch.ptrsize
            loc = sp + (i * sz)
            val = read_int_from_memory(loc)
            key = "[sp + {:#x}]".format(i * sz)
            return key, val

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = get_register("$ra")
            elif frame.older():
                ra = frame.older().pc()
        except Exception:
            pass
        return ra

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 4125
        insns = [
            "li $v0, {:d}".format(_NR_mprotect),
            "li $a0, {:d}".format(addr),
            "li $a1, {:d}".format(size),
            "li $a2, {:d}".format(perm),
            "syscall", # keystone gives nop for delay slot, need not nop
        ]
        return "; ".join(insns)


class MIPS64(MIPS):
    arch = "MIPS"
    mode = "MIPS64"

    all_registers = [
        "$zero", "$at", "$v0", "$v1", "$a0", "$a1", "$a2", "$a3",
        "$a4", "$a5", "$a6", "$a7", "$t0", "$t1", "$t2", "$t3",
        "$s0", "$s1", "$s2", "$s3", "$s4", "$s5", "$s6", "$s7",
        "$t8", "$t9", "$k0", "$k1", "$gp", "$sp", "$fp", "$ra",
        "$sr", "$lo", "$hi", "$bad", "$cause", "$fsr", "$fir", "$pc",
    ]
    alias_registers = {
        "$zero": "$r0", "$at": "$r1", "$v0": "$r2", "$v1": "$r3",
        "$a0": "$r4", "$a1": "$r5", "$a2": "$r6", "$a3": "$r7",
        "$a4": "$r8", "$a5": "$r9", "$a6": "$r10", "$a7": "$r11",
        "$t0": "$r12", "$t1": "$r13", "$t2": "$r14", "$t3": "$r15",
        "$s0": "$r16", "$s1": "$r17", "$s2": "$r18", "$s3": "$r19",
        "$s4": "$r20", "$s5": "$r21", "$s6": "$r22", "$s7": "$r23",
        "$t8": "$r24", "$t9": "$r25", "$k0": "$r26", "$k1": "$r27",
        "$gp": "$r28", "$sp": "$r29", "$fp": "$s8/$r30", "$ra": "$r31",
    }
    function_parameters = ["$a0", "$a1", "$a2", "$a3", "$a4", "$a5", "$a6", "$a7"]
    syscall_parameters = ["$a0", "$a1", "$a2", "$a3", "$a4", "$a5"]

    unicorn_support = False

    def get_ith_parameter(self, i, in_func=True):
        if i < len(self.function_parameters):
            reg = self.function_parameters[i]
            val = get_register(reg)
            key = reg
            return key, val
        else:
            i -= len(self.function_parameters)
            sp = current_arch.sp
            sz = current_arch.ptrsize
            loc = sp + (i * sz)
            val = read_int_from_memory(loc)
            key = "[sp + {:#x}]".format(i * sz)
            return key, val

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 5010
        insns = [
            "ori $a0, $zero, {:#x}".format((addr >> 48) & 0xffff),
            "dsll $a0, $a0, 16",
            "ori $a0, $a0, {:#x}".format((addr >> 32) & 0xffff),
            "dsll $a0, $a0, 16",
            "ori $a0, $a0, {:#x}".format((addr >> 16) & 0xffff),
            "dsll $a0, $a0, 16",
            "ori $a0, $a0, {:#x}".format((addr >> 0) & 0xffff),
            "ori $a1, $zero, {:#x}".format((size >> 48) & 0xffff),
            "dsll $a1, $a1, 16",
            "ori $a1, $a1, {:#x}".format((size >> 32) & 0xffff),
            "dsll $a1, $a1, 16",
            "ori $a1, $a1, {:#x}".format((size >> 16) & 0xffff),
            "dsll $a1, $a1, 16",
            "ori $a1, $a1, {:#x}".format((size >> 0) & 0xffff),
            "li $a2, {:d}".format(perm),
            "li $v0, {:d}".format(_NR_mprotect),
            "syscall", # keystone gives nop for delay slot, need not nop
        ]
        return "; ".join(insns)


class S390X(Architecture):
    arch = "S390X"
    mode = "S390X"

    # https://www.ibm.com/docs/en/SSQ2R2_15.0.0/com.ibm.tpf.toolkit.hlasm.doc/dz9zr006.pdf
    all_registers = [
        "$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7",
        "$r8", "$r9", "$r10", "$r11", "$r12", "$r13", "$r14", "$r15",
        "$pswm", "$pswa", "$fpc", "$gsd", "$gssm", "$gsepla",
        "$gs_reserved", "$pc", "$cc",
    ]
    alias_registers = {
        "$r14": "$lr", "$r15": "$sp",
    }
    flag_register = "$cc"
    flags_table = {
        1: "cc1",
        0: "cc0",
    }
    return_register = "$r2"
    function_parameters = ["$r2", "$r3", "$r4", "$r5", "$r6"]
    syscall_register = [r"svc\s+(\d+)", "$r1"] # $r1 is used when NR > 127
    syscall_parameters = ["$r2", "$r3", "$r4", "$r5", "$r6", "$r7"]

    instruction_length = None # variable length
    has_delay_slot = False
    has_syscall_delay_slot = True
    has_ret_delay_slot = False

    keystone_support = True
    capstone_support = True
    unicorn_support = False

    nop_insn = b"\x07\x07" # bcr 0, %r7
    infloop_insn = b"\x00\x00\xf4\xa7" # j 0
    trap_insn = None
    ret_insn = b"\xfe\x07" # br %r14
    syscall_insn = b"\x00\x0a" # svc 0x0

    def is_syscall(self, insn):
        return insn.mnemonic == "svc"

    # https://www.ibm.com/docs/en/zos/2.1.0?topic=statements-branching-extended-mnemonic-codes
    def is_call(self, insn):
        return insn.mnemonic in ["bal", "balr", "bas", "basr", "bassm", "bsm", "bras", "brasl"]

    def is_jump(self, insn):
        if self.is_ret(insn):
            return False
        if insn.mnemonic in ["b", "br", "j", "bru", "brul", "jlu"]:
            return True
        return self.is_conditional_branch(insn)

    def is_ret(self, insn):
        return insn.mnemonic == "br" and insn.operands[-1] == "%r14"

    def is_conditional_branch(self, insn):
        if insn.mnemonic in ["bc", "bcr", "brc", "brcl"]:
            return True
        conditions = ["h", "l", "e", "nh", "nl", "ne", "p", "m", "z", "o", "np", "nm", "nz", "no"]
        for cc in conditions:
            if insn.mnemonic == f"b{cc}": # alias for `bc N, ...`
                return True
            if insn.mnemonic == f"b{cc}r": # alias for `bcr N, ...`
                return True
            if insn.mnemonic in [f"br{cc}", f"j{cc}"]: # alias for `brc N, ...`
                return True
            if insn.mnemonic in [f"br{cc}l", f"jl{cc}"]: # alias for `brcl N, ...`
                return True

        if insn.mnemonic in ["bct", "bctr", "bctg", "bctgr", "brct", "brctg"]:
            return True
        if insn.mnemonic in ["bxh", "bxhg", "brxh", "brxhg"]:
            return True
        if insn.mnemonic in ["bxle", "bxleg", "brxle", "brxlg"]:
            return True

        if insn.mnemonic in ["crb", "cgrb", "crj", "cgrj"]:
            return True
        if insn.mnemonic in ["cib", "cgib", "cij", "cgij"]:
            return True
        if insn.mnemonic in ["clrb", "clgrb", "clrj", "clgrj"]:
            return True
        if insn.mnemonic in ["clib", "clgib", "clij", "clgij"]:
            return True
        conditions = ["h", "l", "ne"]
        for cc in conditions:
            if insn.mnemonic == f"crb{cc}": # alias for `crb r,r,N`
                return True
            if insn.mnemonic == f"cgrb{cc}": # alias for `cgrb r,r,N`
                return True
            if insn.mnemonic == f"crj{cc}": # alias for `crj r,r,N, ...`
                return True
            if insn.mnemonic == f"cgrj{cc}": # alias for `cgrj r,r,N, ...`
                return True
            if insn.mnemonic == f"cib{cc}": # alias for `cib r,i,N, ...`
                return True
            if insn.mnemonic == f"cgib{cc}": # alias for `cgib r,i,N, ...`
                return True
            if insn.mnemonic == f"cij{cc}": # alias for `cij r,i,N, ...`
                return True
            if insn.mnemonic == f"cgij{cc}": # alias for `cgij r,i,N, ...`
                return True
            if insn.mnemonic == f"clrb{cc}": # alias for `clrb r,r,N, ...`
                return True
            if insn.mnemonic == f"clgrb{cc}": # alias for `clgrb r,r,N, ...`
                return True
            if insn.mnemonic == f"clrj{cc}": # alias for `clrj r,r,N, ...`
                return True
            if insn.mnemonic == f"clgrj{cc}": # alias for `clgrj r,r,N, ...`
                return True
            if insn.mnemonic == f"clib{cc}": # alias for `clib r,i,N, ...`
                return True
            if insn.mnemonic == f"clgib{cc}": # alias for `clgib r,i,N, ...`
                return True
            if insn.mnemonic == f"clij{cc}": # alias for `clij r,i,N, ...`
                return True
            if insn.mnemonic == f"clgij{cc}": # alias for `clgij r,i,N, ...`
                return True
        return False

    def is_branch_taken(self, insn):
        taken, reason = False, ""

        def is_insn_condition_type1(insn):
            if insn.mnemonic in ["bc", "bcr", "brc", "brcl"]:
                return True
            conditions = [
                "h", "l", "e", "nh", "nl", "ne", "p", "m",
                "z", "o", "np", "nm", "nz", "no",
            ]
            for cc in conditions:
                if insn.mnemonic == f"b{cc}": # alias for `bc N, ...`
                    return True
                if insn.mnemonic == f"b{cc}r": # alias for `bcr N, ...`
                    return True
                if insn.mnemonic in [f"br{cc}", f"j{cc}"]: # alias for `brc N, ...`
                    return True
                if insn.mnemonic in [f"br{cc}l", f"jl{cc}"]: # alias for `brcl N, ...`
                    return True
            return False

        def is_insn_condition_type2_signed32(insn):
            if insn.mnemonic in ["crb", "crj"]:
                return True
            if insn.mnemonic in ["cib", "cij"]:
                return True
            conditions = ["h", "l", "ne"]
            for cc in conditions:
                if insn.mnemonic == f"crb{cc}": # alias for `crb r,r,N`
                    return True
                if insn.mnemonic == f"crj{cc}": # alias for `crj r,r,N, ...`
                    return True
                if insn.mnemonic == f"cib{cc}": # alias for `cib r,i,N, ...`
                    return True
                if insn.mnemonic == f"cij{cc}": # alias for `cij r,i,N, ...`
                    return True
            return False

        def is_insn_condition_type2_signed64(insn):
            if insn.mnemonic in ["cgrb", "cgrj"]:
                return True
            if insn.mnemonic in ["cgib", "cgij"]:
                return True
            conditions = ["h", "l", "ne"]
            for cc in conditions:
                if insn.mnemonic == f"cgrb{cc}": # alias for `cgrb r,r,N`
                    return True
                if insn.mnemonic == f"cgrj{cc}": # alias for `cgrj r,r,N, ...`
                    return True
                if insn.mnemonic == f"cgib{cc}": # alias for `cgib r,i,N, ...`
                    return True
                if insn.mnemonic == f"cgij{cc}": # alias for `cgij r,i,N, ...`
                    return True
            return False

        def is_insn_condition_type2_unsigned32(insn):
            if insn.mnemonic in ["clrb", "clrj"]:
                return True
            if insn.mnemonic in ["clib", "clij"]:
                return True
            conditions = ["h", "l", "ne"]
            for cc in conditions:
                if insn.mnemonic == f"clrb{cc}": # alias for `clrb r,r,N, ...`
                    return True
                if insn.mnemonic == f"clrj{cc}": # alias for `clrj r,r,N, ...`
                    return True
                if insn.mnemonic == f"clib{cc}": # alias for `clib r,i,N, ...`
                    return True
                if insn.mnemonic == f"clij{cc}": # alias for `clij r,i,N, ...`
                    return True
            return False

        def is_insn_condition_type2_unsigned64(insn):
            if insn.mnemonic in ["clgrb", "clgrj"]:
                return True
            if insn.mnemonic in ["clgib", "clgij"]:
                return True
            conditions = ["h", "l", "ne"]
            for cc in conditions:
                if insn.mnemonic == f"clgrb{cc}": # alias for `clgrb r,r,N, ...`
                    return True
                if insn.mnemonic == f"clgrj{cc}": # alias for `clgrj r,r,N, ...`
                    return True
                if insn.mnemonic == f"clgib{cc}": # alias for `clgib r,i,N, ...`
                    return True
                if insn.mnemonic == f"clgij{cc}": # alias for `clgij r,i,N, ...`
                    return True
            return False

        if is_insn_condition_type1(insn):
            mask = insn.opcodes[1] >> 4

            val = get_register(self.flag_register)
            flags = dict((self.flags_table[k], k) for k in self.flags_table)
            cc1 = (val >> flags["cc1"]) & 1
            cc0 = (val >> flags["cc0"]) & 1
            cc = (cc1 << 1) + cc0

            if (mask & 0b1) and cc == 3:
                return True, "cc==3"
            if (mask & 0b10) and cc == 2:
                return True, "cc==2"
            if (mask & 0b100) and cc == 1:
                return True, "cc==1"
            if (mask & 0b1000) and cc == 0:
                return True, "cc==0"
            return False, ""

        if insn.mnemonic in ["bct", "bctr", "bctg", "bctgr", "brct", "brctg"]:
            reg = insn.operands[0]
            return get_register(reg) != 1, "{:s}!=1".format(reg)

        if insn.mnemonic in ["bxh", "bxhg", "brxh", "brxhg"]:
            reg1, reg3 = insn.operands[0], insn.operands[1]
            taken = get_register(reg1) + get_register(reg3) > get_register(reg3) + 1
            reason = "({:s}+{:s})>{:#x}".format(reg1, reg3, get_register(reg3) + 1)
            return taken, reason

        if insn.mnemonic in ["bxle", "bxleg", "brxle", "brxlg"]:
            reg1, reg3 = insn.operands[0], insn.operands[1]
            taken = get_register(reg1) + get_register(reg3) <= get_register(reg3) + 1
            reason = "({:s}+{:s})<={:#x}".format(reg1, reg3, get_register(reg3) + 1)
            return taken, reason

        def for_compare(insn, signed, bit):
            if signed and bit == 32:
                trans = lambda a: struct.unpack("<i", struct.pack("<I", a & 0xffffffff))[0]
            elif signed and bit == 64:
                trans = lambda a: struct.unpack("<q", struct.pack("<Q", a & 0xffffffffffffffff))[0]
            elif not signed and bit == 32:
                trans = lambda a: a & 0xffffffff
            elif not signed and bit == 64:
                trans = lambda a: a & 0xffffffffffffffff
            else:
                raise

            mask = insn.opcodes[4] >> 4
            reg1 = insn.operands[0]
            reg2_or_imm = insn.operands[1]

            val1 = trans(get_register(reg1))
            if reg2_or_imm.startswith("%"):
                val2 = trans(get_register(reg2_or_imm))
            else:
                val2 = int(reg2_or_imm, 0)
            if (mask & 0b1) and val1 == val2:
                return True, "{:s}=={:s}".format(reg1, reg2_or_imm)
            if (mask & 0b10) and val1 < val2:
                return True, "{:s}<{:s}".format(reg1, reg2_or_imm)
            if (mask & 0b100) and val1 > val2:
                return True, "{:s}>{:s}".format(reg1, reg2_or_imm)
            return False, ""

        if is_insn_condition_type2_signed32(insn):
            return for_compare(insn, signed=True, bit=32)
        if is_insn_condition_type2_signed64(insn):
            return for_compare(insn, signed=True, bit=64)
        if is_insn_condition_type2_unsigned32(insn):
            return for_compare(insn, signed=False, bit=32)
        if is_insn_condition_type2_unsigned64(insn):
            return for_compare(insn, signed=False, bit=64)

        return taken, reason

    def flag_register_to_human(self, val=None):
        if not val:
            reg = self.flag_register
            val = get_register(reg)
        flags = dict((self.flags_table[k], k) for k in self.flags_table)

        extra_msg = " ["
        if get_register("$pswm"):
            addressing0 = (get_register("$pswm") >> 31) & 1
            addressing1 = (get_register("$pswm") >> 32) & 1
            addressing_mode = {
                (0, 0): "24-bit",
                (0, 1): "31-bit",
                (1, 1): "64-bit",
            }[addressing0, addressing1]
            extra_msg += "AddressingMode={:s}, ".format(addressing_mode)

        cc1 = (val >> flags["cc1"]) & 1
        cc0 = (val >> flags["cc0"]) & 1
        condition_code = (cc1 << 1) + cc0
        extra_msg += "ConditionCode={:d}]".format(condition_code)

        return flags_to_human(val, self.flags_table) + extra_msg

    def get_ith_parameter(self, i, in_func=True):
        if i < len(self.function_parameters):
            reg = self.function_parameters[i]
            val = get_register(reg)
            key = reg
            return key, val
        else:
            i += 15 # ???
            sp = current_arch.sp
            sz = current_arch.ptrsize
            loc = sp + (i * sz)
            val = read_int_from_memory(loc)
            key = "[sp + {:#x}]".format(i * sz)
            return key, val

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = get_register("$r14")
            elif frame.older():
                ra = frame.older().pc()
        except Exception:
            pass
        return ra

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 125
        insns = [
            "llilf %r2, {:#x}".format(addr >> 32),
            "sllg %r2, %r2, 32",
            "oilf %r2, {:#x}".format(addr & 0xffffffff),
            "llilf %r3, {:#x}".format(size >> 32),
            "sllg %r3, %r3, 32",
            "oilf %r3, {:#x}".format(size & 0xffffffff),
            "llilf %r4, {:#x}".format(perm >> 32),
            "sllg %r4, %r4, 32",
            "oilf %r4, {:#x}".format(perm & 0xffffffff),
            ".byte 0x0a, {:#x}".format(_NR_mprotect), # svc 0x7d
            "bcr 0, %r7", # nop
        ]
        return '; '.join(insns)


class SH4(Architecture):
    arch = "SH4"
    mode = "SH4"

    # https://www.renesas.com/us/en/document/man/705261
    all_registers = [
        "$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7",
        "$r8", "$r9", "$r10", "$r11", "$r12", "$r13", "$r14", "$r15",
        "$pc", "$pr", "$gbr", "$mach", "$macl", "$sr",
    ]
    alias_registers = {
        "$r15": "$sp",
    }
    flag_register = "$sr"
    flags_table = {
        0: "t",
    }
    return_register = "$r0"
    function_parameters = ["$r4", "$r5", "$r6", "$r7"]
    syscall_register = "$r3"
    syscall_parameters = ["$r4", "$r5", "$r6", "$r7", "$r0", "$r1", "$r2"]

    instruction_length = 2
    has_delay_slot = True
    has_syscall_delay_slot = True
    has_ret_delay_slot = True

    keystone_support = False
    capstone_support = False
    unicorn_support = False

    nop_insn = b"\x09\x00" # nop
    infloop_insn = b"\xfe\xaf" # bra self
    trap_insn = None
    ret_insn = b"\x0b\x00" # rts
    syscall_insn = b"\x13\xc3" # trapa #19

    def is_syscall(self, insn):
        return insn.mnemonic == "trapa" and insn.operands[0] == "#19"

    def is_call(self, insn):
        return insn.mnemonic in ["bsr", "bsrf", "jsr"]

    def is_jump(self, insn):
        if self.is_conditional_branch(insn):
            return True
        return insn.mnemonic in ["bra", "braf", "jmp"]

    def is_ret(self, insn):
        return insn.mnemonic == "rts"

    def is_conditional_branch(self, insn):
        return insn.mnemonic in ["bf", "bf.s", "bt", "bt.s"]

    def is_branch_taken(self, insn):
        mnemo = insn.mnemonic
        val = get_register(self.flag_register)
        flags = dict((self.flags_table[k], k) for k in self.flags_table)
        taken, reason = False, ""

        t = bool(val & (1 << flags["t"]))

        if mnemo in ["bf", "bf.s"]:
            taken, reason = not t, "!T"
        elif mnemo in ["bt", "bt.s"]:
            taken, reason = t, "T"
        return taken, reason

    def flag_register_to_human(self, val=None):
        if not val:
            reg = self.flag_register
            val = get_register(reg)
        return flags_to_human(val, self.flags_table)

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = get_register("$pr")
            elif frame.older():
                ra = frame.older().pc()
        except Exception:
            pass
        return ra

    mprotect_asm = None

    @classmethod
    def mprotect_asm_raw(cls, addr, size, perm):
        _NR_mprotect = 125
        insns = [
            # In sh4, r0-r7 cannot be set from gdb.
            # Since it can be set to r8-r15, save it there.
            b"\x03\x68", # mov r0, r8
            b"\x33\x69", # mov r3, r9
            b"\x43\x6a", # mov r4, r10
            b"\x53\x6b", # mov r5, r11
            b"\x63\x6c", # mov r6, r12

            b"\x4a\x24", # xor r4, r4
            p8((addr >> 24) & 0xff) + b"\xe0", # mov addr[31:24], r0
            b"\x0c\x60", # extu.b r0, r0
            b"\x18\x40", # shll8 r0
            b"\x18\x40", # shll8 r0
            b"\x18\x40", # shll8 r0
            b"\x0b\x24", # or r0, r4
            p8((addr >> 16) & 0xff) + b"\xe0", # mov addr[23:16], r0
            b"\x0c\x60", # extu.b r0, r0
            b"\x18\x40", # shll8 r0
            b"\x18\x40", # shll8 r0
            b"\x0b\x24", # or r0, r4
            p8((addr >> 8) & 0xff) + b"\xe0", # mov addr[15:8], r0
            b"\x0c\x60", # extu.b r0, r0
            b"\x18\x40", # shll8 r0
            b"\x0b\x24", # or r0, r4
            p8((addr >> 0) & 0xff) + b"\xe0", # mov addr[7:0], r0
            b"\x0c\x60", # extu.b r0, r0
            b"\x0b\x24", # or r0, r4

            b"\x5a\x25", # xor r5, r5
            p8((size >> 24) & 0xff) + b"\xe0", # mov size[31:24], r0
            b"\x0c\x60", # extu.b r0, r0
            b"\x18\x40", # shll8 r0
            b"\x18\x40", # shll8 r0
            b"\x18\x40", # shll8 r0
            b"\x0b\x25", # or r0, r5
            p8((size >> 16) & 0xff) + b"\xe0", # mov size[23:16], r0
            b"\x0c\x60", # extu.b r0, r0
            b"\x18\x40", # shll8 r0
            b"\x18\x40", # shll8 r0
            b"\x0b\x25", # or r0, r5
            p8((size >> 8) & 0xff) + b"\xe0", # mov size[15:8], r0
            b"\x0c\x60", # extu.b r0, r0
            b"\x18\x40", # shll8 r0
            b"\x0b\x25", # or r0, r5
            p8((size >> 0) & 0xff) + b"\xe0", # mov size[7:0], r0
            b"\x0c\x60", # extu.b r0, r0
            b"\x0b\x25", # or r0, r5

            b"\x6a\x26", # xor r6, r6
            p8((perm >> 24) & 0xff) + b"\xe0", # mov perm[31:24], r0
            b"\x0c\x60", # extu.b r0, r0
            b"\x18\x40", # shll8 r0
            b"\x18\x40", # shll8 r0
            b"\x18\x40", # shll8 r0
            b"\x0b\x26", # or r0, r6
            p8((perm >> 16) & 0xff) + b"\xe0", # mov perm[23:16], r0
            b"\x0c\x60", # extu.b r0, r0
            b"\x18\x40", # shll8 r0
            b"\x18\x40", # shll8 r0
            b"\x0b\x26", # or r0, r6
            p8((perm >> 8) & 0xff) + b"\xe0", # mov perm[15:8], r0
            b"\x0c\x60", # extu.b r0, r0
            b"\x18\x40", # shll8 r0
            b"\x0b\x26", # or r0, r6
            p8((perm >> 0) & 0xff) + b"\xe0", # mov perm[7:0], r0
            b"\x0c\x60", # extu.b r0, r0
            b"\x0b\x26", # or r0, r6

            b"\x3a\x23", # xor r3, r3
            p8(_NR_mprotect & 0xff) + b"\xe0", # mov _NR_mprotect, r0
            b"\x0c\x60", # extu.b r0, r0
            b"\x0b\x23", # or r0, r3

            b"\x13\xc3", # trapa #19

            b"\x83\x60", # mov r8, r0
            b"\x93\x63", # mov r9,  r3
            b"\xa3\x64", # mov r10, r4
            b"\xb3\x65", # mov r11, r5
            b"\xc3\x66", # mov r12, r6
        ]
        return b''.join(insns)


class M68K(Architecture):
    arch = "M68K"
    mode = "M68K"

    # https://www.nxp.com/files-static/archives/doc/ref_manual/M68000PRM.pdf
    all_registers = [
        "$d0", "$d1", "$d2", "$d3", "$d4", "$d5", "$d6", "$d7",
        "$a0", "$a1", "$a2", "$a3", "$a4", "$a5", "$fp", "$sp",
        "$ps", "$pc",
    ]
    alias_registers = {
        "$fp": "$a6", "$sp": "$a7", "$ps": "$sr",
    }
    flag_register = "$ps"
    flags_table = {
        0: "carry",
        1: "overflow",
        2: "zero",
        3: "negative",
        4: "extend",
    }
    return_register = "$d0"
    function_parameters = ["$sp"] # but unused because m68k uses stack
    syscall_register = "$d0"
    syscall_parameters = ["$d1", "$d2", "$d3", "$d4", "$d5", "$a0"]

    instruction_length = None # variable length
    has_delay_slot = False
    has_syscall_delay_slot = False
    has_ret_delay_slot = False

    keystone_support = False
    capstone_support = True
    unicorn_support = True

    nop_insn = b"\x71\x4e" # nop
    infloop_insn = b"\xfe\x60" # bras self
    trap_insn = b"\x48\x48" # bkpt 0
    ret_insn = b"\x75\x4e" # rts
    syscall_insn = b"\x40\x4e" # trap #0

    def is_syscall(self, insn):
        return insn.mnemonic == "trap" and insn.operands[0] == "#0"

    def is_call(self, insn):
        return insn.mnemonic in ["bsrs", "bsrw", "bsrl", "jsr"]

    def is_jump(self, insn):
        if self.is_conditional_branch(insn):
            return True
        return insn.mnemonic in ["bras", "braw", "bral", "jmp"]

    def is_ret(self, insn):
        return insn.mnemonic == "rts"

    # https://sourceware.org/binutils/docs/as/M68K_002dBranch.html
    def is_conditional_branch(self, insn):
        conditions = [
            "hi", "ls", "cc", "cs", "ne", "eq", "vc",
            "vs", "pl", "mi", "ge", "lt", "gt", "le",
        ]
        for cc in conditions:
            if insn.mnemonic in [f"b{cc}s", f"b{cc}w", f"b{cc}l"]:
                return True
        conditions = [
            "hi", "ls", "cc", "cs", "ne", "eq", "vc",
            "vs", "pl", "mi", "ge", "lt", "gt", "le",
            "t", "f",
        ]
        for cc in conditions:
            if insn.mnemonic in [f"db{cc}w", f"db{cc}"]:
                return True
        conditions = [
            "ne", "eq", "ge", "lt", "gt", "le", "f", "t",
            "gl", "gle", "nge", "ngl", "ngle", "ngt", "nle", "nlt",
            "oge", "ogl", "ogt", "ole", "olt", "or",
            "seq", "sf", "sne", "st", "ueq", "uge", "ugt", "ule", "ult", "un",
        ]
        for cc in conditions:
            if insn.mnemonic in [f"fb{cc}w", f"fb{cc}l"]:
                return True
        return False

    def is_branch_taken(self, insn):
        mnemo = insn.mnemonic
        flags = dict((self.flags_table[k], k) for k in self.flags_table)
        val = get_register(self.flag_register)
        taken, reason = False, ""

        carry = bool(val & (1 << flags["carry"]))
        overflow = bool(val & (1 << flags["overflow"]))
        zero = bool(val & (1 << flags["zero"]))
        negative = bool(val & (1 << flags["negative"]))

        if mnemo in ["bhis", "bhiw", "bhil"]:
            taken, reason = not carry and not zero, "!C && !Z"
        elif mnemo in ["blss", "blsw", "blsl"]:
            taken, reason = carry or zero, "C || Z"
        elif mnemo in ["bccs", "bccw", "bccl"]:
            taken, reason = not carry, "!C"
        elif mnemo in ["bcss", "bcsw", "bcsl"]:
            taken, reason = carry, "C"
        elif mnemo in ["bnes", "bnew", "bnel"]:
            taken, reason = not zero, "!Z"
        elif mnemo in ["beqs", "beqw", "beql"]:
            taken, reason = zero, "Z"
        elif mnemo in ["bvcs", "bvcw", "bvcl"]:
            taken, reason = not overflow, "!V"
        elif mnemo in ["bvss", "bvsw", "bvsl"]:
            taken, reason = overflow, "V"
        elif mnemo in ["bpls", "bplw", "bpll"]:
            taken, reason = not negative, "!N"
        elif mnemo in ["bmis", "bmiw", "bmil"]:
            taken, reason = negative, "N"
        elif mnemo in ["bges", "bgew", "bgel"]:
            taken, reason = (negative and overflow) or (not negative and not overflow), "(N && V) || (!N && !V)"
        elif mnemo in ["blts", "bltw", "bltl"]:
            taken, reason = (negative and not overflow) or (not negative and overflow), "(N && !V) || (!N && V)"
        elif mnemo in ["bgts", "bgtw", "bgtl"]:
            taken = (negative and overflow and not zero) or (not negative and not overflow and not zero)
            reason = "(N && V && !Z) || (!N && !V && !Z)"
        elif mnemo in ["bles", "blew", "blel"]:
            taken, reason = zero or (negative and not overflow) or (not negative and overflow), "Z || (N && !V) || (!N && V)"
        elif mnemo in ["dbhiw", "dbhi"]:
            regname = insn.operands[0].replace("%", "$")
            val = get_register(regname)
            taken, reason = (carry or zero) and val != 0, "(C || Z) && {:s}==0".format(regname)
        elif mnemo in ["dblsw", "dbls"]:
            regname = insn.operands[0].replace("%", "$")
            val = get_register(regname)
            taken, reason = not carry and not zero and val != 0, "!C && !Z && {:s}==0".format(regname)
        elif mnemo in ["dbccw", "dbcc"]:
            regname = insn.operands[0].replace("%", "$")
            val = get_register(regname)
            taken, reason = carry and val != 0, "C && {:s}==0".format(regname)
        elif mnemo in ["dbcsw", "dbcs"]:
            regname = insn.operands[0].replace("%", "$")
            val = get_register(regname)
            taken, reason = not carry and val != 0, "!C && {:s}==0".format(regname)
        elif mnemo in ["dbnew", "dbne"]:
            regname = insn.operands[0].replace("%", "$")
            val = get_register(regname)
            taken, reason = zero and val != 0, "Z && {:s}==0".format(regname)
        elif mnemo in ["dbeqw", "dbeq"]:
            regname = insn.operands[0].replace("%", "$")
            val = get_register(regname)
            taken, reason = not zero and val != 0, "!Z && {:s}==0".format(regname)
        elif mnemo in ["dbvcw", "dbvc"]:
            regname = insn.operands[0].replace("%", "$")
            val = get_register(regname)
            taken, reason = overflow and val != 0, "V && {:s}==0".format(regname)
        elif mnemo in ["dbvsw", "dbvs"]:
            regname = insn.operands[0].replace("%", "$")
            val = get_register(regname)
            taken, reason = not overflow and val != 0, "!V && {:s}==0".format(regname)
        elif mnemo in ["dbplw", "dbpl"]:
            regname = insn.operands[0].replace("%", "$")
            val = get_register(regname)
            taken, reason = negative and val != 0, "N && {:s}==0".format(regname)
        elif mnemo in ["dbmiw", "dbmi"]:
            regname = insn.operands[0].replace("%", "$")
            val = get_register(regname)
            taken, reason = not negative and val != 0, "!N && {:s}==0".format(regname)
        elif mnemo in ["dbgew", "dbge"]:
            regname = insn.operands[0].replace("%", "$")
            val = get_register(regname)
            taken = ((negative and not overflow) or (not negative and overflow)) and val != 0
            reason = "((N && !V) || (!N && V)) && {:s}==0".format(regname)
        elif mnemo in ["dbltw", "dblt"]:
            regname = insn.operands[0].replace("%", "$")
            val = get_register(regname)
            taken = ((negative and overflow) or (not negative and not overflow)) and val != 0
            reason = "((N && V) || (!N && !V)) && {:s}==0".format(regname)
        elif mnemo in ["dbgtw", "dbgt"]:
            regname = insn.operands[0].replace("%", "$")
            val = get_register(regname)
            taken = (zero or (negative and not overflow) or (not negative and overflow)) and val != 0
            reason = "(Z || (N && !V) || (!N && V)) && {:s}==0".format(regname)
        elif mnemo in ["dblew", "dble"]:
            regname = insn.operands[0].replace("%", "$")
            val = get_register(regname)
            taken = ((negative and overflow and not zero) or (not negative and not overflow and not zero)) and val != 0
            reason = "((N && V && !Z) || (!N && !V && !Z)) && {:s}==0".format(regname)
        elif mnemo in ["dbtw", "dbt"]: # branch never taken
            taken, reason = False, ""
        elif mnemo in ["dbfw", "dbf"]:
            regname = insn.operands[0].replace("%", "$")
            val = get_register(regname)
            taken, reason = val != 0, "{:s}==0".format(regname)
        # TODO fbXXw, fbXXl
        return taken, reason

    def flag_register_to_human(self, val=None):
        if not val:
            reg = self.flag_register
            val = get_register(reg)
        return flags_to_human(val, self.flags_table)

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = to_unsigned_long(dereference(current_arch.sp))
            if frame.older():
                ra = frame.older().pc()
        except Exception:
            pass
        return ra

    def get_ith_parameter(self, i, in_func=True):
        if in_func:
            i += 1 # Account for RA being at the top of the stack
        sp = current_arch.sp
        sz = current_arch.ptrsize
        loc = sp + (i * sz)
        val = read_int_from_memory(loc)
        key = "[sp + {:#x}]".format(i * sz)
        return key, val

    @classmethod
    def mprotect_asm_raw(cls, addr, size, perm):
        _NR_mprotect = 125
        insns = [
            b"\x26\x3c" + p32(perm), # movel perm, %d3
            b"\x24\x3c" + p32(size), # movel size, %d2
            b"\x22\x3c" + p32(addr), # movel addr, %d1
            b"\x20\x3c" + p32(_NR_mprotect), # movel _NR_mprotect, %d0
            b"\x4e\x40", # trap #0
        ]
        return b''.join(insns)


class ALPHA(Architecture):
    arch = "ALPHA"
    mode = "ALPHA"

    # https://download.majix.org/dec/alpha_arch_ref.pdf
    all_registers = [
        "$v0", "$t0", "$t1", "$t2", "$t3", "$t4", "$t5", "$t6",
        "$t7", "$s0", "$s1", "$s2", "$s3", "$s4", "$s5", "$fp",
        "$a0", "$a1", "$a2", "$a3", "$a4", "$a5", "$t8", "$t9",
        "$t10", "$t11", "$ra", "$t12", "$at", "$gp", "$sp", "$pc",
    ]
    alias_registers = {
        "$v0": "$r0", "$t0": "$r1", "$t1": "$r2", "$t2": "$r3",
        "$t3": "$r4", "$t4": "$r5", "$t5": "$r6", "$t6": "$r7",
        "$t7": "$r8", "$s0": "$r9", "$s1": "$r10", "$s2": "$r11",
        "$s3": "$r12", "$s4": "$r13", "$s5": "$r14", "$fp": "$s6/$r15",
        "$a0": "$r16", "$a1": "$r17", "$a2": "$r18", "$a3": "$r19",
        "$a4": "$r20", "$a5": "$r21", "$t8": "$r22", "$t9": "$r23",
        "$t10": "$r24", "$t11": "$r25", "$ra": "$r26", "$t12": "$pv/$r27",
        "$at": "$r28", "$gp": "$r29", "$sp": "$r30", "$pc": "$r31",
    }
    flag_register = None # alpha has no flags register
    return_register = "$v0"
    function_parameters = ["$a0", "$a1", "$a2", "$a3", "$a4", "$a5"]
    syscall_register = "$v0"
    syscall_parameters = ["$a0", "$a1", "$a2", "$a3", "$a4", "$a5"]

    instruction_length = 4
    has_delay_slot = False
    has_syscall_delay_slot = False
    has_ret_delay_slot = False

    keystone_support = False
    capstone_support = False
    unicorn_support = False

    nop_insn = b"\x1f\x04\xff\x47" # nop
    infloop_insn = b"\xff\xff\xff\xc3" # br self
    trap_insn = b"\x80\x00\x00\x00" # bpt
    ret_insn = b"\x01\x80\xfa\x6b" # ret
    syscall_insn = b"\x83\x00\x00\x00" # callsys

    def is_syscall(self, insn):
        return insn.mnemonic in ["callsys"]

    def is_call(self, insn):
        return insn.mnemonic in ["br", "bsr", "jsr"]

    def is_jump(self, insn):
        if self.is_conditional_branch(insn):
            return True
        return insn.mnemonic in ["jmp"]

    def is_ret(self, insn):
        return insn.mnemonic in ["ret", "jsr_coroutine"]

    def is_conditional_branch(self, insn):
        branch_mnemos = [
            "beq", "bge", "bgt", "blbc", "blbs", "ble", "blt", "bne",
        ]
        return insn.mnemonic in branch_mnemos

    def is_branch_taken(self, insn):
        mnemo, ops = insn.mnemonic, insn.operands
        taken, reason = False, ""

        if len(ops) == 0:
            return taken, reason

        regname = ops[0]
        regval = get_register(regname)
        if regval is None:
            return taken, reason

        if mnemo == "beq":
            taken, reason = regval == 0, "{:s} == 0".format(regname)
        elif mnemo == "bne":
            taken, reason = regval != 0, "{:s} != 0".format(regname)
        elif mnemo == "bge":
            taken, reason = regval >= 0, "{:s} >= 0".format(regname)
        elif mnemo == "bgt":
            taken, reason = regval > 0, "{:s} > 0".format(regname)
        elif mnemo == "ble":
            taken, reason = regval <= 0, "{:s} <= 0".format(regname)
        elif mnemo == "blt":
            taken, reason = regval < 0, "{:s} < 0".format(regname)
        elif mnemo == "blbc":
            taken, reason = (regval & 1) == 0, "'({:s}&1) == 0".format(regname)
        elif mnemo == "blbs":
            taken, reason = (regval & 1) == 1, "({:s}&1) == 1".format(regname)

        return taken, reason

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = get_register("$ra")
            elif frame.older():
                ra = frame.older().pc()
        except Exception:
            pass
        return ra

    mprotect_asm = None

    @classmethod
    def mprotect_asm_raw(cls, addr, size, perm):
        _NR_mprotect = 74

        def lda_v0(x):
            return p32(0x201f0000 | x)

        def op_ii(op, reg1, imm, reg2):
            fmt = "0b{:06b}_{:05b}_{:08b}_1_0111001_{:05b}"
            val = fmt.format(op, reg1, imm, reg2)
            return p32(int(val, 2))

        def op_ir(op, reg1, reg2, reg3):
            fmt = "0b{:06b}_{:05b}_{:05b}_000_0_0100000_{:05b}"
            val = fmt.format(op, reg1, reg2, reg3)
            return p32(int(val, 2))

        insns = [
            lda_v0((addr >> 49) & 0x7fff), # lda v0, addr[63:49]
            op_ir(0x11, 16, 0, 16), # or a0, v0, a0
            op_ii(0x12, 16, 0xf, 16), # sll a0, 0xf, a0
            lda_v0((addr >> 34) & 0x7fff), # lda v0, addr[48:34]
            op_ir(0x11, 16, 0, 16), # or a0, v0, a0
            op_ii(0x12, 16, 0xf, 16), # sll a0, 0xf, a0
            lda_v0((addr >> 19) & 0x7fff), # lda v0, addr[33:19]
            op_ir(0x11, 16, 0, 16), # or a0, v0, a0
            op_ii(0x12, 16, 0xf, 16), # sll a0, 0xf, a0
            lda_v0((addr >> 4) & 0x7fff), # lda v0, addr[18:4]
            op_ir(0x11, 16, 0, 16), # or a0, v0, a0
            op_ii(0x12, 16, 0x4, 16), # sll a0, 0x4, a0
            lda_v0((addr >> 0) & 0xf), # lda v0, addr[3:0]
            op_ir(0x11, 16, 0, 16), # or a0, v0, a0

            lda_v0((size >> 49) & 0x7fff), # lda v0, size[63:49]
            op_ir(0x11, 17, 0, 17), # or a1, v0, a1
            op_ii(0x12, 17, 0xf, 17), # sll a1, 0xf, a1
            lda_v0((size >> 34) & 0x7fff), # lda v0, size[48:34]
            op_ir(0x11, 17, 0, 17), # or a1, v0, a1
            op_ii(0x12, 17, 0xf, 17), # sll a1, 0xf, a1
            lda_v0((size >> 19) & 0x7fff), # lda v0, size[33:19]
            op_ir(0x11, 17, 0, 17), # or a1, v0, a1
            op_ii(0x12, 17, 0xf, 17), # sll a1, 0xf, a1
            lda_v0((size >> 4) & 0x7fff), # lda v0, size[18:4]
            op_ir(0x11, 17, 0, 17), # or a1, v0, a1
            op_ii(0x12, 17, 0x4, 17), # sll a1, 0x4, a1
            lda_v0((size >> 0) & 0xf), # lda v0, size[3:0]
            op_ir(0x11, 17, 0, 17), # or a1, v0, a1

            lda_v0((perm >> 49) & 0x7fff), # lda v0, perm[63:49]
            op_ir(0x11, 18, 0, 18), # or a2, v0, a2
            op_ii(0x12, 18, 0xf, 18), # sll a2, 0xf, a2
            lda_v0((perm >> 34) & 0x7fff), # lda v0, perm[48:34]
            op_ir(0x11, 18, 0, 18), # or a2, v0, a2
            op_ii(0x12, 18, 0xf, 18), # sll a2, 0xf, a2
            lda_v0((perm >> 19) & 0x7fff), # lda v0, perm[33:19]
            op_ir(0x11, 18, 0, 18), # or a2, v0, a2
            op_ii(0x12, 18, 0xf, 18), # sll a2, 0xf, a2
            lda_v0((perm >> 4) & 0x7fff), # lda v0, perm[18:4]
            op_ir(0x11, 18, 0, 18), # or a2, v0, a2
            op_ii(0x12, 18, 0xf, 18), # sll a2, 0xf, a2
            lda_v0((perm >> 0) & 0xf), # lda v0, perm[3:0]
            op_ir(0x11, 18, 0, 18), # or a2, v0, a2

            lda_v0(_NR_mprotect), # lda v0, _NR_mprotect
            p32(0x00000083), # callsys
        ]
        return b''.join(insns)


class HPPA(Architecture):
    arch = "HPPA"
    mode = "HPPA32"

    # https://parisc.wiki.kernel.org/images-parisc/6/68/Pa11_acd.pdf
    all_registers = [
        "$r1", "$rp", "$r3", "$r4", "$r5", "$r6", "$r7", "$r8",
        "$r9", "$r10", "$r11", "$r12", "$r13", "$r14", "$r15", "$r16",
        "$r17", "$r18", "$r19", "$r20", "$r21", "$r22", "$r23", "$r24",
        "$r25", "$r26", "$dp", "$ret0", "$ret1", "$sp", "$r31", "$pc",
        "$flags", "$pcoqh", "$pcsqh", "$pcoqt", "$pcsqt",
    ]
    alias_registers = {
        "$rp": "$r2", "$dp": "$r27", "$ret0": "$r28", "$ret1": "$r29",
        "$sp": "$r30",
    }
    flag_register = None # HPPA has no flags register
    return_register = "$ret0"
    function_parameters = ["$r26", "$r25", "$r24", "$r23"]
    syscall_register = "$r20"
    syscall_parameters = ["$r26", "$r25", "$r24", "$r23", "$r22", "$r21"]

    instruction_length = 4
    has_delay_slot = True
    has_syscall_delay_slot = True
    has_ret_delay_slot = True

    keystone_support = False
    capstone_support = False
    unicorn_support = False

    nop_insn = b"\x40\x02\x00\x08" # nop
    infloop_insn = b"\xf7\x1f\x1f\xe8" # b,l,n self, r0
    trap_insn = None
    ret_insn = b"\x02\xc0\x40\xe8" # bv.n r0(rp)
    syscall_insn = b"\x00\x82\x00\xe4" # be,l 100(sr2, r0), sr0, r31

    def is_syscall(self, insn):
        return insn.mnemonic == "be,l" and insn.operands[:4] == ["100(sr2", "r0)", "sr0", "r31"]

    def is_call(self, insn):
        if self.is_syscall(insn):
            return False
        if insn.mnemonic in ["b,l", "b,l,n"]: # alias for BL,n
            return True
        if insn.mnemonic in ["blr", "blr,n"]: # alias for BLR,n
            return True
        if insn.mnemonic in ["be,l", "be,l,n"]: # alias for BLE,n
            return True
        return False

    def is_jump(self, insn):
        if self.is_ret(insn):
            return False
        if self.is_conditional_branch(insn):
            return True
        if insn.mnemonic in ["b,gate", "b,gate,n"]: # alias for GATE,n
            return True
        if insn.mnemonic in ["bv", "bv,n"]: # alias for BV,n
            return True
        if insn.mnemonic in ["be", "be,n"]: # alias for BE,n
            return True
        return False

    def is_ret(self, insn):
        return insn.mnemonic == "bv,n" and insn.operands[-1] == "r0(rp)"

    def is_conditional_branch(self, insn):
        if insn.mnemonic.startswith(("movb", "movib")): # alias for MOVB,cond,n / MOVIB,cond,n
            return True
        if insn.mnemonic.startswith(("cmpb", "cmpib")): # alias for COMB[TF},cond,n / COMIB[TF],cond,n
            return True
        if insn.mnemonic.startswith(("addb", "addib")): # alias for ADDB[TF],cond,n / ADDIB[TF],cond,n
            return True
        if insn.mnemonic.startswith("bb,"): # alias for BVB,cond,n / BB,cond,n
            return True
        return False

    def is_branch_taken(self, insn):

        def check_cond_mov(c, name, val):
            if c == 0: # never
                taken, reason = False, ""
            elif c == 1: # =
                taken, reason = val == 0, "{:s}==0".format(name)
            elif c == 2: # <
                taken, reason = (val >> [31, 63][is_64bit()]) == 1, "MSB({:s})==1".format(name)
            elif c == 3: # OD
                taken, reason = (val & 1) == 1, "LSB({:s})==1".format(name)
            elif c == 4: # TR
                taken, reason = True, "Always True"
            elif c == 5: # <>
                taken, reason = val != 0, "{:s}!=0".format(name)
            elif c == 6: # EV
                taken, reason = (val & 1) == 0, "LSB({:s})==0".format(name)
            return taken, reason

        def check_cond_cmp(c, f, name1, val1, name2, val2):
            if c == 0: # never
                if not f:
                    taken, reason = False, ""
                else:
                    taken, reason = True, "Always True"
            elif c == 1: # =
                if not f:
                    taken, reason = val1 == val2, "{:s}=={:s}".format(name1, name2)
                else:
                    taken, reason = val1 != val2, "{:s}!={:s}".format(name1, name2)
            elif c == 2: # < (signed)
                if not f:
                    taken, reason = val1 < val2, "{:s}<{:s}".format(name1, name2)
                else:
                    taken, reason = val1 >= val2, "{:s}>={:s}".format(name1, name2)
            elif c == 3: # <= (signed)
                if not f:
                    taken, reason = val1 <= val2, "{:s}<={:s}".format(name1, name2)
                else:
                    taken, reason = val1 > val2, "{:s}>{:s}".format(name1, name2)
            elif c == 4: # < (unsigned)
                if is_64bit():
                    shift = 64
                else:
                    shift = 32
                val1 &= (1 << shift) - 1
                val2 &= (1 << shift) - 1
                if not f:
                    taken, reason = val1 < val2, "{:s}<{:s} (unsigned)".format(name1, name2)
                else:
                    taken, reason = val1 >= val2, "{:s}>={:s} (unsigned)".format(name1, name2)
            elif c == 5: # <= (unsigned)
                if is_64bit():
                    shift = 64
                else:
                    shift = 32
                val1 &= (1 << shift) - 1
                val2 &= (1 << shift) - 1
                if not f:
                    taken, reason = val1 <= val2, "{:s}<={:s} (unsigned)".format(name1, name2)
                else:
                    taken, reason = val1 > val2, "{:s}>{:s} (unsigned)".format(name1, name2)
            elif c == 6: # SV
                if is_64bit():
                    shift = 63
                else:
                    shift = 31
                val1_sign = (val1 >> shift) & 1
                val2_sign = (val2 >> shift) & 1
                ans_sign = ((val1 - val2) >> shift) & 1
                overflow = (val1_sign != val2_sign) and (val1_sign != ans_sign) # subtract overflow
                if not f:
                    taken, reason = overflow, "{:s}-{:s} overflows".format(name1, name2)
                else:
                    taken, reason = overflow, "{:s}-{:s} does not overflow".format(name1, name2)
            elif c == 7: # OD
                if not f:
                    taken, reason = ((val1 - val2) & 1) == 1, "LSB({:s}-{:s})==1".format(name1, name2)
                else:
                    taken, reason = ((val1 - val2) & 1) == 0, "LSB({:s}-{:s})==0".format(name1, name2)
            return taken, reason

        def check_cond_add(c, f, name1, val1, name2, val2):
            if c == 0: # never
                if not f:
                    taken, reason = False, ""
                else:
                    taken, reason = True, "Always True"
            elif c == 1: # =
                if not f:
                    taken, reason = val1 == -val2, "{:s}==-{:s}".format(name1, name2)
                else:
                    taken, reason = val1 != -val2, "{:s}!=-{:s}".format(name1, name2)
            elif c == 2: # < (signed)
                if not f:
                    taken, reason = val1 < -val2, "{:s}<-{:s} (signed)".format(name1, name2)
                else:
                    taken, reason = val1 >= -val2, "{:s}>=-{:s} (signed)".format(name1, name2)
            elif c == 3: # <= (signed)
                if not f:
                    taken, reason = val1 <= -val2, "{:s}<=-{:s} (signed)".format(name1, name2)
                else:
                    taken, reason = val1 > -val2, "{:s}>-{:s} (signed)".format(name1, name2)
            elif c == 4: # NUV (unsigned)
                if is_64bit():
                    shift = 63
                else:
                    shift = 31
                val1 &= (1 << (shift + 1)) - 1
                val2 &= (1 << (shift + 1)) - 1
                val1_sign = (val1 >> shift) & 1
                val2_sign = (val2 >> shift) & 1
                ans_sign = ((val1 + val2) >> shift) & 1
                overflow = (val1_sign == val2_sign) and (val1_sign != ans_sign) # addition overflow
                if not f:
                    taken, reason = not overflow, "{:s}+{:s} does not overflow (unsigned)".format(name1, name2)
                else:
                    taken, reason = overflow, "{:s}+{:s} overflows (unsigned)".format(name1, name2)
            elif c == 5: # ZNV (unsigned)
                if is_64bit():
                    shift = 63
                else:
                    shift = 31
                val1 &= (1 << (shift + 1)) - 1
                val2 &= (1 << (shift + 1)) - 1
                val1_sign = (val1 >> shift) & 1
                val2_sign = (val2 >> shift) & 1
                ans_sign = ((val1 + val2) >> shift) & 1
                overflow = (val1_sign == val2_sign) and (val1_sign != ans_sign) # addition overflow
                zero = (val1 + val2) == 0
                if not f:
                    taken, reason = zero or not overflow, "{:s}+{:s} is zero or no overflow (unsigned)".format(name1, name2)
                else:
                    taken, reason = not zero and overflow, "{:s}+{:s} is nonzero and overflows (unsigned)".format(name1, name2)
            elif c == 6: # SV (signed)
                if is_64bit():
                    shift = 63
                else:
                    shift = 31
                val1_sign = (val1 >> shift) & 1
                val2_sign = (val2 >> shift) & 1
                ans_sign = ((val1 + val2) >> shift) & 1
                overflow = (val1_sign == val2_sign) and (val1_sign != ans_sign) # addition overflow
                if not f:
                    taken, reason = overflow, "{:s}+{:s} overflows (signed)".format(name1, name2)
                else:
                    taken, reason = not overflow, "{:s}+{:s} does not overflow (signed)".format(name1, name2)
            elif c == 7: # OD
                if not f:
                    taken, reason = ((val1 + val2) & 1) == 1, "LSB({:s}-{:s})==1".format(name1, name2)
                else:
                    taken, reason = ((val1 + val2) & 1) == 0, "LSB({:s}-{:s})==0".format(name1, name2)
            return taken, reason

        def check_cond_bit(c, name1, val1, name2, val2):
            if is_64bit():
                shift = 63
            else:
                shift = 31
            bit_on = ((val1 >> (shift - val2)) & 1) == 1
            if c == 2: # <
                taken, reason = bit_on, "{:s}.bit({:s})==1".format(name1, name2)
            elif c == 6: # >=
                taken, reason = not bit_on, "{:s}.bit({:s})==0".format(name1, name2)
            else:
                taken, reason = False, ""
            return taken, reason

        taken, reason = False, ""
        if insn.mnemonic.startswith("movb"):
            c = (insn.opcodes[2] >> 5) & 0b111
            v1 = insn.operands[0] # source
            taken, reason = check_cond_mov(c, v1, get_register(v1))
        elif insn.mnemonic.startswith("movib"):
            c = (insn.opcodes[2] >> 5) & 0b111
            v1 = insn.operands[0] # source
            taken, reason = check_cond_mov(c, v1, int(v1, 16))
        elif insn.mnemonic.startswith("cmpb"):
            c = (insn.opcodes[2] >> 5) & 0b111
            f = (insn.opcodes[0] >> 3) & 1
            v1 = insn.operands[0] # source1
            v2 = insn.operands[1] # source2
            taken, reason = check_cond_cmp(c, f, v1, get_register(v1), v2, get_register(v2))
        elif insn.mnemonic.startswith("cmpib"):
            c = (insn.opcodes[2] >> 5) & 0b111
            f = (insn.opcodes[0] >> 3) & 1
            v1 = insn.operands[0] # source1
            v2 = insn.operands[1] # source2
            taken, reason = check_cond_cmp(c, f, v1, int(v1, 16), v2, get_register(v2))
        elif insn.mnemonic.startswith("addb"):
            c = (insn.opcodes[2] >> 5) & 0b111
            f = (insn.opcodes[0] >> 3) & 1
            v1 = insn.operands[0] # source1
            v2 = insn.operands[1] # source2
            taken, reason = check_cond_add(c, f, v1, get_register(v1), v2, get_register(v2))
        elif insn.mnemonic.startswith("addib"):
            c = (insn.opcodes[2] >> 5) & 0b111
            f = (insn.opcodes[0] >> 3) & 1
            v1 = insn.operands[0] # source1
            v2 = insn.operands[1] # source2
            taken, reason = check_cond_add(c, f, v1, int(v1, 16), v2, get_register(v2))
        elif insn.mnemonic.startswith("bb,"): # bb and bvb
            c = (insn.opcodes[2] >> 5) & 0b111
            v1 = insn.operands[0] # source1
            v2 = insn.operands[1] # source2
            vbit = (insn.opcodes[0] >> 2) & 1
            if vbit:
                taken, reason = check_cond_bit(c, v1, get_register(v1), v2, int(v2, 16)) # bv,cond,n
            else:
                taken, reason = check_cond_bit(c, v1, get_register(v1), v2, get_register(v2)) # bvb,cond,n

        if not taken:
            reason = ""
        return taken, reason

    def get_ith_parameter(self, i, in_func=True):
        if i < len(self.function_parameters):
            reg = self.function_parameters[i]
            val = get_register(reg)
            key = reg
            return key, val
        else:
            i -= len(self.function_parameters)
            ret0 = get_register("$ret0")
            sp = current_arch.sp
            sz = current_arch.ptrsize
            loc = ret0 - (i * sz)
            val = read_int_from_memory(loc)
            key = "[sp - {:#x}]".format(sp - loc)
            return key, val

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = get_register("$rp") & ~0b11
            elif frame.older():
                ra = frame.older().pc()
        except Exception:
            pass
        return ra

    mprotect_asm = None

    @classmethod
    def mprotect_asm_raw(cls, addr, size, perm):

        def asm21(x):
            temp = (x & 0x100000) >> 20
            temp |= (x & 0x0ffe00) >> 8
            temp |= (x & 0x000180) << 7
            temp |= (x & 0x00007c) << 14
            temp |= (x & 0x000003) << 12
            return "{:021b}".format(temp)

        def imm14(x, len=14):
            i = len_ones = 0
            while i < len:
                len_ones = (len_ones << 1) | 1
                i += 1
            one_bit_at_len = 1 << (len - 1)
            sign = x & len_ones & one_bit_at_len
            sign >>= (len - 1)
            rest = x & len_ones & (len_ones ^ one_bit_at_len)
            rest <<= 1
            return "{:014b}".format(rest | sign)

        def ldil(reg, imm):
            fmt = "0b001000_{:05b}_{:s}"
            val = fmt.format(reg, asm21(imm))
            return p32(int(val, 2))

        def ldo(reg1, reg2, imm):
            fmt = "0b001101_{:05b}_{:05b}_00_{:s}"
            val = fmt.format(reg1, reg2, imm14(imm))
            return p32(int(val, 2))

        _NR_mprotect = 125
        insns = [
            ldil(26, addr >> 11), # ldil L%addr[31:11], r26
            ldo(26, 26, addr & 0x7ff), # ldo addr[10:0](r26), r26
            ldil(25, size >> 11), # ldil L%size[31:11], r25
            ldo(25, 25, size & 0x7ff), # ldo size[10:0](r25), r25
            ldil(24, perm >> 11), # ldil L%perm[31:11], r24
            ldo(24, 24, perm & 0x7ff), # ldo perm[10:0](r24), r24
            ldil(20, _NR_mprotect >> 11), # ldil L%_NR_mprotect[31:11], r20
            ldo(20, 20, _NR_mprotect & 0x7ff), # ldo _NR_mprotect[10:0](r20), r20
            p32(0xe4008200), # be,l 100(sr2, r0), sr0, r31
        ]
        return b''.join(insns)


class HPPA64(HPPA):
    arch = "HPPA"
    mode = "HPPA64"

    # qemu does not support hppa64, so I could not test


class OR1K(Architecture):
    arch = "OR1K"
    mode = "OR1K"

    # https://openrisc.io/or1k.html
    # https://sourceware.org/cgen/gen-doc/openrisc-insn.html
    all_registers = [
        "$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7",
        "$r8", "$r9", "$r10", "$r11", "$r12", "$r13", "$r14", "$r15",
        "$r16", "$r17", "$r18", "$r19", "$r20", "$r21", "$r22", "$r23",
        "$r24", "$r25", "$r26", "$r27", "$r28", "$r29", "$r30", "$r31",
        "$ppc", "$npc", "$sr",
    ]
    alias_registers = {
        "$r1": "$sp", "$r9": "$lr",
    }
    flag_register = "$sr"
    flags_table = {
        11: "overflow",
        10: "carry",
        9: "flag",
    }
    return_register = "$r11"
    function_parameters = ["$r3", "$r4", "$r5", "$r6", "$r7", "$r8"]
    syscall_register = "$r11"
    syscall_parameters = ["$r3", "$r4", "$r5", "$r6", "$r7", "$r8"]

    instruction_length = 4
    has_delay_slot = True
    has_syscall_delay_slot = True
    has_ret_delay_slot = True

    keystone_support = False
    capstone_support = False
    unicorn_support = False

    nop_insn = b"\x00\x00\x00\x15" # l.nop 0x0
    infloop_insn = b"\x00\x00\x00\x00" # l.j self
    trap_insn = None
    ret_insn = b"\x00\x48\x00\x44" # l.jr r9
    syscall_insn = b"\x01\x00\x00\x20" # l.sys 0x1

    def is_syscall(self, insn):
        return insn.mnemonic == "l.sys" and insn.operands[0] == "0x1"

    def is_call(self, insn):
        return insn.mnemonic in ["l.bal", "l.jal", "ljalr"]

    def is_jump(self, insn):
        if self.is_conditional_branch(insn):
            return True
        return insn.mnemonic in ["l.j", "l.jr"]

    def is_ret(self, insn):
        if insn.mnemonic == "l.jr" and insn.operands[0] == "r9":
            return True
        if insn.mnemonic in ["l.rfe"]:
            return True
        return False

    def is_conditional_branch(self, insn):
        return insn.mnemonic in ["l.bf", "l.bnf"]

    def is_branch_taken(self, insn):
        mnemo = insn.mnemonic
        val = get_register(self.flag_register)
        flags = dict((self.flags_table[k], k) for k in self.flags_table)
        taken, reason = False, ""

        flag = bool(val & (1 << flags["flag"]))

        if mnemo == "l.bf":
            taken, reason = flag, "F"
        if mnemo == "l.bnf":
            taken, reason = not flag, "!F"
        return taken, reason

    def flag_register_to_human(self, val=None):
        if not val:
            reg = self.flag_register
            val = get_register(reg)
        return flags_to_human(val, self.flags_table)

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = get_register("$r9")
            elif frame.older():
                ra = frame.older().pc()
        except Exception:
            pass
        return ra

    mprotect_asm = None

    @classmethod
    def mprotect_asm_raw(cls, addr, size, perm):
        _NR_mprotect = 226
        insns = [
            p32(0xa8600000 | (addr >> 16)), # l.ori r3, r0, addr[31:16]
            p32(0xb8630010), # l.slli r3, r3, 16
            p32(0xa8630000 | (addr & 0xffff)), # l.ori r3, r6, addr[15:0]

            p32(0xa8800000 | (size >> 16)), # l.ori r4, r0, size[31:16]
            p32(0xb8840010), # l.slli r4, r4, 16
            p32(0xa8840000 | (size & 0xffff)), # l.ori r4, r6, size[15:0]

            p32(0xa8a00000 | (perm >> 16)), # l.ori r5, r0, perm[31:16]
            p32(0xb8a50010), # l.slli r5, r5, 16
            p32(0xa8a50000 | (perm & 0xffff)), # l.ori r5, r6, perm[15:0]

            p32(0xa9600000 | _NR_mprotect), # l.ori r11, r0, _NR_mprotect

            p32(0x20000001), # l.sys 0x1
            p32(0x15000000), # l.nop 0x0 (delay slot)
        ]
        return b''.join(insns)


class NIOS2(Architecture):
    arch = "NIOS2"
    mode = "NIOS2"

    # https://www.intel.com/content/www/us/en/docs/programmable/683836/current/introduction.html
    # https://www.intel.co.jp/content/dam/altera-www/global/ja_JP/pdfs/literature/hb/nios2/n2cpu-nii5v1gen2-j.pdf
    all_registers = [
        "$zero", "$at", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7",
        "$r8", "$r9", "$r10", "$r11", "$r12", "$r13", "$r14", "$r15",
        "$r16", "$r17", "$r18", "$r19", "$r20", "$r21", "$r22", "$r23",
        "$et", "$bt", "$gp", "$sp", "$fp", "$ea", "$sstatus", "$ra",
        "$pc",
    ]
    alias_registers = {
        "$zero": "$r0", "$at": "$r1", "$et": "$r24", "$bt": "$r25",
        "$gp": "$r26", "$sp": "$r27", "$fp": "$r28", "$ea": "$r29",
        "$sstatus": "$r30", "$ra": "$r31",
    }
    flag_register = None # NIOS2 has no flags register
    return_register = "$r2"
    function_parameters = ["$r4", "$r5", "$r6", "$r7"]
    syscall_register = "$r2"
    syscall_parameters = ["$r4", "$r5", "$r6", "$r7", "$r8", "$r9"]

    instruction_length = 4
    has_delay_slot = False
    has_syscall_delay_slot = False
    has_ret_delay_slot = False

    keystone_support = False
    capstone_support = False
    unicorn_support = False

    nop_insn = b"\x3a\x88\x01\x00" # nop
    infloop_insn = b"\x06\xff\x3f\x00" # br self
    trap_insn = None
    ret_insn = b"\x3a\x28\x00\xf8" # ret
    syscall_insn = b"\x3a\x68\x3b\x00" # trap 0

    def is_syscall(self, insn):
        return insn.mnemonic == "trap" and insn.operands[0] == "0"

    def is_call(self, insn):
        return insn.mnemonic in ["call", "callr"]

    def is_jump(self, insn):
        if self.is_conditional_branch(insn):
            return True
        return insn.mnemonic in ["br", "jmp", "jmpi"]

    def is_ret(self, insn):
        return insn.mnemonic in ["ret", "bret", "eret"]

    def is_conditional_branch(self, insn):
        branch_mnemos = [
            "beq", "bne",
            "bge", "bgeu", "bgt", "bgtu",
            "ble", "bleu", "blt", "bltu",
        ]
        return insn.mnemonic in branch_mnemos

    def is_branch_taken(self, insn):
        mnemo, ops = insn.mnemonic, insn.operands
        v0 = get_register(ops[0])
        v1 = get_register(ops[1])
        v0u = v0 & 0xffffffff
        v1u = v1 & 0xffffffff
        taken, reason = False, ""

        if mnemo == "beq":
            taken, reason = v0 == v1, "{:s}=={:s}".format(ops[0], ops[1])
        elif mnemo == "bne":
            taken, reason = v0 != v1, "{:s}!={:s}".format(ops[0], ops[1])
        elif mnemo == "bge":
            taken, reason = v0 >= v1, "{:s}>={:s} (signed)".format(ops[0], ops[1])
        elif mnemo == "bgeu":
            taken, reason = v0u >= v1u, "{:s}>={:s} (unsigned)".format(ops[0], ops[1])
        elif mnemo == "bgt":
            taken, reason = v0 > v1, "{:s}>{:s} (signed)".format(ops[0], ops[1])
        elif mnemo == "bgtu":
            taken, reason = v0u > v1u, "{:s}>{:s} (unsigned)".format(ops[0], ops[1])
        elif mnemo == "ble":
            taken, reason = v0 <= v1, "{:s}<={:s} (signed)".format(ops[0], ops[1])
        elif mnemo == "bleu":
            taken, reason = v0u <= v1u, "{:s}<={:s} (unsigned)".format(ops[0], ops[1])
        elif mnemo == "blt":
            taken, reason = v0 < v1, "{:s}<{:s} (signed)".format(ops[0], ops[1])
        elif mnemo == "bltu":
            taken, reason = v0u < v1u, "{:s}<{:s} (unsigned)".format(ops[0], ops[1])
        return taken, reason

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = get_register("$ra")
            elif frame.older():
                ra = frame.older().pc()
        except Exception:
            pass
        return ra

    mprotect_asm = None

    @classmethod
    def mprotect_asm_raw(cls, addr, size, perm):
        _NR_mprotect = 226

        def op_i(op, reg1, reg2, imm):
            fmt = "0b{:05b}_{:05b}_{:016b}_{:06b}"
            val = fmt.format(reg1, reg2, imm, op)
            return p32(int(val, 2))

        insns = [
            op_i(0x34, 0, 4, (addr >> 16) & 0xffff), # orhi r0, r4, addr[31:16]
            op_i(0x14, 4, 4, (addr >> 0) & 0xffff), # ori r4, r4, addr[15:0]

            op_i(0x34, 0, 5, (size >> 16) & 0xffff), # orhi r0, r5, size[31:16]
            op_i(0x14, 5, 5, (size >> 0) & 0xffff), # ori r5, r5, size[15:0]

            op_i(0x34, 0, 6, (perm >> 16) & 0xffff), # orhi r0, r6, perm[31:16]
            op_i(0x14, 6, 6, (perm >> 0) & 0xffff), # ori r6, r6, perm[15:0]

            op_i(0x14, 0, 2, _NR_mprotect), # ori r0, r2, _NR_mprotect
            p32(0x003b683a), # trap 0
        ]
        return b''.join(insns)


class MICROBLAZE(Architecture):
    arch = "MICROBLAZE"
    mode = "MICROBLAZE"

    # https://www.xilinx.com/content/dam/xilinx/support/documents/sw_manuals/xilinx2021_2/ug984-vivado-microblaze-ref.pdf
    all_registers = [
        "$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7",
        "$r8", "$r9", "$r10", "$r11", "$r12", "$r13", "$r14", "$r15",
        "$r16", "$r17", "$r18", "$r19", "$r20", "$r21", "$r22", "$r23",
        "$r24", "$r25", "$r26", "$r27", "$r28", "$r29", "$r30", "$r31",
        "$rpc", "$rmsr",
    ]
    alias_registers = {
        "$r0": "$zero", "$r1": "$sp", "$r15": "$ra",
    }
    lag_register = None
    return_register = "$r3"
    function_parameters = ["$r5", "$r6", "$r7", "$r8", "$r9", "$r10"]
    syscall_register = "$r12"
    syscall_parameters = ["$r5", "$r6", "$r7", "$r8", "$r9", "$r10"]

    instruction_length = 4
    has_delay_slot = True
    has_syscall_delay_slot = True
    has_ret_delay_slot = True

    keystone_support = False
    capstone_support = False
    unicorn_support = False

    nop_insn = b"\x00\x00\x00\x80" # or r0, r0, r0
    infloop_insn = b"\x00\x00\x00\xb8" # bri self
    trap_insn = None
    ret_insn = b"\x08\x00\x0f\xb6" # rtsd r15, 8
    syscall_insn = b"\x08\x00\xcc\xb9" # brki r14,8

    def is_syscall(self, insn):
        return insn.mnemonic == "brki" and insn.operands[:2] == ["r14", "8"]

    def is_call(self, insn):
        return insn.mnemonic in ["brld", "brald", "brlid", "bralid"]

    def is_jump(self, insn):
        if self.is_conditional_branch(insn):
            return True
        branch_mnemos = [
            "br", "bra", "brd", "brad",
            "bri", "brai", "brid", "braid",
        ]
        return insn.mnemonic in branch_mnemos

    def is_ret(self, insn):
        return insn.mnemonic in ["rtsd"]

    def is_conditional_branch(self, insn):
        branch_mnemos = [
            "beq", "beqd", "beqi", "beqid",
            "bne", "bned", "bnei", "bneid",
            "bge", "bged", "bgei", "bgeid",
            "bgt", "bgtd", "bgti", "bgtid",
            "ble", "bled", "blei", "bleid",
            "blt", "bltd", "blti", "bltid",
        ]
        return insn.mnemonic in branch_mnemos

    def is_branch_taken(self, insn):
        mnemo, ops = insn.mnemonic, [x.split()[0] for x in insn.operands]
        taken, reason = False, ""

        pI = lambda a: struct.pack("<I", a & 0xffffffff)
        ui = lambda a: struct.unpack("<i", a)[0]
        u2i = lambda a: ui(pI(a))

        v0 = u2i(get_register(ops[0])) # signed

        if mnemo in ["beq", "beqd", "beqi", "beqid"]:
            taken, reason = v0 == 0, "{:s}==0".format(ops[0])
        elif mnemo in ["bne", "bned", "bnei", "bneid"]:
            taken, reason = v0 != 0, "{:s}!=0".format(ops[0])
        elif mnemo in ["bge", "bged", "bgei", "bgeid"]:
            taken, reason = v0 >= 0, "{:s}>=0".format(ops[0])
        elif mnemo in ["bgt", "bgtd", "bgti", "bgtid"]:
            taken, reason = v0 > 0, "{:s}>0".format(ops[0])
        elif mnemo in ["ble", "bled", "blei", "bleid"]:
            taken, reason = v0 <= 0, "{:s}<=0".format(ops[0])
        elif mnemo in ["blt", "bltd", "blti", "bltid"]:
            taken, reason = v0 < 0, "{:s}<0".format(ops[0])
        return taken, reason

    def get_ith_parameter(self, i, in_func=True):
        if i < len(self.function_parameters):
            reg = self.function_parameters[i]
            val = get_register(reg)
            key = reg
            return key, val
        else:
            sp = current_arch.sp
            sz = current_arch.ptrsize
            loc = sp + (i * sz)
            val = read_int_from_memory(loc)
            key = "[sp + {:#x}]".format(i * sz)
            return key, val

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = get_register("$r15")
            elif frame.older():
                ra = frame.older().pc()
        except Exception:
            pass
        return ra

    mprotect_asm = None

    @classmethod
    def mprotect_asm_raw(cls, addr, size, perm):
        _NR_mprotect = 125

        def op_i(op, reg1, reg2, imm):
            fmt = "0b{:06b}_{:05b}_{:05b}_{:016b}"
            val = fmt.format(op, reg1, reg2, imm)
            return p32(int(val, 2))

        insns = [
            op_i(0xc, 5, 0, (addr >> 16) & 0xffff), # addik r5, r0, addr[31:16]
            op_i(0x24, 5, 5, 0x1e2), # swaph r5, r5
            op_i(0xc, 5, 5, addr & 0xffff), # addik r5, r5, addr[15:0]

            op_i(0xc, 6, 0, (size >> 16) & 0xffff), # addik r6, r0, size[31:16]
            op_i(0x24, 6, 6, 0x1e2), # swaph r6, r6
            op_i(0xc, 6, 6, size & 0xffff), # addik r6, r6, size[15:0]

            op_i(0xc, 7, 0, (perm >> 16) & 0xffff), # addik r7, r0, perm[31:16]
            op_i(0x24, 7, 7, 0x1e2), # swaph r7, r7
            op_i(0xc, 7, 7, perm & 0xffff), # addik r7, r7, perm[15:0]

            op_i(0xc, 12, 0, _NR_mprotect), # addik r12, r0, _NR_mprotect

            p32(0xb9cc0008), # brki r14,8
            p32(0x80000000), # or r0, r0, r0 # delay slot
        ]
        return b''.join(insns)


class XTENSA(Architecture):
    arch = "XTENSA"
    mode = "XTENSA"

    # https://www.cadence.com/content/dam/cadence-www/global/en_US/documents/tools/ip/tensilica-ip/isa-summary.pdf
    # https://dl.espressif.com/github_assets/espressif/xtensa-isa-doc/releases/download/latest/Xtensa.pdf
    # https://usermanual.wiki/Document/Xtensa2020ASSEMBLER20GUIDE.1231659642/html
    all_registers = [
        "$a0", "$a1", "$a2", "$a3", "$a4", "$a5", "$a6", "$a7",
        "$a8", "$a9", "$a10", "$a11", "$a12", "$a13", "$a14", "$a15",
        "$pc", "$sar", "ps",
    ]
    alias_registers = {
        "$a0": "$lr", "$a1": "$sp",
    }
    flag_register = None
    return_register = "$a2"
    function_parameters = ["$a10", "$a11", "$a12", "$a13", "$a14", "$a15"]
    syscall_register = "$a2"
    syscall_parameters = ["$a6", "$a3", "$a4", "$a5", "$a8", "$a9"]

    instruction_length = None # variable length
    has_delay_slot = False
    has_syscall_delay_slot = False
    has_ret_delay_slot = False

    keystone_support = False
    capstone_support = False
    unicorn_support = False

    nop_insn = b"\x3d\xf0" # nop.n
    infloop_insn = b"\x06\xff\xff" # j self
    trap_insn = None
    ret_insn = b"\x1d\xf0" # retw.n
    syscall_insn = b"\x00\x50\x00" # syscall

    def is_syscall(self, insn):
        return insn.mnemonic in ["syscall"]

    def is_call(self, insn):
        call_mnemo = [
            "call0", "call4", "call8", "call12",
            "callx0", "callx4", "callx8", "callx12",
        ]
        return insn.mnemonic in call_mnemo

    def is_jump(self, insn):
        if self.is_conditional_branch(insn):
            return True
        return insn.mnemonic in ["j", "jx"]

    def is_ret(self, insn):
        return insn.mnemonic in ["ret", "retw", "ret.n", "retw.n"]

    def is_conditional_branch(self, insn):
        branch_mnemos = [
            "beq", "beqz", "beqz.n", "beqi",
            "bne", "bnez", "bnez.n", "bnei",
            "bge", "bgez", "bgei", "bgeu", "bgeui",
            "blt", "bltz", "blti", "bltu", "bltui",
            "bbc", "bbs", "bbci", "bbsi",
            "bnone", "bany", "ball", "bnall",
            "bt", "bf",
        ]
        return insn.mnemonic in branch_mnemos

    def is_branch_taken(self, insn):
        mnemo, ops = insn.mnemonic, insn.operands
        taken, reason = False, ""

        pI = lambda a: struct.pack("<I", a & 0xffffffff)
        ui = lambda a: struct.unpack("<i", a)[0]
        u2i = lambda a: ui(pI(a))

        if mnemo == "beq":
            v0 = get_register(ops[0])
            v1 = get_register(ops[1])
            taken, reason = v0 == v1, "{:s}=={:s}".format(ops[0], ops[1])
        if mnemo == "beqi":
            v0 = get_register(ops[0])
            v1 = int(ops[1])
            taken, reason = v0 == v1, "{:s}=={:s}".format(ops[0], ops[1])
        elif mnemo == "bne":
            v0 = get_register(ops[0])
            v1 = get_register(ops[1])
            taken, reason = v0 != v1, "{:s}!={:s}".format(ops[0], ops[1])
        elif mnemo == "bnei":
            v0 = get_register(ops[0])
            v1 = int(ops[1])
            taken, reason = v0 != v1, "{:s}!={:s}".format(ops[0], ops[1])
        elif mnemo in ["beqz", "beqz.n"]:
            v0 = get_register(ops[0])
            taken, reason = v0 == 0, "{:s}==0".format(ops[0])
        elif mnemo in ["bnez", "bnez.n"]:
            v0 = get_register(ops[0])
            taken, reason = v0 != 0, "{:s}!=0".format(ops[0])
        elif mnemo == "bge":
            v0 = u2i(get_register(ops[0]))
            v1 = u2i(get_register(ops[1]))
            taken, reason = v0 >= v1, "{:s}>={:s} (signed)".format(ops[0], ops[1])
        elif mnemo == "bgei":
            v0 = u2i(get_register(ops[0]))
            v1 = int(ops[1])
            taken, reason = v0 >= v1, "{:s}>={:s} (signed)".format(ops[0], ops[1])
        elif mnemo == "bgeu":
            v0 = get_register(ops[0])
            v1 = get_register(ops[1])
            taken, reason = v0 >= v1, "{:s}>={:s} (unsigned)".format(ops[0], ops[1])
        elif mnemo == "bgeui":
            v0 = get_register(ops[0])
            v1 = int(ops[1])
            taken, reason = v0 >= v1, "{:s}>={:s} (unsigned)".format(ops[0], ops[1])
        elif mnemo == "bgez":
            v0 = get_register(ops[0])
            taken, reason = (v0 >> 31) == 0, "({:s}>>31)==0".format(ops[0])
        elif mnemo == "blt":
            v0 = u2i(get_register(ops[0]))
            v1 = u2i(get_register(ops[1]))
            taken, reason = v0 < v1, "{:s}<{:s} (signed)".format(ops[0], ops[1])
        elif mnemo == "blti":
            v0 = u2i(get_register(ops[0]))
            v1 = int(ops[1])
            taken, reason = v0 < v1, "{:s}<{:s} (signed)".format(ops[0], ops[1])
        elif mnemo == "bltu":
            v0 = get_register(ops[0])
            v1 = get_register(ops[1])
            taken, reason = v0 < v1, "{:s}<{:s} (unsigned)".format(ops[0], ops[1])
        elif mnemo == "bltui":
            v0 = get_register(ops[0])
            v1 = int(ops[1])
            taken, reason = v0 < v1, "{:s}<{:s} (unsigned)".format(ops[0], ops[1])
        elif mnemo == "bltz":
            v0 = get_register(ops[0])
            taken, reason = (v0 >> 31) == 1, "({:s}>>31)==1".format(ops[0])
        elif mnemo == "bany":
            v0 = get_register(ops[0])
            v1 = get_register(ops[1])
            taken, reason = (v0 & v1) != 0, "({:s}&{:s})!=0".format(ops[0], ops[1])
        elif mnemo == "bnone":
            v0 = get_register(ops[0])
            v1 = get_register(ops[1])
            taken, reason = (v0 & v1) == 0, "({:s}&{:s})==0".format(ops[0], ops[1])
        elif mnemo == "ball":
            v0 = get_register(ops[0])
            v1 = get_register(ops[1])
            taken, reason = (~v0 & v1) == 0, "(~{:s}&{:s})==0".format(ops[0], ops[1])
        elif mnemo == "bnall":
            v0 = get_register(ops[0])
            v1 = get_register(ops[1])
            taken, reason = (~v0 & v1) != 0, "(~{:s}&{:s})!=0".format(ops[0], ops[1])
        elif mnemo == "bt":
            v0 = get_register(ops[0])
            taken, reason = v0 != 0, "{:s}!=0".format(ops[0])
        elif mnemo == "bf":
            v0 = get_register(ops[0])
            taken, reason = v0 == 0, "{:s}==0".format(ops[0])
        elif mnemo == "bbs":
            v0 = get_register(ops[0])
            v1 = get_register(ops[1])
            taken, reason = ((v0 >> (v1 & 0b11111)) & 1) == 1, "Bit ({:s}&0b11111) of {:s} is 1".format(ops[1], ops[0])
        elif mnemo == "bbsi":
            v0 = get_register(ops[0])
            v1 = int(ops[1])
            taken, reason = ((v0 >> v1) & 1) == 1, "Bit {:s} of {:s} is 1".format(ops[1], ops[0])
        elif mnemo == "bbc":
            v0 = get_register(ops[0])
            v1 = get_register(ops[1])
            taken, reason = ((v0 >> (v1 & 0b11111)) & 1) == 0, "Bit ({:s}&0b11111) of {:s} is 0".format(ops[1], ops[0])
        elif mnemo == "bbci":
            v0 = get_register(ops[0])
            v1 = int(ops[1])
            taken, reason = ((v0 >> v1) & 1) == 0, "Bit {:s} of {:s} is 0".format(ops[1], ops[0])
        return taken, reason

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = get_register("$a0")
                if insn.mnemonic in ["retw", "retw.n"]:
                    ra &= ~(0b11 << 30)
            elif frame.older():
                ra = frame.older().pc()
        except Exception:
            pass
        return ra

    mprotect_asm = None

    @classmethod
    def mprotect_asm_raw(cls, addr, size, perm):
        _NR_mprotect = 82

        def movi(reg, imm):
            fmt = "0b{:04b}_0010_1010_{:04b}_{:08b}"
            val = fmt.format(reg, (imm >> 8) & 0xf, imm & 0xff)
            val = int(val, 2)
            return bytes([(val >> 16) & 0xff, (val >> 8) & 0xff,  val & 0xff])

        def slli(reg1, reg2, imm):
            fmt = "0b{:04b}_0000_{:04b}_{:04b}_000{:01b}_0001"
            val = fmt.format((32 - imm) & 0xf, reg1, reg2, ((32 - imm) >> 4) & 1)
            val = int(val, 2)
            return bytes([(val >> 16) & 0xff, (val >> 8) & 0xff,  val & 0xff])

        def orr(reg1, reg2, reg3):
            fmt = "0b{:04b}_0000_{:04b}_{:04b}_0010_0000"
            val = fmt.format(reg3, reg1, reg2)
            val = int(val, 2)
            return bytes([(val >> 16) & 0xff, (val >> 8) & 0xff,  val & 0xff])

        insns = [
            movi(2, (addr >> 21) & 0x7ff), # mov a2, addr[31:21]
            slli(6, 2, 21), # slli a6, a2, 21
            movi(2, (addr >> 10) & 0x7ff), # mov a2, addr[20:10]
            slli(2, 2, 10), # slli a2, a2, 10
            orr(6, 6, 2), # or a6, a6, a2
            movi(2, (addr >> 0) & 0x3ff), # mov a2, addr[9:0]
            orr(6, 6, 2), # or a6, a6, a2

            movi(2, (size >> 21) & 0x7ff), # mov a2, size[31:21]
            slli(3, 2, 21), # slli a3, a2, 21
            movi(2, (size >> 10) & 0x7ff), # mov a2, size[20:10]
            slli(2, 2, 10), # slli a2, a2, 10
            orr(3, 3, 2), # or a3, a3, a2
            movi(2, (size >> 0) & 0x3ff), # mov a2, size[9:0]
            orr(3, 3, 2), # or a3, a3, a2

            movi(2, (perm >> 21) & 0x7ff), # mov a2, perm[31:21]
            slli(4, 2, 21), # slli a4, a2, 21
            movi(2, (perm >> 10) & 0x7ff), # mov a2, perm[20:10]
            slli(2, 2, 10), # slli a2, a2, 10
            orr(4, 4, 2), # or a4, a4, a2
            movi(2, (perm >> 0) & 0x3ff), # mov a2, perm[9:0]
            orr(4, 4, 2), # or a4, a4, a2

            movi(2, _NR_mprotect), # mov a2, _NR_mprotect

            b"\x00\x50\x00", # syscall
        ]
        return b''.join(insns)


class CRIS(Architecture):
    arch = "CRIS"
    mode = "CRIS"

    # https://www.axis.com/dam/public/25/67/ab/etrax-100lx-programmer%E2%80%99s-manual-en-US-33419.pdf
    all_registers = [
        "$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7",
        "$r8", "$r9", "$r10", "$r11", "$r12", "$r13", "$sp", "$pc",
        "$srp", "$ccr",
    ]
    alias_registers = {
        "$sp": "$r14", "$pc": "$r15",
    }
    flag_register = "$ccr"
    flags_table = {
        9: "write-fail",
        3: "negative",
        2: "zero",
        1: "overflow",
        0: "carry",
    }
    return_register = "$r10"
    function_parameters = ["$r10", "$r11", "$r12", "$r13"]
    # As of linux 4.17, cris is no longer supported.
    syscall_register = "$r9"
    syscall_parameters = ["$r10", "$r11", "$r12", "$r13", "$dcr1/mof", "$sp+0x4"]

    instruction_length = None # variable length
    has_delay_slot = True
    has_syscall_delay_slot = True
    has_ret_delay_slot = True

    keystone_support = False
    capstone_support = False
    unicorn_support = False

    nop_insn = b"\x0f\x05" # nop
    infloop_insn = b"\xff\xe0" # ba self
    trap_insn = None
    ret_insn = b"\x7f\xb6" # ret
    syscall_insn = b"\x3d\xe9" # break 13

    def is_syscall(self, insn):
        return insn.mnemonic == "break" and insn.operands[0] == "13"

    def is_call(self, insn):
        return insn.mnemonic in ["jsr", "jsrc"]

    def is_jump(self, insn):
        if self.is_conditional_branch(insn):
            return True
        return insn.mnemonic in ["ba", "jmpu", "jump"]

    def is_ret(self, insn):
        return insn.mnemonic == "ret"

    def is_conditional_branch(self, insn):
        conditions = [
            "cc", "cs", "ne", "eq", "vc", "vs", "pl", "mi",
            "ls", "hi", "ge", "lt", "gt", "le", "wf"
        ]
        for cc in conditions:
            if insn.mnemonic in [f"b{cc}"]:
                return True
        return False

    def is_branch_taken(self, insn):
        mnemo = insn.mnemonic
        val = get_register(self.flag_register)
        flags = dict((self.flags_table[k], k) for k in self.flags_table)
        taken, reason = False, ""

        zero = bool(val & (1 << flags["zero"]))
        negative = bool(val & (1 << flags["negative"]))
        overflow = bool(val & (1 << flags["overflow"]))
        carry = bool(val & (1 << flags["carry"]))
        write_fail = bool(val & (1 << flags["write-fail"]))

        if mnemo == "bcc":
            taken, reason = not carry, "!C"
        elif mnemo == "bcs":
            taken, reason = carry, "C"
        elif mnemo == "bne":
            taken, reason = not zero, "!Z"
        elif mnemo == "beq":
            taken, reason = zero, "Z"
        elif mnemo == "bvc":
            taken, reason = not overflow, "!V"
        elif mnemo == "bvs":
            taken, reason = overflow, "V"
        elif mnemo == "bpl":
            taken, reason = not negative, "!N"
        elif mnemo == "bmi":
            taken, reason = negative, "N"
        elif mnemo == "bls":
            taken, reason = carry or zero, "C || Z"
        elif mnemo == "bhi":
            taken, reason = not carry and not zero, "!C && !Z"
        elif mnemo == "bge":
            taken, reason = (negative and overflow) or (not negative and not overflow), "(N && V) || (!N && !V)"
        elif mnemo == "blt":
            taken, reason = (negative and not overflow) or (not negative and overflow), "(N && !V) || (!N && V)"
        elif mnemo == "bgt":
            taken = (negative and overflow and not zero) or (not negative and not overflow and not zero)
            reason = "(N && V && !Z) || (!N && !V && !Z)"
        elif mnemo == "ble":
            taken, reason = zero or (negative and not overflow) or (not negative and overflow), "Z || (N && !V) || (!N && V)"
        elif mnemo == "bwf":
            taken, reason = write_fail, "WF"
        return taken, reason

    def flag_register_to_human(self, val=None):
        if not val:
            reg = self.flag_register
            val = get_register(reg)
        return flags_to_human(val, self.flags_table)

    def get_ith_parameter(self, i, in_func=True):
        if i < len(self.function_parameters):
            reg = self.function_parameters[i]
            val = get_register(reg)
            key = reg
            return key, val
        else:
            i -= len(self.function_parameters)
            sp = current_arch.sp
            sz = current_arch.ptrsize
            loc = sp + (i * sz)
            val = read_int_from_memory(loc)
            key = "[sp + {:#x}]".format(i * sz)
            return key, val

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = get_register("$srp")
            elif frame.older():
                ra = frame.older().pc()
        except Exception:
            pass
        return ra

    mprotect_asm = None

    @classmethod
    def mprotect_asm_raw(cls, addr, size, perm):
        return None
        #_NR_mprotect = 125
        #insns = [
        #    b"\x0f\x05", # nop
        #]
        #return b''.join(insns)


# The prototype for new architecture.
#
#class XXX(Architecture):
#    arch = "XXX"
#    mode = "XXX"
#
#    all_registers = [
#        "$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7",
#        "$r8", "$r9", "$r10", "$r11", "$r12", "$r13", "$r14", "$r15",
#        "$pc", "$sr",
#    ]
#    alias_registers = {
#        "$r15": "$sp",
#    }
#    #flag_register = "$flags"
#    #flags_table = {
#    #    0: "negative",
#    #    1: "zero",
#    #}
#    #return_register = "$r0"
#    #function_parameters = ["$r1", "$r2", "$r3", "$r4", "$r5", "$r6"]
#    #syscall_register = "$r0"
#    #syscall_parameters = ["$r1", "$r2", "$r3", "$r4", "$r5", "$r6"]
#
#    #instruction_length = 4
#    #has_delay_slot = False
#    #has_syscall_delay_slot = False
#    #has_ret_delay_slot = False
#
#    #keystone_support = False
#    #capstone_support = False
#    #unicorn_support = False
#
#    #nop_insn = b"\x00\x00" # nop
#    #infloop_insn = b"\x11\x11" # bra self
#    #trap_insn = None
#    #ret_insn = b"\x22\x22" # ret
#    #syscall_insn = b"\x33\x33" # ecall
#
#    #def is_syscall(self, insn):
#    #    return insn.mnemonic in []
#
#    #def is_call(self, insn):
#    #    return insn.mnemonic in []
#
#    #def is_jump(self, insn):
#    #    if self.is_conditional_branch(insn):
#    #        return True
#    #    return insn.mnemonic in []
#
#    #def is_ret(self, insn):
#    #    return insn.mnemonic in []
#
#    #def is_conditional_branch(self, insn):
#    #    return insn.mnemonic in []
#
#    #def is_branch_taken(self, insn):
#    #    mnemo = insn.mnemonic
#    #    val = get_register(self.flag_register)
#    #    flags = dict((self.flags_table[k], k) for k in self.flags_table)
#    #    taken, reason = False, ""
#    #    return taken, reason
#
#    #def flag_register_to_human(self, val=None):
#    #    if not val:
#    #        reg = self.flag_register
#    #        val = get_register(reg)
#    #    return flags_to_human(val, self.flags_table)
#
#    #def get_ith_parameter(self, i, in_func=True):
#    #    if in_func:
#    #        i += 1 # Account for RA being at the top of the stack
#    #    sp = current_arch.sp
#    #    sz = current_arch.ptrsize
#    #    loc = sp + (i * sz)
#    #    val = read_int_from_memory(loc)
#    #    key = "[sp + {:#x}]".format(i * sz)
#    #    return key, val
#
#    #def get_ra(self, insn, frame):
#    #    ra = None
#    #    try:
#    #        if self.is_ret(insn):
#    #            ra = get_register("$sr")
#    #        elif frame.older():
#    #            ra = frame.older().pc()
#    #    except Exception:
#    #        pass
#    #    return ra
#
#    #mprotect_asm = None
#
#    #@classmethod
#    #def mprotect_asm_raw(cls, addr, size, perm):
#    #    insns = [
#    #        b"\x00\x00", # nop
#    #    ]
#    #    return b''.join(insns)


def write_memory(address, buffer, length):
    """Write `buffer` at address `address`."""
    try:
        gdb.selected_inferior().write_memory(address, buffer, length)
        ret = length
        return ret
    except gdb.MemoryError:
        pass

    pid = get_pid()
    if pid and (is_qemu_usermode() or is_pin()):

        def read_memory_via_proc_mem(pid, address, length):
            with open("/proc/{:d}/mem".format(pid), "rb") as fd:
                try:
                    fd.seek(address)
                    return fd.read(length)
                except Exception:
                    return None

        def write_memory_via_proc_mem(pid, address, buffer, length):
            with open("/proc/{:d}/mem".format(pid), "wb") as fd:
                try:
                    fd.seek(address)
                    ret = fd.write(buffer[:length])
                    fd.flush()
                    gdb.execute("maintenance flush dcache", to_string=True)
                    return ret
                except Exception:
                    return None

        def write_with_check(pid, address, buffer, length, offset=0):
            before = read_memory_via_proc_mem(pid, address + offset, length)
            if before is None:
                return None

            ret = write_memory_via_proc_mem(pid, address + offset, buffer, length)
            after = read_memory(address, length)

            if ret:
                if after == buffer[:length]:
                    return ret
                else:
                    # fail, revert
                    write_memory_via_proc_mem(pid, address + offset, before, length)
                    return None
            return None

        # qemu-user (32bit) maps the memory at +0x10000
        if is_qemu_usermode() and is_32bit():
            ret = write_with_check(pid, address, buffer, length, offset=0x10000)
            if ret:
                return ret

        # Under qemu-user/pin, you may not be able to patch code areas, so we patch via /proc/pid/mem
        ret = write_with_check(pid, address, buffer, length)
        if ret:
            return ret

        raise Exception("Unsupported before qemu 5.1")

    raise Exception("Write memory error")


def read_memory(addr, length):
    """Return a `length` long byte array with the copy of the process memory at `addr`."""
    if is_pin():
        # Memory read of pin is very slow, so speed it up
        try:
            pid = get_pid()
            with open("/proc/{:d}/mem".format(pid), "rb") as fd:
                fd.seek(addr)
                return fd.read(length)
        except Exception:
            pass

    # Don't include it in a try-cach, as we might expect a memory error on read_memory.
    return gdb.selected_inferior().read_memory(addr, length).tobytes()


def is_valid_addr(addr):
    if addr < 0:
        return False
    try:
        gdb.selected_inferior().read_memory(addr, 1)
        return True
    except gdb.MemoryError:
        return False


def read_int_from_memory(addr):
    """Return an integer read from memory."""
    sz = current_arch.ptrsize
    mem = read_memory(addr, sz)
    unpack = u32 if sz == 4 else u64
    return unpack(mem)


def read_cstring_from_memory(address, max_length=GEF_MAX_STRING_LENGTH):
    """Return a C-string read from memory."""
    # original GEF uses gdb.Value().cast("char"), but this is too slow if string is too large.
    # for example 0xcccccccccccccccc....(too long), this is in kernel or firmware commonly.
    # to avoid this, gdb.Value().cast() is removed.

    # first, read to page boundary
    length = gef_getpagesize() - (address % gef_getpagesize())
    try:
        res = read_memory(address, length)
    except gdb.MemoryError:
        return None

    # if too short, more read
    while len(res) < max_length:
        if b"\x00" in res:
            break
        try:
            read_length = min(max_length - len(res), gef_getpagesize())
            res += read_memory(address + len(res), read_length)
        except gdb.MemoryError:
            break

    # treat as utf-8
    res = res.split(b"\x00")[0]
    ustr = res.decode("utf-8")
    if len(ustr) > max_length:
        ustr = "{}[...]".format(ustr[:max_length])
    return ustr


def read_ascii_string(address):
    """Read an ASCII string from memory"""
    cstr = read_cstring_from_memory(address)
    if cstr and all([x in string.printable for x in cstr]):
        return cstr
    return None


def strings(data, length=8):
    string_printable = string.printable.replace("\n", "").encode()
    strings_data = []
    current_str = ""
    i = 0
    while i < len(data):
        if data[i] in string_printable:
            current_str += chr(data[i])
        else:
            if len(current_str) >= length:
                strings_data.append(current_str)
            current_str = ""
        i += 1
    if len(current_str) >= length:
        strings_data.append(current_str)
    return strings_data


def read_physmem_secure(paddr, size):
    sm_base, sm_size = XSecureMemAddrCommand.get_secure_memory_base_and_size()
    if sm_base is None or sm_size is None:
        return None
    if not (sm_base <= paddr < sm_base + sm_size):
        return None
    sm = XSecureMemAddrCommand.get_secure_memory_qemu_map(sm_base, sm_size)
    if sm is None:
        return None
    out = XSecureMemAddrCommand.read_secure_memory(sm, paddr - sm_base, size)
    return out


def read_physmem(paddr, size):
    def fast_path(paddr, size):
        out = read_memory(paddr, size)
        return out

    def slow_path(paddr, size): # < qemu 4.1.0-rc0
        res = gdb.execute("monitor xp/{:d}xb {:#x}".format(size, paddr), to_string=True)
        out = b""
        for line in res.splitlines():
            data = line.split()[1:]
            out += bytes([int(x, 16) for x in data])
        return out

    if is_arm32() or is_arm64():
        out = read_physmem_secure(paddr, size)
        if out:
            return out

    if not is_supported_physmode():
        return slow_path(paddr, size)

    try:
        orig_mode = get_current_mmu_mode()
        if orig_mode == "virt":
            enable_phys()
        out = fast_path(paddr, size)
        if orig_mode == "virt":
            disable_phys()
    except gdb.MemoryError:
        if orig_mode == "virt":
            disable_phys()
        # fall through to slow path
        out = slow_path(paddr, size)
    return out


def write_physmem_secure(paddr, buffer):
    sm_base, sm_size = XSecureMemAddrCommand.get_secure_memory_base_and_size()
    if sm_base is None or sm_size is None:
        return None
    if not (sm_base <= paddr < sm_base + sm_size):
        return None
    sm = XSecureMemAddrCommand.get_secure_memory_qemu_map(sm_base, sm_size)
    if sm is None:
        return None
    out = WSecureMemAddrCommand.write_secure_memory(sm, paddr - sm_base, buffer)
    return out


def write_physmem(paddr, buffer):
    if is_arm32() or is_arm64():
        ret = write_physmem_secure(paddr, buffer)
        if ret:
            return ret

    if not is_supported_physmode():
        return None

    try:
        orig_mode = get_current_mmu_mode()
        if orig_mode == "virt":
            enable_phys()
        ret = write_memory(paddr, buffer, len(buffer))
        if orig_mode == "virt":
            disable_phys()
    except Exception:
        if orig_mode == "virt":
            disable_phys()
    return ret


def get_current_mmu_mode():
    try:
        response = gdb.execute('maintenance packet qqemu.PhyMemMode', to_string=True, from_tty=False)
        if 'received: "0"' in response:
            return "virt"
        elif 'received: "1"' in response:
            return "phys"
        else:
            return False
    except Exception:
        return False


def is_supported_physmode():
    return get_current_mmu_mode() in ["virt", "phys"]


def enable_phys():
    response = gdb.execute('maintenance packet Qqemu.PhyMemMode:1', to_string=True, from_tty=False)
    response = gdb.execute('maintenance packet qqemu.PhyMemMode', to_string=True, from_tty=False)
    return 'received: "1"' in response


def disable_phys():
    response = gdb.execute('maintenance packet Qqemu.PhyMemMode:0', to_string=True, from_tty=False)
    response = gdb.execute('maintenance packet qqemu.PhyMemMode', to_string=True, from_tty=False)
    return 'received: "0"' in response


@functools.lru_cache(maxsize=None)
def p8(x, s=False):
    """Pack one byte respecting the current architecture endianness."""
    if not s:
        return struct.pack("{}B".format(endian_str()), x)
    else:
        return struct.pack("{}b".format(endian_str()), x)


@functools.lru_cache(maxsize=None)
def p16(x, s=False):
    """Pack one word respecting the current architecture endianness."""
    if not s:
        return struct.pack("{}H".format(endian_str()), x)
    else:
        return struct.pack("{}h".format(endian_str()), x)


@functools.lru_cache(maxsize=None)
def p32(x, s=False):
    """Pack one dword respecting the current architecture endianness."""
    if not s:
        return struct.pack("{}I".format(endian_str()), x)
    else:
        return struct.pack("{}i".format(endian_str()), x)


@functools.lru_cache(maxsize=None)
def p64(x, s=False):
    """Pack one qword respecting the current architecture endianness."""
    if not s:
        return struct.pack("{}Q".format(endian_str()), x)
    else:
        return struct.pack("{}q".format(endian_str()), x)


@functools.lru_cache(maxsize=None)
def u8(x, s=False):
    """Unpack one byte respecting the current architecture endianness."""
    if not s:
        return struct.unpack("{}B".format(endian_str()), x)[0]
    else:
        return struct.unpack("{}b".format(endian_str()), x)[0]


@functools.lru_cache(maxsize=None)
def u16(x, s=False):
    """Unpack one word respecting the current architecture endianness."""
    if not s:
        return struct.unpack("{}H".format(endian_str()), x)[0]
    else:
        return struct.unpack("{}h".format(endian_str()), x)[0]


@functools.lru_cache(maxsize=None)
def u32(x, s=False):
    """Unpack one dword respecting the current architecture endianness."""
    if not s:
        return struct.unpack("{}I".format(endian_str()), x)[0]
    else:
        return struct.unpack("{}i".format(endian_str()), x)[0]


@functools.lru_cache(maxsize=None)
def u64(x, s=False):
    """Unpack one qword respecting the current architecture endianness."""
    if not s:
        return struct.unpack("{}Q".format(endian_str()), x)[0]
    else:
        return struct.unpack("{}q".format(endian_str()), x)[0]


def is_ascii_string(address):
    """Helper function to determine if the buffer pointed by `address` is an ASCII string (in GDB)"""
    try:
        return read_ascii_string(address) is not None
    except Exception:
        return False


def is_alive():
    """Check if GDB is running."""
    try:
        return gdb.selected_inferior().pid > 0
    except Exception:
        return False
    return False


class ArgparseExitProxyException(Exception):
    pass


def parse_args(f):
    """Decorator wrapper to parse args for command."""

    @functools.wraps(f)
    def wrapper(self, argv, **kwargs):
        try:
            self.parser.exit = lambda *_: exec('raise(ArgparseExitProxyException())')
            args = self.parser.parse_args(argv)
        except ArgparseExitProxyException:
            self.usage(omit_syntax=True)
            return
        except Exception:
            err("Invalid argument")
            return
        return f(self, args, **kwargs)

    return wrapper


def only_if_gdb_running(f):
    """Decorator wrapper to check if GDB is running."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        if is_alive():
            return f(*args, **kwargs)
        else:
            warn("No debugging session active")
            return

    return wrapper


def only_if_gdb_target_local(f):
    """Decorator wrapper to check if GDB is running locally (target not remote)."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        if not is_remote_debug():
            return f(*args, **kwargs)
        else:
            warn("This command cannot work for remote sessions.")
            return

    return wrapper


def only_if_qemu_system(f):
    """Decorator wrapper to check if GDB is connected to qemu-system."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        if is_qemu_system():
            return f(*args, **kwargs)
        else:
            warn("This command can work under qemu-system only.")
            return

    return wrapper


def only_if_not_qemu_system(f):
    """Decorator wrapper to check if GDB is connected to qemu-system."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        if not is_qemu_system():
            return f(*args, **kwargs)
        else:
            warn("This command cannot work under qemu-system.")
            return

    return wrapper


def experimental_feature(f):
    """Decorator to add a warning when a feature is experimental."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        warn("This feature is under development, expect bugs and unstability...")
        return f(*args, **kwargs)

    return wrapper


def only_if_specific_arch(arch=[]):
    """Decorator wrapper to check if the archtecture is specific."""

    def wrapper(f):
        @functools.wraps(f)
        def inner_f(*args, **kwargs):
            for a in arch:
                if a == "x86_32" and is_x86_32():
                    return f(*args, **kwargs)
                elif a == "x86_64" and is_x86_64():
                    return f(*args, **kwargs)
                elif a == "ARM64" and is_arm64():
                    return f(*args, **kwargs)
                elif a == "ARM32" and is_arm32():
                    return f(*args, **kwargs)
                elif a == "MIPS32" and is_mips32():
                    return f(*args, **kwargs)
                elif a == "MIPS64" and is_mips64():
                    return f(*args, **kwargs)
                elif a == "PPC32" and is_ppc32():
                    return f(*args, **kwargs)
                elif a == "PPC64" and is_ppc64():
                    return f(*args, **kwargs)
                elif a == "SPARC32" and is_sparc32():
                    return f(*args, **kwargs)
                elif a == "SPARC64" and is_sparc64():
                    return f(*args, **kwargs)
                elif a == "RISCV32" and is_riscv32():
                    return f(*args, **kwargs)
                elif a == "RISCV64" and is_riscv64():
                    return f(*args, **kwargs)
                elif a == "S390X" and is_s390x():
                    return f(*args, **kwargs)
                elif a == "SH4" and is_sh4():
                    return f(*args, **kwargs)
                elif a == "M68K" and is_m68k():
                    return f(*args, **kwargs)
                elif a == "ALPHA" and is_alpha():
                    return f(*args, **kwargs)
                elif a == "HPPA32" and is_hppa32():
                    return f(*args, **kwargs)
                elif a == "HPPA64" and is_hppa64():
                    return f(*args, **kwargs)
                elif a == "OR1K" and is_or1k():
                    return f(*args, **kwargs)
                elif a == "NIOS2" and is_nios2():
                    return f(*args, **kwargs)
                elif a == "MICROBLAZE" and is_microblaze():
                    return f(*args, **kwargs)
                elif a == "XTENSA" and is_xtensa():
                    return f(*args, **kwargs)
                elif a == "CRIS" and is_cris():
                    return f(*args, **kwargs)
            else:
                warn("This command cannot work under this architecture.")
                return

        return inner_f

    return wrapper


def exclude_specific_arch(arch=[]):
    """Decorator wrapper to check if the archtecture is specific."""

    def wrapper(f):
        @functools.wraps(f)
        def inner_f(*args, **kwargs):
            for a in arch:
                if a == "x86_32" and is_x86_32():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "x86_64" and is_x86_64():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "ARM64" and is_arm64():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "ARM32" and is_arm32():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "MIPS32" and is_mips32():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "MIPS64" and is_mips64():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "PPC32" and is_ppc32():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "PPC64" and is_ppc64():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "SPARC32" and is_sparc32():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "SPARC64" and is_sparc64():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "RISCV32" and is_riscv32():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "RISCV64" and is_riscv64():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "S390X" and is_s390x():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "SH4" and is_sh4():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "M68K" and is_m68k():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "ALPHA" and is_alpha():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "HPPA32" and is_hppa32():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "HPPA64" and is_hppa64():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "OR1K" and is_or1k():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "NIOS2" and is_nios2():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "MICROBLAZE" and is_microblaze():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "XTENSA" and is_xtensa():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "CRIS" and is_cris():
                    warn("This command cannot work under this architecture.")
                    return
            else:
                return f(*args, **kwargs)

        return inner_f

    return wrapper


def only_if_gdb_version_higher_than(required_gdb_version):
    """Decorator to check whether current GDB version requirements."""

    def wrapper(f):
        def inner_f(*args, **kwargs):
            if GDB_VERSION >= required_gdb_version:
                return f(*args, **kwargs)
            else:
                reason = "GDB >= {} for this command".format(required_gdb_version)
                raise EnvironmentError(reason)

        return inner_f

    return wrapper


def timeout(duration):
    def wrapper(function):
        queue = multiprocessing.Queue(maxsize=1)

        def run_function(function, *args, **kwargs):
            try:
                result = function(*args, **kwargs)
            except Exception as e:
                queue.put((False, e))
            else:
                queue.put((True, result))
            return

        def inner_f(*args, **kwargs):
            fargs = [function] + list(args)
            p = multiprocessing.Process(target=run_function, args=fargs, kwargs=kwargs)
            p.start()
            p.join(duration)
            if p.is_alive():
                p.kill()
                raise multiprocessing.TimeoutError
            assert queue.full()
            success, result = queue.get()
            if success:
                return result
            else:
                raise result

        return inner_f

    return wrapper


def use_stdtype():
    if is_32bit():
        return "uint32_t"
    elif is_64bit():
        return "uint64_t"
    return "uint16_t"


def use_default_type():
    if is_32bit():
        return "unsigned int"
    elif is_64bit():
        return "unsigned long"
    return "unsigned short"


def use_golang_type():
    if is_32bit():
        return "uint32"
    elif is_64bit():
        return "uint64"
    return "uint16"


def use_rust_type():
    if is_32bit():
        return "u32"
    elif is_64bit():
        return "u64"
    return "u16"


def to_unsigned_long(v):
    """Cast a gdb.Value to unsigned long."""
    if is_32bit():
        mask = (1 << 32) - 1
    else:
        mask = (1 << 64) - 1
    return int(v.cast(gdb.Value(mask).type)) & mask


def get_register(regname):
    """Return a register's value."""
    if regname[0] in ["%", "@"]:
        regname = "$" + regname[1:]

    if regname[0] != '$':
        regname = "$" + regname

    try:
        value = gdb.parse_and_eval(regname)
        if value.type.code == gdb.TYPE_CODE_INT:
            return to_unsigned_long(value)
        else:
            return int(value)
    except gdb.error:
        if (is_hppa32() or is_hppa64()) and regname == "$r0":
            return 0
        try:
            value = gdb.selected_frame().read_register(regname[1:])
            return int(value)
        except ValueError:
            return None
        except gdb.error:
            return None


def get_path_from_info_proc():
    try:
        response = gdb.execute("info proc", to_string=True)
    except Exception:
        return None
    for x in response.splitlines():
        if x.startswith("exe = "):
            return x.split(" = ")[1].replace("'", "")
    return None


@functools.lru_cache(maxsize=None)
def get_os():
    """Return the current OS."""
    return platform.system().lower()


@functools.lru_cache(maxsize=None)
def is_remote_debug():
    """"Return True is the current debugging session is running through GDB remote session."""
    res = gdb.execute("maintenance print target-stack", to_string=True)
    return "remote" in res


# Removed is_remote_same_host.
# It can detect that gdb connects to a process in the same host.
# However, it cannot detect that traffic is being redirected to another host.


@functools.lru_cache(maxsize=None)
def is_normal_run():
    ret = gdb.execute("info files", to_string=True)
    return "Using the running image of child" in ret


@functools.lru_cache(maxsize=None)
def is_attach():
    ret = gdb.execute("info files", to_string=True)
    return "Using the running image of attached" in ret


@functools.lru_cache(maxsize=None)
def is_container_attach():
    return not is_remote_debug() and is_attach() and gdb.current_progspace().filename.startswith("target:")


@functools.lru_cache(maxsize=None)
def is_pin():
    if not is_remote_debug():
        return False
    response = gdb.execute('maintenance packet qSupported', to_string=True, from_tty=False)
    return 'intel.name=' in response


@functools.lru_cache(maxsize=None)
def is_qemu():
    if not is_remote_debug():
        return False
    response = gdb.execute('maintenance packet Qqemu.sstepbits', to_string=True, from_tty=False)
    return 'ENABLE=' in response


@functools.lru_cache(maxsize=None)
def is_qemu_usermode():
    if is_qemu() is False:
        return False
    response = gdb.execute('maintenance packet qOffsets', to_string=True, from_tty=False)
    return 'Text=' in response


@functools.lru_cache(maxsize=None)
def is_qemu_system():
    if is_qemu() is False:
        return False
    response = gdb.execute('maintenance packet qOffsets', to_string=True, from_tty=False)
    return 'received: ""' in response


def get_tcp_sess(pid):
    # get inode information from opened file descriptor
    inodes = []
    for openfd in os.listdir("/proc/{:d}/fd".format(pid)):
        try:
            fdname = os.readlink("/proc/{:d}/fd/{:s}".format(pid, openfd))
        except (FileNotFoundError, ProcessLookupError, OSError):
            continue
        if fdname.startswith("socket:["):
            inode = fdname[8:-1]
            inodes.append(inode)

    def decode(addr):
        ip, port = addr.split(":")
        ip = socket.inet_ntop(socket.AF_INET, bytes.fromhex(ip)[::-1])
        port = int(port, 16)
        return (ip, port)

    # get connection information
    sessions = []
    with open("/proc/{:d}/net/tcp".format(pid)) as fd:
        for line in fd.readlines()[1:]:
            _, laddr, raddr, status, _, _, _, _, _, inode = line.split()[:10]
            if status != "01": # ESTABLISHED
                continue
            if inode not in inodes:
                continue
            laddr = decode(laddr)
            raddr = decode(raddr)
            sessions.append({"laddr": laddr, "raddr": raddr})
    return sessions


def get_gdb_tcp_sess():
    gdb_pid = os.getpid()
    return get_tcp_sess(gdb_pid)


def get_all_process():
    pids = [int(x) for x in os.listdir("/proc") if x.isdigit()]
    process = []
    for pid in pids:
        try:
            filepath = os.readlink("/proc/{:d}/exe".format(pid))
        except (FileNotFoundError, ProcessLookupError, OSError):
            continue
        process.append({"pid": pid, "filepath": os.path.basename(filepath)})
    return process


@functools.lru_cache(maxsize=None)
def get_pid(remote=False):
    """Return the PID of the debuggee process."""
    def get_filepath_from_info_files():
        response = gdb.execute('info files', to_string=True)
        for line in response.splitlines():
            if line.startswith("Symbols from"):
                return line.split('"')[1]
        return None

    def get_pid_from_tcp_session(filepath, match_prefix_only=False):
        gdb_tcp_sess = [x["raddr"] for x in get_gdb_tcp_sess()]
        if not gdb_tcp_sess:
            err("gdb has no tcp session")
            return None
        for process in get_all_process():
            if match_prefix_only is True and not process["filepath"].startswith(filepath):
                continue
            if match_prefix_only is False and process["filepath"] != os.path.basename(filepath):
                continue
            for c in get_tcp_sess(process["pid"]):
                if c["laddr"] in gdb_tcp_sess:
                    return process["pid"]
        return None

    if is_pin():
        filepath = get_filepath_from_info_files()
        if filepath is None:
            err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            return None
        return get_pid_from_tcp_session(filepath)

    elif is_qemu_usermode() or is_qemu_system():
        return get_pid_from_tcp_session("qemu", match_prefix_only=True)

    elif remote is False and is_remote_debug():
        return None # gdbserver etc.

    return gdb.selected_inferior().pid


def append_proc_root(filepath):
    if filepath is None:
        return None
    pid = get_pid()
    if pid is None:
        return None
    if pid == 0: # under gdbserver, when target exited then pid is 0
        return None
    prefix = "/proc/{}/root".format(pid)
    relative_path = filepath.lstrip("/")
    return os.path.join(prefix, relative_path)


@functools.lru_cache(maxsize=None)
def get_filepath(append_proc_root_prefix=True):
    """Return the local absolute path of the file currently debugged."""
    filepath = gdb.current_progspace().filename

    if is_remote_debug():
        if filepath is None:
            return None
        elif filepath.startswith("target:"):
            return None
        elif filepath.startswith(".gnu_debugdata for target:"):
            return None
        else:
            return filepath
    else:
        # inferior probably did not have name, extract cmdline from info proc
        if filepath is None:
            filepath = get_path_from_info_proc()
            if append_proc_root_prefix:
                # maybe different mnt namespace, so use /proc/<PID>/root
                filepath = append_proc_root(filepath)
        # not remote, but different PID namespace and attaching by pid. it shows with `target:`
        elif filepath.startswith("target:"):
            # /proc/PID/root is not given when used for purposes such as comparing with entry in vmmap
            filepath = filepath[len("target:"):]
            if append_proc_root_prefix:
                # maybe different mnt namespace, so use /proc/<PID>/root
                filepath = append_proc_root(filepath)
        # normal path
        return filepath


@functools.lru_cache(maxsize=None)
def get_filename():
    """Return the full filename of the file currently debugged."""
    filename = get_filepath()
    if filename is None:
        return None
    return os.path.basename(filename)


def read_remote_file(filepath, as_byte=True):
    tmp_name = os.path.join(GEF_TEMP_DIR, "read_remote_file.tmp")
    try:
        gdb.execute("remote get {:s} {:s}".format(filepath, tmp_name), to_string=True)
    except gdb.error:
        return ""
    if as_byte:
        data = open(tmp_name, "rb").read()
    else:
        data = open(tmp_name, "r").read()
    os.unlink(tmp_name)
    return data


def get_process_maps_linux(pid, remote=False):
    """Parse the Linux process `/proc/pid/maps` file."""
    proc_map_file = "/proc/{:d}/maps".format(pid)
    if remote:
        data = read_remote_file(proc_map_file, as_byte=False)
        if not data:
            return []
        lines = data.splitlines()
        tls = None
    else:
        lines = open(proc_map_file, "r").readlines()
        tls = TlsCommand.get_tls()
    maps = []
    for line in lines:
        line = line.strip()
        addr, perm, off, _, rest = line.split(" ", 4)
        rest = rest.split(" ", 1)
        inode = rest[0]
        if len(rest) == 1:
            pathname = ""
        else:
            pathname = rest[1].lstrip()
        addr_start, addr_end = [int(x, 16) for x in addr.split("-")]
        if tls and addr_start <= tls < addr_end:
            pathname = "<tls>"
        off = int(off, 16)
        perm = Permission.from_process_maps(perm)
        sect = Section(page_start=addr_start, page_end=addr_end, offset=off, permission=perm, inode=inode, path=pathname)
        maps.append(sect)
    return maps


# __get_explored_regions (used at qemu-user mode) is very slow,
# Because it repeats read_memory many times to find the upper and lower bounds of the page.
# functools.lru_cache() is not effective as-is, as it is cleared by reset_gef_caches() each time the stepi runs.
# Fortunately, memory maps rarely change.
# I decided to make it a cache clear mechanism independent of reset_gef_caches() and
# introduce a mechanism to forcibly clear it with calling vmmap command.
def clear_explored_regions():
    sys.modules["__main__"].__get_explored_regions.cache_clear()
    return


@functools.lru_cache(maxsize=None)
def __get_explored_regions():
    """Return sections from auxv exploring"""

    if current_arch is None:
        return []

    regions = []

    def get_region_start_end(addr):
        addr &= gef_getpagesize_mask()
        if not is_valid_addr(addr):
            return None, None
        region_start = addr
        region_end = addr + gef_getpagesize()

        end_addrs = [r.page_end for r in regions]
        start_addrs = [r.page_start for r in regions]

        # up search
        lower_bound = 0
        while True:
            if region_start <= lower_bound:
                break
            if region_start in end_addrs:
                break
            if not is_valid_addr(region_start - gef_getpagesize()):
                break
            region_start -= gef_getpagesize()

        upper_bound = (1 << 32) if is_32bit() else (1 << 64)
        # down search
        while True:
            if region_end >= upper_bound:
                break
            if region_end in start_addrs:
                break
            if not is_valid_addr(region_end):
                break
            region_end += gef_getpagesize()
        return region_start, region_end

    def make_regions(addr, label, perm="rw-"):
        if addr is None:
            return []
        # check if already in region
        for rg in regions:
            if rg.page_start <= addr < rg.page_end:
                return []
        # make region
        start, end = get_region_start_end(addr)
        if start is None:
            return []
        perm = Permission.from_process_maps(perm)
        sect = Section(page_start=start, page_end=end, permission=perm, path=label)
        return [sect]

    def get_ehdr(addr):
        upper_bound = (1 << 32) if is_32bit() else (1 << 64)
        for i in range(128):
            if addr < 0 or addr > upper_bound:
                return None
            try:
                if read_memory(addr, 4) == b'\x7FELF':
                    return Elf(addr)
            except gdb.MemoryError:
                return None
            addr -= gef_getpagesize()
        return None

    def parse_region_from_ehdr(addr, label):
        elf = get_ehdr(addr & gef_getpagesize_mask())
        if elf is None:
            return []

        pages = []
        for phdr in elf.phdrs:
            if not phdr.p_memsz:
                continue

            vaddr = phdr.p_vaddr
            if elf.e_type == Elf.ET_DYN: # PIE
                vaddr += elf.addr
            vaddr_end = vaddr + phdr.p_memsz

            offset = phdr.p_offset
            flags = phdr.p_flags

            # align
            vaddr &= gef_getpagesize_mask()
            offset &= gef_getpagesize_mask()
            vaddr_end = (vaddr_end + (gef_getpagesize() - 1)) & gef_getpagesize_mask()

            # add per pages
            for page_addr in range(vaddr, vaddr_end, gef_getpagesize()):
                # check already exist
                for i, page in enumerate(pages):
                    if page['vaddr'] == page_addr:
                        # found, so fix flags
                        if page['flags'] & 1: # already has PF_X
                            flags |= 1
                        pages[i]['flags'] = flags # overwrite, because RELRO
                        break
                else:
                    # not found, so add new page
                    page = {
                        'vaddr': page_addr,
                        'memsize': gef_getpagesize(),
                        'flags': flags,
                        'offset': offset + (page_addr - vaddr),
                    }
                    pages.append(page)

        pages = sorted(pages, key=lambda x: x['vaddr'])

        # merge contiguous
        prev = pages[0]
        for page in pages[1:]:
            prev_vend = prev['vaddr'] + prev['memsize']
            if prev['flags'] == page['flags'] and prev_vend == page['vaddr']:
                prev['memsize'] += page['memsize']
                pages.remove(page)
            else:
                prev = page

        # page -> section
        sects = []
        for page in pages:
            perm = ""
            perm += "r" if page['flags'] & 4 else "-"
            perm += "w" if page['flags'] & 2 else "-"
            perm += "x" if page['flags'] & 1 else "-"
            perm = Permission.from_process_maps(perm)
            page_start = page['vaddr']
            page_end = page['vaddr'] + page['memsize']
            off = page['offset']
            sect = Section(page_start=page_start, page_end=page_end, offset=off, permission=perm, path=label)
            sects.append(sect)
        return sects

    def get_linker(addr):
        elf = get_ehdr(addr & gef_getpagesize_mask())
        phdrs = [phdr for phdr in elf.phdrs if phdr.p_type == Phdr.PT_INTERP]
        if len(phdrs) != 1:
            return None
        vaddr = phdrs[0].p_vaddr
        if elf.e_type == Elf.ET_DYN: # PIE
            vaddr += elf.addr
        linker = read_cstring_from_memory(vaddr)
        return linker

    def get_link_map(addr):
        if addr is None:
            return None

        elf = get_ehdr(addr & gef_getpagesize_mask())

        # get dynamic
        phdrs = [phdr for phdr in elf.phdrs if phdr.p_type == Phdr.PT_DYNAMIC]
        if len(phdrs) != 1:
            return None
        vaddr = phdrs[0].p_vaddr
        vaddr_end = vaddr + phdrs[0].p_memsz
        if elf.e_type == Elf.ET_DYN: # PIE
            vaddr += elf.addr
            vaddr_end += elf.addr

        # search DT_DEBUG
        for tag_addr in range(vaddr, vaddr_end, current_arch.ptrsize * 2):
            tag = read_int_from_memory(tag_addr)
            if tag == 21: # DT_DEBUG
                dt_debug = read_int_from_memory(tag_addr + current_arch.ptrsize)
                break
        else:
            # not found
            return None

        # get link_map
        try:
            link_map = read_int_from_memory(dt_debug + current_arch.ptrsize)
        except Exception:
            return None

        return link_map

    def _get_filepath():
        filepath = get_filepath()
        if filepath:
            return filepath
        filepath = gdb.current_progspace().filename
        if filepath and filepath.startswith("target:"):
            filepath = filepath[7:]
        return filepath

    def parse_region_from_link_map(link_map):
        current = link_map

        regions = []
        while True:
            l_addr = read_int_from_memory(current + current_arch.ptrsize * 0)
            l_name = read_int_from_memory(current + current_arch.ptrsize * 1)
            l_next = read_int_from_memory(current + current_arch.ptrsize * 3)
            name = read_cstring_from_memory(l_name)
            if not name:
                name = _get_filepath() or "[code]"
            regions += parse_region_from_ehdr(l_addr, name)
            if l_next == 0:
                break
            current = l_next
        return regions

    # auxv parse
    auxv = gef_get_auxiliary_values()
    codebase = auxv.get("AT_PHDR", None) or auxv.get("AT_ENTRY", None)

    # plan1: from link_map info (code, all loaded shared library)
    link_map = get_link_map(codebase)
    if link_map:
        regions += parse_region_from_link_map(link_map)

    # plan2: use each auxv info (for code, linker)
    elif auxv:
        # code
        if "AT_PHDR" in auxv:
            regions += parse_region_from_ehdr(auxv["AT_PHDR"], _get_filepath() or "[code]")
        elif "AT_ENTRY" in auxv:
            regions += parse_region_from_ehdr(auxv["AT_ENTRY"], _get_filepath() or "[code]")
        # linker
        if "AT_BASE" in auxv:
            regions += parse_region_from_ehdr(auxv["AT_BASE"], get_linker(codebase) or "[linker]")

    # vdso
    if auxv:
        if "AT_SYSINFO_EHDR" in auxv:
            regions += parse_region_from_ehdr(auxv["AT_SYSINFO_EHDR"], "[vdso]")
        elif "AT_SYSINFO" in auxv:
            regions += parse_region_from_ehdr(auxv["AT_SYSINFO"], "[vdso]")

    # stack registers
    stack_permission = "rw-"
    if auxv and "AT_PHDR" in auxv:
        elf = get_ehdr(auxv["AT_PHDR"] & gef_getpagesize_mask())
        for phdr in elf.phdrs:
            if phdr.p_type != Phdr.PT_GNU_STACK:
                continue
            pflags = {
                0                                 : "---",
                Phdr.PF_X                         : "--x",
                Phdr.PF_W                         : "-w-",
                Phdr.PF_R                         : "r--",
                Phdr.PF_W | Phdr.PF_X             : "-wx",
                Phdr.PF_R | Phdr.PF_X             : "r-x",
                Phdr.PF_R | Phdr.PF_W             : "rw-",
                Phdr.PF_R | Phdr.PF_W | Phdr.PF_X : "rwx",
            }
            stack_permission = pflags[phdr.p_flags]
            break
        else:
            stack_permission = "rwx" # no GNU_STACK phdr means no-NX
    regions += make_regions(current_arch.sp, "[stack]", stack_permission)

    # registers
    for regname in current_arch.all_registers:
        try:
            regions += make_regions(get_register(regname), "<explored>")
        except TypeError:
            pass

    # walk from stack top
    sp = current_arch.sp
    data = None
    if sp is not None:
        try:
            data = read_memory(sp & gef_getpagesize_mask(), gef_getpagesize())
        except gdb.MemoryError:
            pass
    if data:
        data = slice_unpack(data, current_arch.ptrsize)
        data = list(set(data))
        for d in data:
            regions += make_regions(d, "<explored>")

    # walk from known map, because qemu may maps extra regions (?)
    for r in regions.copy():
        regions += make_regions(r.page_start - 1, "<explored>", str(r.permission))
        regions += make_regions(r.page_end + 1, "<explored>", str(r.permission))

    # ok
    regions = sorted(regions, key=lambda x: x.page_start)

    return regions


@functools.lru_cache(maxsize=None)
def get_process_maps(outer=False):
    """Return the mapped memory sections"""
    if is_qemu_usermode():
        if outer:
            pid = get_pid()
            if pid:
                return get_process_maps_linux(pid)
        else: # scan heuristic
            return __get_explored_regions()

    elif is_pin():
        pid = get_pid()
        if pid:
            return get_process_maps_linux(pid)

    elif is_qemu_system():
        return []

    elif is_remote_debug():
        remote_pid = get_pid(remote=True)
        if remote_pid:
            return get_process_maps_linux(remote_pid, remote=True)

    else: # normal pattern
        pid = get_pid()
        if pid:
            return get_process_maps_linux(pid)

    return __get_explored_regions() # scan heuristic


@functools.lru_cache(maxsize=None)
def get_info_files():
    """Retrieve all the files loaded by debuggee."""
    lines = gdb.execute("info files", to_string=True).splitlines()
    info_files = []
    for line in lines:
        line = line.strip()
        if not line:
            break
        if not line.startswith("0x"):
            continue
        blobs = [x.strip() for x in line.split(" ")]
        addr_start = int(blobs[0], 16)
        addr_end = int(blobs[2], 16)
        section_name = blobs[4]
        if "system-supplied DSO" in line:
            filepath = "[vdso]"
        elif len(blobs) == 7:
            filepath = blobs[6]
        else:
            filepath = get_filepath(append_proc_root_prefix=False)
        Zone = collections.namedtuple("Zone", ["name", "zone_start", "zone_end", "filename"])
        info = Zone(section_name, addr_start, addr_end, filepath)
        info_files.append(info)
    return info_files


@functools.lru_cache(maxsize=512)
def process_lookup_address(address):
    """Look up for an address in memory.
    Return an Address object if found, None otherwise."""
    if not is_alive():
        err("Process is not running")
        return None
    if is_x86():
        if is_in_x86_kernel(address):
            return None
    for sect in get_process_maps():
        if sect.page_start <= address < sect.page_end:
            return sect
    return None


@functools.lru_cache(maxsize=None)
def process_lookup_path(names, perm=Permission.ALL):
    """Look up for paths in the process memory mapping.
    Return a Section object of load base if found, None otherwise."""
    if not is_alive():
        err("Process is not running")
        return None

    if isinstance(names, str):
        names = tuple([names]) # make tuple to iterate

    for sect in get_process_maps():
        for name in names:
            if name in sect.path and sect.permission.value & perm:
                return sect
    return None


@functools.lru_cache(maxsize=None)
def file_lookup_name_path(name, path):
    """Look up a file by name and path.
    Return a Zone object if found, None otherwise."""
    for xfile in get_info_files():
        if path == xfile.filename and name == xfile.name:
            return xfile
    return None


@functools.lru_cache(maxsize=512)
def file_lookup_address(address):
    """Look up for a file by its address.
    Return a Zone object if found, None otherwise."""
    for info in get_info_files():
        if info.zone_start <= address < info.zone_end:
            return info
    return None


@functools.lru_cache(maxsize=512)
def lookup_address(address):
    """Try to find the address in the process address space.
    Return an Address object, with validity flag set based on success."""
    sect = process_lookup_address(address)
    info = file_lookup_address(address)
    if sect is None and info is None:
        # i.e. there is no info on this address
        return Address(value=address, valid=False)
    return Address(value=address, section=sect, info=info)


def is_hex(pattern):
    """Return whether provided string is a hexadecimal value."""
    if not pattern.startswith("0x") and not pattern.startswith("0X"):
        return False
    return len(pattern) % 2 == 0 and all(c in string.hexdigits for c in pattern[2:])


def continue_handler(event):
    """GDB event handler for new object continue cases."""
    return


check_info_file = True


def hook_stop_handler(event):
    """GDB event handler for stop cases."""
    reset_gef_caches()
    if current_arch is None:
        set_arch(get_arch())
    gdb.execute("context")

    global check_info_file
    if check_info_file:
        response = gdb.execute('info files', to_string=True)
        if "Symbols from" not in response:
            err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            err("Some architectures may not be automatically recognized. Set it manually with `set architecture YOUR_ARCH`.")
        check_info_file = False
    return


def new_objfile_handler(event):
    """GDB event handler for new object file cases."""
    reset_gef_caches(all=True)
    set_arch()
    load_libc_args()
    return


def exit_handler(event):
    """GDB event handler for exit cases."""
    reset_gef_caches(all=True)
    return


def memchanged_handler(event):
    """GDB event handler for mem changes cases."""
    reset_gef_caches()
    return


def regchanged_handler(event):
    """GDB event handler for reg changes cases."""
    reset_gef_caches()
    return


def load_libc_args():
    # load libc function arguments' definitions
    if not get_gef_setting("context.libc_args"):
        return

    path = get_gef_setting("context.libc_args_path")
    if path is None:
        warn("Config `context.libc_args_path` not set but `context.libc_args` is True. Make sure you have `gef-extras` installed")
        return

    path = os.path.realpath(os.path.expanduser(path))

    if not os.path.isdir(path):
        warn("Config `context.libc_args_path` set but it's not a directory")
        return

    _arch_mode = "{}_{}".format(current_arch.arch.lower(), current_arch.mode)
    _libc_args_file = "{}/{}.json".format(path, _arch_mode)

    global libc_args_definitions

    # current arch and mode already loaded
    if _arch_mode in libc_args_definitions:
        return

    libc_args_definitions[_arch_mode] = {}
    try:
        with open(_libc_args_file) as _libc_args:
            libc_args_definitions[_arch_mode] = json.load(_libc_args)
    except FileNotFoundError:
        del libc_args_definitions[_arch_mode]
        warn("Config context.libc_args is set but definition cannot be loaded: file {} not found".format(_libc_args_file))
    except json.decoder.JSONDecodeError as e:
        del libc_args_definitions[_arch_mode]
        warn("Config context.libc_args is set but definition cannot be loaded from file {}: {}".format(_libc_args_file, e))
    return


def get_terminal_size():
    """Return the current terminal size."""
    if platform.system() == "Windows":
        hStdErr = -12
        herr = ctypes.windll.kernel32.GetStdHandle(hStdErr)
        csbi = ctypes.create_string_buffer(22)
        res = ctypes.windll.kernel32.GetConsoleScreenBufferInfo(herr, csbi)
        if res:
            _, _, _, _, _, left, top, right, bottom, _, _ = struct.unpack("hhhhHhhhhhh", csbi.raw)
            tty_columns = right - left + 1
            tty_rows = bottom - top + 1
            return tty_rows, tty_columns
        else:
            return 600, 100
    else:
        import fcntl
        import termios
        try:
            tty_rows, tty_columns = struct.unpack("hh", fcntl.ioctl(1, termios.TIOCGWINSZ, "1234"))
            return tty_rows, tty_columns
        except OSError:
            return 600, 100


def get_generic_arch(module, prefix, arch, mode, big_endian, to_string=False, extra=[]):
    """Retrieves architecture and mode from the arguments for use for the holy
    {cap,key}stone/unicorn trinity."""
    if to_string:
        arch = "{:s}.{:s}_ARCH_{:s}".format(module.__name__, prefix, arch)
        if mode:
            mode = "{:s}.{:s}_MODE_{:s}".format(module.__name__, prefix, str(mode))
        else:
            mode = "0"
        if big_endian:
            mode += " + {:s}.{:s}_MODE_BIG_ENDIAN".format(module.__name__, prefix)
        else:
            mode += " + {:s}.{:s}_MODE_LITTLE_ENDIAN".format(module.__name__, prefix)
        for e in extra:
            mode += " + {:s}.{:s}_MODE_{:s}".format(module.__name__, prefix, e)
    else:
        arch = getattr(module, "{:s}_ARCH_{:s}".format(prefix, arch))
        if mode:
            mode = getattr(module, "{:s}_MODE_{:s}".format(prefix, mode))
        else:
            mode = 0
        if big_endian:
            mode |= getattr(module, "{:s}_MODE_BIG_ENDIAN".format(prefix))
        else:
            mode |= getattr(module, "{:s}_MODE_LITTLE_ENDIAN".format(prefix))
        for e in extra:
            mode |= getattr(module, "{:s}_MODE_{:s}".format(prefix, e))
    return arch, mode


@load_unicorn
def get_unicorn_arch(arch=None, mode=None, endian=None, to_string=False):
    unicorn = sys.modules["unicorn"]
    if (arch, mode, endian) == (None, None, None):
        arch = current_arch.arch
        mode = current_arch.mode
        endian = is_big_endian()
    if arch == "S390X":
        mode = 0
    if arch == "M68K":
        mode = 0
    return get_generic_arch(unicorn, "UC", arch, mode, endian, to_string)


@load_capstone
def get_capstone_arch(arch=None, mode=None, endian=None, to_string=False):
    capstone = sys.modules["capstone"]
    extra = []
    if (arch, mode, endian) == (None, None, None):
        arch = current_arch.arch
        mode = current_arch.mode
        endian = is_big_endian()
    # hacky patch for applying to capstone's mode
    if arch == "PPC" and mode == "PPC32":
        mode = "32"
    if arch == "PPC" and mode == "PPC64":
        mode = "64"
    if arch == "SPARC" and mode == "SPARC32":
        mode = ""
    if arch == "SPARC" and mode == "SPARC64":
        mode = "V9"
    if arch == "RISCV":
        extra = ["RISCVC"]
    if arch == "S390X":
        arch = "SYSZ"
        mode = 0
    if arch == "M68K":
        mode = "M68K_060"
    return get_generic_arch(capstone, "CS", arch, mode, endian, to_string, extra=extra)


@load_keystone
def get_keystone_arch(arch=None, mode=None, endian=None, to_string=False):
    keystone = sys.modules["keystone"]
    if (arch, mode, endian) == (None, None, None):
        arch = current_arch.arch
        mode = current_arch.mode
        endian = is_big_endian()
    # hacky patch for applying to capstone's mode
    if arch == "ARM64":
        mode = 0
    if arch == "S390X":
        arch = "SYSTEMZ"
        mode = 0
    return get_generic_arch(keystone, "KS", arch, mode, endian, to_string)


@load_unicorn
def get_unicorn_registers(to_string=False):
    "Return a dict matching the Unicorn identifier for a specific register."
    unicorn = sys.modules["unicorn"]
    regs = {}

    if current_arch is not None:
        arch = current_arch.arch.lower()
    else:
        raise OSError("Oops")

    const = getattr(unicorn, "{}_const".format(arch))
    for reg in current_arch.all_registers:
        if arch == "ppc" and reg.startswith("$r"):
            regname = "UC_{:s}_REG_{:s}".format(arch.upper(), reg.lstrip("$r").upper())
        else:
            regname = "UC_{:s}_REG_{:s}".format(arch.upper(), reg.lstrip("$").upper())
        try:
            getattr(const, regname)
        except AttributeError:
            continue
        if to_string:
            regs[reg] = "{:s}.{:s}".format(const.__name__, regname)
        else:
            regs[reg] = getattr(const, regname)
    return regs


@load_keystone
def keystone_assemble(code, arch, mode, *args, **kwargs):
    """Assembly encoding function based on keystone."""
    keystone = sys.modules["keystone"]
    code = gef_pybytes(code)
    addr = kwargs.get("addr", 0x1000)

    # `asm "[]"` returns no response
    @timeout(duration=1)
    def ks_asm(code, addr):
        return ks.asm(code, addr)

    try:
        ks = keystone.Ks(arch, mode)
        enc, cnt = ks_asm(code, addr)
    except keystone.KsError as e:
        err("Keystone assembler error: {:s}".format(str(e)))
        return None
    except multiprocessing.TimeoutError:
        err("Keystone assembler timeout error")
        return None

    if cnt == 0:
        return ""

    enc = bytearray(enc)
    if "raw" not in kwargs:
        s = binascii.hexlify(enc)
        enc = b"\\x" + b"\\x".join([s[i : i + 2] for i in range(0, len(s), 2)])
        enc = enc.decode("utf-8")

    return enc


@functools.lru_cache(maxsize=None)
def get_elf_headers(filepath=None):
    """Return an Elf object with info from `filename`. If not provided, will return
    the currently debugged file."""
    if filepath is None:
        filepath = get_filepath()
        if filepath is None:
            return None
    return Elf(filepath)


@functools.lru_cache(maxsize=None)
def ptr_width():
    void = cached_lookup_type("void")
    if void is None:
        uintptr_t = cached_lookup_type("uintptr_t")
        return uintptr_t.sizeof
    else:
        return void.pointer().sizeof


def is_64bit():
    """Checks if current target is 64bit."""
    return ptr_width() == 8


def is_32bit():
    """Checks if current target is 32bit."""
    return ptr_width() == 4


def is_x86_64():
    """Checks if current target is x86-64."""
    try:
        return current_arch.arch == "X86" and current_arch.mode == "64"
    except Exception:
        return False


def is_x86_32():
    """Checks if current target is x86-32."""
    try:
        return current_arch.arch == "X86" and current_arch.mode == "32"
    except Exception:
        return False


def is_x86():
    return is_x86_32() or is_x86_64()


def is_arm32():
    """Checks if current target is arm-32."""
    try:
        return current_arch.arch == "ARM"
    except Exception:
        return False


def is_arm64():
    """Checks if current target is aarch64."""
    try:
        return current_arch.arch == "ARM64"
    except Exception:
        return False


def is_mips32():
    """Checks if current target is mips-32."""
    try:
        return current_arch.arch == "MIPS" and current_arch.mode == "MIPS32"
    except Exception:
        return False


def is_mips64():
    """Checks if current target is mips-64."""
    try:
        return current_arch.arch == "MIPS" and current_arch.mode == "MIPS64"
    except Exception:
        return False


def is_ppc32():
    """Checks if current target is powerpc-32."""
    try:
        return current_arch.arch == "PPC" and current_arch.mode == "PPC32"
    except Exception:
        return False


def is_ppc64():
    """Checks if current target is powerpc-64."""
    try:
        return current_arch.arch == "PPC" and current_arch.mode == "PPC64"
    except Exception:
        return False


def is_sparc32():
    """Checks if current target is sparc-32."""
    try:
        return current_arch.arch == "SPARC" and current_arch.mode == "SPARC32"
    except Exception:
        return False


def is_sparc64():
    """Checks if current target is sparc-64."""
    try:
        return current_arch.arch == "SPARC" and current_arch.mode == "SPARC64"
    except Exception:
        return False


def is_riscv32():
    """Checks if current target is riscv-32."""
    try:
        return current_arch.arch == "RISCV" and current_arch.mode == "RISCV32"
    except Exception:
        return False


def is_riscv64():
    """Checks if current target is riscv-64."""
    try:
        return current_arch.arch == "RISCV" and current_arch.mode == "RISCV64"
    except Exception:
        return False


def is_s390x():
    """Checks if current target is s390x."""
    try:
        return current_arch.arch == "S390X" and current_arch.mode == "S390X"
    except Exception:
        return False


def is_sh4():
    """Checks if current target is sh4."""
    try:
        return current_arch.arch == "SH4" and current_arch.mode == "SH4"
    except Exception:
        return False


def is_m68k():
    """Checks if current target is m68k."""
    try:
        return current_arch.arch == "M68K" and current_arch.mode == "M68K"
    except Exception:
        return False


def is_alpha():
    """Checks if current target is alpha."""
    try:
        return current_arch.arch == "ALPHA" and current_arch.mode == "ALPHA"
    except Exception:
        return False


def is_hppa32():
    """Checks if current target is hppa-32."""
    try:
        return current_arch.arch == "HPPA" and current_arch.mode == "HPPA32"
    except Exception:
        return False


def is_hppa64():
    """Checks if current target is hppa-64."""
    try:
        return current_arch.arch == "HPPA" and current_arch.mode == "HPPA64"
    except Exception:
        return False


def is_or1k():
    """Checks if current target is or1k."""
    try:
        return current_arch.arch == "OR1K" and current_arch.mode == "OR1K"
    except Exception:
        return False


def is_nios2():
    """Checks if current target is nios2."""
    try:
        return current_arch.arch == "NIOS2" and current_arch.mode == "NIOS2"
    except Exception:
        return False


def is_microblaze():
    """Checks if current target is microblaze."""
    try:
        return current_arch.arch == "MICROBLAZE" and current_arch.mode == "MICROBLAZE"
    except Exception:
        return False


def is_xtensa():
    """Checks if current target is xtensa."""
    try:
        return current_arch.arch == "XTENSA" and current_arch.mode == "XTENSA"
    except Exception:
        return False


def is_cris():
    """Checks if current target is cris."""
    try:
        return current_arch.arch == "CRIS" and current_arch.mode == "CRIS"
    except Exception:
        return False


@functools.lru_cache(maxsize=None)
def is_static(filename=None):
    if filename is None:
        filename = get_filepath()
    file_bin = which("file")
    cmd = [file_bin, filename]
    out = gef_execute_external(cmd)
    return "statically linked" in out


@functools.lru_cache(maxsize=None)
def is_stripped(filename=None):
    if filename is None:
        filename = get_filepath()
    file_bin = which("file")
    cmd = [file_bin, filename]
    out = gef_execute_external(cmd)
    return not ("not stripped" in out)


def set_arch(arch=None, default=None):
    """Sets the current architecture.
    If an arch is explicitly specified, use that one, otherwise try to parse it out of the current target.
    If that fails, and default is specified, select and set that arch.
    Return the selected arch, or raise an OSError."""
    arches = {
        Elf.EM_ARM: ARM, "ARM": ARM, "ARM_ANY": ARM, "ARMV2": ARM, "ARMV2A": ARM, "ARMV3": ARM,
        "ARMV4": ARM, "ARMV4T": ARM, "ARMV5": ARM, "ARMV5T": ARM, "ARMV5TE": ARM, "ARMV5TEJ": ARM,
        "ARMV6": ARM, "ARMV6K": ARM, "ARMV6KZ": ARM, "ARMV6T2": ARM, "ARMV7": ARM,
        Elf.EM_AARCH64: AARCH64, "AARCH64": AARCH64, "ARM64": AARCH64, "ARMV8": AARCH64, "ARMV8-A": AARCH64,
        "ARMV9": AARCH64, "ARMV9-A": AARCH64,
        Elf.EM_386: X86, "X86": X86, "I386": X86, "I386:INTEL": X86, "I8086": X86,
        Elf.EM_X86_64: X86_64, "X64": X86_64, "AMD64": X86_64, "X86_64": X86_64, "X86-64": X86_64,
        "I386:X86-64": X86_64, "I386:X86-64:INTEL": X86_64,
        Elf.EM_PPC: PPC, "POWERPC": PPC, "PPC": PPC, "PPC32": PPC, "POWERPC:COMMON": PPC,
        Elf.EM_PPC64: PPC64, "POWERPC64": PPC64, "PPC64": PPC64, "POWERPC:COMMON64": PPC64,
        "RISCV": RISCV, "RISCV32": RISCV, "RISCV:RV32": RISCV, "RISCV64": RISCV64, "RISCV:RV64": RISCV64,
        Elf.EM_SPARC: SPARC, "SPARC": SPARC, "SPARC32": SPARC, "SPARC:V8": SPARC,
        Elf.EM_SPARCV9: SPARC64, "SPARC64": SPARC64, "SPARC:V9": SPARC64,
        Elf.EM_SPARC32PLUS: SPARC64, "SPARC:V8PLUS": SPARC64, "SPARC:V8PLUSA": SPARC64,
        "MIPS": MIPS, "MIPS:ISA32": MIPS, "MIPS:ISA32R2": MIPS, "MIPS:ISA32R3": MIPS,
        "MIPS:ISA32R5": MIPS, "MIPS:ISA32R6": MIPS,
        "MIPS64": MIPS64, "MIPS:ISA64": MIPS64, "MIPS:ISA64R2": MIPS64, "MIPS:ISA64R3": MIPS64,
        "MIPS:ISA64R5": MIPS64, "MIPS:ISA64R6": MIPS64,
        Elf.EM_S390: S390X, "S390X": S390X, "S390:64-BIT": S390X,
        Elf.EM_SH: SH4, "SH4": SH4, "SH4-NOFPU": SH4, "SH4A": SH4, "SH4A-NOFPU": SH4,
        Elf.EM_68K: M68K, "M68K": M68K, "M68K:68000": M68K, "M68K:68008": M68K, "M68K:68010": M68K,
        "M68K:68020": M68K, "M68K:68030": M68K, "M68K:68040": M68K, "M68K:68060": M68K,
        Elf.EM_ALPHA: ALPHA, Elf.EM_ALPHA_UNOFFICIAL: ALPHA, "ALPHA": ALPHA, "ALPHA:EV4": ALPHA,
        "ALPHA:EV5": ALPHA, "ALPHA;EV6": ALPHA,
        Elf.EM_PARISC: HPPA, "HPPA1.0": HPPA, "HPPA1.1": HPPA,
        Elf.EM_OPENRISC: OR1K, "OR1K": OR1K,
        Elf.EM_ALTERA_NIOS2: NIOS2, "NIOS2": NIOS2, "NIOS2:R1": NIOS2, "NIOS2:R2": NIOS2,
        Elf.EM_MICROBLAZE: MICROBLAZE, "MICROBLAZE": MICROBLAZE,
        Elf.EM_XTENSA: XTENSA, "XTENSA": XTENSA,
        Elf.EM_CRIS: CRIS, "CRIS": CRIS,
    }
    global current_arch, current_elf

    if arch:
        try:
            if isinstance(arch, str):
                current_arch = arches[arch.upper()]()
            else:
                current_arch = arches[arch]()
            return
        except KeyError:
            if isinstance(arch, str):
                raise OSError("Specified arch {:s} is not supported".format(arch.upper()))
            else:
                raise OSError("Specified arch {:d} is not supported".format(arch))
    else:
        if not current_elf:
            elf = get_elf_headers()
            if elf and elf.is_valid():
                current_elf = elf
            else:
                current_elf = None

        try:
            if current_elf and current_elf.e_machine not in [Elf.EM_MIPS, Elf.EM_RISCV]:
                current_arch = arches[current_elf.e_machine]()
            else:
                # MIPS32/64 and RISCV32/64  are indistinguishable because e_machine of the ELF header
                # has the same value, so we use the detection result of gdb
                current_arch = arches[get_arch().upper()]()
        except KeyError:
            if default:
                try:
                    current_arch = arches[default.upper()]()
                except KeyError:
                    raise OSError("CPU not supported, neither is default {:s}".format(default.upper()))
            else:
                raise OSError("CPU type is currently not supported: {:s}".format(get_arch().upper()))
        return


@functools.lru_cache(maxsize=None)
def cached_lookup_type(_type):
    try:
        return gdb.lookup_type(_type).strip_typedefs()
    except RuntimeError:
        return None


@functools.lru_cache(maxsize=None)
def get_memory_alignment(in_bits=False):
    """Try to determine the size of a pointer on this system.
    First, try to parse it out of the ELF header.
    Next, use the size of `size_t`.
    Finally, try the size of $pc.
    If `in_bits` is set to True, the result is returned in bits, otherwise in bytes."""
    if is_32bit():
        return 4 if not in_bits else 32
    elif is_64bit():
        return 8 if not in_bits else 64

    res = cached_lookup_type("size_t")
    if res is not None:
        return res.sizeof if not in_bits else res.sizeof * 8

    try:
        return gdb.parse_and_eval("$pc").type.sizeof
    except Exception:
        pass
    raise EnvironmentError("GEF is running under an unsupported mode")


def clear_screen():
    """Clear the screen."""
    # this is more faster than executing "shell clear -x"
    print("\x1b[H\x1b[2J", end="")
    return


def format_address(addr, memalign_size=None):
    """Format the address according to its size."""
    # if qemu-xxx(32bit arch) runs on x86-64 machine, memalign_size does not match get_memory_alignment()
    # so use the value forcibly if memalign_size is not None
    if memalign_size is None:
        memalign_size = get_memory_alignment()

    if isinstance(addr, str):
        if addr.startswith("0x"):
            return addr
        else:
            return "0x" + addr

    addr = align_address(addr, memalign_size)

    if memalign_size == 4:
        return "{:#010x}".format(addr)

    return "{:#018x}".format(addr)


def format_address_spaces(addr, left=True):
    """Format the address according to its size, but with spaces instead of zeroes."""
    width = get_memory_alignment() * 2 + 2
    addr = align_address(addr)

    if not left:
        return "{:#x}".format(addr).rjust(width)

    return "{:#x}".format(addr).ljust(width)


def align_address(address, memalign_size=None):
    """Align the provided address to the process's native length."""
    # if qemu-xxx(32bit arch) runs on x86-64 machine, memalign_size does not match
    # get_memory_alignment(), so use the value forcibly if memalign_size is not None
    if memalign_size is None and get_memory_alignment() == 4:
        return address & 0xFFFFFFFF
    return address & 0xFFFFFFFFFFFFFFFF


def align_address_to_size(address, align):
    """Align the address to the given size."""
    return address + ((align - (address % align)) % align)


def align_address_to_page(address):
    """Align the address to a page."""
    a = align_address(address) >> DEFAULT_PAGE_ALIGN_SHIFT
    return a << DEFAULT_PAGE_ALIGN_SHIFT


def parse_address(address):
    """Parse an address and return it as an Integer."""
    if is_hex(address):
        return int(address, 16)
    return to_unsigned_long(gdb.parse_and_eval(address))


def get_ksymaddr(sym):
    # use available symbol
    try:
        return parse_address('&' + sym)
    except Exception:
        pass
    # use ksymaddr-remote
    try:
        res = gdb.execute("ksymaddr-remote --silent --exact {:s}".format(sym), to_string=True)
        return int(res.split()[0], 16)
    except Exception:
        return None


def is_in_x86_kernel(address):
    address = align_address(address)
    memalign = get_memory_alignment(in_bits=True) - 1
    return (address >> memalign) == 0xF


@functools.lru_cache(maxsize=None)
def endian_str():
    return "<" if is_little_endian() else ">"


def de_bruijn(alphabet, n):
    """De Bruijn sequence for alphabet and subsequences of length n (for compat. w/ pwnlib)."""
    k = len(alphabet)
    a = [0] * k * n

    def db(t, p):
        if t > n:
            if n % p == 0:
                for j in range(1, p + 1):
                    yield alphabet[a[j]]
        else:
            a[t] = a[t - p]
            for c in db(t + 1, p):
                yield c

            for j in range(a[t - p] + 1, k):
                a[t] = j
                for c in db(t + 1, t):
                    yield c

    return db(1, 1)


def generate_cyclic_pattern(length):
    """Create a `length` byte bytearray of a de Bruijn cyclic pattern."""
    charset = bytearray(b"abcdefghijklmnopqrstuvwxyz")
    cycle = get_memory_alignment()
    return bytearray(itertools.islice(de_bruijn(charset, cycle), length))


def safe_parse_and_eval(value):
    """GEF wrapper for gdb.parse_and_eval(): this function returns None instead of raising
    gdb.error if the eval failed."""
    try:
        return gdb.parse_and_eval(value)
    except gdb.error:
        return None


@functools.lru_cache(maxsize=512)
def dereference(addr):
    """GEF wrapper for gdb dereference function."""
    try:
        ulong_t = cached_lookup_type(use_stdtype())
        if not ulong_t:
            ulong_t = cached_lookup_type(use_default_type())
            if not ulong_t:
                ulong_t = cached_lookup_type(use_golang_type())
                if not ulong_t:
                    ulong_t = cached_lookup_type(use_rust_type())
        unsigned_long_type = ulong_t.pointer()
        res = gdb.Value(addr).cast(unsigned_long_type).dereference()
        # GDB does lazy fetch by default so we need to force access to the value
        res.fetch_lazy()
        return res
    except gdb.MemoryError:
        pass
    return None


def gef_convenience(value):
    """Defines a new convenience value."""
    global __gef_convenience_vars_index__
    var_name = "$_gef{:d}".format(__gef_convenience_vars_index__)
    __gef_convenience_vars_index__ += 1
    gdb.execute("""set {:s} = "{:s}" """.format(var_name, value))
    return var_name


def parse_string_range(s):
    """Parses an address range (e.g. 0x400000-0x401000)"""
    addrs = s.split("-")
    return [int(x, 16) for x in addrs]


AT_CONSTANTS = {
    0  : 'AT_NULL',           # /* End of vector */
    1  : 'AT_IGNORE',         # /* Entry should be ignored */
    2  : 'AT_EXECFD',         # /* File descriptor of program */
    3  : 'AT_PHDR',           # /* Program headers for program */
    4  : 'AT_PHENT',          # /* Size of program header entry */
    5  : 'AT_PHNUM',          # /* Number of program headers */
    6  : 'AT_PAGESZ',         # /* System page size */
    7  : 'AT_BASE',           # /* Base address of interpreter */
    8  : 'AT_FLAGS',          # /* Flags */
    9  : 'AT_ENTRY',          # /* Entry point of program */
    10 : 'AT_NOTELF',         # /* Program is not ELF */
    11 : 'AT_UID',            # /* Real uid */
    12 : 'AT_EUID',           # /* Effective uid */
    13 : 'AT_GID',            # /* Real gid */
    14 : 'AT_EGID',           # /* Effective gid */
    15 : 'AT_PLATFORM',       # /* String identifying platform */
    16 : 'AT_HWCAP',          # /* Machine dependent hints about processor capabilities */
    17 : 'AT_CLKTCK',         # /* Frequency of times() */
    18 : 'AT_FPUCW',          #
    19 : 'AT_DCACHEBSIZE',    #
    20 : 'AT_ICACHEBSIZE',    #
    21 : 'AT_UCACHEBSIZE',    #
    22 : 'AT_IGNOREPPC',      #
    23 : 'AT_SECURE',         #
    24 : 'AT_BASE_PLATFORM',  # String identifying real platforms
    25 : 'AT_RANDOM',         # Address of 16 random bytes
    26 : 'AT_HWCAP2',         # extension of AT_HWCAP
    31 : 'AT_EXECFN',         # Filename of executable
    32 : 'AT_SYSINFO',        #
    33 : 'AT_SYSINFO_EHDR',   #
    34 : 'AT_L1I_CACHESHAPE', #
    35 : 'AT_L1D_CACHESHAPE', #
    36 : 'AT_L2_CACHESHAPE',  #
    37 : 'AT_L3_CACHESHAPE',  #
}


def get_auxiliary_walk(offset=0):
    """Find AUXV by walking stack"""

    addr = current_arch.sp & ~(DEFAULT_PAGE_SIZE - 1)

    # check readable or not
    if not is_valid_addr(addr):
        return None

    # find stack bottom
    try:
        while True:
            if b"\x7fELF" == read_memory(addr, 4):
                break
            addr += DEFAULT_PAGE_SIZE
    except gdb.MemoryError: # if read error, that is stack bottom
        pass
    current = addr - current_arch.ptrsize * 2 - offset

    # check readable or not again
    if not is_valid_addr(addr):
        # something is wrong, maybe stack is pivoted
        return None

    # find auxv end
    while True:
        a = read_int_from_memory(current)
        b = read_int_from_memory(current + current_arch.ptrsize)
        if a == b == 0:
            break
        current -= current_arch.ptrsize * 2

    # skip dummy null if exist
    for i in range(1024):
        a = read_int_from_memory(current)
        if a == 7: # AT_BASE
            break
        current -= current_arch.ptrsize * 2
    else:
        return None

    # find auxv start
    while read_int_from_memory(current) <= 37: # AT_L3_CACHESHAPE
        current -= current_arch.ptrsize * 2
    current += current_arch.ptrsize * 2

    # parse auxv
    res = {}
    while True:
        key = read_int_from_memory(current)
        val = read_int_from_memory(current + current_arch.ptrsize)
        if key not in AT_CONSTANTS:
            break
        res[AT_CONSTANTS[key]] = val
        if key == 0:
            break
        current += current_arch.ptrsize * 2

    # test
    if "AT_ENTRY" not in res:
        return None
    if "AT_PHDR" not in res:
        return None
    if "AT_RANDOM" not in res:
        return None
    if "AT_BASE" not in res:
        return None
    if "AT_NULL" not in res:
        return None

    return res


# __gef_get_auxiliary_values (under qemu-user mode) is very slow,
# Because it may call __get_auxiliary_walk that repeats read_memory many times to find the auxv value.
# functools.lru_cache() is not effective as-is, as it is cleared by reset_gef_caches() each time you stepi runs.
# Fortunately, auxv rarely changes.
# I decided to make it a cache clear mechanism independent of reset_gef_caches().
def clear_auxv_cache():
    sys.modules["__main__"].__gef_get_auxiliary_values.cache_clear()
    return


@functools.lru_cache(maxsize=None)
def __gef_get_auxiliary_values():

    def fast_path():
        try:
            result = gdb.execute("info auxv", to_string=True)
        except gdb.error:
            return None
        res = {}
        for line in result.splitlines():
            tmp = line.split()
            auxv_type = tmp[1]
            if auxv_type in ("AT_PLATFORM", "AT_EXECFN"):
                m = re.match("^.+?(0x[0-9a-f]+)", line)
                res[auxv_type] = int(m.group(1), 0)
            else:
                res[auxv_type] = int(tmp[-1], 0)
        return res

    def slow_path():
        for offset in [0, current_arch.ptrsize]:
            res = get_auxiliary_walk(offset)
            if res:
                return res
        return None

    return fast_path() or slow_path()


def gef_get_auxiliary_values():
    """Retrieves the auxiliary values of the current execution.
    Returns None if not running, or a dict() of values."""
    if not is_alive():
        return None
    if is_qemu_system():
        return None
    return __gef_get_auxiliary_values()


@functools.lru_cache(maxsize=None)
def gef_read_canary():
    """Read the canary of a running process using Auxiliary Vector.
    Return a tuple of (canary, location) if found, None otherwise."""
    auxval = gef_get_auxiliary_values()
    if not auxval:
        return None

    try:
        canary_location = auxval["AT_RANDOM"]
        canary = read_int_from_memory(canary_location)
        canary &= ~0xFF
        return canary, canary_location
    except Exception:
        return None


def gef_get_pie_breakpoint(num):
    global __pie_breakpoints__
    return __pie_breakpoints__[num]


@functools.lru_cache(maxsize=None)
def gef_getpagesize():
    """Get the page size from auxiliary values."""
    auxval = gef_get_auxiliary_values()
    if not auxval or "AT_PAGESZ" not in auxval:
        return DEFAULT_PAGE_SIZE
    return auxval["AT_PAGESZ"]


@functools.lru_cache(maxsize=None)
def gef_getpagesize_mask():
    """Get the page size mask from auxiliary values."""
    auxval = gef_get_auxiliary_values()
    if not auxval or "AT_PAGESZ" not in auxval:
        return DEFAULT_PAGE_SIZE_MASK
    return ~(auxval["AT_PAGESZ"] - 1)


def only_if_events_supported(event_type):
    """Checks if GDB supports events without crashing."""

    def wrap(f):
        def wrapped_f(*args, **kwargs):
            if getattr(gdb, "events") and getattr(gdb.events, event_type):
                return f(*args, **kwargs)
            warn("GDB events cannot be set")
        return wrapped_f

    return wrap


#
# Event hooking
#

@only_if_events_supported("cont")
def gef_on_continue_hook(func):
    return gdb.events.cont.connect(func)


@only_if_events_supported("cont")
def gef_on_continue_unhook(func):
    return gdb.events.cont.disconnect(func)


@only_if_events_supported("stop")
def gef_on_stop_hook(func):
    return gdb.events.stop.connect(func)


@only_if_events_supported("stop")
def gef_on_stop_unhook(func):
    return gdb.events.stop.disconnect(func)


@only_if_events_supported("exited")
def gef_on_exit_hook(func):
    return gdb.events.exited.connect(func)


@only_if_events_supported("exited")
def gef_on_exit_unhook(func):
    return gdb.events.exited.disconnect(func)


@only_if_events_supported("new_objfile")
def gef_on_new_hook(func):
    return gdb.events.new_objfile.connect(func)


@only_if_events_supported("new_objfile")
def gef_on_new_unhook(func):
    return gdb.events.new_objfile.disconnect(func)


@only_if_events_supported("memory_changed")
def gef_on_memchanged_hook(func):
    return gdb.events.memory_changed.connect(func)


@only_if_events_supported("memory_changed")
def gef_on_memchanged_unhook(func):
    return gdb.events.memory_changed.disconnect(func)


@only_if_events_supported("register_changed")
def gef_on_regchanged_hook(func):
    return gdb.events.register_changed.connect(func)


@only_if_events_supported("register_changed")
def gef_on_regchanged_unhook(func):
    return gdb.events.register_changed.disconnect(func)

#
# Virtual breakpoints
#


class PieVirtualBreakpoint:
    """PIE virtual breakpoint (not real breakpoint)."""
    def __init__(self, set_func, vbp_num, addr):
        # set_func(base): given a base address return a
        # "set breakpoint" gdb command string
        self.set_func = set_func
        self.vbp_num = vbp_num
        # breakpoint num, 0 represents not instantiated yet
        self.bp_num = 0
        self.bp_addr = 0
        # this address might be a symbol, just to know where to break
        if isinstance(addr, int):
            self.addr = hex(addr)
        else:
            self.addr = addr
        return

    def instantiate(self, base):
        if self.bp_num:
            self.destroy()

        try:
            res = gdb.execute(self.set_func(base), to_string=True)
        except gdb.error as e:
            err(e)
            return

        if "Breakpoint" not in res:
            err(res)
            return
        res_list = res.split()
        self.bp_num = res_list[1]
        self.bp_addr = res_list[3]
        return

    def destroy(self):
        if not self.bp_num:
            err("Destroy PIE breakpoint not even set")
            return
        gdb.execute("delete {}".format(self.bp_num))
        self.bp_num = 0
        return

#
# Breakpoints
#


class FormatStringBreakpoint(gdb.Breakpoint):
    """Inspect stack for format string."""
    def __init__(self, spec, num_args):
        super().__init__(spec, type=gdb.BP_BREAKPOINT, internal=False)
        self.num_args = num_args
        self.enabled = True
        return

    def stop(self):
        reset_gef_caches()
        msg = []
        ptr, addr = current_arch.get_ith_parameter(self.num_args)
        addr = lookup_address(addr)

        if not addr.valid:
            return False

        if addr.section.permission.value & Permission.WRITE:
            content = read_cstring_from_memory(addr.value)
            content = gef_pystring(str2bytes(content))
            name = addr.info.name if addr.info else addr.section.path
            msg.append(Color.colorify("Format string helper", "bold yellow"))
            m = "Possible insecure format string: {:s}('{:s}' {:s} {:#x}: '{:s}')"
            msg.append(m.format(self.location, ptr, RIGHT_ARROW, addr.value, content))
            m = "Reason: Call to '{:s}()' with format string argument in position "
            m += "#{:d} is in page {:#x} ({:s}) that has write permission"
            msg.append(m.format(self.location, self.num_args, addr.section.page_start, name))
            push_context_message("warn", "\n".join(msg))
            return True
        return False


class StubBreakpoint(gdb.Breakpoint):
    """Create a breakpoint to permanently disable a call (fork/alarm/signal/etc.)."""
    def __init__(self, func, retval):
        super().__init__(func, gdb.BP_BREAKPOINT, internal=False)
        self.func = func
        self.retval = retval

        m = "All calls to '{:s}' will be skipped".format(self.func)
        if self.retval is not None:
            m += " (with return value set to {:#x})".format(self.retval)
        info(m)
        return

    def stop(self):
        m = "Ignoring call to '{:s}' ".format(self.func)
        m += "(setting return value to {:#x})".format(self.retval)
        gdb.execute("return (unsigned int){:#x}".format(self.retval))
        ok(m)
        return False


class ChangePermissionBreakpoint(gdb.Breakpoint):
    """When hit, this temporary breakpoint will restore the original code, and position
    $pc correctly."""
    def __init__(self, loc, code, pc, regs):
        super().__init__(loc, gdb.BP_BREAKPOINT, internal=True, temporary=True)
        self.original_code = code
        self.original_pc = pc
        self.original_regs = regs
        return

    def stop(self):
        info("Restoring original context")
        write_memory(self.original_pc, self.original_code, len(self.original_code))
        info("Restoring registers")
        for k, v in self.original_regs.items():
            try:
                gdb.execute("set {:s} = {:#x}".format(k, v))
            except gdb.error:
                pass
        return True


class TraceMallocBreakpoint(gdb.Breakpoint):
    """Track allocations done with malloc() or calloc()."""
    def __init__(self, name):
        super().__init__(name, gdb.BP_BREAKPOINT, internal=True)
        self.silent = True
        self.name = name
        return

    def stop(self):
        # The first call to malloc calls malloc twice internally, like malloc-> malloc_hook_ini-> malloc.
        # You need to prevent the breakpoint from being set twice.
        if hasattr(self, "retbp"):
            # The retbp is `gdb.FinishBreakpoint`, not `gdb.Breakpoint`.
            # so it is deleted automatically if out of scope, so it must be checked by is_valid().
            if self.retbp.is_valid() and self.retbp.enabled:
                return False
        reset_gef_caches()
        _, size = current_arch.get_ith_parameter(0)
        self.retbp = TraceMallocRetBreakpoint(size, self.name)
        return False


class TraceMallocRetBreakpoint(gdb.FinishBreakpoint):
    """Internal temporary breakpoint to retrieve the return value of malloc()."""
    def __init__(self, size, name):
        super().__init__(gdb.newest_frame(), internal=True)
        self.size = size
        self.name = name
        self.silent = True
        return

    def stop(self):
        global __heap_uaf_watchpoints__, __heap_freed_list__, __heap_allocated_list__

        if self.return_value:
            loc = int(self.return_value)
        else:
            loc = parse_address(current_arch.return_register)

        size = self.size
        ok("{} - {}({})={:#x}".format(Color.colorify("Heap-Analysis", "bold yellow"), self.name, size, loc))
        check_heap_overlap = get_gef_setting("heap-analysis-helper.check_heap_overlap")

        # pop from free-ed list if it was in it
        if __heap_freed_list__:
            idx = 0
            for item in __heap_freed_list__:
                addr = item[0]
                if addr == loc:
                    __heap_freed_list__.remove(item)
                    continue
                idx += 1

        # pop from uaf watchlist
        if __heap_uaf_watchpoints__:
            idx = 0
            for wp in __heap_uaf_watchpoints__:
                wp_addr = wp.address
                if loc <= wp_addr < loc + size:
                    __heap_uaf_watchpoints__.remove(wp)
                    wp.enabled = False
                    continue
                idx += 1

        item = (loc, size)

        if check_heap_overlap:
            # seek all the currently allocated chunks, read their effective size and check for overlap
            msg = []
            align = get_memory_alignment()
            for chunk_addr, _ in __heap_allocated_list__:
                current_chunk = GlibcChunk(chunk_addr)
                current_chunk_size = current_chunk.get_chunk_size()

                if not (chunk_addr <= loc < chunk_addr + current_chunk_size):
                    continue
                offset = loc - chunk_addr - 2 * align
                if offset < 0:
                    continue # false positive, discard

                msg.append(Color.colorify("Heap-Analysis", "bold yellow"))
                msg.append("Possible heap overlap detected")
                fmt = "Reason {} new allocated chunk {:#x} (of size {:d}) overlaps in-used chunk {:#x} (of size {:#x})"
                msg.append(fmt.format(RIGHT_ARROW, loc, size, chunk_addr, current_chunk_size))
                msg.append("Writing {0:d} bytes from {1:#x} will reach chunk {2:#x}".format(offset, chunk_addr, loc))
                msg.append("Payload example for chunk {1:#x} (to overwrite {0:#x} headers):".format(loc, chunk_addr))
                msg.append("  data = 'A'*{0:d} + 'B'*{1:d} + 'C'*{1:d}".format(offset, align))
                push_context_message("warn", "\n".join(msg))
                return True

        # add it to alloc-ed list
        __heap_allocated_list__.append(item)
        return False


class TraceReallocBreakpoint(gdb.Breakpoint):
    """Track re-allocations done with realloc()."""
    def __init__(self):
        super().__init__("__libc_realloc", gdb.BP_BREAKPOINT, internal=True)
        self.silent = True
        return

    def stop(self):
        _, ptr = current_arch.get_ith_parameter(0)
        _, size = current_arch.get_ith_parameter(1)
        self.retbp = TraceReallocRetBreakpoint(ptr, size)
        return False


class TraceReallocRetBreakpoint(gdb.FinishBreakpoint):
    """Internal temporary breakpoint to retrieve the return value of realloc()."""
    def __init__(self, ptr, size):
        super().__init__(gdb.newest_frame(), internal=True)
        self.ptr = ptr
        self.size = size
        self.silent = True
        return

    def stop(self):
        global __heap_uaf_watchpoints__, __heap_freed_list__, __heap_allocated_list__

        if self.return_value:
            newloc = int(self.return_value)
        else:
            newloc = parse_address(current_arch.return_register)

        if newloc != self.ptr:
            msg = Color.redify("{:#x} (return another chunk)".format(newloc))
        else:
            msg = Color.greenify("{:#x} (return same chunk)".format(newloc))
        args = [
            Color.colorify("Heap-Analysis", "bold yellow"),
            self.ptr, self.size, msg,
        ]
        ok("{} - realloc({:#x}, {})={}".format(*args))

        item = (newloc, self.size)

        try:
            # check if item was in alloc-ed list
            idx = [x for x, y in __heap_allocated_list__].index(self.ptr)
            # if so pop it out
            item = __heap_allocated_list__.pop(idx)
        except ValueError:
            if is_debug():
                warn("Chunk {:#x} was not in tracking list".format(self.ptr))
        finally:
            # add new item to alloc-ed list
            __heap_allocated_list__.append(item)

        return False


class TraceFreeBreakpoint(gdb.Breakpoint):
    """Track calls to free() and attempts to detect inconsistencies."""
    def __init__(self):
        super().__init__("__libc_free", gdb.BP_BREAKPOINT, internal=True)
        self.silent = True
        return

    def stop(self):
        reset_gef_caches()
        _, addr = current_arch.get_ith_parameter(0)
        msg = []
        check_free_null = get_gef_setting("heap-analysis-helper.check_free_null")
        check_double_free = get_gef_setting("heap-analysis-helper.check_double_free")
        check_weird_free = get_gef_setting("heap-analysis-helper.check_weird_free")
        check_uaf = get_gef_setting("heap-analysis-helper.check_uaf")

        ok("{} - free({:#x})".format(Color.colorify("Heap-Analysis", "bold yellow"), addr))
        if addr == 0:
            if check_free_null:
                msg.append(Color.colorify("Heap-Analysis", "bold yellow"))
                msg.append("Attempting to free(NULL) at {:#x}".format(current_arch.pc))
                msg.append("Reason: if NULL page is allocatable, this can lead to code execution.")
                push_context_message("warn", "\n".join(msg))
                return True
            return False

        if addr in [x for (x, y) in __heap_freed_list__]:
            if check_double_free:
                msg.append(Color.colorify("Heap-Analysis", "bold yellow"))
                fmt = "Double-free detected {} free({:#x}) is called at {:#x} but is already in the free-ed list"
                msg.append(fmt.format(RIGHT_ARROW, addr, current_arch.pc))
                msg.append("Execution will likely crash...")
                push_context_message("warn", "\n".join(msg))
                return True
            return False

        # if here, no error
        # 1. move alloc-ed item to free list
        try:
            # pop from alloc-ed list
            idx = [x for x, y in __heap_allocated_list__].index(addr)
            item = __heap_allocated_list__.pop(idx)

        except ValueError:
            if check_weird_free:
                msg.append(Color.colorify("Heap-Analysis", "bold yellow"))
                msg.append("Heap inconsistency detected:")
                msg.append("Attempting to free an unknown value: {:#x}".format(addr))
                push_context_message("warn", "\n".join(msg))
                return True
            return False

        # 2. add it to free-ed list
        __heap_freed_list__.append(item)

        self.retbp = None
        if check_uaf:
            # 3. (opt.) add a watchpoint on pointer
            self.retbp = TraceFreeRetBreakpoint(addr)
        return False


class TraceFreeRetBreakpoint(gdb.FinishBreakpoint):
    """Internal temporary breakpoint to track free()d values."""
    def __init__(self, addr):
        super().__init__(gdb.newest_frame(), internal=True)
        self.silent = True
        self.addr = addr
        return

    def stop(self):
        reset_gef_caches()
        wp = UafWatchpoint(self.addr)
        __heap_uaf_watchpoints__.append(wp)
        return False


class UafWatchpoint(gdb.Breakpoint):
    """Custom watchpoints set TraceFreeBreakpoint() to monitor free()d pointers being used."""
    def __init__(self, addr):
        super().__init__("*{:#x}".format(addr), gdb.BP_WATCHPOINT, internal=True)
        self.address = addr
        self.silent = True
        self.enabled = True
        return

    def stop(self):
        """If this method is triggered, we likely have a UaF. Break the execution and report it."""
        reset_gef_caches()
        try:
            frame = gdb.selected_frame()
        except Exception:
            return False
        if frame.name() in ("_int_malloc", "malloc_consolidate", "__libc_calloc", ):
            return False

        # software watchpoints stop after the next statement (see
        # https://sourceware.org/gdb/onlinedocs/gdb/Set-Watchpoints.html)
        pc = gdb_get_nth_previous_instruction_address(current_arch.pc, 2)
        insn = gef_current_instruction(pc)
        msg = []
        msg.append(Color.colorify("Heap-Analysis", "bold yellow"))
        fmt = "Possible Use-after-Free in '{:s}': pointer {:#x} was freed, but is attempted to be used at {:#x}"
        msg.append(fmt.format(get_filepath(), self.address, pc))
        fmt = "{:#x}   {:s} {:s}"
        msg.append(fmt.format(insn.address, insn.mnemonic, Color.yellowify(", ".join(insn.operands))))
        push_context_message("warn", "\n".join(msg))
        return True


class EntryBreakBreakpoint(gdb.Breakpoint):
    """Breakpoint used internally to stop execution at the most convenient entry point."""
    def __init__(self, location):
        super().__init__(location, gdb.BP_BREAKPOINT, internal=True, temporary=True)
        self.silent = True
        return

    def stop(self):
        reset_gef_caches()
        return True


class NamedBreakpoint(gdb.Breakpoint):
    """Breakpoint which shows a specified name, when hit."""
    def __init__(self, location, name):
        super().__init__(location, gdb.BP_BREAKPOINT, internal=False, temporary=False)
        self.name = name
        self.loc = location

        return

    def stop(self):
        reset_gef_caches()
        msg = "Hit breakpoint {} ({})".format(self.loc, Color.colorify(self.name, "bold red"))
        push_context_message("info", msg)
        return True


class SecondBreakpoint(gdb.Breakpoint):
    """Breakpoint which sets a 2nd breakpoint, when hit."""
    def __init__(self, loc, second_loc):
        self.second_loc = second_loc
        super().__init__("*{:#x}".format(loc), gdb.BP_BREAKPOINT, internal=True, temporary=True)
        return

    def stop(self):
        reset_gef_caches()
        gdb.Breakpoint("*{:#x}".format(self.second_loc), gdb.BP_BREAKPOINT, internal=True, temporary=True)
        return True


#
# Commands
#

def register_external_command(obj):
    """Registering function for new GEF (sub-)command to GDB."""
    global __commands__, __gef__
    cls = obj.__class__
    __commands__.append(cls)
    __gef__.load(initial=False)
    __gef__.doc.add_command_to_doc((cls._cmdline_, cls, None))
    __gef__.doc.refresh()
    return cls


def register_command(cls):
    """Decorator for registering new GEF (sub-)command to GDB."""
    global __commands__
    __commands__.append(cls)
    return cls


def register_priority_command(cls):
    """Decorator for registering new command with priority, meaning that it must
    loaded before the other generic commands."""
    global __commands__
    __commands__.insert(0, cls)
    return cls


def register_function(cls):
    """Decorator for registering a new convenience function to GDB."""
    global __functions__
    __functions__.append(cls)
    return cls


class GenericCommand(gdb.Command):
    """This is an abstract class for invoking commands, should not be instantiated."""
    __metaclass__ = abc.ABCMeta

    def __init__(self, *args, **kwargs):
        self.pre_load()

        self.__doc__ = self.__doc__.replace(" " * 4, "")
        if self._syntax_:
            syntax = Color.colorify("\nSyntax:\n", "bold yellow") + self._syntax_.strip()
            self.__doc__ += syntax + "\n"

        if self._example_:
            example = Color.colorify("\nExample:\n", "bold yellow") + self._example_.strip()
            self.__doc__ += example + "\n"

        if hasattr(self, "_aliases_"):
            aliases = Color.colorify("\nAliases:\n", "bold yellow") + str(self._aliases_)
            self.__doc__ += aliases + "\n"

        self.repeat = False
        self.repeat_count = 0
        self.__last_command = None
        command_type = kwargs.get("command", gdb.COMMAND_OBSCURE)
        complete_type = kwargs.get("complete", gdb.COMPLETE_NONE)
        prefix = kwargs.get("prefix", False)
        super().__init__(self._cmdline_, command_type, complete_type, prefix)
        self.post_load()
        return

    def invoke(self, args, from_tty):
        try:
            argv = gdb.string_to_argv(args)
            self.__set_repeat_count(argv, from_tty)
            self.do_invoke(argv)
        except Exception as e:
            # Note: since we are intercepting cleaning exceptions here, commands preferably should avoid
            # catching generic Exception, but rather specific ones. This is allows a much cleaner use.
            if is_debug():
                show_last_exception()
            else:
                err("Command '{:s}' failed to execute properly, reason: {:s}".format(self._cmdline_, str(e)))
        return

    def usage(self, omit_syntax=False):
        if omit_syntax is False:
            gef_print("Syntax:\n{}".format(self._syntax_.strip()))
        else:
            gef_print("") # argparse don't print newline

        if self._example_:
            gef_print("Example:\n{}".format(self._example_.strip()))
        return

    @abc.abstractproperty
    def _cmdline_(self):
        pass

    @abc.abstractproperty
    def _syntax_(self):
        pass

    @abc.abstractproperty
    def _example_(self):
        return ""

    @abc.abstractmethod
    def do_invoke(self, argv):
        pass

    def pre_load(self):
        pass

    def post_load(self):
        pass

    def __get_setting_name(self, name):
        def __sanitize_class_name(clsname):
            if " " not in clsname:
                return clsname
            return "-".join(clsname.split())

        class_name = __sanitize_class_name(self.__class__._cmdline_)
        return "{:s}.{:s}".format(class_name, name)

    @property
    def settings(self):
        """Return the list of settings for this command."""
        return [x.split(".", 1)[1] for x in __config__ if x.startswith("{:s}.".format(self._cmdline_))]

    def get_setting(self, name):
        key = self.__get_setting_name(name)
        setting = __config__[key]
        return setting[1](setting[0])

    def has_setting(self, name):
        key = self.__get_setting_name(name)
        return key in __config__

    def add_setting(self, name, value, description=""):
        # make sure settings are always associated to the root command (which derives from GenericCommand)
        if "GenericCommand" not in [x.__name__ for x in self.__class__.__bases__]:
            return
        key = self.__get_setting_name(name)
        __config__[key] = [value, type(value), description]
        get_gef_setting.cache_clear()
        return

    def del_setting(self, name):
        key = self.__get_setting_name(name)
        del __config__[key]
        get_gef_setting.cache_clear()
        return

    def __set_repeat_count(self, argv, from_tty):
        if not from_tty:
            self.repeat = False
            self.repeat_count = 0
            return

        command = gdb.execute("show commands", to_string=True).strip().split("\n")[-1]
        self.repeat = self.__last_command == command
        self.repeat_count = self.repeat_count + 1 if self.repeat else 0
        self.__last_command = command
        return


# Copy/paste this template for new command
# @register_command
# class TemplateCommand(GenericCommand):
#     """TemplateCommand: description here will be seen in the help menu for the command."""
#     _cmdline_ = "template-fake"
#     _category_ = "Misc"
#     _aliases_ = ["tpl-fk"]
#
#    parser = argparse.ArgumentParser(prog=_cmdline_)
#    _syntax_ = parser.format_help()
#
#     _example_ = "{:s}".format(_cmdline_)
#
#     def __init__(self):
#         super().__init__(complete=gdb.COMPLETE_FILENAME)
#         return
#
#     @parse_args
#     def do_invoke(self, args):
#         self.dont_repeat()
#         return


@register_command
class ResetCacheCommand(GenericCommand):
    """Reset cache of all stored data for debugging and test purposes."""
    _cmdline_ = "reset-cache"
    _category_ = "99. GEF Maintenance Command"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    def do_invoke(self, argv):
        self.dont_repeat()
        reset_gef_caches(all=True)
        return


@register_priority_command
class GefThemeCommand(GenericCommand):
    """Customize GEF appearance."""
    _cmdline_ = "theme"
    _category_ = "99. GEF Maintenance Command"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('key', metavar='KEY', nargs='?', help='color theme key. (default: %(default)s)')
    parser.add_argument('value', metavar='VALUE', nargs='*', help='color theme value. (default: %(default)s)')
    _syntax_ = parser.format_help()

    _example_ = "{:s}                        # show all theme settings\n".format(_cmdline_)
    _example_ += "{:s} address_code           # show specified theme setting\n".format(_cmdline_)
    _example_ += "{:s} address_code bold cyan # set new theme".format(_cmdline_)

    def __init__(self, *args, **kwargs):
        super().__init__()
        self.add_setting("context_title_line", "gray", "Color of the borders in context window")
        self.add_setting("context_title_message", "cyan", "Color of the title in context window")
        self.add_setting("default_title_line", "gray", "Default color of borders")
        self.add_setting("default_title_message", "cyan", "Default color of title")
        self.add_setting("table_heading", "bold blue", "Color of the column headings to tables (e.g. vmmap)")
        self.add_setting("old_context", "gray", "Color to use to show things such as code that is not immediately relevant")
        self.add_setting("disassemble_current_instruction", "green", "Color to use to highlight the current $pc when disassembling")
        self.add_setting("dereference_string", "yellow", "Color of dereferenced string")
        self.add_setting("dereference_code", "gray", "Color of dereferenced code")
        self.add_setting("dereference_base_address", "cyan", "Color of dereferenced address")
        self.add_setting("dereference_register_value", "bold blue", "Color of dereferenced register")
        self.add_setting("registers_register_name", "blue", "Color of the register name in the register window")
        self.add_setting("registers_value_changed", "bold red", "Color of the changed register in the register window")
        self.add_setting("address_stack", "pink", "Color to use when a stack address is found")
        self.add_setting("address_heap", "green", "Color to use when a heap address is found")
        self.add_setting("address_code", "red", "Color to use when a code address is found")
        self.add_setting("source_current_line", "green", "Color to use for the current code line in the source window")
        return

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()

        if args.key is None:
            for setting in sorted(self.settings):
                value = self.get_setting(setting)
                value = Color.colorify(value, value)
                gef_print("{:40s}: {:s}".format(setting, value))
            return

        if not self.has_setting(args.key):
            err("Invalid key")
            return

        if args.value == []:
            value = self.get_setting(args.key)
            value = Color.colorify(value, value)
            gef_print("{:40s}: {:s}".format(args.key, value))
            return

        val = [x for x in args.value if x in Color.colors]
        self.add_setting(args.key, " ".join(val))
        return


@register_command
class VersionCommand(GenericCommand):
    """Display GEF version info."""
    _cmdline_ = "version"
    _category_ = "99. GEF Maintenance Command"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    def gef_version(self):
        gef_fpath = os.path.abspath(os.path.realpath(os.path.expanduser(inspect.stack()[0][1])))
        gef_dir = os.path.dirname(gef_fpath)
        gef_hash = hashlib.sha1(open(gef_fpath, "rb").read()).hexdigest()

        if os.access("{}/.git".format(gef_dir), os.X_OK):
            ver = subprocess.check_output('git log --format="%H" -n 1 HEAD', cwd=gef_dir, shell=True).decode("utf8").strip()
            extra = "dirty" if len(subprocess.check_output('git ls-files -m', cwd=gef_dir, shell=True).decode("utf8").strip()) else "clean"
            return "rev:{} (Git - {}) SHA1: {}".format(ver, extra, gef_hash)
        else:
            return "(Standalone) SHA1:{}".format(gef_hash)

    def gdb_version(self):
        try:
            return gdb.VERSION # GDB >= 8.1 (or earlier?)
        except AttributeError:
            return gdb.execute('show version', to_string=True).split('\n')[0]

    def python_version(self):
        return sys.version.replace('\n', ' ')

    @load_capstone
    def capstone_version(self):
        try:
            capstone = sys.modules['capstone']
            return '.'.join(map(str, capstone.cs_version()))
        except KeyError:
            return 'not found'

    @load_keystone
    def keystone_version(self):
        try:
            keystone = sys.modules['keystone']
            return '.'.join(map(str, keystone.ks_version()))
        except KeyError:
            return 'not found'

    @load_unicorn
    def unicorn_version(self):
        try:
            unicorn = sys.modules['unicorn']
            return unicorn.__version__
        except KeyError:
            return 'not found'

    @load_ropper
    def ropper_version(self):
        try:
            ropper = sys.modules['ropper']
            return '.'.join(map(str, ropper.VERSION))
        except KeyError:
            return 'not found'

    def readelf_version(self):
        try:
            command = which("readelf")
            res = gef_execute_external([command, "-v"], as_list=True)
            return res[0]
        except IOError:
            return 'not found'

    def objdump_version(self):
        try:
            command = which("objdump")
            res = gef_execute_external([command, "-v"], as_list=True)
            return res[0]
        except IOError:
            return 'not found'

    def seccomp_tools_version(self):
        try:
            command = which("seccomp-tools")
            res = gef_execute_external([command, "--version"], as_list=True)
            return res[0]
        except IOError:
            return 'not found'

    def one_gadget_version(self):
        try:
            command = which("one_gadget")
            res = gef_execute_external([command, "--version"], as_list=True)
            return res[0]
        except IOError:
            return 'not found'

    def rp_version(self):
        try:
            command = which("rp-lin-x64")
        except IOError:
            try:
                command = which("rp-lin-x86")
            except IOError:
                return 'not found'
        try:
            res = gef_execute_external([command, "--version"], as_list=True)
            return res[0]
        except IOError:
            return 'not found'

    def qemu_version(self):
        return gdb.execute('monitor info version', to_string=True).strip()

    def kernel_version(self):
        try:
            command = which("uname")
            res = gef_execute_external([command, "-a"], as_list=True)
            return res[0]
        except IOError:
            return 'not found'

    def os_version(self):
        try:
            command = which("lsb_release")
            res = gef_execute_external([command, "-d"], as_list=True)
            for line in res:
                if line.startswith("Description:"):
                    return line.split(":")[1].strip("\\t")
        except IOError:
            return 'not found'

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()

        gef_print(titlify("versions"))
        gef_print("OS:            \t{:s}".format(self.os_version()))
        gef_print("Kernel:        \t{:s}".format(self.kernel_version()))
        gef_print("GEF:           \t{:s}".format(self.gef_version()))
        gef_print("Gdb:           \t{:s}".format(self.gdb_version()))
        gef_print("Python:        \t{:s}".format(self.python_version()))
        gef_print("Capstone:      \t{:s}".format(self.capstone_version()))
        gef_print("Keystone:      \t{:s}".format(self.keystone_version()))
        gef_print("Unicorn:       \t{:s}".format(self.unicorn_version()))
        gef_print("Ropper:        \t{:s}".format(self.ropper_version()))
        gef_print("readelf:       \t{:s}".format(self.readelf_version()))
        gef_print("objdump:       \t{:s}".format(self.objdump_version()))
        gef_print("seccomp-tools: \t{:s}".format(self.seccomp_tools_version()))
        gef_print("one_gadget:    \t{:s}".format(self.one_gadget_version()))
        gef_print("rp:            \t{:s}".format(self.rp_version()))

        if is_qemu_system():
            gef_print("qemu:          \t{:s}".format(self.qemu_version()))

        gef_print(titlify("gdb build config"))
        gdb.execute("show configuration")
        return


@register_command
class HighlightCommand(GenericCommand):
    """This command highlights user defined text matches which modifies GEF output universally."""
    _cmdline_ = "highlight"
    _category_ = "01-f. Debugging Support - Context Extension"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    subparsers = parser.add_subparsers(title='command', required=True)
    subparsers.add_parser('add')
    subparsers.add_parser('remove')
    subparsers.add_parser('list')
    subparsers.add_parser('clear')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(prefix=True)
        self.add_setting("regex", False, "Enable regex highlighting")
        return

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()
        return


@register_command
class HighlightListCommand(GenericCommand):
    """Show the current highlight table with matches to colors."""
    _cmdline_ = "highlight list"
    _category_ = "01-f. Debugging Support - Context Extension"
    _aliases_ = ["highlight ls"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    def print_highlight_table(self):
        if not highlight_table:
            err("no matches found")
            return

        left_pad = max(map(len, highlight_table.keys()))
        for match, color in sorted(highlight_table.items()):
            gef_print("{} {} {}".format(Color.colorify(match.ljust(left_pad), color), VERTICAL_LINE, Color.colorify(color, color)))
        return

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()
        self.print_highlight_table()
        return


@register_command
class HighlightClearCommand(GenericCommand):
    """Clear the highlight table, remove all matches."""
    _cmdline_ = "highlight clear"
    _category_ = "01-f. Debugging Support - Context Extension"
    _aliases_ = ["highlight reset"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()
        highlight_table.clear()
        return


@register_command
class HighlightAddCommand(GenericCommand):
    """Add a match to the highlight table."""
    _cmdline_ = "highlight add"
    _category_ = "01-f. Debugging Support - Context Extension"
    _aliases_ = ["highlight set"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('match', metavar='MATCH', help='the keyword phrase you want to highlight.')
    parser.add_argument('color', metavar='COLOR', nargs='+', help='the color you want use to highlight.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} \"call   rcx\" bold yellow\n".format(_cmdline_)
    _example_ += "use config `gef config highlight.regex true` if need regex"

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()
        highlight_table[args.match] = ' '.join(args.color)
        return


@register_command
class HighlightRemoveCommand(GenericCommand):
    """Remove a match in the highlight table."""
    _cmdline_ = "highlight remove"
    _category_ = "01-f. Debugging Support - Context Extension"
    _aliases_ = ["highlight del", "highlight unset", "highlight rm"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('match', metavar='MATCH', help='the keyword phrase you want to remove from highlight.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} \"call   rcx\"".format(_cmdline_)

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()
        highlight_table.pop(args.match, None)
        return


@register_command
class NiCommand(GenericCommand):
    """`ni` wrapper for specific arch.
    s390x: it sometimes returns `PC not saved` when nexti command is executed.
    or1k: branch operations don't work well, so use breakpoints to simulate.
    cris: si/ni commands don't work well. so use breakpoints to simulate."""
    _cmdline_ = "ni"
    _category_ = "01-c. Debugging Support - Basic Command Extension"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('args', metavar='ARGS', nargs='*',
                        help='An array of arguments to pass as is to the nexti command. (default: %(default)s)')
    _syntax_ = parser.format_help()

    def ni_set_bp_for_branch(self):
        target = None
        delay_slot = False

        try:
            frame = gdb.selected_frame()
        except gdb.error:
            # For unknown reasons, gdb.selected_frame() may cause an error (often occurs during kernel startup).
            frame = None

        insn = get_insn()
        insn_next = get_insn_next()

        if insn and current_arch.is_jump(insn):
            target = ContextCommand.get_branch_addr(insn)
            delay_slot = current_arch.has_delay_slot
        elif insn and current_arch.is_ret(insn):
            target = current_arch.get_ra(insn, frame)
            delay_slot = current_arch.has_ret_delay_slot

        if target is None:
            return

        # something wrong if infinity loop under cris architecture
        if is_cris() and target == insn.address:
            SecondBreakpoint(loc=insn_next.address, second_loc=target)
            return

        gdb.Breakpoint("*{:#x}".format(target), gdb.BP_BREAKPOINT, internal=True, temporary=True)
        if delay_slot:
            gdb.Breakpoint("*{:#x}".format(insn_next.address), gdb.BP_BREAKPOINT, internal=True, temporary=True)
        return

    def ni_set_bp_next(self):
        insn_next = get_insn_next()
        gdb.Breakpoint("*{:#x}".format(insn_next.address), gdb.BP_BREAKPOINT, internal=True, temporary=True)
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        if is_cris():
            self.ni_set_bp_for_branch()
            self.ni_set_bp_next()
            gdb.execute("c") # use c wrapper
            return

        if is_or1k():
            self.ni_set_bp_for_branch()

        cmd = "nexti " + ' '.join(args.args)
        try:
            gdb.execute(cmd.rstrip())
        except gdb.error:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            if str(exc_value) == "PC not saved":
                gdb.execute("context")
            else:
                err(exc_value)
        return


@register_command
class SiCommand(GenericCommand):
    """`si` wrapper for specific arch.
    s390x: it sometimes returns `PC not saved` when stepi command is executed.
    or1k: branch operations don't work well, so use breakpoints to simulate.
    cris: si/ni commands don't work well. so use breakpoints to simulate."""
    _cmdline_ = "si"
    _category_ = "01-c. Debugging Support - Basic Command Extension"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('args', metavar='ARGS', nargs='*',
                        help='An array of arguments to pass as is to the stepi command. (default: %(default)s)')
    _syntax_ = parser.format_help()

    def si_set_bp_for_branch(self):
        target = None
        delay_slot = False

        try:
            frame = gdb.selected_frame()
        except gdb.error:
            # For unknown reasons, gdb.selected_frame() may cause an error (often occurs during kernel startup).
            frame = None

        insn = get_insn()
        insn_next = get_insn_next()

        if insn and current_arch.is_jump(insn) or current_arch.is_call(insn): # si also stops at `call` target
            target = ContextCommand.get_branch_addr(insn)
            delay_slot = current_arch.has_delay_slot
        elif insn and current_arch.is_ret(insn):
            target = current_arch.get_ra(insn, frame)
            delay_slot = current_arch.has_ret_delay_slot

        if target is None:
            return

        # something wrong if infinity loop under cris architecture
        if is_cris() and target == insn.address:
            SecondBreakpoint(loc=insn_next.address, second_loc=target)
            return

        gdb.Breakpoint("*{:#x}".format(target), gdb.BP_BREAKPOINT, internal=True, temporary=True)
        if delay_slot:
            gdb.Breakpoint("*{:#x}".format(insn_next.address), gdb.BP_BREAKPOINT, internal=True, temporary=True)
        return

    def si_set_bp_next(self):
        insn_next = get_insn_next()
        gdb.Breakpoint("*{:#x}".format(insn_next.address), gdb.BP_BREAKPOINT, internal=True, temporary=True)
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        if is_cris():
            self.si_set_bp_for_branch()
            self.si_set_bp_next()
            gdb.execute("c") # use c wrapper
            return

        if is_or1k():
            self.si_set_bp_for_branch()

        cmd = "stepi " + ' '.join(args.args)
        try:
            gdb.execute(cmd.rstrip())
        except gdb.error:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            if str(exc_value) == "PC not saved":
                gdb.execute("context")
            else:
                err(exc_value)
        return


@register_command
class ContCommand(GenericCommand):
    """`c` wraper to solve the problem that Ctrl+C cannot interrupt when using qemu-user gdb stub."""
    _cmdline_ = "c"
    _category_ = "01-c. Debugging Support - Basic Command Extension"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('args', metavar='ARGS', nargs='*',
                        help='An array of arguments to pass as is to the continue command. (default: %(default)s)')
    _syntax_ = parser.format_help()

    def continue_for_qemu(self):
        import threading
        import signal
        thread_started = False
        thread_finished = False

        def continue_thread():
            nonlocal thread_started, thread_finished
            thread_started = True
            try:
                gdb.execute("continue")
            except gdb.error:
                exc_type, exc_value, exc_traceback = sys.exc_info()
                err(exc_value)
            thread_finished = True
            return

        def sig_handler(signum, frame):
            os.kill(get_pid(), signal.SIGINT)
            return

        th = threading.Thread(target=continue_thread, daemon=True)
        th.start()
        while thread_started is False:
            time.sleep(0.1)
        old = signal.signal(signal.SIGINT, sig_handler)
        while thread_finished is False:
            time.sleep(0.1)
        th.join()
        signal.signal(signal.SIGINT, old)
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        if is_qemu_usermode() and get_pid():
            self.continue_for_qemu()
        else:
            try:
                cmd = "continue " + ' '.join(args.args)
                gdb.execute(cmd.rstrip())
            except gdb.error:
                exc_type, exc_value, exc_traceback = sys.exc_info()
                err(exc_value)
        return


@register_command
class PrintFormatCommand(GenericCommand):
    """Print bytes format in high level languages."""
    _cmdline_ = "print-format"
    _category_ = "09-c. Misc - Generation"
    _aliases_ = ["pf"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-f', dest='format', default='py', choices=['py', 'c', 'js', 'asm', 'hex'],
                        help='the output format. (default: %(default)s)')
    parser.add_argument('-b', dest='bitlen', type=int, default=8, choices=[8, 16, 32, 64],
                        help='the size of bit. (default: %(default)s)')
    parser.add_argument('-l', dest='length', type=parse_address, default=256, help='the length of array. (default: %(default)s)')
    parser.add_argument('-c', dest='copy_to_clipboard', action='store_true', help='the result of data will copied to clipboard.')
    parser.add_argument('location', metavar='LOCATION', type=parse_address, help='the address of data you want to dump.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} -f py -b 8 -l 256 $rsp".format(_cmdline_)

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def clip(self, data):
        if sys.platform == "linux":
            try:
                xclip = which("xclip")
            except FileNotFoundError as e:
                err("{}".format(e))
                return False
            prog = [xclip, "-selection", "clipboard", "-i"] # For linux

        elif sys.platform == "darwin":
            try:
                pbcopy = which("pbcopy")
            except FileNotFoundError as e:
                err("{}".format(e))
                return False
            prog = [pbcopy] # For OSX

        else:
            warn("Can't copy to clipboard, platform not supported")
            return False

        try:
            p = subprocess.Popen(prog, stdin=subprocess.PIPE)
        except Exception:
            warn("Can't copy to clipboard, Something went wrong while copying")
            return False

        p.stdin.write(data)
        p.stdin.close()
        p.wait()
        return True

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        """Default value for print-format command."""
        self.dont_repeat()

        bitformat = {8: "<B", 16: "<H", 32: "<I", 64: "<Q"}
        c_type = {8: "char", 16: "short", 32: "int", 64: "long long"}
        asm_type = {8: "db", 16: "dw", 32: "dd", 64: "dq"}

        if args.format == "hex" and args.bitlen != 8:
            err("hex must be bit == 8")
            return

        unit_size = args.bitlen // 8
        start_addr = args.location
        end_addr = start_addr + args.length * unit_size
        bf = bitformat[args.bitlen]

        # extract memory
        data = []
        for address in range(start_addr, end_addr, unit_size):
            try:
                mem = read_memory(address, unit_size)
            except gdb.MemoryError:
                err("Memory read error")
                return None
            value = struct.unpack(bf, mem)[0]
            data.append(value)

        # parse data
        sdata = ""
        if args.format == "hex":
            for i, x in enumerate(data):
                sdata += "{:02x}".format(x)
                if (i % 16) == 15:
                    sdata += "\n"
        else:
            for i, x in enumerate(data):
                if (i % 8) == 0:
                    sdata += "    "
                sdata += "{:#0{}x}, ".format(x, args.bitlen // 4 + 2)
                if (i % 8) == 7:
                    sdata += "\n"
        sdata = sdata.rstrip()

        # make format
        if args.format == "py":
            out = "buf = [\n{:s}\n]".format(sdata)
        elif args.format == "c":
            out = "unsigned {:s} buf[{:d}] = {{\n{:s}\n}};".format(c_type[args.bitlen], args.length, sdata)
        elif args.format == "js":
            out = "var buf = [\n{:s}\n];".format(sdata)
        elif args.format == "asm":
            out = "buf {:s}\n{:s}".format(asm_type[args.bitlen], sdata)
        elif args.format == "hex":
            out = sdata

        if args.copy_to_clipboard:
            if self.clip(bytes(out, "utf-8")):
                info("Copied to clipboard")
            else:
                warn("There's a problem while copying")

        gef_print(out)
        return


@register_command
class CanaryCommand(GenericCommand):
    """Show the canary value of the current process from auxv information."""
    _cmdline_ = "canary"
    _category_ = "02-f. Process Information - Security"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()
        self.dump_canary()
        return

    def dump_canary(self):
        res = gef_read_canary()
        if not res:
            err("Failed to get the canary")
            return

        canary, location = res
        gef_print(titlify("canary value"))
        info("Found AT_RANDOM at {:#x}, reading {} bytes".format(location, current_arch.ptrsize))
        info("The canary is {:s}".format(Color.boldify("{:#x}".format(canary))))

        gef_print(titlify("found canary"))
        vmmap = get_process_maps()
        unpack = u32 if current_arch.ptrsize == 4 else u64
        sp = current_arch.sp
        for m in vmmap:
            if not (m.permission & Permission.READ) or not (m.permission & Permission.WRITE):
                continue
            if m.path == "[vvar]":
                continue
            try:
                data = read_memory(m.page_start, m.page_end - m.page_start)
            except gdb.MemoryError:
                continue
            prev_addr = -1
            for pos in range(0, m.page_end - m.page_start, current_arch.ptrsize):
                addr = m.page_start + pos
                d = data[pos: pos + current_arch.ptrsize]
                if canary != unpack(d):
                    continue
                if m.path == "":
                    path = "unknown"
                else:
                    path = m.path
                if prev_addr <= sp <= addr:
                    info("(Stack pointer is at {:#x})".format(sp))
                info("Found at {:#x} in {:s}".format(addr, repr(path)))
                prev_addr = addr
        return


@register_command
class AuxvCommand(GenericCommand):
    """Show ELF auxiliary vectors."""
    _cmdline_ = "auxv"
    _category_ = "02-d. Process Information - Trivial Information"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        auxval = gef_get_auxiliary_values()
        if not auxval:
            return None

        gef_print(titlify("ELF auxiliary vector"))
        for k, v in auxval.items():
            for num, name in AT_CONSTANTS.items():
                if k == name:
                    break
            else:
                num = -1
            if k == "AT_NULL":
                gef_print("[{:#4x}] {:16s} {:#x} (End of vector)".format(num, k + ":", v))
            elif k in ["AT_EXECFN", "AT_PLATFORM"]:
                s = read_cstring_from_memory(v)
                gef_print("[{:#4x}] {:16s} {:#x}{:s}{}".format(num, k + ":", v, RIGHT_ARROW, Color.yellowify(repr(s))))
            elif k in ["AT_RANDOM"]:
                s = read_int_from_memory(v)
                gef_print("[{:#4x}] {:16s} {:#x}{:s}{:#x}".format(num, k + ":", v, RIGHT_ARROW, s))
            else:
                gef_print("[{:#4x}] {:16s} {:#x}".format(num, k + ":", v))
        return


@register_command
class ArgvCommand(GenericCommand):
    """Show argv."""
    _cmdline_ = "argv"
    _category_ = "02-d. Process Information - Trivial Information"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-v', dest='verbose', action='store_true', help='print all elements. (default: outputs up to 100).')
    _syntax_ = parser.format_help()

    def get_address_from_symbol(self, symbol):
        try:
            return parse_address(symbol)
        except Exception:
            return None

    def print_from_mem(self, array, verbose):
        i = 0
        while True:
            pos = array + i * current_arch.ptrsize
            addr = read_int_from_memory(pos)
            if addr == 0:
                break
            if not verbose and i > 99:
                gef_print("...")
                break
            s = read_cstring_from_memory(addr, gef_getpagesize())
            s = Color.yellowify(repr(s))
            gef_print("[{:3d}]: {:#x}: {:#x}{:s}{:s}".format(i, pos, addr, RIGHT_ARROW, s))
            i += 1
        return

    def print_from_proc(self, filename, verbose):
        lines = open(filename).read()
        for i, elem in enumerate(lines.split("\0")):
            if not elem:
                break
            if not verbose and i > 99:
                gef_print("...")
                break
            gef_print("[{:3d}]: {:s}".format(i, repr(elem)))
        return

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        paddr1 = self.get_address_from_symbol("&_dl_argv")
        addr1 = self.get_address_from_symbol("_dl_argv")
        if paddr1 and addr1:
            gef_print(titlify("ARGV from _dl_argv"))
            info("_dl_argv @ {:#x}".format(paddr1))
            self.print_from_mem(addr1, args.verbose)

        paddr2 = self.get_address_from_symbol("&__libc_argv")
        addr2 = self.get_address_from_symbol("__libc_argv")
        if paddr2 and addr2:
            gef_print(titlify("ARGV from __libc_argv"))
            info("__libc_argv @ {:#x}".format(paddr2))
            self.print_from_mem(addr2, args.verbose)

        if not is_remote_debug():
            gef_print(titlify("ARGV from /proc/{:d}/cmdline".format(get_pid())))
            self.print_from_proc("/proc/{:d}/cmdline".format(get_pid()), args.verbose)
        else:
            if not (paddr1 or paddr2):
                err("Not found argv")
        return


@register_command
class EnvpCommand(GenericCommand):
    """Show initial envp from __environ@ld, or modified envp from last_environ@libc."""
    _cmdline_ = "envp"
    _category_ = "02-d. Process Information - Trivial Information"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-v', dest='verbose', action='store_true', help='print all elements. (default: outputs up to 100).')
    _syntax_ = parser.format_help()

    def get_address_from_symbol(self, symbol):
        try:
            return parse_address(symbol)
        except Exception:
            return None

    def print_from_mem(self, array, verbose):
        i = 0
        while True:
            pos = array + i * current_arch.ptrsize
            addr = read_int_from_memory(pos)
            if addr == 0:
                break
            if not verbose and i > 99:
                gef_print("...")
                break
            s = read_cstring_from_memory(addr, gef_getpagesize())
            s = Color.yellowify(repr(s))
            gef_print("[{:3d}]: {:#x}: {:#x}{:s}{:s}".format(i, pos, addr, RIGHT_ARROW, s))
            i += 1
        return

    def print_from_proc(self, filename, verbose):
        lines = open(filename).read()
        for i, elem in enumerate(lines.split("\0")):
            if not elem:
                break
            if not verbose and i > 99:
                gef_print("...")
                break
            gef_print("[{:3d}]: {:s}".format(i, repr(elem)))
        return

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        gef_print(titlify("ENVP from __environ"))
        paddr = self.get_address_from_symbol("&__environ")
        addr = self.get_address_from_symbol("__environ")
        if paddr and addr:
            info("__environ @ {:#x}".format(paddr))
            self.print_from_mem(addr, args.verbose)
        elif addr == 0:
            err("___environ is 0x0")
        else:
            err("Not found __environ")

        gef_print(titlify("ENVP from last_environ (for putenv, etc.)"))
        paddr = self.get_address_from_symbol("&last_environ")
        addr = self.get_address_from_symbol("last_environ")
        if paddr and addr:
            info("last_environ @ {:#x}".format(paddr))
            self.print_from_mem(addr, args.verbose)
        elif addr == 0:
            err("last_environ is 0x0")
        else:
            err("Not found last_environ")

        if not is_remote_debug():
            gef_print(titlify("ENVP from /proc/{:d}/environ".format(get_pid())))
            self.print_from_proc("/proc/{:d}/environ".format(get_pid()), args.verbose)
        return


@register_command
class PidCommand(GenericCommand):
    """Show the local PID or remote PID."""
    _cmdline_ = "pid"
    _category_ = "02-d. Process Information - Trivial Information"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        pid = get_pid()
        if pid:
            if is_qemu_usermode() or is_qemu_system():
                gef_print("Local qemu PID: {:d}".format(pid))
            else:
                gef_print("Local PID: {:d}".format(pid))
            return

        if is_remote_debug():
            pid = get_pid(remote=True)
            if pid:
                gef_print("Remote PID: {:d}".format(pid))
                return

        err("Failed to get pid")
        return


@register_command
class FilenameCommand(GenericCommand):
    """Show current debugged filename."""
    _cmdline_ = "filename"
    _category_ = "02-d. Process Information - Trivial Information"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        filepath = get_filepath()
        if filepath:
            gef_print(repr(filepath))
            return

        elif is_remote_debug():
            filepath = gdb.current_progspace().filename
            if filepath and filepath.startswith("target:"):
                filepath = filepath[7:]
            if filepath:
                gef_print(repr(filepath))
                return

        err("Failed to get filename")
        return


@register_command
class ProcInfoCommand(GenericCommand):
    """Extends the info given by GDB `info proc`."""
    _cmdline_ = "procinfo"
    _category_ = "02-a. Process Information - General"
    _aliases_ = ["pr"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()
        self.show_info_proc()
        self.show_info_proc_extra()
        self.show_parent()
        self.show_childs()
        self.show_info_thread()
        self.show_info_proc_ns()
        self.show_fds()
        self.show_connections()
        return

    def get_state_of(self, pid):
        try:
            status = open("/proc/{}/status".format(pid), "r").read()
        except Exception:
            return {}
        res = {}
        for line in status.splitlines():
            key, value = line.split(":", 1)
            res[key.strip()] = value.strip()
        return res

    def get_stat_of(self, pid):
        try:
            stat = open("/proc/{}/stat".format(pid), "r").read()
        except Exception:
            return []
        name = re.search(r"\((.+)\)", stat)
        other = re.sub(r"\(.+\) ", "", stat).split()
        res = [int(other[0]), name, other[1]] + [int(x) for x in other[2:]]
        return res

    def get_cmdline_of(self, pid):
        try:
            cmdline = open("/proc/{}/cmdline".format(pid), "r").read()
        except Exception:
            return ""
        return cmdline.replace("\x00", "\x20").strip()

    def get_process_path_of(self, pid):
        try:
            return os.readlink("/proc/{}/exe".format(pid))
        except Exception:
            return "Not Found"

    def get_process_cwd(self, pid):
        try:
            return os.readlink("/proc/{}/cwd".format(pid))
        except Exception:
            return "Not Found"

    def get_process_root(self, pid):
        try:
            return os.readlink("/proc/{}/root".format(pid))
        except Exception:
            return "Not Found"

    def get_thread_ids(self, pid):
        try:
            tids = os.listdir("/proc/{}/task".format(pid))
            return [int(x) for x in tids]
        except Exception:
            return []

    def get_children_pids(self, pid):
        try:
            ps = which("ps")
        except FileNotFoundError as e:
            err("{}".format(e))
            return []

        cmd = [ps, "-o", "pid", "--ppid", "{}".format(pid), "--noheaders"]
        try:
            return [int(x) for x in gef_execute_external(cmd, as_list=True)]
        except Exception:
            return []

    def get_uid_map(self, pid):
        try:
            uid_map = open("/proc/{}/uid_map".format(pid), "r").read().strip()
        except Exception:
            return []
        return slicer([int(x) for x in uid_map.split()], 3)

    def get_gid_map(self, pid):
        try:
            gid_map = open("/proc/{}/gid_map".format(pid), "r").read().strip()
        except Exception:
            return []
        return slicer([int(x) for x in gid_map.split()], 3)

    def get_tty_str(self, major, minor):
        try:
            file = which("file")
        except FileNotFoundError as e:
            err("{}".format(e))
            return "Not Found"

        if not os.path.exists("/dev"):
            return "Not Found"
        if not os.path.exists("/proc/devices"):
            return "Not Found"

        try:
            devices = open("/proc/devices", "r").read()
        except Exception:
            return "Not found"
        for line in devices.splitlines():
            if not line or line.endswith(":"):
                continue
            n, name = line.strip().split()
            if major == int(n):
                if not name.startswith("/dev"):
                    name = os.path.join("/dev", name)
                break
        else:
            return "Not Found"

        if os.path.islink(name):
            return "Not Found"
        elif os.path.isfile(name):
            res = gef_execute_external([file, name], as_iist=True)
            m = re.search(r"\((\d+)/(\d+)\)", res)
            if m and int(m.group(1)) == major and int(m.group(2)) == minor:
                return name
            else:
                return "Not Found"
        elif os.path.isdir(name):
            for root, dirs, files in os.walk(name, followlinks=False):
                for f in files:
                    path = os.path.join(root, f)
                    if os.path.islink(path):
                        continue
                    res = gef_execute_external([file, path], as_iist=True)
                    m = re.search(r"\((\d+)/(\d+)\)", res)
                    if m and int(m.group(1)) == major and int(m.group(2)) == minor:
                        return path
            return "Not Found"

    def show_info_proc(self):
        gef_print(titlify("Process Information"))

        pid = get_pid()
        executable = self.get_process_path_of(pid)
        cmdline = self.get_cmdline_of(pid)
        cwd = self.get_process_cwd(pid)
        root = self.get_process_root(pid)
        gef_print("{:32s} {} {}".format("PID", RIGHT_ARROW, pid))
        gef_print("{:32s} {} {}".format("  Executable", RIGHT_ARROW, repr(executable)))
        gef_print("{:32s} {} {}".format("  Command Line", RIGHT_ARROW, repr(cmdline)))
        gef_print("{:32s} {} {}".format("  Current Working Directory", RIGHT_ARROW, repr(cwd)))
        gef_print("{:32s} {} {}".format("  Root Directory", RIGHT_ARROW, repr(root)))
        uids = re.sub(r"\s+", " : ", self.get_state_of(pid)['Uid'])
        gids = re.sub(r"\s+", " : ", self.get_state_of(pid)['Gid'])
        gef_print("{:32s} {} {}".format("  RUID:EUID:SavedUID:FSUID", RIGHT_ARROW, uids))
        gef_print("{:32s} {} {}".format("  RGID:EGID:SavedGID:FSGID", RIGHT_ARROW, gids))
        seccomp_n = self.get_state_of(pid)['Seccomp']
        seccomp_s = {'0': 'Disabled', '1': 'Strict', '2': 'CustomFilter'}[seccomp_n]
        gef_print("{:32s} {} {} ({})".format("  Seccomp Mode", RIGHT_ARROW, seccomp_n, seccomp_s))
        return

    def show_info_proc_extra(self):
        gef_print(titlify("Process Information Additional"))

        pid = get_pid()
        pgid = self.get_stat_of(pid)[4]
        pgid_exec = self.get_process_path_of(pgid)
        pgid_cmdline = self.get_cmdline_of(pgid)
        gef_print("{:32s} {} {}".format("Process Group ID", RIGHT_ARROW, pgid))
        gef_print("{:32s} {} {}".format("  Executable", RIGHT_ARROW, repr(pgid_exec)))
        gef_print("{:32s} {} {}".format("  Command Line", RIGHT_ARROW, repr(pgid_cmdline)))
        sid = self.get_stat_of(pid)[5]
        sid_exec = self.get_process_path_of(sid)
        sid_cmdline = self.get_cmdline_of(sid)
        gef_print("{:32s} {} {}".format("Session ID", RIGHT_ARROW, sid))
        gef_print("{:32s} {} {}".format("  Executable", RIGHT_ARROW, repr(sid_exec)))
        gef_print("{:32s} {} {}".format("  Command Line", RIGHT_ARROW, repr(sid_cmdline)))
        tpgid = self.get_stat_of(pid)[7]
        tpgid_exec = self.get_process_path_of(tpgid)
        tpgid_cmdline = self.get_cmdline_of(tpgid)
        gef_print("{:32s} {} {}".format("TTY Process Group ID", RIGHT_ARROW, tpgid))
        gef_print("{:32s} {} {}".format("  Executable", RIGHT_ARROW, repr(tpgid_exec)))
        gef_print("{:32s} {} {}".format("  Command Line", RIGHT_ARROW, repr(tpgid_cmdline)))
        ttynr = self.get_stat_of(pid)[6]
        major, minor = (ttynr >> 8) & 0xff, ((ttynr >> 20) << 8) | (ttynr & 0xff)
        ttystr = self.get_tty_str(major, minor)
        gef_print("{:32s} {} {} ({})".format("  TTY Device Number", RIGHT_ARROW, ttynr, repr(ttystr)))
        return

    def show_parent(self):
        gef_print(titlify("Parent Process Information"))
        ppid = int(self.get_state_of(get_pid())["PPid"])
        ppid_exec = self.get_process_path_of(ppid)
        ppid_cmdline = self.get_cmdline_of(ppid)
        gef_print("{:32s} {} {}".format("Parent PID", RIGHT_ARROW, ppid))
        gef_print("{:32s} {} {}".format("  Executable", RIGHT_ARROW, repr(ppid_exec)))
        gef_print("{:32s} {} {}".format("  Command Line", RIGHT_ARROW, repr(ppid_cmdline)))
        return

    def show_childs(self):
        gef_print(titlify("Children Process Information"))

        children = self.get_children_pids(get_pid())
        if not children:
            gef_print("No child process")
            return

        for i, cpid in enumerate(children, start=1):
            cpid_exec = self.get_process_path_of(cpid)
            cpid_cmdline = self.get_cmdline_of(cpid)
            gef_print("{:32s} {} {}".format("Child {} PID".format(i), RIGHT_ARROW, cpid))
            gef_print("{:32s} {} {}".format("  Executable", RIGHT_ARROW, repr(cpid_exec)))
            gef_print("{:32s} {} {}".format("  Command Line", RIGHT_ARROW, repr(cpid_cmdline)))
        return

    def show_info_thread(self):
        gef_print(titlify("Thread Information"))

        pid = get_pid()
        nthreads = self.get_state_of(pid)['Threads']
        tgid = self.get_state_of(pid)['Tgid']
        gef_print("{:32s} {} {}".format("Num of Threads", RIGHT_ARROW, nthreads))
        gef_print("{:32s} {} {}".format("Thread Group ID", RIGHT_ARROW, tgid))
        tids = self.get_thread_ids(pid)
        split = 8
        gef_print("{:32s} {} {}".format("Thread ID List", RIGHT_ARROW, tids[:split]))
        for i in range(split, len(tids), split):
            gef_print("{:32s} {} {}".format("", RIGHT_ARROW, tids[i:i + split]))
        return

    def show_info_proc_ns(self):
        gef_print(titlify("Namespace Information"))

        pid = get_pid()
        gdb_pid = os.getpid()
        ns_symbols = ["cgroup", "ipc", "mnt", "net", "pid", "time", "user", "uts"]
        for ns in ns_symbols:
            sym1 = os.readlink("/proc/{:d}/ns/{:s}".format(pid, ns))
            sym2 = os.readlink("/proc/{:d}/ns/{:s}".format(gdb_pid, ns))
            m = "{:s} namespace separation".format(ns.upper())
            gef_print("{:32s} {} {}".format(m, RIGHT_ARROW, str(sym1 != sym2)))

        gef_print(titlify("Pid Namespace Information"))
        state = self.get_state_of(pid)
        if len(state['NSpid'].split()) > 1:
            gef_print("{:32s} {} {}".format("Host PID  : Namespace PID", RIGHT_ARROW, re.sub(r"\s+", " : ", state['NSpid'])))
            gef_print("{:32s} {} {}".format("Host PGID : Namespace PGID", RIGHT_ARROW, re.sub(r"\s+", " : ", state['NSpgid'])))
            gef_print("{:32s} {} {}".format("Host SID  : Namespace SID", RIGHT_ARROW, re.sub(r"\s+", " : ", state['NSsid'])))
            gef_print("{:32s} {} {}".format("Host TGID : Namespace TGID", RIGHT_ARROW, re.sub(r"\s+", " : ", state['NStgid'])))
        else:
            gef_print("{:32s}".format("No pid namespace"))

        gef_print(titlify("User Namespace Information"))
        for u in self.get_uid_map(pid):
            gef_print("{:32s} {} [{:#x} : {:#x} : {:#x}]".format("UID_MAP [NameSpace:Host:Range]", RIGHT_ARROW, u[0], u[1], u[2]))
        for g in self.get_gid_map(pid):
            gef_print("{:32s} {} [{:#x} : {:#x} : {:#x}]".format("GID_MAP [NameSpace:Host:Range]", RIGHT_ARROW, g[0], g[1], g[2]))
        return

    def show_fds(self):
        gef_print(titlify("File Descriptors"))

        pid = get_pid()
        path = "/proc/{:d}/fd".format(pid)

        gef_print("{:32s} {} {}".format("Num of FD slots", RIGHT_ARROW, self.get_state_of(pid)['FDSize']))
        items = os.listdir(path)
        if not items:
            gef_print("No FD opened")
            return

        for fname in items:
            fullpath = os.path.join(path, fname)
            if os.path.islink(fullpath):
                gef_print("{:32s} {:s} {:s}".format(fullpath, RIGHT_ARROW, os.readlink(fullpath)))
        return

    def list_sockets(self, pid):
        sockets = []
        path = "/proc/{:d}/fd".format(pid)
        items = os.listdir(path)
        for fname in items:
            fullpath = os.path.join(path, fname)
            if os.path.islink(fullpath) and os.readlink(fullpath).startswith("socket:"):
                p = os.readlink(fullpath).replace("socket:", "")[1:-1]
                sockets.append(int(p))
        return sockets

    def parse_ip_port(self, addr):
        ip, port = addr.split(":")
        return socket.inet_ntoa(struct.pack("<I", int(ip, 16))), int(port, 16)

    def show_connections(self):
        gef_print(titlify("Network Connections"))

        # https://github.com/torvalds/linux/blob/v4.7/include/net/tcp_states.h#L16
        tcp_states_str = {
            0x01: "TCP_ESTABLISHED",
            0x02: "TCP_SYN_SENT",
            0x03: "TCP_SYN_RECV",
            0x04: "TCP_FIN_WAIT1",
            0x05: "TCP_FIN_WAIT2",
            0x06: "TCP_TIME_WAIT",
            0x07: "TCP_CLOSE",
            0x08: "TCP_CLOSE_WAIT",
            0x09: "TCP_LAST_ACK",
            0x0A: "TCP_LISTEN",
            0x0B: "TCP_CLOSING",
            0x0C: "TCP_NEW_SYN_RECV",
        }

        udp_states_str = {
            0x07: "UDP_LISTEN",
        }

        pid = get_pid()
        sockets = self.list_sockets(pid)
        if not sockets:
            gef_print("No open connections")
            return

        entries = {}
        entries["TCP"] = [x.split() for x in open("/proc/{:d}/net/tcp".format(pid), "r").readlines()[1:]]
        entries["UDP"] = [x.split() for x in open("/proc/{:d}/net/udp".format(pid), "r").readlines()[1:]]

        for proto in entries:
            for entry in entries[proto]:
                local, remote, state = entry[1:4]
                inode = int(entry[9])
                if inode in sockets:
                    local = self.parse_ip_port(local)
                    remote = self.parse_ip_port(remote)
                    state = int(state, 16)
                    state_str = tcp_states_str[state] if proto == "TCP" else udp_states_str[state]

                    conn_local = "{}:{}".format(local[0], local[1])
                    conn_remote = "{}:{}".format(remote[0], remote[1])
                    gef_print("{:32s} {} {} ({})".format(conn_local, RIGHT_ARROW, conn_remote, state_str))
        return


@register_command
class CapabilityCommand(GenericCommand):
    """Show the capabilities of the debugging process."""
    _cmdline_ = "capability"
    _category_ = "02-f. Process Information - Security"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-v', dest='verbose', action='store_true', help='also display detailed bit information other than cap_eff.')
    _syntax_ = parser.format_help()

    def get_thread_ids(self, pid):
        try:
            tids = os.listdir("/proc/{}/task".format(pid))
            return [int(x) for x in tids]
        except Exception:
            return []

    def print_cap_details(self, name, cap):
        bit_info = [
            [40, "CAP_CHECKPOINT_RESTORE", "Update /proc/sys/kernel/ns_last_pid; read /proc/[another_pid]/map_files; etc.", ""],
            [39, "CAP_BPF", "Allow privileged BPF operations", ""],
            [38, "CAP_PERFMON", "Allow various performance-monitoring mechanisms; allow perf_event_open(2); allow some BPF operations", ""],
            [37, "CAP_AUDIT_READ", "Allow reading the audit log via a multicast netlink socket", ""],
            [36, "CAP_BLOCK_SUSPEND", "Allow features that can block system suspend", ""],
            [35, "CAP_WAKE_ALARM", "Trigger something that will wake up the system", ""],
            [34, "CAP_SYSLOG", "Allow privileged syslog(2) operations; View kernel addresses exposed via /proc even if kptr_restrict=1", ""],
            [33, "CAP_MAC_ADMIN", "Allow MAC configuration or state changes", ""],
            [32, "CAP_MAC_OVERRIDE", "Override MAC", ""],
            [31, "CAP_SETFCAP", "Set arbitrary capabilities on a file", ""],
            [30, "CAP_AUDIT_CONTROL", "Enable/disable kernel audit; change audit filter rules; retrieve audit status and filter rules", ""],
            [29, "CAP_AUDIT_WRITE", "Write records to kernel audit log", ""],
            [28, "CAP_LEASE", "Establish leases", ""],
            [27, "CAP_MKNOD", "Create special files using mknod(2)", ""],
            [26, "CAP_SYS_TTY_CONFIG", "Allow vhangup(2); allow various privileged ioctl(2) operations on virtual terminals", ""],
            [25, "CAP_SYS_TIME", "Set system cloc; set real-time (hardware) clock", ""],
            [24, "CAP_SYS_RESOURCE", "Override disk quota limits; override RLIMIT_NPROC resource limit; etc.", ""],
            [23, "CAP_SYS_NICE", "Lower the process nice value and change the nice value for arbitrary processes; etc.", ""],
            [22, "CAP_SYS_BOOT", "Allow reboot(2) and kexec_load(2)", ""],
            [21, "CAP_SYS_ADMIN", "Allow various privileges operations", ""],
            [20, "CAP_SYS_PACCT", "Allow acct(2)", ""],
            [19, "CAP_SYS_PTRACE", "Trace arbitrary processes using ptrace(2); etc.", ""],
            [18, "CAP_SYS_CHROOT", "Allow chroot(2); change mount namespaces using setns(2)", ""],
            [17, "CAP_SYS_RAWIO", "Perform I/O port operations; etc.", ""],
            [16, "CAP_SYS_MODULE", "Load and unload kernel modules", ""],
            [15, "CAP_IPC_OWNER", "Bypass permission checks for operations on SystemV IPC objects", ""],
            [14, "CAP_IPC_LOCK", "Lock memory; allocate memory using huge pages", ""],
            [13, "CAP_NET_RAW", "Use RAW and PACKET sockets; bind to any address for transparent proxying", ""],
            [12, "CAP_NET_ADMIN", "Perform various network-related operations", ""],
            [11, "CAP_NET_BROADCASTE", "(Unused) Make socket broadcasts, and listen to multicast", ""],
            [10, "CAP_NET_BIND_SERVICE", "Bind a socket to Internet domain privileged ports (less than 1024)", ""],
            [9, "CAP_LINUX_IMMUTABLE", "Set the FS_APPEND_FL and FS_IMMUTABLE_FL inode flags", ""],
            [8, "CAP_SETPCAP", "Add any capability from the calling thread's bounding set to its inheritable set; etc.", ""],
            [7, "CAP_SETUID", "Make arbitrary manipulations of process UIDs; etc.", ""],
            [6, "CAP_SETGID", "Make arbitrary manipulations of process GIDs and supplementary GID list; etc.", ""],
            [5, "CAP_KILL", "Bypass permission checks for sending signals", ""],
            [4, "CAP_FSETID", "Don't clear SUID and SGID bits when a file is modified; etc.", ""],
            [3, "CAP_FOWNER", "Bypass permission checks whether FSUID == file UID; set ACLs; etc.", ""],
            [2, "CAP_DAC_READ_SEARCH", "Bypass permission checks of file read, dir read/exec; etc.", ""],
            [1, "CAP_DAC_OVERRIDE", "Bypass permission checks of file read/write/exec", ""],
            [0, "CAP_CHOWN", "Make arbitrary changes to file UIDs and GIDs", ""],
        ]
        PrintBitInfo(name, 64, None, bit_info).print(cap)
        return

    def print_capability_from_pid(self, verbose):
        pid = get_pid()
        if pid is None:
            return

        tids = self.get_thread_ids(pid)
        for tid in tids:
            gef_print(titlify("Thread capability set [PID={:d}, TID={:d}]".format(pid, tid)))
            try:
                status_path = "/proc/{:d}/task/{:d}/status".format(pid, tid)
                status = open(status_path, "r").read()
            except Exception:
                err("Failed to get the information of capability from {:s}".format(status_path))
                continue

            caps = {}
            m = re.search(r"CapInh:\s+(.+)", status)
            if m:
                caps["cap_inh"] = int(m.group(1), 16)
            m = re.search(r"CapPrm:\s+(.+)", status)
            if m:
                caps["cap_prm"] = int(m.group(1), 16)
            m = re.search(r"CapEff:\s+(.+)", status)
            if m:
                caps["cap_eff"] = int(m.group(1), 16)
            m = re.search(r"CapBnd:\s+(.+)", status)
            if m:
                caps["cap_bnd"] = int(m.group(1), 16)
            m = re.search(r"CapAmb:\s+(.+)", status)
            if m:
                caps["cap_amb"] = int(m.group(1), 16)

            if "cap_prm" in caps:
                msg = "Capability set that Effective and Inheritable are allowed to have"
                gef_print("Permitted  : {:#018x} - {:s}".format(caps["cap_prm"], msg))
                if verbose:
                    self.print_cap_details("cap_prm", caps["cap_prm"])
            if "cap_inh" in caps:
                msg = "Capability set that can be inherited when execve(2)"
                gef_print("Inheritable: {:#018x} - {:s}".format(caps["cap_inh"], msg))
                if verbose:
                    self.print_cap_details("cap_inh", caps["cap_inh"])
            if "cap_amb" in caps:
                msg = "Capability set that inherited when execve(2) not suid/sgid program"
                gef_print("Ambient    : {:#018x} - {:s}".format(caps["cap_amb"], msg))
                if verbose:
                    self.print_cap_details("cap_amb", caps["cap_amb"])
            if "cap_eff" in caps:
                msg = "Capability set that kernel actually uses to determine privileges"
                gef_print("Effective  : {:#018x} - {:s}".format(caps["cap_eff"], msg))
                self.print_cap_details("cap_eff", caps["cap_eff"])
            if "cap_bnd" in caps:
                msg = "Capability set that limits the capabilities set that can be acquired"
                gef_print("Bounding   : {:#018x} - {:s}".format(caps["cap_bnd"], msg))
                if verbose:
                    self.print_cap_details("cap_bnd", caps["cap_bnd"])
        return

    def print_capability_from_file(self, verbose):
        filepath = get_filepath()
        if filepath is None:
            return

        gef_print(titlify("File capability set [{:s}]".format(filepath)))
        try:
            raw_caps = os.getxattr(filepath, "security.capability")
        except OSError:
            err("No data available")
            return

        caps = {}
        magic = struct.unpack("<I", raw_caps[:4])[0]
        caps["magic"] = magic & ~1
        caps["cap_eff"] = magic & 1
        if caps["magic"] == 0x01000000:
            cap_prm, cap_inh = struct.unpack("<II", raw_caps[4:12])
        elif caps["magic"] == 0x02000000:
            cap_prm_low, cap_inh_low, cap_prm_high, cap_inh_high = struct.unpack("<IIII", raw_caps[4:20])
            cap_prm = (cap_prm_high << 32) | cap_prm_low
            cap_inh = (cap_inh_high << 32) | cap_inh_low
        elif caps["magic"] == 0x03000000:
            cap_prm_low, cap_inh_low, cap_prm_high, cap_inh_high, rootid = struct.unpack("<IIIII", raw_caps[4:24])
            cap_prm = (cap_prm_high << 32) | cap_prm_low
            cap_inh = (cap_inh_high << 32) | cap_inh_low
            caps["rootid"] = rootid
        else:
            err("Invalid magic values: {:#x}".format(magic))
            return
        caps["cap_prm"] = cap_prm
        caps["cap_inh"] = cap_inh

        if "magic" in caps:
            msg = "Magic number: ver1: 0x01000000, ver2:0x02000000, ver3:0x03000000"
            gef_print("Magic      : {:#010x} - {:s}".format(caps["magic"], msg))
        if "cap_eff" in caps:
            msg = "If 1, new cap_prm are added to new cap_eff after execve(2)"
            gef_print("Effective  : {:#03x} - {:s}".format(caps["cap_eff"], msg))
        if "cap_prm" in caps:
            msg = "Capability set that permitted to the thread, regardless of the thread's cap_inh"
            gef_print("Permitted  : {:#018x} - {:s}".format(caps["cap_prm"], msg))
            if verbose:
                self.print_cap_details("cap_prm", caps["cap_prm"])
        if "cap_inh" in caps:
            msg = "Capability set that is ANDed with thread cap_inh to determine cap_inh after execve(2)"
            gef_print("Inheritable: {:#018x} - {:s}".format(caps["cap_inh"], msg))
            if verbose:
                self.print_cap_details("cap_inh", caps["cap_inh"])
        if "rootid" in caps:
            msg = "UID of root in user namespace"
            gef_print("Root ID    : {:#010x} - {:s}".format(caps["rootid"], msg))
        return

    @parse_args
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()
        self.print_capability_from_pid(args.verbose)
        self.print_capability_from_file(args.verbose)
        return


@register_command
class SmartMemoryDumpCommand(GenericCommand):
    """Smart dump the process memory."""
    _cmdline_ = "smart-memory-dump"
    _category_ = "03-e. Memory - Dump"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--prefix', help='use this name for the dump destination file prefix. (default: PID)')
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        if args.prefix is None:
            pid = get_pid(remote=True)
            if pid is None:
                prefix = "{:05d}".format(0)
            else:
                prefix = "{:05d}".format(pid)
        else:
            prefix = args.prefix

        self.smart_memory_dump(prefix)
        return

    def smart_memory_dump(self, prefix):
        maps = get_process_maps()
        if maps is None:
            err("Failed to get maps")
            return

        addr_len = current_arch.ptrsize * 2
        for entry in maps:
            start = entry.page_start
            end = entry.page_end
            perm = str(entry.permission)

            if entry.path in ["[vvar]", "[vsyscall]"]:
                continue

            if not entry.path.startswith("["):
                path = os.path.basename(entry.path)
            else:
                path = entry.path
                path = path.replace("[", "").replace("]", "") # consider [heap], [stack], [vdso]
                path = path.replace("<", "").replace(">", "") # consider under qemu-user. ex: <explored>
                path = path.replace(" ", "_") # consider deleted case. ex: /path/to/file (deleted)

            try:
                data = read_memory(start, end - start)
            except gdb.MemoryError:
                continue

            fmt = "{:s}-{:0{}x}-{:0{}x}_{:s}_{:s}.raw"
            dumpfile_name = fmt.format(prefix, start, addr_len, end, addr_len, perm, path)
            filepath = os.path.join(GEF_TEMP_DIR, dumpfile_name)
            open(filepath, "wb").write(data)
            info("Saved to {:s}".format(filepath))
        return


@register_command
class HijackFdCommand(GenericCommand):
    """Redirect file descriptor during runtime."""
    _cmdline_ = "hijack-fd"
    _category_ = "01-g. Debugging Support - Other"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('old_fd', metavar='OLD_FD', type=int, help='file descriptor number you want to redirect.')
    parser.add_argument('new_output', metavar='NEW_OUTPUT', type=str, help='the location redirected data is stored.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} 2 /tmp/stderr_output.txt\n".format(_cmdline_)
    _example_ += "{:s} 2 localhost:8000".format(_cmdline_)

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    @exclude_specific_arch(['CRIS'])
    def do_invoke(self, args):
        self.dont_repeat()

        self.fd_adjust_connect = 0
        self.fd_adjust_dup3 = 0
        # On certain architectures on qemu fd is slightly off.
        if is_qemu_usermode():
            if is_x86_32():
                self.fd_adjust_connect = 80
                self.fd_adjust_dup3 = 80

        self.AF_INET = 2
        self.SOCK_STREAM = 1
        self.O_APPEND = 0o2000
        self.O_CREAT = 0o100
        self.O_RDWR = 0o2
        # some architecture use different consts.
        if is_mips32() or is_mips64():
            # /usr/mipsel-linux-gnu/include/bits/socket_type.h
            # /usr/mips64el-linux-gnuabi64/include/bits/socket_type.h
            self.SOCK_STREAM = 2
            # /usr/mipsel-linux-gnu/include/bits/fcntl.h
            # /usr/mips64el-linux-gnuabi64/include/bits/fcntl.h
            self.O_APPEND = 0x0008
            self.O_CREAT = 0x0100
        elif is_sparc32() or is_sparc64():
            # sparcv8--uclibc--stable-2022.08-1/sparc-buildroot-linux-uclibc/sysroot/usr/include/bits/fcntl.h
            # sparc64--glibc--stable-2022.08-1/sparc64-buildroot-linux-gnu/sysroot/usr/include/bits/fcntl.h
            self.O_APPEND = 0x0008
            self.O_CREAT = 0x0200
        elif is_alpha():
            # /usr/alpha-linux-gnu/include/bits/fcntl.h
            self.O_APPEND = 0o0010
            self.O_CREAT = 0o1000
        elif is_hppa32() or is_hppa64():
            # /usr/hppa-linux-gnu/include/bits/fcntl.h
            self.O_APPEND = 0o0010
            self.O_CREAT = 0o0400

        self.hijack_fd(args)
        return

    def call_syscall(self, syscall_name, args):
        args = ' '.join(["{:#x}".format(x) for x in args])
        cmd = "call-syscall {:s} {}".format(syscall_name, args)
        info(cmd)
        res = gdb.execute(cmd, to_string=True)
        output_line = res.splitlines()[-1]
        info(output_line)
        return int(output_line.split()[2], 0)

    def hijack_fd(self, args):
        if ":" in args.new_output:
            new_fd = self.get_fd_from_connect_server(args)
        else:
            new_fd = self.get_fd_from_file_open(args)
        if new_fd is None:
            return

        # call dup3
        # dup2 does not exist in aarch64. So use dup3 instead of dup2.
        dup3_result = self.call_syscall("dup3", [new_fd - self.fd_adjust_dup3, args.old_fd, 0])
        if dup3_result - self.fd_adjust_dup3 != args.old_fd:
            err("Failed to dup3 (result {:d} != fd #{:d})".format(dup3_result, args.old_fd))
            return
        info("Duplicated fd #{:d}{:s}#{:d}".format(new_fd, RIGHT_ARROW, args.old_fd))

        # call close
        close_result = self.call_syscall("close", [new_fd])
        if close_result == -1:
            err("Failed to close fd #{:d}".format(new_fd))
            return
        info("Closed extra fd #{:d}".format(new_fd))

        ok("Success")
        return

    def write_stack(self, data):
        data = str2bytes(data)

        # get stack address
        vmmap = get_process_maps()
        stack_addrs = [entry.page_start for entry in vmmap if entry.path == "[stack]"]
        if len(stack_addrs) == 0:
            err("Not found stack")
            return None, None
        stack_addr = stack_addrs[0]

        # read original contents
        try:
            original_contents = read_memory(stack_addr, len(data))
        except gdb.MemoryError:
            err("Failed to read stack")
            return None, None

        info("original contents: {}".format(original_contents))
        info("overwrite data: {}".format(data))

        # overwrite it
        try:
            write_memory(stack_addr, data, len(data))
        except Exception:
            err("Failed to write stack")
            return None, None

        # read again and check
        if read_memory(stack_addr, len(data)) != data:
            err("Failed to write stack")
            return None, None

        return stack_addr, original_contents

    def get_fd_from_file_open(self, args):
        # call open
        stack_addr, original_contents = self.write_stack(args.new_output + "\0")
        if stack_addr is None:
            return None

        info("Trying to open {}".format(args.new_output))

        AT_FDCWD = -100
        flags = self.O_APPEND | self.O_CREAT | self.O_RDWR
        mode = 0o666
        # open does not exist in aarch64. So use openat instead of open.
        open_fd = self.call_syscall("openat", [AT_FDCWD, stack_addr, flags, mode])
        write_memory(stack_addr, original_contents, len(original_contents)) # revert

        if open_fd == -1:
            err("Failed to open {}".format(args.new_output))
            return None

        info("Opened {} with 0o666 as fd #{:d}".format(args.new_output, open_fd))
        return open_fd

    def get_fd_from_connect_server(self, args):
        address = socket.gethostbyname(args.new_output.split(":")[0])
        port = int(args.new_output.split(":")[1])

        # call socket
        sock_fd = self.call_syscall("socket", [self.AF_INET, self.SOCK_STREAM, 0])
        if sock_fd == -1:
            err("Failed to socket")
            return None
        info("Created socket fd #{:d}".format(sock_fd))

        # call connect (Also supports big endian)
        sockaddr_in = p16(self.AF_INET) + struct.pack("<H", socket.htons(port)) + socket.inet_aton(address)
        stack_addr, original_contents = self.write_stack(sockaddr_in)
        if stack_addr is None:
            return None

        info("Trying to connect to {}".format(args.new_output))
        connect_result = self.call_syscall("connect", [sock_fd - self.fd_adjust_connect, stack_addr, 16])
        write_memory(stack_addr, original_contents, len(original_contents)) # revert

        if connect_result == -1:
            err("Failed to connect to {}:{}".format(address, port))
            return

        info("Connected to {} as fd #{:d}".format(args.new_output, sock_fd))
        return sock_fd


@register_command
class ScanSectionCommand(GenericCommand):
    """Search for addresses that are located in a memory mapping (haystack) that belonging to another (needle)."""
    _cmdline_ = "scan-section"
    _category_ = "03-a. Memory - Search"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('haystack', metavar='HAYSTACK', help='where to search for the needle.')
    parser.add_argument('needle', metavar='NEEDLE', help='what to explore.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} stack binary # scan binary address from stack\n".format(_cmdline_)
    _example_ += "{:s} stack libc   # scan libc address from stack\n".format(_cmdline_)
    _example_ += "{:s} stack heap   # scan heap address from stack\n".format(_cmdline_)
    _example_ += "{:s} heap libc    # scan libc address from heap\n".format(_cmdline_)
    _example_ += "{:s} 0x0000555555772000-0x0000555555774000 libc".format(_cmdline_)

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        haystack = args.haystack
        needle = args.needle

        info("Searching for addresses in '{:s}' that point to '{:s}'"
             .format(Color.yellowify(haystack), Color.yellowify(needle)))

        if haystack in ["binary", "bin"]:
            haystack = get_filepath(append_proc_root_prefix=False)

        if needle in ["binary", "bin"]:
            needle = get_filepath(append_proc_root_prefix=False)

        self.scan(haystack, needle)
        return

    def scan(self, haystack, needle):
        needle_sections = []
        haystack_sections = []

        if "0x" in haystack:
            try:
                start, end = parse_string_range(haystack)
                haystack_sections.append((start, end, ""))
            except Exception:
                pass

        if "0x" in needle:
            try:
                start, end = parse_string_range(needle)
                needle_sections.append((start, end))
            except Exception:
                pass

        for sect in get_process_maps():
            if haystack in sect.path:
                haystack_sections.append((sect.page_start, sect.page_end, os.path.basename(sect.path)))
            if needle in sect.path:
                needle_sections.append((sect.page_start, sect.page_end))

        step = current_arch.ptrsize
        unpack = u32 if step == 4 else u64

        for hstart, hend, hname in haystack_sections:
            try:
                mem = read_memory(hstart, hend - hstart)
            except gdb.MemoryError:
                continue

            for i in range(0, len(mem), step):
                target = unpack(mem[i:i + step])
                for nstart, nend in needle_sections:
                    if not (nstart <= target < nend):
                        continue
                    deref = to_string_dereference_from(hstart + i)
                    if hname != "":
                        name = Color.colorify(hname, "yellow")
                        gef_print("{:s}: {:s}".format(name, deref))
                    else:
                        gef_print(" {:s}".format(deref))
        return


@register_command
class SearchPatternCommand(GenericCommand):
    """Search a pattern in memory."""
    _cmdline_ = "search-pattern"
    _category_ = "03-a. Memory - Search"
    _aliases_ = ["find"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('pattern', metavar='PATTERN', help='search target value. "double-espaced string" or 0xXXXXXXXX style.')
    parser.add_argument('--hex', action='store_true', help="interpret PATTERN as hex. invalid character is ignored.")
    parser.add_argument('--big', action='store_true', help="interpret PATTERN as big endian if PATTERN is 0xXXXXXXXX style.")
    parser.add_argument('section', metavar='SECTION', nargs="?", help="range to search.")
    parser.add_argument('--aligned', type=int, default=1, help="alignment unit. (default: %(default)s)")
    parser.add_argument('-v', dest='verbose', action='store_true', help='shows the section you are currently searching.')
    parser.add_argument('--disable-utf16', action='store_true', help='disable utf16 search if PATTERN is ascii string.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} AAAA                       # search 'AAAA' from whole memory\n".format(_cmdline_)
    _example_ += "{:s} 0x41414141                 # search 0x41414141 from whole memory.\n".format(_cmdline_)
    _example_ += '{:s} --hex "41 41 41 41" stack  # another valid format\n'.format(_cmdline_)
    _example_ += "{:s} 0x555555554000 stack       # search 0x555555554000 (6byte) from stack\n".format(_cmdline_)
    _example_ += "{:s} 0x0000555555554000 stack   # search 0x0000555555554000 (8byte) from stack\n".format(_cmdline_)
    _example_ += "{:s} AAAA binary                # 'binary' means the area executable itself. (only usermode)\n".format(_cmdline_)
    _example_ += "{:s} AAAA 0x400000-0x404000     # search 'AAAA' from specific range\n".format(_cmdline_)
    _example_ += "{:s} AAAA heap --aligned 16     # search with aligned".format(_cmdline_)

    def print_section(self, section):
        if isinstance(section, Address):
            section = section.section

        if section is None:
            return

        title = "In "
        if section.path:
            title += "'{}' ".format(Color.blueify(section.path))

        title += "({:#x}-{:#x} [{}])".format(section.page_start, section.page_end, section.permission)
        ok(title)
        return

    def print_loc(self, loc):
        if self.aligned and loc[0] % self.aligned:
            return
        gef_print('''  {:#x} - {:#x} {}  "{}"'''.format(loc[0], loc[1], RIGHT_ARROW, Color.pinkify(loc[2]),))
        return

    def search_pattern_by_address(self, pattern, start_address, end_address):
        """Search a pattern within a range defined by arguments."""
        pattern = gef_pybytes(pattern)
        if is_qemu_system():
            step = gef_getpagesize()
        else:
            step = 0x400 * gef_getpagesize()
        locations = []

        for chunk_addr in range(start_address, end_address, step):
            if chunk_addr + step > end_address:
                chunk_size = end_address - chunk_addr
            else:
                chunk_size = step

            try:
                mem = read_memory(chunk_addr, chunk_size)
            except gdb.MemoryError:
                # cannot access memory this range. It doesn't make sense to try any more
                break

            for match in re.finditer(pattern, mem):
                start = chunk_addr + match.start()
                ustr = gef_pystring(pattern)
                end = start + len(pattern.decode("unicode-escape"))
                locations.append((start, end, ustr))
            del mem
        return locations

    @staticmethod
    def get_process_maps_qemu_system():
        res = get_maps_by_pagewalk("pagewalk -q")
        res = sorted(set(res.splitlines()))
        res = list(filter(lambda line: line.endswith("]"), res))
        res = list(filter(lambda line: "[+]" not in line, res))
        res = list(filter(lambda line: "*" not in line, res))
        for line in res:
            if is_x86() and "ACCESSED" not in line:
                continue
            lines = line.split()
            addr_start, addr_end = [int(x, 16) for x in lines[0].split("-")]
            if is_x86():
                perm = Permission.from_process_maps(lines[5][1:].lower())
            elif is_arm32():
                perm = line.split("/")[-1][:3]
                perm = Permission.from_process_maps(perm.lower())
            elif is_arm64():
                if 0xffff000008010000 <= addr_start < 0xffff000008020000 : # qemu process will be die if touch
                    continue
                if 0xffff000008030000 <= addr_start < 0xffff000008040000 : # qemu process will be die if touch
                    continue
                perm = line.split("/")[-1][:3]
                perm = Permission.from_process_maps(perm.lower())
            yield Section(page_start=addr_start, page_end=addr_end, permission=perm)

    def search_pattern(self, pattern, section_name=""):
        """Search a pattern within the whole userland memory."""
        if is_qemu_system():
            maps_generator = self.get_process_maps_qemu_system()
        else:
            maps_generator = get_process_maps()

        for section in maps_generator:
            if not section.permission & Permission.READ:
                continue
            if section.path == "[vvar]":
                continue
            if section_name not in section.path:
                continue

            if self.verbose:
                self.print_section(section) # verbose: always print section before search

            start = section.page_start
            end = section.page_end
            ret = self.search_pattern_by_address(pattern, start, end) # search

            if ret:
                if not self.verbose:
                    self.print_section(section) # default: print section if found

            for loc in ret:
                self.print_loc(loc)

            if not is_alive():
                err("The process is dead")
                break
        return

    def isascii(self, string):
        val = codecs.escape_decode(string)[0]
        return all([0x20 <= c < 0x7f for c in val])

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        self.verbose = args.verbose
        self.aligned = args.aligned

        # pattern replace
        if args.hex: # "41414141" -> "\x41\x41\x41\x41"
            _pattern = ""
            for c in args.pattern.lower():
                if c in '0123456789abcdef':
                    _pattern += c
            if len(_pattern) % 2 != 0:
                err("hex pattern length is odd")
                return
            pattern = "".join(["\\x" + _pattern[i:i + 2] for i in range(0, len(_pattern), 2)])

        elif is_hex(args.pattern): # "0x41414141" -> "\x41\x41\x41\x41"
            if args.big or is_big_endian():
                pattern = "".join(["\\x" + args.pattern[i:i + 2] for i in range(2, len(args.pattern), 2)])
            else:
                pattern = "".join(["\\x" + args.pattern[i:i + 2] for i in range(len(args.pattern) - 2, 0, -2)])
        else:
            pattern = args.pattern

        # create utf16 pattern
        pattern_utf16 = None
        if not args.disable_utf16 and self.isascii(pattern) and "\\" not in pattern:
            pattern_utf16 = "".join([x + "\\x00" for x in pattern])

        # section replace
        if args.section:
            if re.match(r"(0x)?[0-9a-fA-F]+-(0x)?[0-9a-fA-F]+", args.section):
                # specified range -> call search_pattern_by_address directly
                info("Searching '{:s}' in {:s}".format(Color.yellowify(pattern), args.section))
                start, end = parse_string_range(args.section)

                loc = lookup_address(start)
                if loc.valid:
                    if args.verbose:
                        self.print_section(loc) # verbose: always print section before search
                else:
                    err("Not found valid memory area")
                    return

                ret = self.search_pattern_by_address(pattern, start, end) # search

                if ret and not args.verbose:
                    self.print_section(loc) # default: print section if found

                for found_loc in ret:
                    self.print_loc(found_loc)

                if pattern_utf16 is not None:
                    info("Searching '{:s}' in {:s}".format(Color.yellowify(pattern_utf16), args.section))
                    ret = self.search_pattern_by_address(pattern_utf16, start, end)
                    for found_loc in ret:
                        self.print_loc(found_loc)
            else:
                # section name -> call search wrapper
                if args.section in ["binary", "bin"] and not is_qemu_system():
                    section_name = get_filepath(append_proc_root_prefix=False)
                else:
                    section_name = args.section

                info("Searching '{:s}' in {:s}".format(Color.yellowify(pattern), section_name))
                self.search_pattern(pattern, section_name)

                if pattern_utf16 is not None:
                    info("Searching '{:s}' in {:s}".format(Color.yellowify(pattern_utf16), section_name))
                    self.search_pattern(pattern_utf16, section_name)
        else:
            # whole memory -> call search wrapper
            info("Searching '{:s}' in memory".format(Color.yellowify(pattern)))
            self.search_pattern(pattern)
            if pattern_utf16 is not None:
                info("Searching '{:s}' in memory".format(Color.yellowify(pattern_utf16)))
                self.search_pattern(pattern_utf16)
        return


@register_command
class PtrDemangleCommand(GenericCommand):
    """Demangle a mangled value by PTR_MANGLE."""
    _cmdline_ = "ptr-demangle"
    _category_ = "02-f. Process Information - Security"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('value', metavar='VALUE', nargs='?', type=lambda x: int(x, 0), help='the value you want to demangle.')
    group.add_argument('--source', action='store_true', help='shows the source instead of displaying demangled value.')
    _syntax_ = parser.format_help()

    @staticmethod
    def get_cookie():
        if is_x86_64():
            tls = TlsCommand.getfs()
            cookie = read_int_from_memory(tls + 0x30)
        elif is_x86_32():
            tls = TlsCommand.getgs()
            cookie = read_int_from_memory(tls + 0x18)
        elif is_arm32() or is_arm64():
            if is_arm32():
                try:
                    tls = parse_address("(unsigned int)__aeabi_read_tp()")
                except Exception:
                    err("Not found symbol (__aeabi_read_tp)")
                    return None
            else:
                try:
                    tls = get_register("$TPIDR_EL0")
                except Exception:
                    err("Fail reading $TPIDR_EL0 register")
                    return None
            try:
                cookie_ptr = parse_address("&__pointer_chk_guard_local")
            except Exception:
                err("Not found symbol (__pointer_chk_guard_local)")
                return None
            cookie = read_int_from_memory(cookie_ptr)
        return cookie

    @staticmethod
    def decode(value, cookie):
        def ror(val, bits, arch_bits):
            new_val = (val >> bits) | (val << (arch_bits - bits))
            mask = (1 << arch_bits) - 1
            return new_val & mask

        if is_x86_64():
            decoded = ror(value, 17, 64) ^ cookie
        elif is_x86_32():
            decoded = ror(value, 9, 32) ^ cookie
        elif is_arm32() or is_arm64():
            decoded = value ^ cookie
        return decoded

    @parse_args
    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, args):
        self.dont_repeat()

        if args.source:
            s = inspect.getsource(PtrDemangleCommand.decode).rstrip()
            gef_print(s)
            return

        cookie = self.get_cookie()
        if cookie is None:
            return
        info("Cookie is {:#x}".format(cookie))

        decoded = self.decode(args.value, cookie)
        decoded_sym = get_symbol_string(decoded)
        if is_valid_addr(decoded):
            valid_msg = Color.colorify("valid", "bold green")
        else:
            valid_msg = Color.colorify("invalid", "bold red")
        decoded = Color.boldify("{:#x}".format(decoded))
        info("Decoded value is {:s}{:s} [{:s}]".format(decoded, decoded_sym, valid_msg))
        return


@register_command
class SearchMangledPtrCommand(GenericCommand):
    """Search a mangled pointer value in memory."""
    _cmdline_ = "search-mangled-ptr"
    _category_ = "02-f. Process Information - Security"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-v', dest='verbose', action='store_true', help='shows the section you are currently searching.')
    _syntax_ = parser.format_help()

    def print_section(self, section):
        if isinstance(section, Address):
            section = section.section

        if section is None:
            return

        title = "In "
        if section.path:
            title += "'{}' ".format(Color.blueify(section.path))

        title += "({:#x}-{:#x} [{}])".format(section.page_start, section.page_end, section.permission)
        ok(title)
        return

    def print_loc(self, loc):
        addr, value, decoded = loc[0], loc[1], loc[2]
        addr_sym = get_symbol_string(addr)
        decoded_sym = get_symbol_string(decoded)
        try:
            read_memory(decoded, 1)
            valid_msg = Color.colorify("valid", "bold green")
        except gdb.MemoryError:
            valid_msg = Color.colorify("invalid", "bold red")
        decoded = Color.boldify("{:#x}".format(decoded))
        gef_print("  {:#x}{:s}: {:#x} (={:s}{:s}) [{:s}]".format(addr, addr_sym, value, decoded, decoded_sym, valid_msg))
        return

    def search_mangled_ptr(self, start_address, end_address):
        """Search a mangled pointer within a range defined by arguments."""
        if is_qemu_system():
            step = gef_getpagesize()
        else:
            step = 0x400 * gef_getpagesize()
        locations = []

        for chunk_addr in range(start_address, end_address, step):
            if chunk_addr + step > end_address:
                chunk_size = end_address - chunk_addr
            else:
                chunk_size = step

            try:
                mem = read_memory(chunk_addr, chunk_size)
            except gdb.MemoryError:
                # cannot access memory this range. It doesn't make sense to try any more
                break

            for i, value in enumerate(slice_unpack(mem, current_arch.ptrsize)):
                decoded = PtrDemangleCommand.decode(value, self.cookie)
                try:
                    read_memory(decoded, 1)
                except gdb.MemoryError:
                    continue
                addr = chunk_addr + i * current_arch.ptrsize
                locations.append((addr, value, decoded))
            del mem
        return locations

    @parse_args
    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, args):
        self.dont_repeat()

        # init
        self.cookie = PtrDemangleCommand.get_cookie()
        if self.cookie is None:
            return
        info("Cookie is {:#x}".format(self.cookie))

        # search
        if is_qemu_system():
            maps_generator = self.get_process_maps_qemu_system()
        else:
            maps_generator = get_process_maps()
        for section in maps_generator:
            if not section.permission & Permission.READ:
                continue
            if not section.permission & Permission.WRITE:
                continue
            if args.verbose:
                self.print_section(section) # verbose: always print section before search

            start = section.page_start
            end = section.page_end
            ret = self.search_mangled_ptr(start, end)

            if ret:
                if not args.verbose:
                    self.print_section(section) # default: print section if found

            for loc in ret:
                self.print_loc(loc)

            if not is_alive():
                err("The process is dead")
                break
        return


@register_command
class EditFlagsCommand(GenericCommand):
    """Edit flags in a human friendly way."""
    _cmdline_ = "edit-flags"
    _category_ = "04-b. Register - Modify"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('flagname', metavar='[FLAGNAME(+|-|~) ...]', nargs="*", help='the flag name you want to edit..')
    parser.add_argument('-v', dest='verbose', action='store_true', help='show the bit informations of the flag register.')
    _syntax_ = parser.format_help()

    _example_ = "{:s}            # show the flag register\n".format(_cmdline_)
    _example_ += "{:s} zero+      # set ZERO flag\n".format(_cmdline_)
    _example_ += "{:s} direction- # unset DIRECTION flag\n".format(_cmdline_)
    _example_ += "{:s} sign~      # toggle SIGN flag\n".format(_cmdline_)
    _example_ += "{:s} -v         # verbose output".format(_cmdline_)

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        if current_arch.flag_register is None:
            warn("This command cannot work under this architecture.")
            return

        self.edit_flags(args.flagname)

        gef_print(current_arch.flag_register_to_human())
        if args.verbose:
            if is_x86():
                self.verbose_x86()
            elif is_arm32():
                self.verbose_arm32()
            elif is_arm64():
                self.verbose_arm64()
        return

    def edit_flags(self, flag_names):
        for flag in flag_names:
            if len(flag) < 2:
                err("Too short length of the name")
                return

            if flag[-1] not in ("+", "-", "~"):
                err("Invalid action for flag '{:s}'".format(flag))
                return

        for flag in flag_names:
            action = flag[-1]
            name = flag[:-1].lower()

            if is_x86():
                dic = {
                    "id": "identification",
                    "ac": "align",
                    "vm": "virtualx86",
                    "rf": "resume",
                    "nt": "nested",
                    "of": "overflow",
                    "df": "direction",
                    "if": "interrupt",
                    "tf": "trap",
                    "sf": "sign",
                    "zf": "zero",
                    "af": "adjust",
                    "pf": "parity",
                    "cf": "carry",
                }
                if name in dic:
                    name = dic[name]

            if name not in current_arch.flags_table.values():
                err("Invalid flag name '{:s}'".format(flag[:-1]))
                continue

            for off in current_arch.flags_table:
                if current_arch.flags_table[off] == name:
                    old_flag = get_register(current_arch.flag_register)
                    if action == "+":
                        new_flags = old_flag | (1 << off)
                    elif action == "-":
                        new_flags = old_flag & ~(1 << off)
                    else:
                        new_flags = old_flag ^ (1 << off)

                    gdb.execute("set ({:s}) = {:#x}".format(current_arch.flag_register, new_flags))
        return

    def bits_split(self, x, bits=32):
        out = ""
        for i in range(bits):
            if x & (1 << i):
                out = "1" + out
            else:
                out = "0" + out
            if i % 4 == 3:
                out = "_" + out
        return "0b" + out[1:]

    def verbose_x86(self):
        eflags = get_register("$eflags")
        gef_print("{:s}  {:s}".format(self.bits_split(eflags), Color.colorify("MASK", "bold")))

        def c(msg):
            mask = int(msg.split()[0], 16)
            if eflags & mask:
                color = "bold"
            else:
                color = ""
            return Color.colorify(msg, color)

        gef_print(" " * 14 + "|| |||| |||| |||| |||| |||+- " + c("0x000001 [CF]   Carry flag"))
        gef_print(" " * 14 + "|| |||| |||| |||| |||| ||+-- " + c("0x000002        Reserved (always 1)"))
        gef_print(" " * 14 + "|| |||| |||| |||| |||| |+--- " + c("0x000004 [PF]   Parity flag"))
        gef_print(" " * 14 + "|| |||| |||| |||| |||| +---- " + c("0x000008        Reserved (always 0)"))
        gef_print(" " * 14 + "|| |||| |||| |||| ||||")
        gef_print(" " * 14 + "|| |||| |||| |||| |||+------ " + c("0x000010 [AF]   Adjust flag (for BCD calc)"))
        gef_print(" " * 14 + "|| |||| |||| |||| ||+------- " + c("0x000020        Reserved (always 0)"))
        gef_print(" " * 14 + "|| |||| |||| |||| |+-------- " + c("0x000040 [ZF]   Zero flag"))
        gef_print(" " * 14 + "|| |||| |||| |||| +--------- " + c("0x000080 [SF]   Sign flag"))
        gef_print(" " * 14 + "|| |||| |||| ||||")
        gef_print(" " * 14 + "|| |||| |||| |||+----------- " + c("0x000100 [TF]   Trap flag (single step)"))
        gef_print(" " * 14 + "|| |||| |||| ||+------------ " + c("0x000200 [IF]   Interrupt enable flag"))
        gef_print(" " * 14 + "|| |||| |||| |+------------- " + c("0x000400 [DF]   Direction flag"))
        gef_print(" " * 14 + "|| |||| |||| +-------------- " + c("0x000800 [OF]   Overflow flag"))
        gef_print(" " * 14 + "|| |||| ||||")
        gef_print(" " * 14 + "|| |||| ||++---------------- " + c("0x003000 [IOPL] I/O privilege level (2bit)"))
        gef_print(" " * 14 + "|| |||| |+------------------ " + c("0x004000 [NT]   Nested task flag"))
        gef_print(" " * 14 + "|| |||| +------------------- " + c("0x008000        Reserved (always 0)"))
        gef_print(" " * 14 + "|| ||||")
        gef_print(" " * 14 + "|| |||+--------------------- " + c("0x010000 [RF]   Resume flag"))
        gef_print(" " * 14 + "|| ||+---------------------- " + c("0x020000 [VM]   Virtual 8086 mode flag"))
        gef_print(" " * 14 + "|| |+----------------------- " + c("0x040000 [AC]   Alignment check flag"))
        gef_print(" " * 14 + "|| +------------------------ " + c("0x080000 [VIF]  Virtual interrupt flag"))
        gef_print(" " * 14 + "||")
        gef_print(" " * 14 + "|+-------------------------- " + c("0x100000 [VIP]  Virtual interrupt pending"))
        gef_print(" " * 14 + "+--------------------------- " + c("0x200000 [ID]   Able to use CPUID instruction"))
        return

    def verbose_arm32(self):
        cpsr = get_register("$cpsr")
        gef_print("{:s}  {:s}".format(self.bits_split(cpsr), Color.colorify("MASK", "bold")))

        def c(msg):
            mask = int(msg.split()[0], 16)
            if cpsr & mask:
                color = "bold"
            else:
                color = ""
            return Color.colorify(msg, color)

        gef_print("  |||| |||| |||| |||| |||| |||| |||+-++++- " + c("0x0000001f [M]  Mode field (5bit)"))
        gef_print("  |||| |||| |||| |||| |||| |||| |||        " + "  User:0b10000 FIQ:0b10001 IRQ:0b10010")
        gef_print("  |||| |||| |||| |||| |||| |||| |||        " + "  Supervisor:0b10011 Monitor:0b10110 Abort:0b10111")
        gef_print("  |||| |||| |||| |||| |||| |||| |||        " + "  Hyp:0b11010 Undefined:0b11011 System:0b11111")
        gef_print("  |||| |||| |||| |||| |||| |||| |||")
        gef_print("  |||| |||| |||| |||| |||| |||| ||+------- " + c("0x00000020 [T]  Thumb execution state bit"))
        gef_print("  |||| |||| |||| |||| |||| |||| |+-------- " + c("0x00000040 [F]  FIQ mask bit"))
        gef_print("  |||| |||| |||| |||| |||| |||| +--------- " + c("0x00000080 [I]  IRQ mask bit"))
        gef_print("  |||| |||| |||| |||| |||| ||||")
        gef_print("  |||| |||| |||| |||| |||| |||+----------- " + c("0x00000100 [A]  Asynchronous abort mask bit"))
        gef_print("  |||| |||| |||| |||| |||| ||+------------ " + c("0x00000200 [E]  Endianness execution state bit"))
        gef_print("  |||| |++------------++++-++------------- " + c("0x0600fc00 [IT] If-Then execution state bits for Thumb IT instruction"))
        gef_print("  |||| |  | |||| ||||")
        gef_print("  |||| |  | |||| ++++--------------------- " + c("0x000f0000 [GE] Greater than or Equal flags for SIMD instruction"))
        gef_print("  |||| |  | ||||")
        gef_print("  |||| |  | ++++-------------------------- " + c("0x00f00000      Reserved"))
        gef_print("  |||| |  |")
        gef_print("  |||| |  +------------------------------- " + c("0x01000000 [J]  Jazelle bit"))
        gef_print("  |||| +---------------------------------- " + c("0x08000000 [Q]  Cumulative saturation bit"))
        gef_print("  ||||")
        gef_print("  |||+------------------------------------ " + c("0x10000000 [V]  Overflow condition flag"))
        gef_print("  ||+------------------------------------- " + c("0x20000000 [C]  Carry condition flag"))
        gef_print("  |+-------------------------------------- " + c("0x40000000 [Z]  Zero condition flag"))
        gef_print("  +--------------------------------------- " + c("0x80000000 [N]  Negative condition flag"))
        return

    def verbose_arm64(self):
        cpsr = get_register("$cpsr")
        gef_print("{:s}  {:s}".format(self.bits_split(cpsr), Color.colorify("MASK", "bold")))

        def c(msg):
            mask = int(msg.split()[0], 16)
            if cpsr & mask:
                color = "bold"
            else:
                color = ""
            return Color.colorify(msg, color)

        if ((cpsr >> 4) & 1) == 0: # AArch64 state
            gef_print("  |||| |||| |||| |||| |||| |||| |||| ||++- " + c("0x00000003 [M.SP]  Selected stack pointer (2bit)"))
            gef_print("  |||| |||| |||| |||| |||| |||| |||| ++--- " + c("0x0000000c [M.EL]  Exception level (2bit)"))
            gef_print("  |||| |||| |||| |||| |||| |||| ||||")
            gef_print("  |||| |||| |||| |||| |||| |||| |||+------ " + c("0x00000010 [M.S]   Execution state (AArch64:0, AArch32:1)"))
            gef_print("  |||| |||| |||| |||| |||| |||| ||+------- " + c("0x00000020         Reserved (always 0)"))
            gef_print("  |||| |||| |||| |||| |||| |||| |+-------- " + c("0x00000040 [F]     FIQ interrupt mask bit"))
            gef_print("  |||| |||| |||| |||| |||| |||| +--------- " + c("0x00000080 [I]     IRQ interrupt mask bit"))
            gef_print("  |||| |||| |||| |||| |||| ||||")
            gef_print("  |||| |||| |||| |||| |||| |||+----------- " + c("0x00000100 [A]     SError interrupt mask bit"))
            gef_print("  |||| |||| |||| |||| |||| ||+------------ " + c("0x00000200 [D]     Debug exception mask bit"))
            gef_print("  |||| |||| |||| |||| |||| ++------------- " + c("0x00000c00 [BTYPE] Branch Type Indicator when FEAT_BTI is implemented"))
            gef_print("  |||| |||| |||| |||| ||||")
            gef_print("  |||| |||| |||| |||| |||+---------------- " + c("0x00001000 [SSBS]  Speculative Store Bypass when FEAT_SSBS is implemented"))
            gef_print("  |||| |||| |||| ++++-+++----------------- " + c("0x000fe000         Reserved"))
            gef_print("  |||| |||| ||||")
            gef_print("  |||| |||| |||+-------------------------- " + c("0x00100000 [IL]    Illegal execution state"))
            gef_print("  |||| |||| ||+--------------------------- " + c("0x00200000 [SS]    Software step flag"))
            gef_print("  |||| |||| |+---------------------------- " + c("0x00400000 [PAN]   Privileged Access Never when FEAT_PAN is implemented"))
            gef_print("  |||| |||| +----------------------------- " + c("0x00800000 [UAO]   User Access Override when FEAT_UAO is implemented"))
            gef_print("  |||| ||||")
            gef_print("  |||| |||+------------------------------- " + c("0x01000000 [DIT]   Data Independent Timing when FEAT_DIT is implemented"))
            gef_print("  |||| ||+-------------------------------- " + c("0x02000000 [TCO]   Tag Check Override when FEAT_MTE is implemented"))
            gef_print("  |||| ++--------------------------------- " + c("0x0c000000         Reserved"))
            gef_print("  ||||")
            gef_print("  |||+------------------------------------ " + c("0x10000000 [V]     Overflow condition flag"))
            gef_print("  ||+------------------------------------- " + c("0x20000000 [C]     Carry condition flag"))
            gef_print("  |+-------------------------------------- " + c("0x40000000 [Z]     Zero condition flag"))
            gef_print("  +--------------------------------------- " + c("0x80000000 [N]     Negative condition flag"))
        else: # AArch32 state
            gef_print("  |||| |||| |||| |||| |||| |||| |||| ++++- " + c("0x0000000f [M.A32] AArch32 mode (4bit)"))
            gef_print("  |||| |||| |||| |||| |||| |||| ||||       " + "   User:0b0000 FIQ:0b0001 IRQ:0b0010")
            gef_print("  |||| |||| |||| |||| |||| |||| ||||       " + "   Supervisor:0b0011 Monitor:0b0110 Abort:0b0111")
            gef_print("  |||| |||| |||| |||| |||| |||| ||||       " + "   Hyp:0b1010 Undefined:0b1011 System:0b1111")
            gef_print("  |||| |||| |||| |||| |||| |||| ||||")
            gef_print("  |||| |||| |||| |||| |||| |||| |||+------ " + c("0x00000010 [M.S]   Execution state (AAch64:0, AArch32:1)"))
            gef_print("  |||| |||| |||| |||| |||| |||| ||+------- " + c("0x00000020 [T]     T32 instruction set (Thumb) state bit"))
            gef_print("  |||| |||| |||| |||| |||| |||| |+-------- " + c("0x00000040 [F]     FIQ interrupt mask bit"))
            gef_print("  |||| |||| |||| |||| |||| |||| +--------- " + c("0x00000080 [I]     IRQ interrupt mask bit"))
            gef_print("  |||| |||| |||| |||| |||| ||||")
            gef_print("  |||| |||| |||| |||| |||| |||+----------- " + c("0x00000100 [A]     SError interrupt mask bit"))
            gef_print("  |||| |||| |||| |||| |||| ||+------------ " + c("0x00000200 [E]     Endianness execution state bit"))
            gef_print("  |||| |++------------++++-++------------- " + c("0x0600fc00 [IT]    If-Then execution state bits for Thumb IT instruction"))
            gef_print("  |||| |  | |||| ||||")
            gef_print("  |||| |  | |||| ++++--------------------- " + c("0x000f0000 [GE]    Greater than or Equal flags for SIMD instruction"))
            gef_print("  |||| |  | ||||")
            gef_print("  |||| |  | |||+-------------------------- " + c("0x00100000 [IL]    Illegal execution state"))
            gef_print("  |||| |  | ||+--------------------------- " + c("0x00200000 [SS]    Software step flag"))
            gef_print("  |||| |  | |+---------------------------- " + c("0x00400000 [PAN]   Privileged Access Never when FEAT_PAN is implemented"))
            gef_print("  |||| |  | +----------------------------- " + c("0x00800000 [SSBS]  Speculative Store Bypass when FEAT_SBSS is implemented"))
            gef_print("  |||| |  |")
            gef_print("  |||| |  +------------------------------- " + c("0x01000000 [DIT]   Data Independent Timing when FEAT_DIT is implemented"))
            gef_print("  |||| +---------------------------------- " + c("0x08000000 [Q]     Overflow or saturation flag"))
            gef_print("  ||||")
            gef_print("  |||+------------------------------------ " + c("0x10000000 [V]     Overflow condition flag"))
            gef_print("  ||+------------------------------------- " + c("0x20000000 [C]     Carry condition flag"))
            gef_print("  |+-------------------------------------- " + c("0x40000000 [Z]     Zero condition flag"))
            gef_print("  +--------------------------------------- " + c("0x80000000 [N]     Negative condition flag"))
        return


@register_command
class MprotectCommand(GenericCommand):
    """Change a page permission. By default, it will change it to RWX."""
    _cmdline_ = "mprotect"
    _category_ = "05-a. Syscall - Invoke"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('location', metavar='LOCATION', type=parse_address, help='the address you want to change the permission.')
    parser.add_argument('permission', metavar='PERMISSION', nargs='?', default="rwx",
                        help='the permission you set to the LOCATION. (default: %(default)s)')
    parser.add_argument('--patch-only', action='store_true', help='do not execute after patch.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} $sp rwx".format(_cmdline_)

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    @load_keystone
    def do_invoke(self, args):
        self.dont_repeat()

        if re.match(r"[rwx-]{3}", args.permission):
            perm = Permission.NONE
            if args.permission[0] == "r":
                perm |= Permission.READ
            if args.permission[1] == "w":
                perm |= Permission.WRITE
            if args.permission[2] == "x":
                perm |= Permission.EXECUTE
        else:
            err("Invalid permission")
            return

        self.do_mprotect(args.location, perm, args.patch_only)
        return

    def do_mprotect(self, location, perm, patch_only):
        sect = process_lookup_address(location)
        if sect is None:
            err("Unmapped address")
            return

        size = sect.page_end - sect.page_start
        original_pc = current_arch.pc
        if is_arm32() and current_arch.is_thumb():
            original_pc -= 1

        fmt = "Generating sys_mprotect({:#x}, {:#x}, '{:s}') stub for arch {:s}"
        info(fmt.format(sect.page_start, size, str(Permission(value=perm)), get_arch()))
        stub = self.get_stub_by_arch(sect.page_start, size, perm)
        if stub is None:
            err("Failed to generate mprotect opcodes")
            return

        info("Saving original code")
        try:
            original_code = read_memory(original_pc, len(stub))
        except gdb.MemoryError:
            err("Failed to read memory")
            return

        info("Saving original registers value")
        try:
            original_regs = {}
            for r in current_arch.all_registers:
                v = get_register(r)
                original_regs[r] = v
        except Exception:
            err("Failed to read register")
            return

        bp_loc = "*{:#x}".format(original_pc + len(stub))
        info("Setting a restore breakpoint at {:s}".format(bp_loc))
        ChangePermissionBreakpoint(bp_loc, original_code, original_pc, original_regs)

        info("Overwriting current memory at {:#x} ({:d} bytes)".format(location, len(stub)))
        write_memory(original_pc, stub, len(stub))
        after_data = read_memory(original_pc, len(stub))
        if stub != after_data:
            err("Failed to write memory (qemu doesn't support writing to code area?)")
            return

        if patch_only:
            return

        info("Resuming execution")
        gdb.execute("continue")
        return

    def get_stub_by_arch(self, addr, size, perm):
        if hasattr(current_arch, "mprotect_asm_raw"):
            raw_insns = current_arch.mprotect_asm_raw(addr, size, perm)
        else:
            code = current_arch.mprotect_asm(addr, size, perm)
            if code is None:
                return None
            arch, mode = get_keystone_arch()
            raw_insns = keystone_assemble(code, arch, mode, raw=True)
        return raw_insns


@register_command
class CallSyscallCommand(GenericCommand):
    """A wrapper for calling syscall easily."""
    _cmdline_ = "call-syscall"
    _category_ = "05-a. Syscall - Invoke"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('syscall_name', metavar='SYSCALL_NAME',
                        help='system call name you want to invoke.')
    parser.add_argument('syscall_args', metavar='SYSCALL_ARG', nargs='*', type=parse_address,
                        help='arguments of system call.')
    _syntax_ = parser.format_help()

    _example_ = '{:s} write 1 "*(void**)($rsp+0x18)" 15'.format(_cmdline_)

    def get_state(self, code_len):
        d = {}

        # pc
        d["pc"] = current_arch.pc
        if is_arm32() and current_arch.is_thumb() and d["pc"] & 1:
            d["pc"] -= 1

        # code
        d["code"] = read_memory(d["pc"], code_len)

        # reg
        d["reg"] = {}
        for reg in current_arch.all_registers:
            d["reg"][reg] = get_register(reg)

        # mem
        if is_mips32():
            d["mem"] = {}
            for offset in [0x10, 0x14, 0x18, 0x1c]:
                d["mem"][offset] = read_memory(current_arch.sp + offset, 4)
        if is_cris():
            d["mem"] = {}
            for offset in [0x1c]:
                d["mem"][offset] = read_memory(current_arch.sp + offset, 4)
        return d

    def revert_state(self, d):
        # code
        write_memory(d["pc"], d["code"], len(d["code"]))

        # reg
        for reg, v in d["reg"].items():
            if get_register(reg) == v:
                continue
            if is_sh4() and reg in ["$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7"]:
                reg = reg + "b0" # since r0-r7 cannot be changed directly, use bank 0
            try:
                gdb.execute("set {:s} = {:#x}".format(reg, v), to_string=True)
            except Exception:
                info("set {:s} = {:#x} is failed".format(reg, v))
                pass

        # mem
        if is_mips32():
            for offset in [0x10, 0x14, 0x18, 0x1c]:
                if read_memory(current_arch.sp + offset, 4) == d["mem"][offset]:
                    continue
                write_memory(current_arch.sp + offset, d["mem"][offset], 4)
        if is_cris():
            for offset in [0x1c]:
                if read_memory(current_arch.sp + offset, 4) == d["mem"][offset]:
                    continue
                write_memory(current_arch.sp + offset, d["mem"][offset], 4)
        return

    def close_stdout(self):
        self.stdout = 1
        self.stdout_bak = os.dup(self.stdout)
        f = open("/dev/null")
        os.dup2(f.fileno(), self.stdout)
        f.close()
        return

    def revert_stdout(self):
        os.dup2(self.stdout_bak, self.stdout)
        os.close(self.stdout_bak)
        return

    def syscall_execute(self, nr, syscall_args):
        if is_big_endian():
            code = current_arch.infloop_insn[::-1] # to stop another thread
            if current_arch.has_delay_slot:
                code += current_arch.nop_insn[::-1]
            code += current_arch.syscall_insn[::-1]
            if is_s390x() and nr <= 127:
                code = code[:-1] + bytes([nr])
            if current_arch.has_syscall_delay_slot:
                code += current_arch.nop_insn[::-1]
        else:
            code = current_arch.infloop_insn # to stop another thread
            if current_arch.has_delay_slot:
                code += current_arch.nop_insn
            code += current_arch.syscall_insn
            if current_arch.has_syscall_delay_slot:
                code += current_arch.nop_insn

        # backup
        gef_on_stop_unhook(hook_stop_handler)
        d = self.get_state(len(code))

        # modify syscall args
        if is_mips32():
            syscall_parameters = current_arch.syscall_parameters_o32
        else:
            syscall_parameters = current_arch.syscall_parameters
        for reg, val in zip(syscall_parameters, syscall_args):
            if is_mips32() and "+" in reg:
                reg, off = reg.split("+")
                write_memory(get_register(reg) + int(off, 16), p32(val), 4)
            else:
                if is_sh4() and reg in ["$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7"]:
                    reg = reg + "b0" # since r0-r7 cannot be changed directly, use bank 0
                gdb.execute("set {:s} = {:#x}".format(reg, val), to_string=True)

        # modify syscall register
        if is_s390x():
            if nr > 127: # embedded in instruction
                reg = current_arch.syscall_register[1]
                gdb.execute("set {:s} = {:#x}".format(reg, nr), to_string=True)
        else:
            reg = current_arch.syscall_register
            if is_sh4() and reg in ["$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7"]:
                reg = reg + "b0" # since r0-r7 cannot be changed directly, use bank 0
            gdb.execute("set {:s} = {:#x}".format(reg, nr), to_string=True)

        # modify code
        write_memory(d["pc"], code, len(code))

        # skip infloop
        dst = d["pc"] + len(current_arch.infloop_insn)
        if current_arch.has_delay_slot:
            dst += len(current_arch.nop_insn)

        if is_hppa32() or is_hppa64():
            gdb.execute("set $pcoqh = {:#x}".format(dst), to_string=True)
            dst2 = dst + len(current_arch.syscall_insn)
            gdb.execute("set $pcoqt = {:#x}".format(dst2), to_string=True)
        elif is_sparc32() or is_sparc64():
            gdb.execute("set $pc = {:#x}".format(dst), to_string=True)
            dst2 = dst + len(current_arch.syscall_insn)
            gdb.execute("set $npc = {:#x}".format(dst2), to_string=True)
        else:
            gdb.execute("set $pc = {:#x}".format(dst), to_string=True)

        # exec
        self.close_stdout()
        if is_hppa32() or is_hppa64():
            step = 3 # syscall, delay slot, trampoline
        else:
            step = 1
        gdb.execute("stepi {:d}".format(step), to_string=True)
        ret = get_register(current_arch.return_register)

        # revert
        self.revert_stdout()
        self.revert_state(d)
        gef_on_stop_hook(hook_stop_handler)
        return ret

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        if current_arch is None:
            err("current_arch is not set.")
            return

        try:
            syscall_table = get_syscall_table(None, None)
        except Exception:
            err("syscall table does not exist")
            return

        syscall_name = args.syscall_name
        syscall_args = args.syscall_args

        for key, entry in syscall_table.table.items():
            if is_mips32() and key > 6000: # force use o32
                continue
            if syscall_name == entry.name:
                syscall_params = entry.params
                nr = key
                break
        else:
            err("System call `{:s}` is not found.".format(syscall_name))
            return

        if len(syscall_params) != len(syscall_args):
            err("Argument count mismatch.")
            params = "(" + ', '.join([param.param for param in syscall_params]) + ");"
            gef_print("Prototype: {:s}{:s}".format(Color.boldify(syscall_name), params))
            return

        title = "{:s}({:s})".format(syscall_name, ', '.join(["{:#x}".format(x) for x in syscall_args]))
        gef_print(titlify(title))
        ret = self.syscall_execute(nr, syscall_args)
        gef_print("{:s} = {:#x}".format(current_arch.return_register, ret))
        return


@register_command
class MmapMemoryCommand(GenericCommand):
    """Allocate a new memory (syntax sugar of `call mmap(...)`)."""
    _cmdline_ = "mmap"
    _category_ = "05-a. Syscall - Invoke"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('location', metavar='LOCATION', nargs='?', type=parse_address, default=0,
                        help='the address you want to allocate. (default: %(default)s)')
    parser.add_argument('size', metavar='SIZE', nargs='?', type=parse_address, default=gef_getpagesize(),
                        help='the size you want to allocate. (default: %(default)s)')
    parser.add_argument('permission', metavar='PERMISSION', nargs='?', default="rwx",
                        help='the permission you want to allocate. `_` is interpreted as `-`. (default: %(default)s)')
    _syntax_ = parser.format_help()

    _example_ = "{:s} 0x10000 0x1000 r-x\n".format(_cmdline_)
    _example_ += "{:s} 0 0x1000 _wx".format(_cmdline_)

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        # get mmap symbol
        try:
            parse_address("mmap")
        except gdb.error:
            err("Not found mmap function")
            return

        # location
        if args.location % gef_getpagesize():
            err("Address is not a multiple of {:#x}".format(gef_getpagesize()))
            return

        # size
        if args.size % gef_getpagesize():
            err("Size is not a multiple of {:#x}".format(gef_getpagesize()))
            return

        # permission
        if re.match(r"[-_r][-_w][-_x]", args.permission):
            perm = Permission.NONE
            if args.permission[0] == "r":
                perm |= Permission.READ
            if args.permission[1] == "w":
                perm |= Permission.WRITE
            if args.permission[2] == "x":
                perm |= Permission.EXECUTE
        else:
            err("Invalid permission")
            return

        # flags
        flags = 0x22 # MAP_ANONYMOUS | MAP_PRIVATE
        if args.location != 0:
            flags |= 0x10 # MAP_FIXED
        if is_mips32() or is_mips64():
            flags |= 0x800 # MAP_DENYWRITE (why?)

        # doit
        cmd = "call mmap({:#x}, {:#x}, {:#x}, {:#x}, -1, 0)".format(args.location, args.size, perm, flags)
        gef_print(titlify(cmd))
        gdb.execute(cmd)
        reset_gef_caches()
        return


@register_command
class UnicornEmulateCommand(GenericCommand):
    """Use Unicorn-Engine to emulate the behavior of the binary."""
    _cmdline_ = "unicorn-emulate"
    _category_ = "01-d. Debugging Support - Execution"
    _aliases_ = ["emulate"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-f', dest='from_location', type=parse_address,
                        help='specifies the start address of the emulated run. (default: current_arch.pc)')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-t', dest='to_location', type=parse_address, help='specifies the end address of the emulated run.')
    group.add_argument('-n', dest='nb_insn', type=parse_address, help='indicates the number of instructions to execute.')
    group.add_argument('-g', dest='nb_gadget', type=parse_address, help='indicates the number of gadgets to execute.')
    parser.add_argument('-o', dest='output_path', help='writes the persistent Unicorn script into this file.')
    parser.add_argument('-s', dest='skip_emulation', action='store_true', help='do not run it, just script it.')
    parser.add_argument('-v', dest='verbose', action='store_true', help='displays the register values for each instruction is executed.')
    parser.add_argument('-q', dest='quiet', action='store_true', help='quiet execution.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} -n 5                         # from $pc to 5 later asm\n".format(_cmdline_)
    _example_ += "{:s} -g 4                         # from $pc to the point where 4 instructions are executed\n".format(_cmdline_)
    _example_ += "{:s} -t 0x805678a4 -o /tmp/emu.py # from/to specified address with saving script\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "NOTE:\n"
    _example_ += "* unicorn does not support some instructions (ex: xsavec, xrstor, vpbroadcastb, etc)\n"
    _example_ += "* unicorn does not emulate ARM kernel-provided-user-helpers like $pc=0xffff0fe0, 0xffff0fc0, etc.\n"
    _example_ += "  see: https://www.kernel.org/doc/Documentation/arm/kernel_user_helpers.txt"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    @load_capstone
    @load_unicorn
    def do_invoke(self, args):
        self.dont_repeat()

        if current_arch.unicorn_support is False:
            warn("This command cannot work under this architecture.")
            return

        start_insn = args.from_location
        if start_insn is None:
            start_insn = current_arch.pc

        thumb_mode = False
        if is_arm32():
            thumb_mode = start_insn & 1

        if args.to_location is None and args.nb_insn is None and args.nb_gadget is None:
            err("No stop condition (-t|-n|-g) defined.")
            return

        end_insn = args.to_location
        if args.nb_insn is not None:
            end_insn = self.get_unicorn_end_addr(start_insn, args.nb_insn)

        kwargs = {
            "skip_emulation": args.skip_emulation,
            "to_file": args.output_path,
            "verbose": args.verbose,
            "nb_gadget": args.nb_gadget,
            "quiet": args.quiet,
            "thumb_mode": thumb_mode,
        }

        if end_insn is not None:
            self.run_unicorn(start_insn, end_insn, **kwargs)
        elif args.nb_gadget is not None:
            self.run_unicorn(start_insn, 0, **kwargs)
        else:
            err("Invalid argumetns")
        return

    def get_unicorn_end_addr(self, start_addr, nb):
        dis = list(gef_disassemble(start_addr, nb + 1))
        last_insn = dis[-1]
        return last_insn.address

    def run_unicorn(self, start_insn_addr, end_insn_addr, *args, **kwargs):
        arch, mode = get_unicorn_arch(to_string=True)
        unicorn_registers = get_unicorn_registers(to_string=True)
        cs_arch, cs_mode = get_capstone_arch(to_string=True)

        pythonbin = which("python3")
        if is_remote_debug():
            filepath = gdb.current_progspace().filename
            if filepath.startswith("target:"):
                filepath = filepath[7:]
            filename = os.path.basename(filepath)
        else:
            filename = get_filename()

        content = "#!{:s} -i\n".format(pythonbin)
        content += "#\n"
        content += "# Emulation script for '{:s}'".format(filename)
        if kwargs["nb_gadget"]:
            content += " from {:#x} to after {:#x} gadgets\n".format(start_insn_addr, kwargs["nb_gadget"])
        else:
            content += " from {:#x} to {:#x}\n".format(start_insn_addr, end_insn_addr)
        content += "#\n"
        content += "# Powered by gef, unicorn-engine, and capstone-engine\n"
        content += "#\n"
        content += "# original:  by @_hugsy_\n"
        content += "# improvement: by @bata_24\n"
        content += "#\n"
        content += "from __future__ import print_function\n"
        content += "import sys\n"
        content += "import traceback\n"
        content += "import collections\n"
        content += "import capstone\n"
        content += "import unicorn\n"
        if is_ppc64() or is_ppc32():
            content += "import unicorn.ppc_const\n"
        elif is_riscv32() or is_riscv64():
            content += "import unicorn.riscv_const\n"
        elif is_s390x():
            content += "import unicorn.s390x_const\n"
        content += "\n"

        content += "registers = collections.OrderedDict({\n"
        for r in unicorn_registers:
            content += "    '{:s}': {:s},\n".format(r.strip(), unicorn_registers[r])
        content += "})\n"
        content += "uc = None\n"
        content += "verbose = {:s}\n".format(str(kwargs["verbose"]))
        content += "quiet = {:s}\n".format(str(kwargs["quiet"]))
        content += "syscall_register = '{:s}'\n".format(current_arch.syscall_register)
        content += "count = 0\n"
        content += "changed_mem = {}\n"
        if is_arm32():
            content += "enable_thumb = {:d}\n".format(int(kwargs["thumb_mode"]))
            content += "\n"
            content += "\n"
            content += "def thumb_check(emu, insn):\n"
            content += "    global enable_thumb\n"
            content += "    if insn.mnemonic in ['blx', 'bx']:\n"
            content += "        enable_thumb = emu.reg_read(registers['$' + insn.op_str]) & 1\n"
            content += "    return\n"

            # hack: unicorn can handle if thumb or not, but capstone can't.
            # we have to handle it manually for capstone.
            # since CS_MODE_ARM is 0x0, it can be ignored. we represent
            # status of thumb: CS_MODE_THUMB * (0 or 1).
            endian = cs_mode.split(" + ")[-1]
            cs_mode = "capstone.CS_MODE_THUMB * enable_thumb + " + endian

        content += "\n"
        content += "\n"
        content += "def disassemble(code, addr):\n"
        content += "    cs = capstone.Cs({:s}, {:s})\n".format(cs_arch, cs_mode)
        content += "    for i in cs.disasm(code, addr):\n"
        content += "        return i\n"
        content += "\n"
        content += "\n"
        content += "def code_hook(emu, address, size, user_data):\n"
        content += "    global count\n"
        content += "    if not quiet:\n"
        # min() is the workaround since unicorn passes 0xf1f1f1f1 as size if opcode is unsupported.
        # The execution will be failed, but the information of the error message increases.
        content += "        code = emu.mem_read(address, min(size, 0x10))\n"
        content += "        insn = disassemble(code, address)\n"
        content += "        code_hex = code[:insn.size].hex()\n"
        content += "        if verbose:\n"
        content += "            print_regs(emu, registers)\n"
        content += "        fmt = '>>> {:d} {:#x}: {:24s} {:s} {:s}'\n"
        content += "        print(fmt.format(count, insn.address, code_hex, insn.mnemonic, insn.op_str))\n"
        if is_arm32():
            content += "        thumb_check(emu, insn)\n"
        content += "    count += 1\n"
        content += "    return\n"
        content += "\n"
        content += "\n"
        content += "def mem_invalid_hook(emu, access, address, size, value, user_data):\n"
        content += "    if access == unicorn.UC_MEM_WRITE_INVALID:\n"
        content += "        fmt = '  --> Invalid memory access; addr:{:#x}, size:{:#x}, value:{:#x}'\n"
        content += "        print(fmt.format(address, size, value))\n"
        content += "    elif access == unicorn.UC_MEM_READ_INVALID:\n"
        content += "        fmt = '  --> Invalid memory access; addr:{:#x}, size:{:#x}'\n"
        content += "        print(fmt.format(address, size))\n"
        content += "    return\n"
        content += "\n"
        content += "\n"
        content += "def mem_write_hook(emu, access, address, size, value, user_data):\n"
        content += "    before = emu.mem_read(address, size)\n"
        content += "    for i in range(size):\n"
        content += "        accessed_address = address + i\n"
        content += "        if accessed_address not in changed_mem:\n"
        content += "            changed_mem[accessed_address] = {}\n"
        content += "            changed_mem[accessed_address]['before'] = before[i]\n"
        content += "        changed_mem[accessed_address]['after'] = (value >> (8 * i)) & 0xff\n"
        content += "        changed_mem[accessed_address]['type'] = 'modified'\n"
        content += "    return\n"
        content += "\n"
        content += "\n"
        content += "def intr_hook(emu, intno, data):\n"
        content += "    print('  --> interrupt={:d}'.format(intno))\n"
        content += "    raise\n"
        content += "\n"
        content += "\n"
        content += "def syscall_hook(emu, user_data):\n"
        content += "    sysno = emu.reg_read(registers[syscall_register])\n"
        content += "    print('  --> syscall={:d} (not emulated)'.format(sysno))\n"
        content += "    return\n"
        content += "\n"
        content += "\n"
        content += "def print_regs(emu, regs):\n"
        content += "    for i, r in enumerate(regs):\n"
        content += "        fmt = '{{:7s}} = {{:#0{:d}x}}  '\n".format(current_arch.ptrsize * 2 + 2)
        content += "        print(fmt.format(r, emu.reg_read(regs[r])), end='')\n"
        content += "        if (i % 4 == 3) or (i == len(regs) - 1):\n"
        content += "            print('')\n"
        content += "    return\n"
        content += "\n"
        content += "\n"
        content += "def print_mems(emu):\n"
        content += "    aligned_addrs = set([x & ~0xf for x in changed_mem.keys()])\n"
        content += "    for aligned_addr in aligned_addrs:\n"
        content += "        for pad_addr in range(aligned_addr, aligned_addr + 0x10):\n"
        content += "            if pad_addr in changed_mem:\n"
        content += "                pass\n"
        content += "            else:\n"
        content += "                changed_mem[pad_addr] = {}\n"
        content += "                changed_mem[pad_addr]['before'] = emu.mem_read(pad_addr, 1)[0]\n"
        content += "                changed_mem[pad_addr]['after'] = emu.mem_read(pad_addr, 1)[0]\n"
        content += "                changed_mem[pad_addr]['type'] = None\n"
        content += "    sorted_data = sorted(changed_mem.items())\n"
        content += "    sliced = [sorted_data[i:i + 16] for i in range(0, len(sorted_data), 16)]\n"
        content += "    prev_address = None\n"
        content += "    for chunk in sliced:\n"
        content += "        address = chunk[0][0]\n"
        content += "        prefix = '{:#018x}'.format(address)\n"
        content += "        before = ''\n"
        content += "        after = ''\n"
        content += "        for i in range(16):\n"
        content += "            a = chunk[i][1]['after']\n"
        content += "            b = chunk[i][1]['before']\n"
        content += "            if a == b:\n"
        content += "                if chunk[i][1]['type'] is None:\n"
        content += "                    before += '{:02x} '.format(b)\n"
        content += "                    after += '{:02x} '.format(a)\n"
        content += "                else:\n"
        content += "                    before += '\033[2m{:02x}\033[0m '.format(b)\n"
        content += "                    after += '\033[2m{:02x}\033[0m '.format(a)\n"
        content += "            else:\n"
        content += "                before += '\033[2m\033[1m{:02x}\033[0m '.format(b)\n"
        content += "                after += '\033[2m\033[1m{:02x}\033[0m '.format(a)\n"
        content += "        line = '{:s} | {:s}| {:s}|'.format(prefix, before, after)\n"
        content += "        if prev_address is not None and prev_address + 0x10 != address:\n"
        content += "            print('*')\n"
        content += "        print(line)\n"
        content += "        prev_address = address\n"
        content += "    print('\033[2m00\033[0m: write accessed, ', end='')\n"
        content += "    print('\033[2m\033[1m00\033[0m: value changes')\n"
        content += "    return\n"

        if is_x86():
            # need to handle segmentation (and pagination) via MSR
            content += "\n"
            content += "\n"
            content += "# from https://github.com/unicorn-engine/unicorn/blob/master/tests/regress/x86_64_msr.py\n"
            content += "SCRATCH_ADDR = 0xf000\n"
            content += "FSMSR = 0xC0000100\n"
            content += "GSMSR = 0xC0000101\n"
            content += "\n"
            content += "\n"
            content += "def set_msr(uc, msr, value, scratch=SCRATCH_ADDR):\n"
            content += "    buf = b'\\x0f\\x30' # x86: wrmsr\n"
            content += "    uc.mem_map(scratch, 0x1000)\n"
            content += "    uc.mem_write(scratch, buf)\n"
            content += "    uc.reg_write(unicorn.x86_const.UC_X86_REG_RAX, value & 0xFFFFFFFF)\n"
            content += "    uc.reg_write(unicorn.x86_const.UC_X86_REG_RDX, (value >> 32) & 0xFFFFFFFF)\n"
            content += "    uc.reg_write(unicorn.x86_const.UC_X86_REG_RCX, msr & 0xFFFFFFFF)\n"
            content += "    uc.emu_start(scratch, scratch+len(buf), count=1)\n"
            content += "    uc.mem_unmap(scratch, 0x1000)\n"
            content += "    return\n"
            content += "\n"
            content += "\n"
            content += "def set_gs(uc, addr):\n"
            content += "    return set_msr(uc, GSMSR, addr)\n"
            content += "\n"
            content += "\n"
            content += "def set_fs(uc, addr):\n"
            content += "    return set_msr(uc, FSMSR, addr)\n"

        content += "\n"
        content += "\n"
        content += "def reset():\n"
        content += "    emu = unicorn.Uc({arch}, {mode})\n".format(arch=arch, mode=mode)

        if is_x86():
            content += "\n"
            content += "\n"
            content += "    set_fs(emu, {:#x})\n".format(TlsCommand.getfs() if is_x86_64() else 0)
            content += "    set_gs(emu, {:#x})\n".format(TlsCommand.getgs() if is_x86_32() else 0)

        if kwargs["verbose"]:
            info("Duplicating registers")

        if is_arm32() or is_arm64():
            # need first. because other register values may be broken when $cpsr is set
            gregval = get_register("$cpsr")
            content += "    emu.reg_write({:s}, {:#x})\n".format(unicorn_registers["$cpsr"], gregval)
        for r in current_arch.all_registers:
            if is_x86_64() and r == "$fs":
                continue
            if is_x86_32() and r == "$gs":
                continue
            if (is_arm32() or is_arm64()) and r == "$cpsr":
                continue
            if r not in unicorn_registers:
                continue
            gregval = get_register(r)
            content += "    emu.reg_write({:s}, {:#x})\n".format(unicorn_registers[r], gregval)
        content += "\n"

        reset_gef_caches(all=True)

        vmmap = get_process_maps()
        if not vmmap:
            warn("An error occurred when reading memory map.")
            return

        if kwargs["verbose"]:
            info("Duplicating memory map")

        for sect in vmmap:
            if sect.path == "[vvar]":
                # this section is for GDB only, skip it
                continue

            content += "    # Mapping {:s}: {:#x}-{:#x}\n".format(sect.path, sect.page_start, sect.page_end)
            content += "    emu.mem_map({:#x}, {:#x}, {})\n".format(sect.page_start, sect.size, oct(sect.permission.value))

            if sect.permission & Permission.READ:
                code = read_memory(sect.page_start, sect.size)
                loc = os.path.join(GEF_TEMP_DIR, "unicorn-emulate-{:s}-{:#x}.raw".format(filename, sect.page_start))
                open(loc, "wb").write(bytes(code))
                content += "    emu.mem_write({:#x}, open('{:s}', 'rb').read())\n".format(sect.page_start, loc)
                content += "\n"

        content += "    emu.hook_add(unicorn.UC_HOOK_CODE, code_hook)\n"
        content += "    emu.hook_add(unicorn.UC_HOOK_INTR, intr_hook)\n"
        if is_x86_64():
            content += "    emu.hook_add(unicorn.UC_HOOK_INSN, syscall_hook, None, 1, 0, unicorn.x86_const.UC_X86_INS_SYSCALL)\n"
        content += "    emu.hook_add(unicorn.UC_HOOK_MEM_READ_INVALID | unicorn.UC_HOOK_MEM_WRITE_INVALID, mem_invalid_hook)\n"
        content += "    emu.hook_add(unicorn.UC_HOOK_MEM_WRITE, mem_write_hook)\n"
        content += "    return emu\n"

        content += "\n"
        content += "\n"
        content += "def emulate(emu, start_addr, end_addr, count):\n"
        content += "    print('========================= Initial registers =========================')\n"
        content += "    print_regs(emu, registers)\n"
        content += "\n"
        content += "    try:\n"
        content += "        print('========================= Starting emulation =========================')\n"
        content += "        emu.emu_start(start_addr, end_addr, count=count)\n"
        content += "    except Exception:\n"
        content += "        emu.emu_stop()\n"
        content += "        print('========================= Emulation failed =========================')\n"
        content += "        traceback.print_exc(file=sys.stdout)\n"
        content += "\n"
        content += "    print('========================= Final registers =========================')\n"
        content += "    print_regs(emu, registers)\n"
        content += "    print('========================= Modified memories (before | after) =========================')\n"
        content += "    print_mems(emu)\n"
        content += "    return\n"
        content += "\n"
        content += "\n"
        content += "uc = reset()\n"
        content += "emulate(uc, {:#x}, {:#x}, {:#x})\n".format(start_insn_addr, end_insn_addr, kwargs["nb_gadget"] or -1)
        content += "\n"
        content += "\n"
        content += "# unicorn-engine script generated by gef\n"

        if kwargs["to_file"]:
            tmp_filename = kwargs["to_file"]
            tmp_fd_ = open(kwargs["to_file"], "w")
            tmp_fd = tmp_fd_.fileno()
        else:
            tmp_fd, tmp_filename = tempfile.mkstemp(dir=GEF_TEMP_DIR, suffix=".py", prefix="gef-uc-")
        os.write(tmp_fd, gef_pybytes(content))
        os.close(tmp_fd)
        if kwargs["to_file"] or kwargs["skip_emulation"]:
            info("Unicorn script generated as '{:s}'".format(tmp_filename))
            os.chmod(tmp_filename, 0o700)

        if kwargs["skip_emulation"]:
            return

        if kwargs["nb_gadget"] is None:
            fmt = "Starting emulation: {:#x} {:s} {:#x}"
            ok(fmt.format(start_insn_addr, RIGHT_ARROW, end_insn_addr))
        else:
            fmt = "Starting emulation: {:#x} {:s} after {:d} instructions are executed"
            ok(fmt.format(start_insn_addr, RIGHT_ARROW, kwargs["nb_gadget"]))

        try:
            res = gef_execute_external([pythonbin, tmp_filename], as_list=True)
            gef_print("\n".join(res))
        except subprocess.CalledProcessError as e:
            gef_print(e.output.decode("utf-8").rstrip())

        if not kwargs["to_file"]:
            os.unlink(tmp_filename)
        return


@register_command
class StubCommand(GenericCommand):
    """Stub out the specified function to skip it. (ex: fork)."""
    _cmdline_ = "stub"
    _category_ = "03-c. Memory - Patch"
    _aliases_ = ["deactive"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-r', dest='retval', type=int, default=0, help='the return value from stub. (default: %(default)s)')
    parser.add_argument('location', metavar='LOCATION', type=parse_address, help='address/symbol to stub out.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} -r 0 fork".format(_cmdline_)

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()
        loc = "*{:#x}".format(args.location)
        StubBreakpoint(loc, args.retval)
        return


@register_command
class CapstoneDisassembleCommand(GenericCommand):
    """Use capstone disassembly framework to disassemble code."""
    _cmdline_ = "capstone-disassemble"
    _category_ = "01-e. Debugging Support - Assemble"
    _aliases_ = ["cs-dis"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('location', metavar='LOCATION', nargs='?', type=parse_address,
                        help='the address you want to disassemble. (default: current_arch.pc)')
    parser.add_argument('-l', dest='length', type=parse_address,
                        help='the length you want to disassemble. (default: context.nb_lines_code)')
    parser.add_argument('--code', help='disassemble specific code bytes.')
    parser.add_argument('args', metavar='ARGS', nargs='*', help='arguments for capstone. see following example.')
    _syntax_ = parser.format_help()

    valid_arch_modes = {
        "ARM" : ["ARM", "THUMB"],
        "ARM64" : ["ARM"],
        "MIPS" : ["MIPS32", "MIPS64"],
        "PPC" : ["PPC32", "PPC64"],
        "SPARC" : ["SPARC32", "SPARC64"],
        "X86" : ["16", "32", "64"],
    }

    _example_ = "{:s} $pc -l 50                            # dump from $pc up to 50 lines later\n".format(_cmdline_)
    _example_ += "{:s} $pc -l 50 arch=ARM mode=ARM endian=1 # specify arch, mode and endian (1:big endian)\n".format(_cmdline_)
    _example_ += '{:s} code="9090"                          # disassemble specified byte patterns\n'.format(_cmdline_)
    _example_ += "\n"
    _example_ += "Available architectures and modes:\n"
    for arch in valid_arch_modes:
        _example_ += " - {:8s} {}\n".format(arch, " / ".join(valid_arch_modes[arch]))

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @parse_args
    @only_if_gdb_running
    @load_capstone
    def do_invoke(self, args):
        if args.length is None:
            length = int(get_gef_setting("context.nb_lines_code"))
        else:
            length = args.length

        kwargs = {}
        for arg in args.args:
            if "=" in arg:
                key, value = arg.split("=", 1)
                kwargs[key] = value
            else:
                err("ARGS must be KEY=VALUE style")
                return

        if args.code:
            kwargs["code"] = args.code
            if args.location is None:
                location = 0
            else:
                location = args.location
        else:
            if args.location is None:
                location = current_arch.pc
            else:
                location = args.location

        try:
            skip = length * self.repeat_count
            for insn in capstone_disassemble(location, length, skip=skip, **kwargs):
                text_insn = "{:12o}".format(insn)
                msg = ""
                if insn.address == current_arch.pc:
                    msg = Color.colorify("{}  {}".format(RIGHT_ARROW, text_insn), "bold red")
                    reason = self.capstone_analyze_pc(insn, length)[0]
                    if reason:
                        gef_print(msg)
                        gef_print(reason)
                        break
                else:
                    msg = "{} {}".format(" " * 5, text_insn)
                gef_print(msg)
        except AttributeError:
            err("Maybe unsupported architecture")
        except gdb.error:
            pass
        return

    def capstone_analyze_pc(self, insn, nb_insn):
        if current_arch.is_conditional_branch(insn):
            is_taken, reason = current_arch.is_branch_taken(insn)
            if is_taken:
                reason = "[Reason: {:s}]".format(reason) if reason else ""
                msg = Color.colorify("\tTAKEN {:s}".format(reason), "bold green")
            else:
                reason = "[Reason: !({:s})]".format(reason) if reason else ""
                msg = Color.colorify("\tNOT taken {:s}".format(reason), "bold red")
            return (is_taken, msg)

        if current_arch.is_call(insn):
            try:
                target_address = int(insn.operands[-1].split()[0], 16)
                msg = []
                for i, new_insn in enumerate(capstone_disassemble(target_address, nb_insn)):
                    msg.append("   {}  {}".format(DOWN_ARROW if i == 0 else " ", str(new_insn)))
                return (True, "\n".join(msg))
            except Exception:
                pass

        return (False, "")


@register_command
class PdisasCommand(GenericCommand):
    """Shortcut `cs-dis -l 50`."""
    _cmdline_ = "pdisas"
    _category_ = "01-e. Debugging Support - Assemble"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('location', metavar='LOCATION', nargs='?', type=parse_address,
                        help='the address you want to disassemble. (default: current_arch.pc)')
    parser.add_argument('-l', dest='length', type=parse_address, default=50,
                        help='the length you want to disassemble. (default: %(default)s)')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        if args.location is None:
            location = ""
        else:
            location = "{:#x}".format(args.location)
        gdb.execute("cs-dis {:s} -l {:d}".format(location, args.length))
        return


@register_command
class GlibcHeapCommand(GenericCommand):
    """Base command to get information about the Glibc heap structure."""
    _cmdline_ = "heap"
    _category_ = "06-a. Heap - Glibc"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    subparsers = parser.add_subparsers(title='command', required=True)
    subparsers.add_parser('arena')
    subparsers.add_parser('arenas')
    subparsers.add_parser('bins')
    subparsers.add_parser('chunk')
    subparsers.add_parser('chunks')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(prefix=True)
        return

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()
        return


@register_command
class GlibcHeapArenasCommand(GenericCommand):
    """List up heap arenas."""
    _cmdline_ = "heap arenas"
    _category_ = "06-a. Heap - Glibc"
    _aliases_ = ["arenas"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        arena = get_main_arena()
        if arena is None:
            err("Could not find Glibc main arena")
            return

        gef_print(titlify("main_arena"))
        gef_print("{}".format(arena))

        gef_print(titlify("thread_arena"))
        arena = arena.get_next()
        if arena is None:
            gef_print("Not found")
        while arena:
            gef_print("{}".format(arena))
            arena = arena.get_next()
        return


@register_command
class GlibcHeapArenaCommand(GenericCommand):
    """Display information on a heap arena."""
    _cmdline_ = "heap arena"
    _category_ = "06-a. Heap - Glibc"
    _aliases_ = ["arena"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-a', dest='arena_addr', type=parse_address,
                        help='the address you want to interpret as an arena. (default: main_arena)')
    parser.add_argument('-n', '--no-pager', action='store_true', help='do not use less.')
    _syntax_ = parser.format_help()

    def parse_arena(self, arena):
        if arena is None:
            return []

        if cached_lookup_type("struct malloc_state") is None:
            return []

        try:
            out = []
            cmd = "p ((struct malloc_state*) {:#x})[0]".format(arena.addr)
            title = titlify("[arena] ----- {:s}".format(cmd))
            out.append(title)
            result = gdb.execute(cmd, to_string=True)
            out.append(result)
        except gdb.error:
            return []
        return out

    def parse_mp(self):
        try:
            mp = parse_address("&mp_")
        except gdb.error:
            return []

        if cached_lookup_type("struct malloc_par") is None:
            return []

        try:
            out = []
            cmd = "p ((struct malloc_par*) {:#x})[0]".format(mp)
            title = titlify("[mp_] ----- {:s}".format(cmd))
            out.append(title)
            result = gdb.execute(cmd, to_string=True)
            out.append(result)
        except gdb.error:
            return []
        return out

    def parse_heap_info(self, arena):
        if arena is None:
            return []

        if cached_lookup_type("struct _heap_info") is None:
            return []

        if arena.is_main_arena():
            return []

        try:
            out = []
            cmd = "p ((struct _heap_info*) {:#x})[0]".format(arena.addr & ~0xfff)
            title = titlify("[heap_info] ----- {:s}".format(cmd))
            out.append(title)
            result = gdb.execute(cmd, to_string=True)
            out.append(result)
        except gdb.error:
            return []
        return out

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()
        if args.arena_addr:
            arena = get_thread_arena(args.arena_addr)
        else:
            arena = get_main_arena()

        out = []

        ret = self.parse_arena(arena)
        out.extend(ret)

        ret = self.parse_mp()
        out.extend(ret)

        ret = self.parse_heap_info(arena)
        out.extend(ret)

        # colorize
        for i in range(len(out)):
            out[i] = re.sub("  ([a-zA-Z_]+) =", "  \033[36m\\1\033[0m =", out[i])
            out[i] = re.sub(" = (0x[0-9a-f]+)", " = \033[34m\\1\033[0m", out[i])

        gef_print('\n'.join(out).rstrip(), less=not args.no_pager)
        return


@register_command
class GlibcHeapChunkCommand(GenericCommand):
    """Display information on a heap chunk.
    See https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1123."""
    _cmdline_ = "heap chunk"
    _category_ = "06-a. Heap - Glibc"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('location', metavar='LOCATION', type=parse_address,
                        help='the address you want to interpret as a chunk.')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        if get_main_arena() is None:
            err("Heap is not initialized")
            return

        chunk = GlibcChunk(args.location)
        try:
            gef_print(chunk.psprint())
        except gdb.MemoryError:
            err("Invalid address")
        return


@register_command
class GlibcHeapChunksCommand(GenericCommand):
    """Display information all heap chunks."""
    _cmdline_ = "heap chunks"
    _category_ = "06-a. Heap - Glibc"
    _aliases_ = ["chunks"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('location', metavar='LOCATION', nargs='?', type=parse_address,
                        help='the address you want to interpret as the beginning of a contiguous chunk. (default: arena.heap_base)')
    parser.add_argument('-a', dest='arena_addr', type=parse_address,
                        help='the address you want to interpret as an arena. (default: main_arena)')
    _syntax_ = parser.format_help()

    _example_ = "{:s}\n".format(_cmdline_)
    _example_ += "{:s} -a 0x7ffff0000020 -v".format(_cmdline_)

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        self.add_setting("peek_nb_byte", 0, "Hexdump N first byte(s) inside the chunk data (0 to disable)")
        return

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        # parse arena
        if args.arena_addr:
            arena = get_thread_arena(args.arena_addr)
        else:
            arena = get_main_arena()

        if arena is None:
            err("No valid arena")
            return

        if arena.heap_base is None:
            err("Heap is not initialized")
            return

        if args.location is None:
            dump_start = arena.heap_base
            # specified pattern
            if current_arch.ptrsize == 4 and arena.is_main_arena():
                dump_start += 8
        else:
            dump_start = args.location

        self.print_heap_chunks(arena, dump_start)
        return

    def print_heap_chunks(self, arena, dump_start):
        # Do not show if top is broken, as it affects exit conditions.
        if is_32bit() and arena.top % 0x08:
            err("arena.top is corrupted")
            return
        elif is_64bit() and arena.top % 0x10:
            err("arena.top is corrupted")
            return

        # It continues even if last_remainder is broken because it doesn't affect the exit condition.
        if arena.last_remainder % 0x10:
            warn("arena.last_remainder is corrupted")

        nb = self.get_setting("peek_nb_byte")
        current_chunk = GlibcChunk(dump_start, from_base=True)

        # Even if an error occurs during free-list parsing, It trust the free-list that has been parsed so far.
        tcache_list = arena.tcache_list()
        fastbin_list = arena.fastbin_list()
        unsortedbin_list = arena.unsortedbin_list()
        smallbin_list = arena.smallbin_list()
        largebin_list = arena.largebin_list()

        while True:
            if current_chunk.chunk_base_address == arena.top:
                gef_print("{} {} {}".format(str(current_chunk), LEFT_ARROW, Color.colorify("top chunk", "bold blue")))
                break
            if current_chunk.chunk_base_address > arena.top:
                err("Corrupted: chunk > top")
                break
            if current_chunk.size == 0:
                # EOF
                break

            line = str(current_chunk)

            # in or not in free-list
            for k, v in tcache_list.items():
                if current_chunk.address in v:
                    line += " {} {}".format(LEFT_ARROW, Color.colorify("tcache[{}]".format(k), "bold blue"))
            for k, v in fastbin_list.items():
                if current_chunk.address in v:
                    line += " {} {}".format(LEFT_ARROW, Color.colorify("fastbin[{}]".format(k), "bold blule"))
            for k, v in unsortedbin_list.items():
                if current_chunk.address in v:
                    line += " {} {}".format(LEFT_ARROW, Color.colorify("unsortedbin", "bold blue"))
            for k, v in smallbin_list.items():
                if current_chunk.address in v:
                    line += " {} {}".format(LEFT_ARROW, Color.colorify("smallbin[{}]".format(k), "bold blue"))
            for k, v in largebin_list.items():
                if current_chunk.address in v:
                    line += " {} {}".format(LEFT_ARROW, Color.colorify("largebin[{}]".format(k), "bold blue"))

            # peek nbyte
            if nb:
                peeked_data = read_memory(current_chunk.chunk_base_address, nb)
                h = hexdump(peeked_data, 0x10, base=current_chunk.chunk_base_address)
                line += "\n{:s}".format(h.replace("\n", "     \n"))

            gef_print(line)
            next_chunk = current_chunk.get_next_chunk()
            if next_chunk is None:
                break
            if not Address(value=next_chunk.address).valid:
                err("Corrupted: next_chunk_address is invalid")
                break
            current_chunk = next_chunk
        return


@register_command
class GlibcHeapBinsCommand(GenericCommand):
    """Display information on the bins on an arena (default: main_arena).
    See https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1123."""
    _cmdline_ = "heap bins"
    _category_ = "06-a. Heap - Glibc"
    _aliases_ = ["bins"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-a', dest='arena_addr', type=parse_address,
                        help='the address you want to interpret as an arena. (default: main_arena)')
    parser.add_argument('-v', dest='verbose', action='store_true', help='display empty bins.')
    _syntax_ = parser.format_help()

    _example_ = "{:s}\n".format(_cmdline_)
    _example_ += "{:s} -a 0x7ffff0000020 -v".format(_cmdline_)

    def __init__(self):
        super().__init__(prefix=True)
        return

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        # parse arena
        if args.arena_addr:
            arena = get_thread_arena(args.arena_addr)
        else:
            arena = get_main_arena()

        if arena is None:
            err("No valid arena")
            return

        if arena.heap_base is None:
            err("Heap is not initialized")
            return

        if args.verbose:
            verbose = "-v"
        else:
            verbose = ""

        # doit
        bin_types = ["tcache", "fast", "unsorted", "small", "large"]
        for bin_t in bin_types:
            if arena.is_main_arena():
                gdb.execute("heap bins {:s} {:s}".format(bin_t, verbose))
            else:
                gdb.execute("heap bins {:s} -a {:#x} {:s}".format(bin_t, arena.addr, verbose))
        return

    @staticmethod
    def pprint_bin(arena, index, bin_name, verbose=False):
        fw, bk = arena.bin(index)

        if bk == 0x00 and fw == 0x00:
            warn("Invalid backward and forward bin pointers(fd==bk==NULL)")
            return -1

        nb_chunk = 0
        head = GlibcChunk(bk, from_base=True).fwd
        if fw == head and not verbose:
            return nb_chunk

        bin_table = get_binsize_table()[bin_name]
        if index not in bin_table:
            return 0
        bin_info = bin_table[index]
        if "size" in bin_info:
            size_str = "{:#x}".format(bin_info["size"])
        elif "size_min" in bin_info and "size_max" in bin_info:
            size_str = "{:#x}-{:#x}".format(bin_info["size_min"], bin_info["size_max"])
        else:
            size_str = "any"
        bin_addr = arena.bin_addr(index)
        ok("{:s}[idx={:d}, size={:s}, @{:#x}]: fd={:#x}, bk={:#x}".format(bin_name, index, size_str, bin_addr, fw, bk))

        m = []
        error = False
        seen = []
        while fw != head:
            chunk = GlibcChunk(fw, from_base=True)
            if chunk.address in seen:
                error = True
                break
            seen.append(chunk.address)
            m.append("{:s} {:s}".format(RIGHT_ARROW, str(chunk)))
            fw = chunk.fwd
            if fw is None:
                error = True
                break
            nb_chunk += 1
        if m:
            gef_print("\n".join(m))
        if error:
            err("Read memory error (Corrupted?)")
        return nb_chunk


@register_command
class GlibcHeapTcachebinsCommand(GenericCommand):
    """Display information on the Tcache on an arena."""
    _cmdline_ = "heap bins tcache"
    _category_ = "06-a. Heap - Glibc"
    _aliases_ = ["tcache"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-a', dest='arena_addr', type=parse_address,
                        help='the address you want to interpret as an arena. (default: main_arena)')
    parser.add_argument('-v', dest='verbose', action='store_true', help='display empty bins.')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        # Determine if we are using libc with tcache built in (2.26+)
        if get_libc_version() < (2, 26):
            info("No Tcache in this version of libc")
            return

        # parse arena
        if args.arena_addr:
            arena = get_thread_arena(args.arena_addr)
        else:
            arena = get_main_arena()

        if arena is None:
            err("No valid arena")
            return

        if arena.heap_base is None:
            err("Heap is not initialized")
            return

        # doit
        self.print_tcache(arena, args.verbose)
        return

    def print_tcache(self, arena, verbose):
        # Get tcache_perthread_struct for this arena
        tcache_perthread_struct = arena.heap_base + 0x10

        gef_print(titlify("Tcachebins for arena '{:s}'".format(arena.name)))

        nb_chunk = 0
        for i in range(GlibcArena.TCACHE_MAX_BINS):
            if get_libc_version() < (2, 30):
                count = ord(read_memory(tcache_perthread_struct + i, 1))
            else:
                count = u16(read_memory(tcache_perthread_struct + 2 * i, 2))
            chunk = arena.tcachebin(i)
            chunks = set()
            m = []

            # Only print the entry if there are valid chunks. Don't trust count
            while True:
                if chunk is None:
                    break
                try:
                    m.append("{:s} {:s} ".format(RIGHT_ARROW, str(chunk)))
                    if chunk.address in chunks:
                        m.append("{:s} [loop detected]".format(RIGHT_ARROW))
                        break

                    chunks.add(chunk.address)
                    nb_chunk += 1

                    next_chunk = chunk.get_fwd_ptr(True)
                    if next_chunk == 0 or next_chunk is None:
                        break

                    chunk = GlibcChunk(next_chunk)
                except gdb.MemoryError:
                    m.append("{:s} [Corrupted chunk at {:#x}]".format(LEFT_ARROW, chunk.address))
                    break
            if m or verbose:
                size = get_binsize_table()["tcache"][i]["size"]
                bin_addr = arena.tcachebin_addr(i)
                ok("Tcachebins[idx={:d}, size={:#x}, @{:#x}] count={:d}".format(i, size, bin_addr, count))
                if m:
                    gef_print("\n".join(m))

        info("Found {:d} chunks in tcache.".format(nb_chunk))
        return


@register_command
class GlibcHeapFastbinsYCommand(GenericCommand):
    """Display information on the fastbinsY on an arena."""
    _cmdline_ = "heap bins fast"
    _category_ = "06-a. Heap - Glibc"
    _aliases_ = ["fastbins"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-a', dest='arena_addr', type=parse_address,
                        help='the address you want to interpret as an arena. (default: main_arena)')
    parser.add_argument('-v', dest='verbose', action='store_true', help='display empty bins.')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        # parse arena
        if args.arena_addr:
            arena = get_thread_arena(args.arena_addr)
        else:
            arena = get_main_arena()

        if arena is None:
            err("No valid arena")
            return

        if arena.heap_base is None:
            err("Heap is not initialized")
            return

        # doit
        self.print_fastbin(arena, args.verbose)
        return

    def print_fastbin(self, arena, verbose):
        def fastbin_index(sz):
            return (sz >> 4) - 2 if SIZE_SZ == 8 else (sz >> 3) - 2

        SIZE_SZ = current_arch.ptrsize
        MAX_FAST_SIZE = 80 * SIZE_SZ // 4
        NFASTBINS = fastbin_index(MAX_FAST_SIZE) - 1

        gef_print(titlify("Fastbins for arena '{:s}'".format(arena.name)))

        nb_chunk = 0
        for i in range(NFASTBINS):
            chunk = arena.fastbin(i)
            chunks = set()
            m = []

            while True:
                if chunk is None:
                    break

                try:
                    m.append("{:s} {:s} ".format(RIGHT_ARROW, str(chunk)))
                    if chunk.address in chunks:
                        m.append("{:s} [loop detected]".format(RIGHT_ARROW))
                        break

                    if fastbin_index(chunk.get_chunk_size()) != i:
                        m.append("[incorrect fastbin_index]")

                    chunks.add(chunk.address)
                    nb_chunk += 1

                    next_chunk = chunk.get_fwd_ptr(True)
                    if next_chunk == 0 or next_chunk is None:
                        break

                    chunk = GlibcChunk(next_chunk, from_base=True)
                except gdb.MemoryError:
                    m.append("{:s} [Corrupted chunk at {:#x}]".format(LEFT_ARROW, chunk.address))
                    break

            if m or verbose:
                bin_table = get_binsize_table()["fastbins"]
                if i in bin_table:
                    size = bin_table[i]["size"]
                    bin_addr = arena.fastbin_addr(i)
                    ok("Fastbins[idx={:d}, size={:#x}, @{:#x}] ".format(i, size, bin_addr))
                    if m:
                        gef_print("\n".join(m))

        info("Found {:d} chunks in fastbin.".format(nb_chunk))
        return


@register_command
class GlibcHeapUnsortedBinsCommand(GenericCommand):
    """Display information on the Unsorted Bins of an arena."""
    _cmdline_ = "heap bins unsorted"
    _category_ = "06-a. Heap - Glibc"
    _aliases_ = ["unsortedbin"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-a', dest='arena_addr', type=parse_address,
                        help='the address you want to interpret as an arena. (default: main_arena)')
    parser.add_argument('-v', dest='verbose', action='store_true', help='display empty bins.')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        # parse arena
        if args.arena_addr:
            arena = get_thread_arena(args.arena_addr)
        else:
            arena = get_main_arena()

        if arena is None:
            err("No valid arena")
            return

        if arena.heap_base is None:
            err("Heap is not initialized")
            return

        # doit
        gef_print(titlify("Unsorted Bin for arena '{:s}'".format(arena.name)))
        nb_chunk = GlibcHeapBinsCommand.pprint_bin(arena, 0, "unsorted_bins", args.verbose)
        info("Found {:d} chunks in unsorted bin.".format(nb_chunk))
        return


@register_command
class GlibcHeapSmallBinsCommand(GenericCommand):
    """Display information on the Small Bins of an arena."""
    _cmdline_ = "heap bins small"
    _category_ = "06-a. Heap - Glibc"
    _aliases_ = ["smallbin"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-a', dest='arena_addr', type=parse_address,
                        help='the address you want to interpret as an arena. (default: main_arena)')
    parser.add_argument('-v', dest='verbose', action='store_true', help='display empty bins.')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        # parse arena
        if args.arena_addr:
            arena = get_thread_arena(args.arena_addr)
        else:
            arena = get_main_arena()

        if arena is None:
            err("No valid arena")
            return

        if arena.heap_base is None:
            err("Heap is not initialized")
            return

        # doit
        gef_print(titlify("Small Bins for arena '{:s}'".format(arena.name)))
        bins = {}
        for i in range(1, 63):
            nb_chunk = GlibcHeapBinsCommand.pprint_bin(arena, i, "small_bins", args.verbose)
            if nb_chunk < 0:
                break
            if nb_chunk > 0:
                bins[i] = nb_chunk
        info("Found {:d} chunks in {:d} small non-empty bins.".format(sum(bins.values()), len(bins)))
        return


@register_command
class GlibcHeapLargeBinsCommand(GenericCommand):
    """Display information on the Large Bins of an arena."""
    _cmdline_ = "heap bins large"
    _category_ = "06-a. Heap - Glibc"
    _aliases_ = ["largebin"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-a', dest='arena_addr', type=parse_address,
                        help='the address you want to interpret as an arena. (default: main_arena)')
    parser.add_argument('-v', dest='verbose', action='store_true', help='display empty bins.')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        # parse arena
        if args.arena_addr:
            arena = get_thread_arena(args.arena_addr)
        else:
            arena = get_main_arena()

        if arena is None:
            err("No valid arena")
            return

        if arena.heap_base is None:
            err("Heap is not initialized")
            return

        # doit
        gef_print(titlify("Large Bins for arena '{:s}'".format(arena.name)))
        bins = {}
        for i in range(63, 126):
            nb_chunk = GlibcHeapBinsCommand.pprint_bin(arena, i, "large_bins", args.verbose)
            if nb_chunk < 0:
                break
            if nb_chunk > 0:
                bins[i] = nb_chunk
        info("Found {:d} chunks in {:d} large non-empty bins.".format(sum(bins.values()), len(bins)))
        return


@functools.lru_cache(maxsize=None)
def __get_binsize_table():
    table = {
        "tcache": {},
        "fastbins": {},
        "unsorted_bins": {},
        "small_bins": {},
        "large_bins": {},
    }

    # tcache
    # "MALLOC_ALIGNMENT is changed from libc 2.26,
    # for 32 bit arch, tcache 0x8 align is no longer used.
    for i in range(64):
        if is_64bit():
            min_size = 0x20
        else:
            min_size = 0x10
        size = i * 0x10 + min_size
        table["tcache"][i] = {"size": size}

    # fastbins
    if is_64bit():
        for i in range(7):
            size = i * 0x10 + 0x20
            table["fastbins"][i] = {"size": size}
    elif is_32bit():
        # MALLOC_ALIGNMENT is changed from libc 2.26.
        # for 32 bit arch, fastbin exists every 8 bytes, but only used every 16 bytes.
        table["fastbins"][0] = {"size": 0x10}
        table["fastbins"][2] = {"size": 0x20}
        table["fastbins"][4] = {"size": 0x30}
        table["fastbins"][6] = {"size": 0x40}

    # unsorted bins
    table["unsorted_bins"][0] = {"bins_idx": 0}

    # smallbins
    if is_64bit():
        min_size = 0x20
    else:
        min_size = 0x10
    for i in range(1, 63):
        size = (i - 1) * 0x10 + min_size
        table["small_bins"][i] = {"size": size}

    # largebins
    if is_64bit():
        table["large_bins"][63] = {"size_min": 0x400, "size_max": 0x440}
        table["large_bins"][64] = {"size_min": 0x440, "size_max": 0x480}
        table["large_bins"][65] = {"size_min": 0x480, "size_max": 0x4c0}
        table["large_bins"][66] = {"size_min": 0x4c0, "size_max": 0x500}
        table["large_bins"][67] = {"size_min": 0x500, "size_max": 0x540}
        table["large_bins"][68] = {"size_min": 0x540, "size_max": 0x580}
        table["large_bins"][69] = {"size_min": 0x580, "size_max": 0x5c0}
        table["large_bins"][70] = {"size_min": 0x5c0, "size_max": 0x600}
        table["large_bins"][71] = {"size_min": 0x600, "size_max": 0x640}
        table["large_bins"][72] = {"size_min": 0x640, "size_max": 0x680}
        table["large_bins"][73] = {"size_min": 0x680, "size_max": 0x6c0}
        table["large_bins"][74] = {"size_min": 0x6c0, "size_max": 0x700}
        table["large_bins"][75] = {"size_min": 0x700, "size_max": 0x740}
        table["large_bins"][76] = {"size_min": 0x740, "size_max": 0x780}
        table["large_bins"][77] = {"size_min": 0x780, "size_max": 0x7c0}
        table["large_bins"][78] = {"size_min": 0x7c0, "size_max": 0x800}
        table["large_bins"][79] = {"size_min": 0x800, "size_max": 0x840}
        table["large_bins"][80] = {"size_min": 0x840, "size_max": 0x880}
        table["large_bins"][81] = {"size_min": 0x880, "size_max": 0x8c0}
        table["large_bins"][82] = {"size_min": 0x8c0, "size_max": 0x900}
        table["large_bins"][83] = {"size_min": 0x900, "size_max": 0x940}
        table["large_bins"][84] = {"size_min": 0x940, "size_max": 0x980}
        table["large_bins"][85] = {"size_min": 0x980, "size_max": 0x9c0}
        table["large_bins"][86] = {"size_min": 0x9c0, "size_max": 0xa00}
        table["large_bins"][87] = {"size_min": 0xa00, "size_max": 0xa40}
        table["large_bins"][88] = {"size_min": 0xa40, "size_max": 0xa80}
        table["large_bins"][89] = {"size_min": 0xa80, "size_max": 0xac0}
        table["large_bins"][90] = {"size_min": 0xac0, "size_max": 0xb00}
        table["large_bins"][91] = {"size_min": 0xb00, "size_max": 0xb40}
        table["large_bins"][92] = {"size_min": 0xb40, "size_max": 0xb80}
        table["large_bins"][93] = {"size_min": 0xb80, "size_max": 0xbc0}
        table["large_bins"][94] = {"size_min": 0xbc0, "size_max": 0xc00}
        table["large_bins"][95] = {"size_min": 0xc00, "size_max": 0xc40}
        table["large_bins"][96] = {"size_min": 0xc40, "size_max": 0xe00}
    elif is_32bit():
        table["large_bins"][63] = {"size_min": 0x3f0, "size_max": 0x400}
        table["large_bins"][64] = {"size_min": 0x400, "size_max": 0x440}
        table["large_bins"][65] = {"size_min": 0x440, "size_max": 0x480}
        table["large_bins"][66] = {"size_min": 0x480, "size_max": 0x4c0}
        table["large_bins"][67] = {"size_min": 0x4c0, "size_max": 0x500}
        table["large_bins"][68] = {"size_min": 0x500, "size_max": 0x540}
        table["large_bins"][69] = {"size_min": 0x540, "size_max": 0x580}
        table["large_bins"][70] = {"size_min": 0x580, "size_max": 0x5c0}
        table["large_bins"][71] = {"size_min": 0x5c0, "size_max": 0x600}
        table["large_bins"][72] = {"size_min": 0x600, "size_max": 0x640}
        table["large_bins"][73] = {"size_min": 0x640, "size_max": 0x680}
        table["large_bins"][74] = {"size_min": 0x680, "size_max": 0x6c0}
        table["large_bins"][75] = {"size_min": 0x6c0, "size_max": 0x700}
        table["large_bins"][76] = {"size_min": 0x700, "size_max": 0x740}
        table["large_bins"][77] = {"size_min": 0x740, "size_max": 0x780}
        table["large_bins"][78] = {"size_min": 0x780, "size_max": 0x7c0}
        table["large_bins"][79] = {"size_min": 0x7c0, "size_max": 0x800}
        table["large_bins"][80] = {"size_min": 0x800, "size_max": 0x840}
        table["large_bins"][81] = {"size_min": 0x840, "size_max": 0x880}
        table["large_bins"][82] = {"size_min": 0x880, "size_max": 0x8c0}
        table["large_bins"][83] = {"size_min": 0x8c0, "size_max": 0x900}
        table["large_bins"][84] = {"size_min": 0x900, "size_max": 0x940}
        table["large_bins"][85] = {"size_min": 0x940, "size_max": 0x980}
        table["large_bins"][86] = {"size_min": 0x980, "size_max": 0x9c0}
        table["large_bins"][87] = {"size_min": 0x9c0, "size_max": 0xa00}
        table["large_bins"][88] = {"size_min": 0xa00, "size_max": 0xa40}
        table["large_bins"][89] = {"size_min": 0xa40, "size_max": 0xa80}
        table["large_bins"][90] = {"size_min": 0xa80, "size_max": 0xac0}
        table["large_bins"][91] = {"size_min": 0xac0, "size_max": 0xb00}
        table["large_bins"][92] = {"size_min": 0xb00, "size_max": 0xb40}
        table["large_bins"][93] = {"size_min": 0xb40, "size_max": 0xb80}
        # table["large_bins"][94] is unused
        table["large_bins"][95] = {"size_min": 0xb80, "size_max": 0xc00}
        table["large_bins"][96] = {"size_min": 0xc00, "size_max": 0xe00}

    table["large_bins"][97] = {"size_min": 0xe00, "size_max": 0x1000}
    table["large_bins"][98] = {"size_min": 0x1000, "size_max": 0x1200}
    table["large_bins"][99] = {"size_min": 0x1200, "size_max": 0x1400}
    table["large_bins"][100] = {"size_min": 0x1400, "size_max": 0x1600}
    table["large_bins"][101] = {"size_min": 0x1600, "size_max": 0x1800}
    table["large_bins"][102] = {"size_min": 0x1800, "size_max": 0x1a00}
    table["large_bins"][103] = {"size_min": 0x1a00, "size_max": 0x1c00}
    table["large_bins"][104] = {"size_min": 0x1c00, "size_max": 0x1e00}
    table["large_bins"][105] = {"size_min": 0x1e00, "size_max": 0x2000}
    table["large_bins"][106] = {"size_min": 0x2000, "size_max": 0x2200}
    table["large_bins"][107] = {"size_min": 0x2200, "size_max": 0x2400}
    table["large_bins"][108] = {"size_min": 0x2400, "size_max": 0x2600}
    table["large_bins"][109] = {"size_min": 0x2600, "size_max": 0x2800}
    table["large_bins"][110] = {"size_min": 0x2800, "size_max": 0x2a00}
    table["large_bins"][111] = {"size_min": 0x2a00, "size_max": 0x3000}
    table["large_bins"][112] = {"size_min": 0x3000, "size_max": 0x4000}
    table["large_bins"][113] = {"size_min": 0x4000, "size_max": 0x5000}
    table["large_bins"][114] = {"size_min": 0x5000, "size_max": 0x6000}
    table["large_bins"][115] = {"size_min": 0x6000, "size_max": 0x7000}
    table["large_bins"][116] = {"size_min": 0x7000, "size_max": 0x8000}
    table["large_bins"][117] = {"size_min": 0x8000, "size_max": 0x9000}
    table["large_bins"][118] = {"size_min": 0x9000, "size_max": 0xa000}
    table["large_bins"][119] = {"size_min": 0xa000, "size_max": 0x10000}
    table["large_bins"][120] = {"size_min": 0x10000, "size_max": 0x18000}
    table["large_bins"][121] = {"size_min": 0x18000, "size_max": 0x20000}
    table["large_bins"][122] = {"size_min": 0x20000, "size_max": 0x28000}
    table["large_bins"][123] = {"size_min": 0x28000, "size_max": 0x40000}
    table["large_bins"][124] = {"size_min": 0x40000, "size_max": 0x80000}
    table["large_bins"][125] = {"size_min": 0x80000, "size_max": 0x0}
    table["large_bins"][126] = {"size_min": 0x0, "size_max": 0x0} # maybe unused
    return table


def get_binsize_table():
    return __get_binsize_table() # to prevent clear_all_cache


@register_command
class DetailRegistersCommand(GenericCommand):
    """Display full details on one, many or all registers value from current architecture."""
    _cmdline_ = "registers"
    _category_ = "01-a. Debugging Support - Context"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('registers', metavar='REGISTERS', nargs='*',
                        help='An array of registers. (default: current_arch.all_registers)')
    _syntax_ = parser.format_help()

    _example_ = "{:s}\n".format(_cmdline_)
    _example_ += "{:s} $eax $eip $esp".format(_cmdline_)

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        unchanged_color = get_gef_setting("theme.registers_register_name")
        changed_color = get_gef_setting("theme.registers_value_changed")

        if args.registers:
            regs = []
            for creg in current_arch.all_registers:
                for reg in args.registers:
                    if not reg.startswith("$"):
                        reg = "$" + reg
                    if reg == creg:
                        regs.append(reg)
                        break
        else:
            regs = current_arch.all_registers

        widest = current_arch.get_aliased_registers_name_max()
        special_line = ""

        for regname in regs:
            reg = gdb.parse_and_eval(regname)
            if reg.type.code == gdb.TYPE_CODE_VOID:
                continue

            # https://arvid.io/2016/08/21/test-if-a-variable-is-unavailable-in-gdb/
            if str(reg) == "<unavailable>":
                padreg = current_arch.get_aliased_registers()[regname].ljust(widest, " ")
                line = "{}: ".format(Color.colorify(padreg, unchanged_color))
                line += Color.colorify("no value", "yellow underline")
                gef_print(line)
                continue

            # colorling
            value = align_address(int(reg))
            old_value = ContextCommand.old_registers.get(regname, 0)
            if value == old_value:
                color = unchanged_color
            else:
                color = changed_color

            # Special (e.g. segment) registers go on their own line
            if regname in current_arch.special_registers:
                special_line += "{}: ".format(Color.colorify(regname, color))
                special_line += "{:#04x} ".format(get_register(regname))
                continue

            # reg name
            padreg = current_arch.get_aliased_registers()[regname].ljust(widest, " ")
            line = "{}: ".format(Color.colorify(padreg, color))

            # flag register
            if current_arch.flag_register and regname == current_arch.flag_register:
                line += current_arch.flag_register_to_human()
                gef_print(line)
                continue

            # dereference values
            line += to_string_dereference_from(value)

            gef_print(line)

        if special_line:
            gef_print(special_line)
        return


@register_command
class RopperCommand(GenericCommand):
    """Invoke ropper to search rop gadgets."""
    _cmdline_ = "ropper"
    _category_ = "07-b. External Command - Exploit Development"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('args', metavar='ROPPER_OPTIONS', nargs='*',
                        help='An array of arguments to pass as is to the ropper command. (default: %(default)s)')
    _syntax_ = parser.format_help()

    _example_ = "{:s}\n".format(_cmdline_)
    _example_ += "{:s} -h                 # show detail of options\n".format(_cmdline_)
    _example_ += '{:s} --jmp rax,rcx      # filter by jmp registers\n'.format(_cmdline_)
    _example_ += '{:s} --search "pop r?x" # filter by pop registers\n'.format(_cmdline_)

    _help_ = None
    _help_examples_ = None

    def print_help(self):
        self.usage()

        if self._help_ is None:
            self._help_ = subprocess.check_output('ropper --help', shell=True).decode("utf-8")
        if self._help_examples_ is None:
            self._help_examples_ = subprocess.check_output('ropper --help-examples', shell=True).decode("utf-8")

        help_text = titlify("gef --help")
        help_text += self._help_
        help_text += titlify("gef --help-examples")
        help_text += self._help_examples_
        gef_print(help_text, less=True)
        return

    # Need not @parse_args because argparse can't stop interpreting options for ropper.
    @only_if_gdb_running
    @only_if_not_qemu_system
    @load_ropper
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv or "--help" in argv:
            self.print_help()
            return

        if "--file" not in argv:
            filepath = get_filepath()
            if filepath is None:
                err("Missing info about file. Please set: `file /path/to/target_binary`")
                return
            argv.extend(["--file", filepath])

        # ropper set up own autocompleter after which gdb/gef autocomplete don't work
        # due to fork/waitpid, child will be broken but parent will not change
        gef_print(titlify(filepath))
        pid = os.fork()
        if pid == 0:
            try:
                ropper = sys.modules["ropper"]
                ropper.start(argv)
            except Exception:
                pass
            os._exit(0)
        else:
            os.waitpid(pid, 0)
        return


@register_command
class RpCommand(GenericCommand):
    """Invoke rp++ v1 command to search rop gadgets. (x64/x86 only)"""
    _cmdline_ = "rp"
    _category_ = "07-b. External Command - Exploit Development"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--bin', action='store_true', help='apply rp++ to binary itself.')
    group.add_argument('--libc', action='store_true', help='apply rp++ to libc.so searched from vmmap.')
    group.add_argument('--file', help='apply rp++ to specified file.')
    group.add_argument('--kernel', action='store_true', help='dump kernel, then apply vmlinux-to-elf and rp++.')
    parser.add_argument('-f', '--filter', action='append', default=[], help='REGEXP filter.')
    parser.add_argument('-r', '--rop', dest='rop_N', default=3, help='the max length of rop gadget. (default: %(default)s)')
    parser.add_argument('--no-print', action='store_true', help="run rp, create a temporary file, but don't display it.")
    _syntax_ = parser.format_help()

    _example_ = "{:s} --bin -f 'pop r[abcd]x'\n".format(_cmdline_)
    _example_ += "{:s} --libc -f '(xchg|mov) [re]sp, \\\\w+' -f 'ret'\n".format(_cmdline_)
    _example_ += "{:s} --kernel # under qemu-system only".format(_cmdline_)

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_FILENAME)
        self.rp_version = 1
        return

    def exec_rp(self, ropN):
        output_file = "rp{}_rop{}_{}.txt".format(self.rp_version, ropN, os.path.basename(self.path))
        output_path = os.path.join(GEF_TEMP_DIR, output_file)
        cmd = f"{self.rp} --file='{self.path}' --rop={ropN} --unique > {output_path}"
        gef_print(titlify(cmd))
        if not os.path.exists(output_path):
            os.system(cmd)
        return output_path

    def apply_filter(self, rp_output_path, filter_patterns, base_address):
        if not os.path.exists(rp_output_path):
            err(f"{rp_output_path} is not found")
            return
        lines = open(rp_output_path, "r").read()

        out = []
        for line in lines.splitlines():
            line = re.sub(r"\x1B\[([0-9]{1,2}(;[0-9]{1,2})*)?m", "", line) # remove color

            match = True
            for pat in filter_patterns:
                if not re.search(pat, line):
                    match = False
                    break

            if match:
                if line.startswith("0x"):
                    x = line.split(":")
                    addr, gadget = int(x[0], 16), ':'.join(x[1:])
                    addr -= base_address # fix address
                    x = Color.redify("{:#08x}".format(addr)) + ":" + gadget # repaint color
                else:
                    x = line
                out.append(x)
        return '\n'.join(out)

    @parse_args
    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, args):
        self.dont_repeat()

        # load rp path
        if self.rp_version == 1:
            try:
                self.rp = which("rp-lin-x64")
            except FileNotFoundError as e1:
                try:
                    self.rp = which("rp-lin-x86")
                except FileNotFoundError as e2:
                    err("{}".format(e1))
                    err("{}".format(e2))
                    return
        elif self.rp_version == 2:
            try:
                self.rp = which("rp-lin-x64-v2")
            except FileNotFoundError as e1:
                err("{}".format(e1))
                return

        base_address = 0
        if args.libc:
            libc = process_lookup_path(("libc-2.", "libc.so.6"))
            if libc is None:
                err("libc is not found")
                return
            self.path = libc.path
        elif args.bin:
            binary = get_filepath()
            if binary is None:
                err("binary is not found")
                return
            self.path = binary
        elif args.file:
            if not os.path.exists(args.file):
                err("{} is not found".format(args.file))
                return
            self.path = args.file
        elif args.kernel:
            if not is_qemu_system():
                err("--kernel are supported only under qemu-system.")
                return
            # dump kernel then apply vmlinux-to-elf
            dump_mem_file = os.path.join(GEF_TEMP_DIR, "rp-dump-memory.raw")
            self.path = symboled_vmlinux_file = os.path.join(GEF_TEMP_DIR, "rp-dump-memory.elf")
            kinfo = VmlinuxToElfApplyCommand().dump_kernel_elf(dump_mem_file, symboled_vmlinux_file)
            if kinfo is None:
                err("Failed to get symboled ELF")
                return
            base_address = kinfo.kbase

        # invoke rp++
        rp_output_path = self.exec_rp(args.rop_N)

        # filtering
        out = self.apply_filter(rp_output_path, args.filter, base_address)

        # print
        if not args.no_print:
            gef_print(out, less=True)
        return


@register_command
class Rp2Command(RpCommand):
    """Invoke rp++ v2 command to search rop gadgets. (x64/x86 only)"""
    _cmdline_ = "rp2"
    _category_ = "07-b. External Command - Exploit Development"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--bin', action='store_true', help='apply rp++ to binary itself.')
    group.add_argument('--libc', action='store_true', help='apply rp++ to libc.so searched from vmmap.')
    group.add_argument('--file', help='apply rp++ to specified file.')
    group.add_argument('--kernel', action='store_true', help='dump kernel, then apply vmlinux-to-elf and rp++.')
    parser.add_argument('-f', '--filter', action='append', default=[], help='REGEXP filter.')
    parser.add_argument('-r', '--rop', dest='rop_N', default=3, help='the max length of rop gadget. (default: %(default)s)')
    parser.add_argument('--no-print', action='store_true', help="run rp, create a temporary file, but don't display it.")
    _syntax_ = parser.format_help()

    _example_ = "{:s} --bin -f 'pop r[abcd]x'\n".format(_cmdline_)
    _example_ += "{:s} --libc -f '(xchg|mov) [re]sp, \\\\w+' -f 'ret'\n".format(_cmdline_)
    _example_ += "{:s} --kernel # under qemu-system only".format(_cmdline_)

    def __init__(self):
        super().__init__()
        self.rp_version = 2
        return


@register_command
class AssembleCommand(GenericCommand):
    """Inline code assemble by keystone."""
    _cmdline_ = "asm"
    _category_ = "01-e. Debugging Support - Assemble"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-a', dest='arch', help='specify the architecture. (default: current_arch.arch)')
    parser.add_argument('-m', dest='mode', help='specify the mode. (default: current_arch.mode)')
    parser.add_argument('-e', dest='big_endian', action='store_true', help='use big-endian. (default: %(default)s)')
    parser.add_argument('-s', dest='as_shellcode', action='store_true', help='output like shellcode style. (default: %(default)s)')
    parser.add_argument('-l', dest='overwrite_location', metavar='LOCATION', type=parse_address, help='write to memory address.')
    parser.add_argument("instruction", metavar='INSTRUCTION', nargs='+', help='the code you want to assemble')
    _syntax_ = parser.format_help()

    _example_ = '{:s} -a X86 -m 64 "mov rax, qword ptr [rax] ; inc rax ;"\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m 32 "mov eax, dword ptr [eax] ; inc eax ;"\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m 16 "mov ax, word ptr [ax] ; inc ax"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m ARM      "sub r1, r2, r3"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m ARM -e   "sub r1, r2, r3"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m THUMB    "movs r4, #0xf0"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m THUMB -e "movs r4, #0xf0"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM64 -m ARM    "ldr w1, [sp, #0x8]"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS32    "and $9, $6, $7"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS32 -e "and $9, $6, $7"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS64    "and $9, $6, $7"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS64 -e "and $9, $6, $7"\n'.format(_cmdline_)
    _example_ += '{:s} -a PPC -m PPC32 -e "add 1, 2, 3"\n'.format(_cmdline_)
    _example_ += '{:s} -a PPC -m PPC64    "add 1, 2, 3"\n'.format(_cmdline_)
    _example_ += '{:s} -a PPC -m PPC64 -e "add 1, 2, 3"\n'.format(_cmdline_)
    _example_ += '{:s} -a SPARC -m SPARC32 -e "add %g1, %g2, %g3"\n'.format(_cmdline_)
    _example_ += '{:s} -a SPARC -m SPARC64 -e "add %g1, %g2, %g3"\n'.format(_cmdline_)
    _example_ += '{:s} -a S390X -m S390X -e "a %r0, 4095(%r15,%r1)"'.format(_cmdline_)

    @parse_args
    @load_keystone
    def do_invoke(self, args):
        self.dont_repeat()

        if (args.arch, args.mode) == (None, None):
            if is_alive():
                arch, mode = get_keystone_arch(arch=current_arch.arch, mode=current_arch.mode, endian=is_big_endian())
                arch_mode_s = ":".join([current_arch.arch, current_arch.mode])
                endian_s = "big" if is_big_endian() else "little"
            else:
                # if not alive, defaults to x86-64
                arch, mode = get_keystone_arch(arch="X86", mode="64", endian=False)
                arch_mode_s = "X86:64"
                endian_s = "little"
        elif not args.arch:
            err("An architecture (-a) must be provided")
            return
        elif not args.mode:
            # keystone gives no error so check here
            err("A mode (-m) must be provided")
            return
        elif args.arch in ["SPARC", "S390X"] and args.big_endian is False:
            # keystone gives no error so check here
            err("A big endian flag (-e) must be provided")
            return
        else:
            try:
                arch, mode = get_keystone_arch(arch=args.arch, mode=args.mode, endian=args.big_endian)
                arch_mode_s = ":".join([args.arch, args.mode])
                endian_s = "big" if args.big_endian else "little"
            except AttributeError:
                self.usage()
                return

        insns = " ".join(args.instruction)
        insns = [x.strip() for x in insns.split(";") if x is not None and x.strip() != ""]

        info("Assembling {} instruction{} for {} ({} endian)".format(len(insns), "s" if len(insns) > 1 else "", arch_mode_s, endian_s))

        if args.as_shellcode:
            gef_print('sc = ""')

        raw = b""
        for insn in insns:
            res = keystone_assemble(insn, arch, mode, raw=True)
            if not res:
                gef_print("(Invalid)")
                continue

            if args.overwrite_location is not None:
                raw += res
                continue

            s = binascii.hexlify(res)
            res = b"\\x" + b"\\x".join([s[i:i + 2] for i in range(0, len(s), 2)])
            res = res.decode("utf-8")

            if args.as_shellcode:
                res = 'sc += "{:s}"'.format(res)

            gef_print("{:60s} # {:s}".format(res, insn))

        if args.overwrite_location is not None:
            hex_code = binascii.hexlify(raw).decode()
            gdb.execute("patch hexstring {:#x} {:s}".format(args.overwrite_location, hex_code))
        return


@register_command
class DisassembleCommand(GenericCommand):
    """Inline code disassemble by capstone."""
    _cmdline_ = "dasm"
    _category_ = "01-e. Debugging Support - Assemble"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-a', dest='arch', help='specify the architecture. (default: current_arch.arch)')
    parser.add_argument('-m', dest='mode', help='specify the mode. (default: current_arch.mode)')
    parser.add_argument('-e', dest='big_endian', action='store_true', help='use big-endian. (default: %(default)s)')
    parser.add_argument("hex_code", metavar='HEX_CODE', nargs='+', help='the hex code you want to disassemble')
    _syntax_ = parser.format_help()

    _example_ = '{:s} -a X86 -m 64 "488b00 48ffc0"\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m 32 "8b00 40"\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m 16 "8b00 40"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m ARM      "031042e0"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m ARM -e   "e0421003"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m THUMB    "f024"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m THUMB -e "24f0"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM64 -m ARM    "e10b40b9"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS32    "2448c700"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS32 -e "00c74824"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS64    "2448c700"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS64 -e "00c74824"\n'.format(_cmdline_)
    _example_ += '{:s} -a PPC -m 32 -e "7c221a14"\n'.format(_cmdline_)
    _example_ += '{:s} -a PPC -m 64    "141a227c"\n'.format(_cmdline_)
    _example_ += '{:s} -a PPC -m 64 -e "7c221a14"\n'.format(_cmdline_)
    _example_ += '{:s} -a SPARC -m SPARC32 -e "86004002"\n'.format(_cmdline_)
    _example_ += '{:s} -a SPARC -m SPARC64 -e "86004002"\n'.format(_cmdline_)
    _example_ += '{:s} -a RISCV -m RISCV32 "97c10600"\n'.format(_cmdline_)
    _example_ += '{:s} -a RISCV -m RISCV64 "97c10600"\n'.format(_cmdline_)
    _example_ += '{:s} -a S390X -m S390X -e "5a0f1fff"\n'.format(_cmdline_)
    _example_ += '{:s} -a M68K -m M68K -e "9dce"'.format(_cmdline_)

    @parse_args
    @load_capstone
    def do_invoke(self, args):
        self.dont_repeat()

        if (args.arch, args.mode) == (None, None):
            if is_alive():
                arch, mode = get_capstone_arch(arch=current_arch.arch, mode=current_arch.mode, endian=is_big_endian())
                arch_mode_s = ":".join([current_arch.arch, current_arch.mode])
                endian_s = "big" if is_big_endian() else "little"
            else:
                # if not alive, defaults to x86-64
                arch, mode = get_capstone_arch(arch="X86", mode="64", endian=False)
                arch_mode_s = "X86:64"
                endian_s = "little"
        elif not args.arch:
            err("An architecture (-a) must be provided")
            return
        elif not args.mode:
            err("A mode (-m) must be provided")
            return
        elif args.arch in ["SPARC", "S390X"] and args.big_endian is False:
            # capstone gives no error so check here
            err("A big endian flag (-e) must be provided")
            return
        else:
            try:
                arch, mode = get_capstone_arch(arch=args.arch, mode=args.mode, endian=args.big_endian)
                arch_mode_s = ":".join([args.arch, args.mode])
                endian_s = "big" if args.big_endian else "little"
            except AttributeError:
                self.usage()
                return

        insns = " ".join(args.hex_code)
        insns = insns.replace(" ", "").replace("\t", "")
        try:
            insns = binascii.unhexlify(insns)
        except Exception:
            err("Invalid format")
            return

        info("Disassembling {} bytes for {} ({} endian)".format(len(insns), arch_mode_s, endian_s))

        capstone = sys.modules["capstone"]
        try:
            cs = capstone.Cs(arch, mode)
        except capstone.CsError:
            err("CsError")
            return
        cs.detail = True

        for insn in cs.disasm(insns, 0x0):
            b = binascii.hexlify(insn.bytes).decode("utf-8")
            gef_print("{:>#6x}:\t{:<10s}\t{:s}\t{:s}".format(insn.address, b, insn.mnemonic, insn.op_str))
        return


@register_command
class AsmListCommand(GenericCommand):
    """List up general instructions by capstone (x64/x86 only)."""
    _cmdline_ = "asm-list"
    _category_ = "01-e. Debugging Support - Assemble"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-a', dest='arch', help='specify the architecture. (default: current_arch.arch)')
    parser.add_argument('-m', dest='mode', help='specify the mode. (default: current_arch.mode)')
    parser.add_argument('-e', dest='big_endian', action='store_true', help='use big-endian. (default: %(default)s)')
    parser.add_argument("-n", dest='nbyte', type=int, help='filter by the length of asm byte.')
    parser.add_argument("-f", dest='include', action='append', help='filter by specified string.')
    parser.add_argument("-v", dest='exclude', action='append', help='filter by specified string.')
    _syntax_ = parser.format_help()

    _example_ = '{:s} -a X86 -m 64\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m 32\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m 16\n'.format(_cmdline_)
    _example_ += '  F0 (LOCK prefix) is ignored\n'
    _example_ += '  F2/F3 (REPNE/REP prefix) are ignored\n'
    _example_ += '  2E/36/3E/26/64/65 (CS/SS/DS/ES/FS/GS override prefix) are ignored\n'
    _example_ += '  2E/3E (branch hint prefix) are ignored\n'
    _example_ += '  66 (operand size prefix) is included\n'
    _example_ += '  67 (address size prefix) is ignored\n'
    _example_ += '  40-4F (REX prefix) are ignored\n'
    _example_ += '  C4/C5 (VEX prefix) are ignored\n'
    _example_ += '  8F (XOP prefix) is ignored\n'
    _example_ += '  62 (EVEX prefix) is ignored'

    def listup_x86(self, arch, mode):
        DISP64 = "1122334455667788"
        DISP32 = "11223344"
        DISP16 = "1122"
        DISP8 = "11"

        def get_typical_bytecodes_modrm(_reg):
            bytecodes = []
            for (mod, reg, rm) in itertools.product([0b00, 0b01, 0b10, 0b11], _reg, [0b000]):
                modrm = "%02X" % ((mod << 6) | (reg << 3) | rm)
                if mod == 0b00:
                    if rm == 0b101: # special case; [REG + disp32]
                        bytecode = modrm + DISP32
                    elif rm == 0b100: # use sib; [INDEX * SCALE + BASE]
                        for sib in filter(lambda x: x & 0b111 != 0b101, range(256)):
                            bytecode = modrm + "%02X" % sib
                    else: # [REG]
                        bytecode = modrm
                elif mod == 0b01:
                    if rm == 0b100: # use sib; [INDEX * SCALE + BASE + disp8]
                        bytecode = []
                        for sib in filter(lambda x: x & 0b111 != 0b101, range(256)):
                            b = modrm + ("%02X" % sib) + DISP8
                            bytecode.append(b)
                    else: # [REG + disp8]
                        bytecode = modrm + DISP8
                elif mod == 0b10:
                    if rm == 0b100: # use sib; [INDEX * SCALE + BASE + disp32]
                        bytecode = []
                        for sib in filter(lambda x: x & 0b111 != 0b101, range(256)):
                            b = modrm + ("%02X" % sib) + DISP32
                            bytecode.append(b)
                    else: # [REG + disp32]
                        bytecode = modrm + DISP32
                elif mod == 0b11: # REG
                    bytecode = modrm
                bytecodes.append(bytecode)
            return bytecodes

        def get_typical_bytecodes(opcodes):
            bytecodes = []
            for i, operand in enumerate(opcodes.split()):
                if operand in ["ib", "cb"]:
                    bytecode = [DISP8]
                elif operand in ["iw", "cw"]:
                    bytecode = [DISP16]
                elif operand in ["id", "cd"]:
                    bytecode = [DISP32]
                elif operand in ["iq"]:
                    bytecode = [DISP64]
                elif operand in ["/0", "/1", "/2", "/3", "/4", "/5", "/6", "/7"]:
                    bytecode = get_typical_bytecodes_modrm(tuple([int(operand[1])]))
                elif operand == "/r":
                    bytecode = get_typical_bytecodes_modrm(tuple([0]))
                elif operand.endswith(("+r", "+i")):
                    b = int(operand.split("+")[0], 16)
                    bytecode = ["%02X" % (b + x) for x in range(8)]
                else:
                    bytecode = [operand]
                bytecodes.append(bytecode)
            return [''.join(b) for b in itertools.product(*bytecodes)]

        # load capstone
        capstone = sys.modules["capstone"]
        try:
            cs = capstone.Cs(arch, mode)
        except capstone.CsError:
            err("CsError")
            return None

        # download defines
        url = 'https://raw.githubusercontent.com/bata24/gef/dev/asmdb/x86data.js'
        x86 = http_get(url)
        if x86 is None:
            err("Connection timed out: {:s}".format(url))
            return None
        x86 = x86.split(b"// ${JSON:BEGIN}")[1].split(b"// ${JSON:END}")[0]
        x86 = json.loads(x86)

        # manually added
        x86_insns = x86["instructions"]
        # [opcode_str, unused, unused, opcodes, attr]
        x86_insns.append(["icebp", "", "", "F1", "Undocumented"])
        x86_insns.append(["salc", "", "", "D6", "Undocumented"])
        #x86_insns.append(["umov", "", "", "0F 10 /r", "Undocumented"]) # used by another opcode
        #x86_insns.append(["umov", "", "", "0F 11 /r", "Undocumented"]) # used by another opcode
        #x86_insns.append(["umov", "", "", "0F 12 /r", "Undocumented"]) # used by another opcode
        #x86_insns.append(["umov", "", "", "0F 13 /r", "Undocumented"]) # used by another opcode
        #x86_insns.append(["loadall", "", "", "0F 05", "Undocumented"]) # used by another opcode
        #x86_insns.append(["loadall", "", "", "0F 07", "Undocumented"]) # used by another opcode
        #x86_insns.append(["xbts", "", "", "0F A6", "Undocumented"]) # removed now
        #x86_insns.append(["ibts", "", "", "0F A7", "Undocumented"]) # removed now

        # parse it
        valid_patterns = []
        seen_patterns = []
        for insn in x86_insns:
            opcodes = insn[3]
            attr = insn[4].split()

            # filter ignore prefix pattern
            if "REX.W" in opcodes.split():
                continue
            if "VEX" in opcodes.split()[0].split("."):
                continue
            if "EVEX" in opcodes.split()[0].split("."):
                continue
            if "XOP" in opcodes.split()[0].split("."):
                continue

            # ex: "FF /2" -> ["FF10", "FF5011", ...]
            bytecodes = get_typical_bytecodes(opcodes)

            # check it is valid or not
            for hex_code in bytecodes:
                # dup check
                if hex_code in seen_patterns:
                    continue
                # disasm
                code = bytes.fromhex(hex_code)
                try:
                    asm = cs.disasm(code, 0).__next__()
                except Exception:
                    continue
                opstr = asm.mnemonic + " " + asm.op_str
                # add
                valid_patterns.append([hex_code, opstr, opcodes, attr])
                seen_patterns.append(hex_code)
        return valid_patterns

    @parse_args
    @load_capstone
    def do_invoke(self, args):
        self.dont_repeat()

        if (args.arch, args.mode) == (None, None):
            if is_alive():
                arch, mode = get_capstone_arch(arch=args.arch, mode=args.mode, endian=is_big_endian())
                arch_mode_s = ":".join([current_arch.arch, current_arch.mode])
                endian_s = "big" if is_big_endian() else "little"
            else:
                # if not alive, defaults to x86-64
                arch, mode = get_capstone_arch(arch="X86", mode="64", endian=False)
                arch_mode_s = "X86:64"
                endian_s = "little"
        elif not args.arch:
            err("An architecture (-a) must be provided")
            return
        elif not args.mode:
            err("A mode (-m) must be provided")
            return
        elif args.arch in ["SPARC", "S390X"] and args.big_endian is False:
            # capstone gives no error so check here
            err("A big endian flag (-e) must be provided")
            return
        else:
            try:
                arch, mode = get_capstone_arch(arch=args.arch, mode=args.mode, endian=args.big_endian)
                arch_mode_s = ":".join([args.arch, args.mode])
                endian_s = "big" if args.big_endian else "little"
            except AttributeError:
                self.usage()
                return

        endian_s # for future update

        # list up bytecode pattern
        if arch_mode_s.startswith("X86:"):
            patterns = self.listup_x86(arch, mode)
        else:
            err("Unsupported")
            return

        if patterns is None:
            err("Failed to listup")
            return

        # filter and print
        fmt = "{:22s} {:60s} {:22s} {}\n"
        legend = ["Hex code", "Assembly code", "Opcode", "Attributes"]
        text = Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading"))
        for hex_code, opstr, opcodes, attr in patterns:
            # byte length filter
            if args.nbyte is not None and args.nbyte * 2 != len(hex_code):
                continue

            # keyword filter
            line = "{:22s} {:60s} {:22s} {}".format(hex_code, opstr, opcodes, ','.join(attr))
            if args.include and any([f not in line for f in args.include]):
                continue
            if args.exclude and any([f in line for f in args.exclude]):
                continue

            # not filtered
            text += line + "\n"

        gef_print(text.rstrip(), less=True)
        return


@register_command
class ProcessListingCommand(GenericCommand):
    """List and filter processes."""
    _cmdline_ = "process-search"
    _category_ = "09-b. Misc - Search"
    _aliases_ = ["ps"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('pattern', metavar='REGEX_PATTERN', nargs='?', help='filter by regex.')
    parser.add_argument('-a', dest='do_attach', action='store_true', help='attach it. (default: %(default)s)')
    parser.add_argument('-s', dest='smart_scan', action='store_true',
                        help='filter kernel thread, socat, grep, gdb, sshd, bash, systemd, etc. (default: %(default)s)')
    _syntax_ = parser.format_help()

    _example_ = "{:s} gdb.*".format(_cmdline_)

    def __init__(self):
        super().__init__()
        ps = which("ps")
        self.add_setting("ps_command", "{:s} auxww".format(ps), "`ps` command to get process information")
        return

    @parse_args
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        if args.pattern:
            pattern = re.compile(args.pattern)
        else:
            pattern = re.compile("^.*$")

        for process in self.get_processes():
            pid = int(process["pid"])
            command = process["command"]
            process["user"] = process["user"].ljust(8)

            if not re.search(pattern, command):
                continue

            if args.smart_scan:
                if command.startswith("[") and command.endswith("]"): # kernel thread
                    continue
                if command.startswith("socat "):
                    continue
                if command.startswith("grep "):
                    continue
                if command.startswith("gdb "):
                    continue
                if command.startswith("-bash"):
                    continue
                if command.startswith("sshd: "):
                    continue
                if command.startswith("avahi-daemon: "):
                    continue
                if command.startswith("@dbus-daemon "):
                    continue
                if command.startswith("(sd-pam)"):
                    continue
                if command.startswith("/lib/systemd/"):
                    continue
                if command.startswith("vmhgfs-fuse "):
                    continue
                if command.startswith("vmware-vmblock-fuse "):
                    continue
                if command.startswith("fusermount3 "):
                    continue
                if command.startswith("/usr/bin/vmtoolsd "):
                    continue
                if command.startswith("/usr/libexec/"):
                    continue
                if command.startswith("/snap/"):
                    continue

            if args and args.do_attach:
                ok("Attaching to process='{:s}' pid={:d}".format(process["command"], pid))
                gdb.execute("attach {:d}".format(pid))
                return

            line = [process[i] for i in ("pid", "user", "cpu", "mem", "tty", "command")]
            gef_print("\t".join(line))
        return

    def get_processes(self):
        output = gef_execute_external(self.get_setting("ps_command").split(), True)
        names = [x.lower().replace("%", "") for x in output[0].split()]

        for line in output[1:]:
            fields = line.split()
            t = {}

            for i, name in enumerate(names):
                if i == len(names) - 1:
                    t[name] = " ".join(fields[i:])
                else:
                    t[name] = fields[i]
            yield t
        return


@register_command
class ArchInfoCommand(GenericCommand):
    """Show current architecture information."""
    _cmdline_ = "arch-info"
    _category_ = "02-a. Process Information - General"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    def is_emulated32(self):
        if is_64bit():
            return False

        if is_qemu_usermode():
            # This case cannot be determined
            return False

        if is_qemu_system():
            # corner case (ex: using qemu-system-x86_64, but process is executed as 32bit mode)
            # is not able to be detected
            return True

        for m in get_process_maps():
            # native x86:
            # 0xbffdf000 0xc0000000 0x021000 0x000000 rw- [stack]
            # emulated x86 on x86_64
            # 0xfffdd000 0xffffe000 0x021000 0x000000 rw- [stack]
            # native arm:
            # 0xbefdf000 0xbf000000 0x021000 0x000000 rw- [stack]
            # emulated arm on aarch64
            # 0xfffcf000 0xffff0000 0x021000 0x000000 rw- [stack]
            if m.path == "[stack]":
                return (m.page_start >> 28) == 0xf
        else:
            return False # by default it considers on native

    def do_invoke(self, args):
        self.dont_repeat()

        if current_arch is None:
            err("current_arch not set")
            return

        gef_print(titlify("GDB/ELF settings"))
        show_arch = gdb.execute("show architecture", to_string=True).rstrip()
        gef_print("{:30s} {:s} {:s}".format("show architecture", RIGHT_ARROW, show_arch))
        if is_64bit():
            bit_str = "64-bit"
        else:
            bit_str = "32-bit"
        if is_big_endian():
            endian_str = "big"
        else:
            endian_str = "little"
        gef_print("{:30s} {:s} {:s}".format("bit", RIGHT_ARROW, bit_str))
        gef_print("{:30s} {:s} {:s}".format("endian", RIGHT_ARROW, endian_str))

        gef_print(titlify("GDB mode"))
        gef_print("{:30s} {:s} {:s}".format("is_normal_run()", RIGHT_ARROW, str(is_normal_run())))
        gef_print("{:30s} {:s} {:s}".format("is_attach()", RIGHT_ARROW, str(is_attach())))
        gef_print("{:30s} {:s} {:s}".format("is_remote_debug()", RIGHT_ARROW, str(is_remote_debug())))
        gef_print("{:30s} {:s} {:s}".format("is_container_attach()", RIGHT_ARROW, str(is_container_attach())))
        gef_print("{:30s} {:s} {:s}".format("is_qemu_system()", RIGHT_ARROW, str(is_qemu_system())))
        gef_print("{:30s} {:s} {:s}".format("is_qemu_usermode()", RIGHT_ARROW, str(is_qemu_usermode())))
        gef_print("{:30s} {:s} {:s}".format("is_pin()", RIGHT_ARROW, str(is_pin())))

        gef_print(titlify("GEF settings"))
        gef_print("{:30s} {:s} {:s}".format("current_arch.arch", RIGHT_ARROW, current_arch.arch))
        gef_print("{:30s} {:s} {:s}".format("current_arch.mode", RIGHT_ARROW, current_arch.mode))
        if current_arch.instruction_length is None:
            inst_len = "variable length"
        else:
            inst_len = str(current_arch.instruction_length)
        gef_print("{:30s} {:s} {:s}".format("instruction length", RIGHT_ARROW, inst_len))
        fparams = ', '.join(current_arch.function_parameters)
        if len(current_arch.function_parameters) == 1:
            fparams += "(passing via stack)"
        gef_print("{:30s} {:s} {:s}".format("return register", RIGHT_ARROW, current_arch.return_register))
        gef_print("{:30s} {:s} {:s}".format("function parameters", RIGHT_ARROW, fparams))
        gef_print("{:30s} {:s} {:s}".format("syscall register", RIGHT_ARROW, str(current_arch.syscall_register)))
        sparams = ', '.join(current_arch.syscall_parameters)
        gef_print("{:30s} {:s} {:s}".format("syscall parameters", RIGHT_ARROW, sparams))
        if is_x86() or is_arm32() or is_arm64():
            gef_print("{:30s} {:s} {:s}".format("32bit-emulated (compat mode)", RIGHT_ARROW, str(self.is_emulated32())))
        gef_print("{:30s} {:s} {:s}".format("Has a call/jump delay slot", RIGHT_ARROW, str(current_arch.has_delay_slot)))
        gef_print("{:30s} {:s} {:s}".format("Has a syscall delay slot", RIGHT_ARROW, str(current_arch.has_syscall_delay_slot)))
        gef_print("{:30s} {:s} {:s}".format("Has a ret delay slot", RIGHT_ARROW, str(current_arch.has_ret_delay_slot)))
        gef_print("{:30s} {:s} {:s}".format("keystone support", RIGHT_ARROW, str(current_arch.keystone_support)))
        gef_print("{:30s} {:s} {:s}".format("capstone support", RIGHT_ARROW, str(current_arch.capstone_support)))
        gef_print("{:30s} {:s} {:s}".format("unicorn support", RIGHT_ARROW, str(current_arch.unicorn_support)))
        return


@register_command
class ElfInfoCommand(GenericCommand):
    """Display a limited subset of ELF header information."""
    _cmdline_ = "elf-info"
    _category_ = "02-a. Process Information - General"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-e', dest='use_readelf', action='store_true', help='use readelf. (default: %(default)s)')
    parser.add_argument('-r', dest='remote', action='store_true',
                        help='parse remote binary if download feature is available. (default: %(default)s)')
    parser.add_argument('-f', dest='file', help='the file path you want to parse.')
    parser.add_argument('-a', dest='address', type=parse_address, help='the memory address you want to parse.')
    _syntax_ = parser.format_help()

    _example_ = "{:s}                   # parse binary itself\n".format(_cmdline_)
    _example_ += "{:s} -f /bin/ls        # parse binary\n".format(_cmdline_)
    _example_ += "{:s} -f /bin/ls -r     # parse remote binary\n".format(_cmdline_)
    _example_ += "{:s} -a 0x555555554000 # parse memory\n".format(_cmdline_)
    _example_ += "{:s} -e -f /bin/ls     # show `readelf -a FILE | less`".format(_cmdline_)

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_FILENAME)
        return

    def elf_info(self, elf, orig_filepath=None):
        # http://www.sco.com/developers/gabi/latest/ch4.eheader.html
        classes = {
            Elf.ELF_CLASS_NONE : "Unknown",
            Elf.ELF_32_BITS    : "32-bit",
            Elf.ELF_64_BITS    : "64-bit",
        }

        endianness = {
            Elf.ELF_DATA_NONE : "Unknown",
            Elf.LITTLE_ENDIAN : "Little-Endian",
            Elf.BIG_ENDIAN    : "Big-Endian",
        }

        osabis = {
            Elf.OSABI_SYSTEMV    : "UNIX System V ABI",
            Elf.OSABI_HPUX       : "Hewlett-Packard HP-UX",
            Elf.OSABI_NETBSD     : "NetBSD",
            Elf.OSABI_LINUX      : "GNU Linux",
            Elf.OSABI_HURD       : "GNU Hurd",
            Elf.OSABI_86OPEN     : "86Open Common IA32 ABI",
            Elf.OSABI_SOLARIS    : "Sun Solaris",
            Elf.OSABI_AIX        : "IBM AIX",
            Elf.OSABI_IRIX       : "SGI IRIX",
            Elf.OSABI_FREEBSD    : "FreeBSD",
            Elf.OSABI_TRU64      : "Compaq TRU64 UNIX",
            Elf.OSABI_MODESTO    : "Novell Modesto",
            Elf.OSABI_OPENBSD    : "OpenBSD",
            Elf.OSABI_OPENVMS    : "OpenVMS",
            Elf.OSABI_NSK        : "Hewlett-Packard Non-Stop Kernel",
            Elf.OSABI_AROS       : "Amiga Research OS",
            Elf.OSABI_FENIXOS    : "The FenixOS highly scalable multi-core OS",
            Elf.OSABI_CLOUDABI   : "Nuxi CloudABI",
            Elf.OSABI_OPENVOS    : "Stratus Technologies OpenVOS",
            Elf.OSABI_ARM_AEABI  : "ARM EABI",
            Elf.OSABI_ARM        : "ARM",
            Elf.OSABI_STANDALONE : "Standalone (embedded) application",
        }

        types = {
            Elf.ET_NONE : "No file type",
            Elf.ET_REL  : "Relocatable",
            Elf.ET_EXEC : "Executable",
            Elf.ET_DYN  : "Shared",
            Elf.ET_CORE : "Core",
        }

        machines = {
            Elf.EM_NONE                  : "No machine",
            Elf.EM_M32                   : "AT&T WE 32100",
            Elf.EM_SPARC                 : "SUN SPARC",
            Elf.EM_386                   : "Intel 80386",
            Elf.EM_68K                   : "Motorola m68k family",
            Elf.EM_88K                   : "Motorola m88k family",
            Elf.EM_IAMCU                 : "Intel MCU",
            Elf.EM_860                   : "Intel 80860",
            Elf.EM_MIPS                  : "MIPS R3000 big-endian",
            Elf.EM_S370                  : "IBM System/370 Processor",
            Elf.EM_MIPS_RS3_LE           : "MIPS RS3000 Little-endian",
            Elf.EM_PARISC                : "Hewlett-Packard PA-RISC",
            Elf.EM_VPP500                : "Fujitsu VPP500",
            Elf.EM_SPARC32PLUS           : "Enhanced instruction set SPARC",
            Elf.EM_960                   : "Intel 80960",
            Elf.EM_PPC                   : "PowerPC",
            Elf.EM_PPC64                 : "64-bit PowerPC",
            Elf.EM_S390                  : "IBM System/390 Processor",
            Elf.EM_SPU                   : "IBM SPU/SPC",
            Elf.EM_V800                  : "NEC V800",
            Elf.EM_FR20                  : "Fujitsu FR20",
            Elf.EM_RH32                  : "TRW RH-32",
            Elf.EM_RCE                   : "Motorola RCE",
            Elf.EM_ARM                   : "ARM 32-bit architecture (AARCH32)",
            Elf.EM_ALPHA                 : "Digital Alpha",
            Elf.EM_SH                    : "Hitachi SH",
            Elf.EM_SPARCV9               : "SPARC Version 9",
            Elf.EM_TRICORE               : "Siemens TriCore embedded processor",
            Elf.EM_ARC                   : "Argonaut RISC Core, Argonaut Technologies Inc.",
            Elf.EM_H8_300                : "Hitachi H8/300",
            Elf.EM_H8_300H               : "Hitachi H8/300H",
            Elf.EM_H8S                   : "Hitachi H8S",
            Elf.EM_H8_500                : "Hitachi H8/500",
            Elf.EM_IA_64                 : "Intel IA-64 processor architecture",
            Elf.EM_MIPS_X                : "Stanford MIPS-X",
            Elf.EM_COLDFIRE              : "Motorola ColdFire",
            Elf.EM_68HC12                : "Motorola M68HC12",
            Elf.EM_MMA                   : "Fujitsu MMA Multimedia Accelerator",
            Elf.EM_PCP                   : "Siemens PCP",
            Elf.EM_NCPU                  : "Sony nCPU embedded RISC processor",
            Elf.EM_NDR1                  : "Denso NDR1 microprocessor",
            Elf.EM_STARCORE              : "Motorola Star*Core processor",
            Elf.EM_ME16                  : "Toyota ME16 processor",
            Elf.EM_ST100                 : "STMicroelectronics ST100 processor",
            Elf.EM_TINYJ                 : "Advanced Logic Corp. TinyJ embedded processor family",
            Elf.EM_X86_64                : "AMD x86-64 architecture",
            Elf.EM_PDSP                  : "Sony DSP Processor",
            Elf.EM_PDP10                 : "Digital Equipment Corp. PDP-10",
            Elf.EM_PDP11                 : "Digital Equipment Corp. PDP-11",
            Elf.EM_FX66                  : "Siemens FX66 microcontroller",
            Elf.EM_ST9PLUS               : "STMicroelectronics ST9+ 8/16 bit microcontroller",
            Elf.EM_ST7                   : "STMicroelectronics ST7 8-bit microcontroller",
            Elf.EM_68HC16                : "Motorola MC68HC16 Microcontroller",
            Elf.EM_68HC11                : "Motorola MC68HC11 Microcontroller",
            Elf.EM_68HC08                : "Motorola MC68HC08 Microcontroller",
            Elf.EM_68HC05                : "Motorola MC68HC05 Microcontroller",
            Elf.EM_SVX                   : "Silicon Graphics SVx",
            Elf.EM_ST19                  : "STMicroelectronics ST19 8-bit microcontroller",
            Elf.EM_VAX                   : "Digital VAX",
            Elf.EM_CRIS                  : "Axis Communications 32-bit embedded processor",
            Elf.EM_JAVELIN               : "Infineon Technologies 32-bit embedded processor",
            Elf.EM_FIREPATH              : "Element 14 64-bit DSP Processor",
            Elf.EM_ZSP                   : "LSI Logic 16-bit DSP Processor",
            Elf.EM_MMIX                  : "Donald Knuth's educational 64-bit processor",
            Elf.EM_HUANY                 : "Harvard University machine-independent object files",
            Elf.EM_PRISM                 : "SiTera Prism",
            Elf.EM_AVR                   : "Atmel AVR 8-bit microcontroller",
            Elf.EM_FR30                  : "Fujitsu FR30",
            Elf.EM_D10V                  : "Mitsubishi D10V",
            Elf.EM_D30V                  : "Mitsubishi D30V",
            Elf.EM_V850                  : "NEC v850",
            Elf.EM_M32R                  : "Mitsubishi M32R",
            Elf.EM_MN10300               : "Matsushita MN10300",
            Elf.EM_MN10200               : "Matsushita MN10200",
            Elf.EM_PJ                    : "picoJava",
            Elf.EM_OPENRISC              : "OpenRISC 32-bit embedded processor",
            Elf.EM_ARC_COMPACT           : "ARC International ARCompact processor (old spelling/synonym: EM_ARC_A5)",
            Elf.EM_XTENSA                : "Tensilica Xtensa Architecture",
            Elf.EM_VIDEOCORE             : "Alphamosaic VideoCore processor",
            Elf.EM_TMM_GPP               : "Thompson Multimedia General Purpose Processor",
            Elf.EM_NS32K                 : "National Semiconductor 32000 series",
            Elf.EM_TPC                   : "Tenor Network TPC processor",
            Elf.EM_SNP1K                 : "Trebia SNP 1000 processor",
            Elf.EM_ST200                 : "STMicroelectronics ST200 microcontroller",
            Elf.EM_IP2K                  : "Ubicom IP2xxx microcontroller family",
            Elf.EM_MAX                   : "MAX Processor",
            Elf.EM_CR                    : "National Semiconductor CompactRISC microprocessor",
            Elf.EM_F2MC16                : "Fujitsu F2MC16",
            Elf.EM_MSP430                : "Texas Instruments embedded microcontroller msp430",
            Elf.EM_BLACKFIN              : "Analog Devices Blackfin (DSP) processor",
            Elf.EM_SE_C33                : "S1C33 Family of Seiko Epson processors",
            Elf.EM_SEP                   : "Sharp embedded microprocessor",
            Elf.EM_ARCA                  : "Arca RISC Microprocessor",
            Elf.EM_UNICORE               : "Microprocessor series from PKU-Unity Ltd. and MPRC of Peking University",
            Elf.EM_EXCESS                : "eXcess: 16/32/64-bit configurable embedded CPU",
            Elf.EM_DXP                   : "Icera Semiconductor Inc. Deep Execution Processor",
            Elf.EM_ALTERA_NIOS2          : "Altera Nios II soft-core processor",
            Elf.EM_CRX                   : "National Semiconductor CompactRISC CRX microprocessor",
            Elf.EM_XGATE                 : "Motorola XGATE embedded processor",
            Elf.EM_C166                  : "Infineon C16x/XC16x processor",
            Elf.EM_M16C                  : "Renesas M16C series microprocessors",
            Elf.EM_DSPIC30F              : "Microchip Technology dsPIC30F Digital Signal Controller",
            Elf.EM_CE                    : "Freescale Communication Engine RISC core",
            Elf.EM_M32C                  : "Renesas M32C series microprocessors",
            Elf.EM_TSK3000               : "Altium TSK3000 core",
            Elf.EM_RS08                  : "Freescale RS08 embedded processor",
            Elf.EM_SHARC                 : "Analog Devices SHARC family of 32-bit DSP processors",
            Elf.EM_ECOG2                 : "Cyan Technology eCOG2 microprocessor",
            Elf.EM_SCORE7                : "Sunplus S+core7 RISC processor",
            Elf.EM_DSP24                 : "New Japan Radio (NJR) 24-bit DSP Processor",
            Elf.EM_VIDEOCORE3            : "Broadcom VideoCore III processor",
            Elf.EM_LATTICEMICO32         : "RISC processor for Lattice FPGA architecture",
            Elf.EM_SE_C17                : "Seiko Epson C17 family",
            Elf.EM_TI_C6000              : "The Texas Instruments TMS320C6000 DSP family",
            Elf.EM_TI_C2000              : "The Texas Instruments TMS320C2000 DSP family",
            Elf.EM_TI_C5500              : "The Texas Instruments TMS320C55x DSP family",
            Elf.EM_TI_ARP32              : "Texas Instruments Application Specific RISC Processor, 32bit fetch",
            Elf.EM_TI_PRU                : "Texas Instruments Programmable Realtime Unit",
            Elf.EM_MMDSP_PLUS            : "STMicroelectronics 64bit VLIW Data Signal Processor",
            Elf.EM_CYPRESS_M8C           : "Cypress M8C microprocessor",
            Elf.EM_R32C                  : "Renesas R32C series microprocessors",
            Elf.EM_TRIMEDIA              : "NXP Semiconductors TriMedia architecture family",
            Elf.EM_QDSP6                 : "QUALCOMM DSP6 Processor",
            Elf.EM_8051                  : "Intel 8051 and variants",
            Elf.EM_STXP7X                : "STMicroelectronics STxP7x family of configurable and extensible RISC processors",
            Elf.EM_NDS32                 : "Andes Technology compact code size embedded RISC processor family",
            Elf.EM_ECOG1                 : "Cyan Technology eCOG1X family",
            Elf.EM_ECOG1X                : "Cyan Technology eCOG1X family",
            Elf.EM_MAXQ30                : "Dallas Semiconductor MAXQ30 Core Micro-controllers",
            Elf.EM_XIMO16                : "New Japan Radio (NJR) 16-bit DSP Processor",
            Elf.EM_MANIK                 : "M2000 Reconfigurable RISC Microprocessor",
            Elf.EM_CRAYNV2               : "Cray Inc. NV2 vector architecture",
            Elf.EM_RX                    : "Renesas RX family",
            Elf.EM_METAG                 : "Imagination Technologies META processor architecture",
            Elf.EM_MCST_ELBRUS           : "MCST Elbrus general purpose hardware architecture",
            Elf.EM_ECOG16                : "Cyan Technology eCOG16 family",
            Elf.EM_CR16                  : "National Semiconductor CompactRISC CR16 16-bit microprocessor",
            Elf.EM_ETPU                  : "Freescale Extended Time Processing Unit",
            Elf.EM_SLE9X                 : "Infineon Technologies SLE9X core",
            Elf.EM_L10M                  : "Intel L10M",
            Elf.EM_K10M                  : "Intel K10M",
            182                          : "Reserved for future Intel use",
            Elf.EM_AARCH64               : "ARM 64-bit architecture (AARCH64)",
            184                          : "Reserved for future ARM use",
            Elf.EM_AVR32                 : "Atmel Corporation 32-bit microprocessor family",
            Elf.EM_STM8                  : "STMicroeletronics STM8 8-bit microcontroller",
            Elf.EM_TILE64                : "Tilera TILE64 multicore architecture family",
            Elf.EM_TILEPRO               : "Tilera TILEPro multicore architecture family",
            Elf.EM_MICROBLAZE            : "Xilinx MicroBlaze 32-bit RISC soft processor core",
            Elf.EM_CUDA                  : "NVIDIA CUDA architecture",
            Elf.EM_TILEGX                : "Tilera TILE-Gx multicore architecture family",
            Elf.EM_CLOUDSHIELD           : "CloudShield architecture family",
            Elf.EM_COREA_1ST             : "KIPO-KAIST Core-A 1st generation processor family",
            Elf.EM_COREA_2ND             : "KIPO-KAIST Core-A 2nd generation processor family",
            Elf.EM_ARC_COMPACT2          : "Synopsys ARCompact V2",
            Elf.EM_OPEN8                 : "Open8 8-bit RISC soft processor core",
            Elf.EM_RL78                  : "Renesas RL78 family",
            Elf.EM_VIDEOCORE5            : "Broadcom VideoCore V processor",
            Elf.EM_78KOR                 : "Renesas 78KOR family",
            Elf.EM_56800EX               : "Freescale 56800EX Digital Signal Controller (DSC)",
            Elf.EM_BA1                   : "Beyond BA1 CPU architecture",
            Elf.EM_BA2                   : "Beyond BA2 CPU architecture",
            Elf.EM_XCORE                 : "XMOS xCORE processor family",
            Elf.EM_MCHP_PIC              : "Microchip 8-bit PIC(r) family",
            Elf.EM_INTEL205              : "Reserved by Intel",
            Elf.EM_INTEL206              : "Reserved by Intel",
            Elf.EM_INTEL207              : "Reserved by Intel",
            Elf.EM_INTEL208              : "Reserved by Intel",
            Elf.EM_INTEL209              : "Reserved by Intel",
            Elf.EM_KM32                  : "KM211 KM32 32-bit processor",
            Elf.EM_KMX32                 : "KM211 KMX32 32-bit processor",
            Elf.EM_KMX16                 : "KM211 KMX16 16-bit processor",
            Elf.EM_KMX8                  : "KM211 KMX8 8-bit processor",
            Elf.EM_KVARC                 : "KM211 KVARC processor",
            Elf.EM_CDP                   : "Paneve CDP architecture family",
            Elf.EM_COGE                  : "Cognitive Smart Memory Processor",
            Elf.EM_COOL                  : "Bluechip Systems CoolEngine",
            Elf.EM_NORC                  : "Nanoradio Optimized RISC",
            Elf.EM_CSR_KALIMBA           : "CSR Kalimba architecture family",
            Elf.EM_Z80                   : "Zilog Z80",
            Elf.EM_VISIUM                : "Controls and Data Services VISIUMcore processor",
            Elf.EM_FT32                  : "FTDI Chip FT32 high performance 32-bit RISC architecture",
            Elf.EM_MOXIE                 : "Moxie processor family",
            Elf.EM_AMDGPU                : "AMD GPU architecture",
            Elf.EM_RISCV                 : "RISC-V",
            Elf.EM_LANAI                 : "Lanai 32-bit processor",
            Elf.EM_BPF                   : "Linux BPF -- in-kernel virtual machine",
            Elf.EM_LOONGARCH             : "LoongArch",

            Elf.EM_AVR_UNOFFICIAL        : "AVR (unofficial)",
            Elf.EM_MSP430_UNOFFICIAL     : "MSP430 (unofficial)",
            Elf.EM_EPIPHANY_UNOFFICIAL   : "Adapteva Epiphany (unofficial)",
            Elf.EM_AVR32_UNOFFICIAL      : "Atmel AVR32 (unofficial)",
            Elf.EM_MT_UNOFFICIAL         : "Morpho MT (unofficial)",
            Elf.EM_FR30_UNOFFICIAL       : "FR30 (unofficial)",
            Elf.EM_OPENRISC_OLD          : "OpenRISC (obsolete)",
            Elf.EM_C166_UNOFFICIAL       : "Infineon C166 (unofficial)",
            Elf.EM_FRV_UNOFFICIAL        : "Cygnus FR-V (unofficial)",
            Elf.EM_DLX_UNOFFICIAL        : "DLX (unofficial)",
            Elf.EM_D10V_UNOFFICIAL       : "Cygnus D10V (unofficial)",
            Elf.EM_D30V_UNOFFICIAL       : "Cygnus D30V (unofficial)",
            Elf.EM_IP2K_UNOFFICIAL       : "Ubicom IP2xxx (unofficial)",
            Elf.EM_OPENRISC_OLD2         : "OpenRISC (obsolete)",
            Elf.EM_PPC_UNOFFICIAL        : "Cygnus PowerPC (unofficial)",
            Elf.EM_ALPHA_UNOFFICIAL      : "Digital Alpha (unofficial)",
            Elf.EM_M32R_UNOFFICIAL       : "Cygnus M32R (unofficial)",
            Elf.EM_V850_UNOFFICIAL       : "Cygnus V859 (unofficial)",
            Elf.EM_S390_OLD              : "IBM S/390 (obsolete)",
            Elf.EM_XTENSA_UNOFFICIAL     : "Old Xtensa (unofficial)",
            Elf.EM_XSTORMY_UNOFFICIAL    : "xstormy16 (unofficial)",
            Elf.EM_MICROBLAZE_UNOFFICIAL : "Old MicroBlaze (unofficial)",
            Elf.EM_MN10300_UNOFFICIAL    : "Cygnus MN10300 (unofficial)",
            Elf.EM_MN10200_UNOFFICIAL    : "Cygnus MN10200 (unofficial)",
            Elf.EM_MEP_UNOFFICIAL        : "Toshiba MeP (unofficial)",
            Elf.EM_M32C_UNOFFICIAL       : "Renesas M32C (unofficial)",
            Elf.EM_IQ2000_UNOFFICIAL     : "Vitesse IQ2000 (unofficial)",
            Elf.EM_NIOS_UNOFFICIAL       : "NIOS (unofficial)",
            Elf.EM_MOXIE_UNOFFICIAL      : "Moxie (unofficial)",
        }

        versions = {
            Elf.EV_NONE    : "Invalid version",
            Elf.EV_CURRENT : "Current version",
        }

        if elf.filename:
            if orig_filepath:
                filename = "{:s} (remote: {:s})".format(elf.filename, orig_filepath)
            else:
                filename = elf.filename
        elif elf.addr is not None:
            filename = "{:#x}".format(elf.addr)
        gef_print(titlify("ELF Header - {:s}".format(filename)))

        magic_hex = hexdump(struct.pack(">I", elf.e_magic), show_raw=True)
        magic_str = repr(p32(elf.e_magic).decode()[::-1])
        data = [
            ("Magic", "{:s} ({:s})".format(magic_hex, magic_str)),
            ("Class", "{:#x} - {:s}".format(elf.e_class, classes[elf.e_class])),
            ("Endianness", "{:#x} - {:s}".format(elf.e_endianness, endianness[elf.e_endianness])),
            ("ELF Version", "{:#x} - {:s}".format(elf.e_eiversion, versions[elf.e_eiversion])),
            ("OS ABI", "{:#x} - {:s}".format(elf.e_osabi, osabis[elf.e_osabi])),
            ("ABI Version", "{:#x}".format(elf.e_abiversion)),
            ("Type", "{:#x} - {:s}".format(elf.e_type, types[elf.e_type])),
            ("Machine", "{:#x} - {:s}".format(elf.e_machine, machines.get(elf.e_machine, "Unknown"))),
            ("Version", "{:#x} - {:s}".format(elf.e_version, versions[elf.e_version])),
            ("Entry point", "{:s}".format(format_address(elf.e_entry))),
            ("Program Header Table", "{:s}".format(format_address(elf.e_phoff))),
            ("Program Header Entry Size", "{0:d} ({0:#x})".format(elf.e_phentsize)),
            ("Number of Program Headers", "{:d}".format(elf.e_phnum)),
            ("Section Header Table", "{:s}".format(format_address(elf.e_shoff))),
            ("Section Header Entry Size", "{0:d} ({0:#x})".format(elf.e_shentsize)),
            ("Number of Section Headers", "{:d}".format(elf.e_shnum)),
            ("ELF Header Size", "{0:d} ({0:#x})".format(elf.e_ehsize)),
            ("Section Header String Table Index", "{0:d} ({0:#x})".format(elf.e_shstrndx)),
            ("Processor Specific Flags", "{:#x}".format(elf.e_flags)),
        ]

        for title, content in data:
            gef_print("{:<34s}: {}".format(title, content))

        ptype = {
            Phdr.PT_NULL          : "NULL",
            Phdr.PT_LOAD          : "LOAD",
            Phdr.PT_DYNAMIC       : "DYNAMIC",
            Phdr.PT_INTERP        : "INTERP",
            Phdr.PT_NOTE          : "NOTE",
            Phdr.PT_SHLIB         : "SHLIB",
            Phdr.PT_PHDR          : "PHDR",
            Phdr.PT_TLS           : "TLS",
            Phdr.PT_GNU_EH_FRAME  : "GNU_EH_FLAME",
            Phdr.PT_GNU_STACK     : "GNU_STACK",
            Phdr.PT_GNU_RELRO     : "GNU_RELRO",
            Phdr.PT_SUNWBSS       : "SUNWBSS",
            Phdr.PT_SUNWSTACK     : "SUNWSTACK",
            Phdr.PT_MIPS_REGINFO  : "REGINFO",
            Phdr.PT_MIPS_RTPROC   : "RTPROC",
            Phdr.PT_MIPS_OPTIONS  : "OPTIONS",
            Phdr.PT_MIPS_ABIFLAGS : "ABIFLAGS",
        }

        pflags = {
            0                                 : "---",
            Phdr.PF_X                         : "--X",
            Phdr.PF_W                         : "-W-",
            Phdr.PF_R                         : "R--",
            Phdr.PF_W | Phdr.PF_X             : "-WX",
            Phdr.PF_R | Phdr.PF_X             : "R-X",
            Phdr.PF_R | Phdr.PF_W             : "RW-",
            Phdr.PF_R | Phdr.PF_W | Phdr.PF_X : "RWX",
        }

        name_width = max([len(ptype.get(p.p_type, "UNKNOWN")) for p in elf.phdrs])

        gef_print(titlify("Program Header - {:s}".format(filename)))
        fmt = "[{:>2s}] {:{:d}s} {:>12s} {:>12s} {:>12s} {:>12s} {:>12s} {:5s} {:>8s}"
        legend = [
            "#", "Type", name_width, "Offset", "Virtaddr",
            "Physaddr", "FileSiz", "MemSiz", "Flags", "Align",
        ]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for i, p in enumerate(elf.phdrs):
            p_type = ptype[p.p_type] if p.p_type in ptype else "UNKNOWN"
            p_flags = pflags[p.p_flags] if p.p_flags in pflags else "???"
            fmt = "[{:2d}] {:{:d}s} {:#12x} {:#12x} {:#12x} {:#12x} {:#12x} {:5s} {:#8x}"
            args = [
                i, p_type, name_width, p.p_offset, p.p_vaddr,
                p.p_paddr, p.p_filesz, p.p_memsz, p_flags, p.p_align,
            ]
            gef_print(fmt.format(*args))

        stype = {
            Shdr.SHT_NULL           : "NULL",
            Shdr.SHT_PROGBITS       : "PROGBITS",
            Shdr.SHT_SYMTAB         : "SYMTAB",
            Shdr.SHT_STRTAB         : "STRTAB",
            Shdr.SHT_RELA           : "RELA",
            Shdr.SHT_HASH           : "HASH",
            Shdr.SHT_DYNAMIC        : "DYNAMIC",
            Shdr.SHT_NOTE           : "NOTE",
            Shdr.SHT_NOBITS         : "NOBITS",
            Shdr.SHT_REL            : "REL",
            Shdr.SHT_SHLIB          : "SHLIB",
            Shdr.SHT_DYNSYM         : "DYNSYM",
            Shdr.SHT_NUM            : "NUM",
            Shdr.SHT_INIT_ARRAY     : "INIT_ARRAY",
            Shdr.SHT_FINI_ARRAY     : "FINI_ARRAY",
            Shdr.SHT_PREINIT_ARRAY  : "PREINIT_ARRAY",
            Shdr.SHT_GROUP          : "GROUP",
            Shdr.SHT_SYMTAB_SHNDX   : "SYMTAB_SHNDX",
            Shdr.SHT_NUM            : "NUM",
            Shdr.SHT_GNU_ATTRIBUTES : "GNU_ATTRIBUTES",
            Shdr.SHT_GNU_HASH       : "GNU_HASH",
            Shdr.SHT_GNU_LIBLIST    : "GNU_LIBLIST",
            Shdr.SHT_CHECKSUM       : "CHECKSUM",
            Shdr.SHT_SUNW_move      : "SUNW_move",
            Shdr.SHT_SUNW_COMDAT    : "SUNW_COMDAT",
            Shdr.SHT_SUNW_syminfo   : "SUNW_syminfo",
            Shdr.SHT_GNU_verdef     : "GNU_verdef",
            Shdr.SHT_GNU_verneed    : "GNU_verneed",
            Shdr.SHT_GNU_versym     : "GNU_versym",
        }

        gef_print(titlify("Section Header - {:s}".format(filename)))
        if not elf.shdrs:
            gef_print("Not loaded")
        else:
            name_width = max([len(s.sh_name) for s in elf.shdrs])
            fmt = "[{:>2s}] {:{:d}s} {:>15s} {:>12s} {:>12s} {:>12s} {:>12s} {:>5s} {:>5s} {:>5s} {:>8s}"
            legend = ["#", "Name", name_width, "Type", "Address", "Offset", "Size", "EntSiz", "Flags", "Link", "Info", "Align"]
            gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
            for i, s in enumerate(elf.shdrs):
                sh_type = stype[s.sh_type] if s.sh_type in stype else "UNKNOWN"
                sh_flags = ""
                if s.sh_flags & Shdr.SHF_WRITE:
                    sh_flags += "W"
                if s.sh_flags & Shdr.SHF_ALLOC:
                    sh_flags += "A"
                if s.sh_flags & Shdr.SHF_EXECINSTR:
                    sh_flags += "X"
                if s.sh_flags & Shdr.SHF_MERGE:
                    sh_flags += "M"
                if s.sh_flags & Shdr.SHF_STRINGS:
                    sh_flags += "S"
                if s.sh_flags & Shdr.SHF_INFO_LINK:
                    sh_flags += "I"
                if s.sh_flags & Shdr.SHF_LINK_ORDER:
                    sh_flags += "L"
                if s.sh_flags & Shdr.SHF_OS_NONCONFORMING:
                    sh_flags += "O"
                if s.sh_flags & Shdr.SHF_GROUP:
                    sh_flags += "G"
                if s.sh_flags & Shdr.SHF_TLS:
                    sh_flags += "T"
                if s.sh_flags & Shdr.SHF_EXCLUDE:
                    sh_flags += "E"
                if s.sh_flags & Shdr.SHF_COMPRESSED:
                    sh_flags += "C"

                fmt = "[{:2d}] {:{:d}s} {:>15s} {:#12x} {:#12x} {:#12x} {:#12x} {:5s} {:#5x} {:#5x} {:#8x}"
                args = [
                    i, s.sh_name, name_width, sh_type, s.sh_addr, s.sh_offset, s.sh_size,
                    s.sh_entsize, sh_flags, s.sh_link, s.sh_info, s.sh_addralign,
                ]
                gef_print(fmt.format(*args))
        return

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()

        local_filepath = None
        remote_filepath = None
        tmp_filepath = None

        # memory parse pattern
        if args.address is not None:
            elf = Elf(args.address)
            if elf is None or not elf.is_valid():
                err("Failed to parse elf.")
            else:
                self.elf_info(elf)
            return

        # file parse pattern
        if args.remote:
            if not is_remote_debug():
                err("-r option is allowed only remote debug.")
                return
            if is_qemu_system():
                err("-r option is unsupported under qemu-system.")
                return

            if args.file:
                remote_filepath = args.file # if specified, assume it is remote
            elif gdb.current_progspace().filename:
                f = gdb.current_progspace().filename
                if f.startswith("target:"): # gdbserver
                    f = f[7:]
                remote_filepath = f
            elif get_pid(remote=True):
                remote_filepath = "/proc/{:d}/exe".format(get_pid(remote=True))
            else:
                err("File name could not be determined.")
                return

            data = read_remote_file(remote_filepath, as_byte=True) # qemu-user is failed here, it is ok
            if not data:
                err("Failed to read remote filepath")
                return
            tmp_fd, tmp_filepath = tempfile.mkstemp(dir=GEF_TEMP_DIR, suffix=".elf", prefix="elf-info-")
            os.write(tmp_fd, data)
            os.close(tmp_fd)
            local_filepath = tmp_filepath
            del data

        elif args.file:
            local_filepath = args.file

        elif args.file is None:
            if is_qemu_system():
                err("Argument-less calls are unsupported under qemu-system.")
                return
            local_filepath = get_filepath()

        if local_filepath is None:
            err("File name could not be determined.")
            return

        # readelf pattern
        if args.use_readelf:
            os.system("readelf -a '{:s}' | less".format(local_filepath))
            if tmp_filepath and os.path.exists(tmp_filepath):
                os.unlink(tmp_filepath)
            return

        # self parse pattern
        elf = get_elf_headers(local_filepath)
        if elf is None or not elf.is_valid():
            err("Failed to parse elf.")
        else:
            data = open(local_filepath, "rb").read()
            info("size: {:d} bytes, sha1: {:s}".format(len(data), hashlib.sha1(data).hexdigest()))
            self.elf_info(elf, remote_filepath)

        if tmp_filepath and os.path.exists(tmp_filepath):
            os.unlink(tmp_filepath)
        return


@register_command
class ChecksecCommand(GenericCommand):
    """Checksec the security properties of the current executable or passed as argument."""
    _cmdline_ = "checksec"
    _category_ = "02-f. Process Information - Security"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-r', dest='remote', action='store_true',
                        help='parse remote binary if download feature is available. (default: %(default)s)')
    parser.add_argument('-f', dest='file', help='the file path you want to parse.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} -f /bin/ls\n".format(_cmdline_)
    _example_ += "{:s} -r".format(_cmdline_)

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_FILENAME)
        return

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()

        if is_qemu_system():
            self.print_security_properties_qemu_system()
            return

        local_filepath = None
        remote_filepath = None
        tmp_filepath = None

        if args.remote:
            if not is_remote_debug():
                err("-r option is allowed only remote debug.")
                return

            if args.file:
                remote_filepath = args.file # if specified, assume it is remote
            elif gdb.current_progspace().filename:
                f = gdb.current_progspace().filename
                if f.startswith("target:"): # gdbserver
                    f = f[7:]
                remote_filepath = f
            elif get_pid(remote=True):
                remote_filepath = "/proc/{:d}/exe".format(get_pid(remote=True))
            else:
                err("File name could not be determined.")
                return

            data = read_remote_file(remote_filepath, as_byte=True) # qemu-user is failed here, it is ok
            if not data:
                err("Failed to read remote filepath")
                return
            tmp_fd, tmp_filepath = tempfile.mkstemp(dir=GEF_TEMP_DIR, suffix=".elf", prefix="checksec-")
            os.write(tmp_fd, data)
            os.close(tmp_fd)
            local_filepath = tmp_filepath
            del data

        elif args.file:
            local_filepath = args.file

        elif args.file is None:
            if is_qemu_system():
                err("Argument-less calls are unsupported under qemu-system.")
                return
            local_filepath = get_filepath()

        if local_filepath is None:
            err("File name could not be determined.")
            return

        if remote_filepath:
            print_filename = "{:s} (remote: {:s})".format(local_filepath, remote_filepath)
        else:
            print_filename = local_filepath
        gef_print(titlify("checksec - {:s}".format(print_filename)))

        self.print_security_properties(local_filepath)

        if tmp_filepath and os.path.exists(tmp_filepath):
            os.unlink(tmp_filepath)
        return

    def print_security_properties(self, filename):

        def get_colored_msg(val):
            if val is True:
                msg = Color.greenify(Color.boldify("Enabled"))
            elif val is False:
                msg = Color.redify(Color.boldify("Disabled"))
            elif val is None:
                msg = Color.grayify(Color.boldify("Unknown"))
            return msg

        sec = checksec(filename)
        if sec is False:
            err("checksec is failed")
            return

        gef_print(titlify("Basic information"))

        # Canary
        msg = get_colored_msg(sec["Canary"])
        if sec["Canary"] is True and is_alive():
            res = gef_read_canary()
            if not res:
                msg += " (Could not get the canary value)"
            else:
                msg += " (value: {:#x})".format(res[0])
        gef_print("{:<30s}: {:s}".format("Canary", msg))

        # NX
        gef_print("{:<30s}: {:s}".format("NX", get_colored_msg(sec["NX"])))

        # PIE
        gef_print("{:<30s}: {:s}".format("PIE", get_colored_msg(sec["PIE"])))

        # RELRO
        if sec["Full RELRO"]:
            gef_print("{:<30s}: {:s}".format("RELRO", Color.colorify("Full RELRO", "bold green")))
        elif sec["Partial RELRO"]:
            gef_print("{:<30s}: {:s}".format("RELRO", Color.colorify("Partial RELRO", "bold yellow")))
        else:
            gef_print("{:<30s}: {:s}".format("RELRO", Color.colorify("No RELRO", "bold red")))

        # Fortify
        if sec["Fortify"]:
            gef_print("{:<30s}: {:s}".format("Fortify", Color.colorify("Found", "bold green")))
        else:
            gef_print("{:<30s}: {:s}".format("Fortify", Color.colorify("Not Found", "bold red")))

        gef_print(titlify("Additional information"))

        # Static
        if sec["Static"]:
            gef_print("{:<30s}: {:s}".format("Static/Dynamic", "Static"))
        else:
            gef_print("{:<30s}: {:s}".format("Static/Dynamic", "Dynamic"))

        # Stripped
        if sec["Stripped"]:
            msg = Color.colorify("Yes", "bold green")
            gef_print("{:<30s}: {:s}".format("Stripped", msg))
        else:
            msg = Color.colorify("No", "bold red") + " (The symbol remains)"
            gef_print("{:<30s}: {:s}".format("Stripped", msg))

        # CET
        if sec["Intel CET"]:
            msg = Color.colorify("Found", "bold green") + " (endbr64/endbr32 is found)"
            gef_print("{:<30s}: {:s}".format("Intel CET", msg))
        else:
            msg = Color.colorify("Not Found", "bold red") + " (endbr64/endbr32 is not found)"
            gef_print("{:<30s}: {:s}".format("Intel CET", msg))

        # RPATH
        if not sec["RPATH"]:
            gef_print("{:<30s}: {:s}".format("RPATH", Color.colorify("Not Found", "bold green")))
        else:
            gef_print("{:<30s}: {:s}".format("RPATH", Color.colorify("Found", "bold red")))

        # RUNPATH
        if not sec["RUNPATH"]:
            gef_print("{:<30s}: {:s}".format("RUNPATH", Color.colorify("Not Found", "bold green")))
        else:
            gef_print("{:<30s}: {:s}".format("RUNPATH", Color.colorify("Found", "bold red")))

        # Clang CFI
        if sec["Clang CFI"]:
            gef_print("{:<30s}: {:s}".format("Clang CFI", get_colored_msg(sec["Clang CFI"])))

        # Clang SafeStack
        if sec["Clang SafeStack"]:
            gef_print("{:<30s}: {:s}".format("Clang SafeStack", get_colored_msg(sec["Clang SafeStack"])))

        # System-ASLR
        if is_remote_debug():
            msg = Color.colorify("Unknown", "bold gray")
            gef_print("{:<30s}: {:s} (remote process)".format("System-ASLR", msg))
        else:
            try:
                system_aslr = int(open("/proc/sys/kernel/randomize_va_space").read())
                if system_aslr == 0:
                    msg = Color.colorify("Disabled", "bold red")
                    gef_print("{:<30s}: {:s} (randomize_va_space: 0)".format("System ASLR", msg))
                elif system_aslr == 1:
                    msg = Color.colorify("Partially Enabled", "bold yellow")
                    gef_print("{:<30s}: {:s} (randomize_va_space: 1)".format("System ASLR", msg))
                elif system_aslr == 2:
                    msg = Color.colorify("Enabled", "bold green")
                    gef_print("{:<30s}: {:s} (randomize_va_space: 2)".format("System ASLR", msg))
            except Exception:
                msg = Color.colorify("Unknown", "bold gray")
                gef_print("{:<30s}: {:s} (randomize_va_space: error)".format("System-ASLR", msg))

        # gdb ASLR
        if is_attach() or is_remote_debug():
            msg = Color.colorify("Ignored", "bold gray")
            gef_print("{:<30s}: {:s} (attached or remote process)".format("GDB ASLR setting", msg))
        else:
            ret = gdb.execute("show disable-randomization", to_string=True)
            if "virtual address space is on." in ret:
                msg = Color.colorify("Disabled", "bold red")
                gef_print("{:<30s}: {:s} (disable-randomization: on)".format("GDB ASLR setting", msg))
            elif "virtual address space is off." in ret:
                msg = Color.colorify("Enabled", "bold green")
                gef_print("{:<30s}: {:s} (disable-randomization: off)".format("GDB ASLR setting", msg))
            else:
                msg = Color.colorify("Unknown", "bold gray")
                gef_print("{:<30s}: {:s}".format("GDB ASLR setting", msg))
        return

    def print_security_properties_qemu_system(self):
        if not is_x86():
            return
        ret = gdb.execute("qreg -v", to_string=True)
        flag = False
        for line in ret.splitlines():
            if "CR0 (Control Register 0)" in line:
                flag = True
            if "CR1 (Control Register 1)" in line:
                flag = False
            if "CR4 (Control Register 4)" in line:
                flag = True
            if "DR0-DR3 (Debug Address Register 0-3)" in line:
                flag = False
            if flag:
                gef_print(line)
        return


@register_command
class DwarfExceptionHandlerInfoCommand(GenericCommand):
    """Dump the DWARF exception handler informations with the byte code itself."""
    _cmdline_ = "dwarf-exception-handler"
    _category_ = "02-e. Process Information - Complex Structure Information"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-f', dest='file', help='the file path you want to parse.')
    parser.add_argument('-r', dest='remote', action='store_true',
                        help='parse remote binary if download feature is available. (default: %(default)s)')
    parser.add_argument('-x', dest='hexdump', action='store_true', help='with hexdump. (default: %(default)s)')
    parser.add_argument('-n', '--no-pager', action='store_true', help='do not use less.')
    _syntax_ = parser.format_help()

    _example_ = "{:s}                    # parse loaded binary\n".format(_cmdline_)
    _example_ += "{:s} -r                 # parse remote binary\n".format(_cmdline_)
    _example_ += "{:s} -f /path/to/binary # parse specified binary\n".format(_cmdline_)
    _example_ += "{:s} -x                 # with hexdump\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "Simplified DWARF Exception structure:\n"
    _example_ += "\n"
    _example_ += "\n"
    _example_ += "[OLD IMPLEMENTATION]\n"
    _example_ += " libgcc_s.so bss area               ELF Program Header (for .eh_frame_hdr)\n"
    _example_ += "+-----------------------+      +-> +----------------+\n"
    _example_ += "| ...                   |      |   | p_type         |\n"
    _example_ += "| frame_hdr_cache_head  |---+  |   | p_flags        |\n"
    _example_ += "+-frame_hdr_cache_entry-+ <-+  |   | p_offset       |\n"
    _example_ += "| pc_low                |      |   | p_vaddr        |----+\n"
    _example_ += "| pc_high               |      |   | p_paddr        |    |\n"
    _example_ += "| load_base             |      |   | p_filesz       |    |\n"
    _example_ += "| p_eh_frame_hdr        |------+   | p_memsz        |    |\n"
    _example_ += "| p_dynamic             |          | p_align        |    |         [NEW IMPLEMENTATION]\n"
    _example_ += "| link                  |---+      +----------------+    |          _dlfo_main@ld.so rodata area\n"
    _example_ += "+-frame_hdr_cache_entry-+ <-+                            |          _dlfo_nodelete_mappings@ld.so rodata area\n"
    _example_ += "| pc_low                |                                |         +-------------+\n"
    _example_ += "| pc_high               |                                |         | map_start   |\n"
    _example_ += "| load_base             |                                |         | map_end     |\n"
    _example_ += "| p_eh_frame_hdr        |                                |         | map         |\n"
    _example_ += "| p_dynamic             |                                | <-------| eh_frame    |\n"
    _example_ += "| link                  |                                |         | (eh_dbase)  |\n"
    _example_ += "+-----------------------+                                |         | (eh_count)  |\n"
    _example_ += "The frame_hdr_cache_head and frame_hdr_cache_entry are   |         +-------------+\n"
    _example_ += "initialized the first time they are called.              |\n"
    _example_ += "                                                         |\n"
    _example_ += "                           +-----------------------------+\n"
    _example_ += "                           |\n"
    _example_ += ".eh_frame_hdr              |      .eh_frame                                           .gcc_except_table\n"
    _example_ += "+----------------------+ <-+  +-> +-CIE-------------------+ <-+                   +-> +-LSDA-----------------+\n"
    _example_ += "| version              |      |   | length                |   |                   |   | lpstart_enc          |\n"
    _example_ += "| eh_frame_ptr_enc     |      |   | cie_id (=0)           |   |                   |   | ttype_enc            |\n"
    _example_ += "| fde_count_enc        |      |   | version               |   |                   |   | ttype_off            |\n"
    _example_ += "| table_enc            |      |   | augmentation_string   |   |                   |   | call_site_encoding   |\n"
    _example_ += "| eh_frame_ptr         |------+   | code_alignment_factor |   |                   |   | call_site_table_len  |\n"
    _example_ += "| fde_count            |          | data_alignment_factor |   |                   |   |+-CallSite-----------+|\n"
    _example_ += "| Table[0] initial_loc |          | retaddr_register      |   |                   |   || call_site_start    || try_start\n"
    _example_ += "| Table[0] fde         |---+      | augmentation_len      |   |                   |   || call_site_length   || try_end\n"
    _example_ += "| Table[1] initial_loc |   |      | augmentation_data[0]  |   |                   |   || landing_pad        || catch_start\n"
    _example_ += "| Table[1] fde         |   |      | ...                   |-(augmentation=='P')-+ |   || action             ||---+\n"
    _example_ += "| ...                  |   |      | ...                   |   |                 | |   |+-CallSite-----------+|   |\n"
    _example_ += "| Table[N] initial_loc |   |      | augmentation_data[N]  |   |                 | |   || ...                ||   |\n"
    _example_ += "| Table[N] fde         |   |      | program               |   |                 | |   |+-ActionTable--------+| <-+\n"
    _example_ += "+----------------------+   +----> +-FDE-------------------+   |                 | |   || ar_filter          ||---+\n"
    _example_ += "                                  | length                |   |                 | |   || ar_disp            ||   |\n"
    _example_ += "                                  | cie_pointer (!=0)     |---+                 | |   |+-ActionTable--------+|   |\n"
    _example_ += "                                  | pc_begin              | try_catch_base      | |   || ...                ||   |\n"
    _example_ += "                                  | pc_range              |                     | |   |+-TTypeTable---------+|   |\n"
    _example_ += "                                  | augmentation_len      |                     | |   || ...(stored upward) ||   |\n"
    _example_ += "                                  | augmentation_data[0]  |                     | |   |+-TTypeTable---------+| <-+\n"
    _example_ += "                                  | ...                   |-(augmentation=='L')-|-+   || ttype              ||---> type_info\n"
    _example_ += "                                  | augmentation_data[N]  |                     |     |+--------------------+|\n"
    _example_ += "                                  | program               |                     |     +-LSDA-----------------+\n"
    _example_ += "                                  +-CIE-------------------+   +-----------------+     | ...                  |\n"
    _example_ += "                                  | ...                   |   |                       +----------------------+\n"
    _example_ += "                                  +-FDE-------------------+   |\n"
    _example_ += "                                  | ...                   |   |\n"
    _example_ += "                                  +-----------------------+   |\n"
    _example_ += "                                                              +----> personality_routine(=__gxx_personality_v0@libstdc++.so)"

    # FDE data encoding
    DW_EH_PE_ptr      = 0x00
    DW_EH_PE_uleb128  = 0x01
    DW_EH_PE_udata2   = 0x02
    DW_EH_PE_udata4   = 0x03
    DW_EH_PE_udata8   = 0x04
    DW_EH_PE_signed   = 0x08
    DW_EH_PE_sleb128  = 0x09
    DW_EH_PE_sdata2   = 0x0a
    DW_EH_PE_sdata4   = 0x0b
    DW_EH_PE_sdata8   = 0x0c
    # FDE flags
    DW_EH_PE_absptr   = 0x00
    DW_EH_PE_pcrel    = 0x10
    DW_EH_PE_textrel  = 0x20
    DW_EH_PE_datarel  = 0x30
    DW_EH_PE_funcrel  = 0x40
    DW_EH_PE_aligned  = 0x50
    DW_EH_PE_indirect = 0x80
    DW_EH_PE_omit     = 0xff

    def format_entry(self, sec, entries):
        out = []
        out.append(titlify(sec.name))

        # hexdump
        if self.hexdump:
            out.append(hexdump(sec.data, show_symbol=False, base=sec.offset))

        # print details
        fmt = "[{:<8}|+{:<6}] {:<23s} {:<30s}: {:<18s}  |  {:s}"
        legend = ["FileOff", "Offset", "Raw bytes", "Name", "Value", "Extra Information"]
        out.append(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))

        for entry in entries:
            if len(entry) == 1:
                out.append("[!] " + entry[0])

            elif len(entry) == 3: # separation
                pos, name, extra = entry
                if extra:
                    extra_s = "  |  {:s}".format(extra)
                else:
                    extra_s = ""
                out.append(titlify("[{:#06x}] {:4s}{:s}".format(pos, name, extra_s), color="red", msg_color="red"))

            elif len(entry) == 5: # data
                pos, raw_data, name, value, extra = entry

                pos_s = "[{:#08x}|+{:#06x}]".format(sec.offset + pos, pos)

                if raw_data is None:
                    raw_data_s = ""
                elif isinstance(raw_data, int):
                    raw_data_s = "{:02x}".format(raw_data)
                elif isinstance(raw_data, bytes):
                    raw_data_s = ' '.join(["{:02x}".format(x) for x in raw_data])
                else:
                    raise

                if isinstance(value, str):
                    value_s = value
                elif isinstance(value, int):
                    value_s = "{:#018x}".format(value)
                elif isinstance(value, list):
                    value_s = ' '.join(["{:#018x}".format(x) for x in value])

                if value is not None:
                    out.append("{:s} {:<23s} {:<30s}: {:<18s}  |  {:s}".format(pos_s, raw_data_s, name, value_s, extra))
                else:
                    out.append("{:s} {:<23s} {:<50s}  |  {:s}".format(pos_s, raw_data_s, name, extra))
        return out

    def get_uleb128(self, data, pos):
        acc = 0
        i = 0
        while True:
            if i == 10:
                return pos, 0xffffffffffffffff
            pos, b = self.read_1ubyte(data, pos)
            acc |= (b & 0x7f) << (i * 7)
            if (b & 0x80) == 0:
                return pos, acc
            i += 1

    def get_sleb128(self, data, pos):
        orig_pos = pos
        pos, acc = self.get_uleb128(data, pos)
        length = pos - orig_pos
        sleb_sign_mask = 1 << (length * 7 - 1)
        if (acc & sleb_sign_mask) == 0:
            return pos, acc
        else:
            sleb_value_mask = sleb_sign_mask - 1
            sleb_value = acc & sleb_value_mask
            bit_len = len("{:b}".format(sleb_value))
            real_sign_mask = 1 << bit_len
            real_value_mask = real_sign_mask - 1
            return pos, -1 * (((~sleb_value) & real_value_mask) + 1)

    def read_1ubyte(self, data, pos):
        acc = data[pos]
        return pos + 1, acc

    def read_1sbyte(self, data, pos):
        pB = lambda a: struct.pack("<B", a & 0xff)
        ub = lambda a: struct.unpack("<b", a)[0]
        u2i = lambda a: ub(pB(a))
        acc = data[pos]
        return pos + 1, u2i(acc)

    def read_2ubyte(self, data, pos):
        acc = (data[pos + 1] << 8) | data[pos]
        return pos + 2, acc

    def read_2sbyte(self, data, pos):
        pH = lambda a: struct.pack("<H", a & 0xffff)
        uh = lambda a: struct.unpack("<h", a)[0]
        u2i = lambda a: uh(pH(a))
        acc = (data[pos + 1] << 8) | data[pos]
        return pos + 2, u2i(acc)

    def read_4ubyte(self, data, pos):
        acc = (data[pos + 3] << 24) | (data[pos + 2] << 16) | (data[pos + 1] << 8) | data[pos]
        return pos + 4, acc

    def read_4sbyte(self, data, pos):
        pI = lambda a: struct.pack("<I", a & 0xffffffff)
        ui = lambda a: struct.unpack("<i", a)[0]
        u2i = lambda a: ui(pI(a))
        acc = (data[pos + 3] << 24) | (data[pos + 2] << 16) | (data[pos + 1] << 8) | data[pos]
        return pos + 4, u2i(acc)

    def read_8ubyte(self, data, pos):
        acc = (data[pos + 7] << 56) | (data[pos + 6] << 48) | (data[pos + 5] << 40) | (data[pos + 4] << 32)
        acc |= (data[pos + 3] << 24) | (data[pos + 2] << 16) | (data[pos + 1] << 8) | data[pos]
        return pos + 8, acc

    def read_8sbyte(self, data, pos):
        pQ = lambda a: struct.pack("<Q", a & 0xffffffffffffffff)
        uq = lambda a: struct.unpack("<q", a)[0]
        u2i = lambda a: uq(pQ(a))
        acc = (data[pos + 7] << 56) | (data[pos + 6] << 48) | (data[pos + 5] << 40) | (data[pos + 4] << 32)
        acc |= (data[pos + 3] << 24) | (data[pos + 2] << 16) | (data[pos + 1] << 8) | data[pos]
        return pos + 8, u2i(acc)

    def read_encoded(self, encoding, data, pos):
        if (encoding & 0xf) == self.DW_EH_PE_ptr:
            if self.elf.e_class == Elf.ELF_32_BITS:
                pos, res = self.read_4ubyte(data, pos)
            else:
                pos, res = self.read_8ubyte(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_uleb128:
            pos, res = self.get_uleb128(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_sleb128:
            pos, res = self.get_sleb128(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_udata2:
            pos, res = self.read_2ubyte(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_udata4:
            pos, res = self.read_4ubyte(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_udata8:
            pos, res = self.read_8ubyte(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_sdata2:
            pos, res = self.read_2sbyte(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_sdata4:
            pos, res = self.read_4sbyte(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_sdata8:
            pos, res = self.read_8sbyte(data, pos)
        else:
            raise
        return pos, res

    def get_encoding_str(self, fde_encoding):
        if fde_encoding == self.DW_EH_PE_omit:
            return "omit"
        s = []
        if (fde_encoding & 0xf) == self.DW_EH_PE_ptr:
            s.append("ptr")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_uleb128:
            s.append("uleb128")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_sleb128:
            s.append("sleb128")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_udata2:
            s.append("udata2")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_sdata2:
            s.append("sdata2")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_udata4:
            s.append("udata4")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_sdata4:
            s.append("sdata4")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_udata8:
            s.append("udata8")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_sdata8:
            s.append("sdata8")
        if (fde_encoding & 0x70) == self.DW_EH_PE_absptr:
            s.append("absptr")
        elif (fde_encoding & 0x70) == self.DW_EH_PE_pcrel:
            s.append("pcrel")
        elif (fde_encoding & 0x70) == self.DW_EH_PE_textrel:
            s.append("textrel")
        elif (fde_encoding & 0x70) == self.DW_EH_PE_datarel:
            s.append("datarel")
        elif (fde_encoding & 0x70) == self.DW_EH_PE_funcrel:
            s.append("funcrel")
        elif (fde_encoding & 0x70) == self.DW_EH_PE_aligned:
            s.append("aligned")
        if (fde_encoding & 0x80) == self.DW_EH_PE_indirect:
            s.append("indirect")
        return ','.join(s)

    def encoded_ptr_size(self, encoding, ptr_size):
        if (encoding & 0xf) == self.DW_EH_PE_ptr:
            return ptr_size
        elif (encoding & 0xf) in [self.DW_EH_PE_udata2, self.DW_EH_PE_sdata2]:
            return 2
        elif (encoding & 0xf) in [self.DW_EH_PE_udata4, self.DW_EH_PE_sdata4]:
            return 4
        elif (encoding & 0xf) in [self.DW_EH_PE_udata8, self.DW_EH_PE_sdata8]:
            return 8
        elif encoding == self.DW_EH_PE_omit:
            return 0
        err("Unsupported pointer encoding: {:#x}, assuming pointer size of {:d}.".format(encoding, ptr_size))
        return 0

    def parse_eh_frame_hdr(self, eh_frame_hdr):
        data = eh_frame_hdr.data
        shdr = [s for s in self.elf.shdrs if s.sh_name == ".eh_frame_hdr"][0]
        load_base = [phdr for phdr in self.elf.phdrs if phdr.p_type == Phdr.PT_LOAD][0].p_vaddr

        entries = []
        pos = 0

        try:
            new_pos, version = self.read_1ubyte(data, pos)
            entries.append([pos, data[pos:new_pos], "version", version, ""])
            pos = new_pos

            new_pos, eh_frame_ptr_enc = self.read_1ubyte(data, pos)
            encoding_str = self.get_encoding_str(eh_frame_ptr_enc)
            entries.append([pos, data[pos:new_pos], "eh_frame_ptr_enc", eh_frame_ptr_enc, "encoding: {:s}".format(encoding_str)])
            pos = new_pos

            new_pos, fde_count_enc = self.read_1ubyte(data, pos)
            encoding_str = self.get_encoding_str(fde_count_enc)
            entries.append([pos, data[pos:new_pos], "fde_count_enc", fde_count_enc, "encoding: {:s}".format(encoding_str)])
            pos = new_pos

            new_pos, table_enc = self.read_1ubyte(data, pos)
            encoding_str = self.get_encoding_str(table_enc)
            entries.append([pos, data[pos:new_pos], "table_enc", table_enc, "encoding: {:s}".format(encoding_str)])
            pos = new_pos

            eh_frame_ptr = 0
            if eh_frame_ptr_enc != self.DW_EH_PE_omit:
                new_pos, eh_frame_ptr = self.read_encoded(eh_frame_ptr_enc, data, pos)
                if (eh_frame_ptr_enc & 0x70) == self.DW_EH_PE_pcrel:
                    elf_offset = shdr.sh_offset + 4 + eh_frame_ptr
                    if self.is_pie:
                        extra_s = "vma: $codebase+{:#x}".format(load_base + elf_offset)
                    else:
                        extra_s = "vma: {:#x}".format(load_base + elf_offset)
                    entries.append([pos, data[pos:new_pos], "eh_frame_ptr", elf_offset, extra_s])
                else:
                    entries.append([pos, data[pos:new_pos], "eh_frame_ptr", eh_frame_ptr, ""])
                pos = new_pos

            fde_count = 0
            if fde_count_enc != self.DW_EH_PE_omit:
                new_pos, fde_count = self.read_encoded(fde_count_enc, data, pos)
                entries.append([pos, data[pos:new_pos], "fde_count", fde_count, ""])
                pos = new_pos

            table_cnt = 0
            if table_enc == (self.DW_EH_PE_datarel | self.DW_EH_PE_sdata4):
                while fde_count and data[pos:]:
                    entries.append([pos, "Table[{:4d}]".format(table_cnt), ""])

                    new_pos, initial_loc = self.read_4sbyte(data, pos)
                    initial_offset = shdr.sh_offset + initial_loc
                    if self.is_pie:
                        extra_s = "vma: $codebase+{:#x}".format(load_base + initial_offset)
                    else:
                        extra_s = "vma: {:#x}".format(load_base + initial_offset)
                    entries.append([pos, data[pos:new_pos], "initial_loc", initial_offset, extra_s])
                    pos = new_pos

                    new_pos, fde_offset = self.read_4sbyte(data, pos)
                    fde_offset_adjusted = fde_offset - (eh_frame_ptr + 4)
                    if self.is_pie:
                        extra_s = "vma: $codebase+{:#x}".format(load_base + shdr.sh_offset + fde_offset)
                    else:
                        extra_s = "vma: {:#x}".format(load_base + shdr.sh_offset + fde_offset)
                    entries.append([pos, data[pos:new_pos], "fde", fde_offset_adjusted, extra_s])
                    pos = new_pos

                    table_cnt += 1
        except Exception:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            entries.append(["Parse Error\n{}".format(exc_value)])
        return entries

    def parse_eh_frame(self, eh_frame):
        data = eh_frame.data
        shdr = [s for s in self.elf.shdrs if s.sh_name == ".eh_frame"][0]
        load_base = [phdr for phdr in self.elf.phdrs if phdr.p_type == Phdr.PT_LOAD][0].p_vaddr

        cies = []
        entries = []
        pos = 0

        try:
            while data[pos:]:
                offset = pos
                tmp_entries = []

                # parse length
                new_pos, unit_length = self.read_4ubyte(data, pos)
                length = 4 # default
                tmp_entries.append([pos, data[pos:new_pos], "length", unit_length, ""])
                pos = new_pos
                if unit_length == 0xffffffff:
                    new_pos, unit_length = self.read_8ubyte(data, pos)
                    length = 8
                    tmp_entries.append([pos, data[pos:new_pos], "extended_length", unit_length, ""])
                    pos = new_pos
                if unit_length == 0:
                    entries.append([offset, "Zero terminator", ""])
                    entries += tmp_entries
                    tmp_entries = []
                    continue

                ptr_size = 4 if self.elf.e_class == Elf.ELF_32_BITS else 8
                start = pos # use later
                cie_end = pos + unit_length

                # parse cie_id / cie_pointer
                if length == 4:
                    new_pos, cie_id = self.read_4ubyte(data, pos)
                else:
                    new_pos, cie_id = self.read_8ubyte(data, pos)
                if cie_id == 0:
                    tmp_entries.append([pos, data[pos:new_pos], "cie_id", cie_id, "type: CIE"])
                else:
                    extra_s = "type: FDE, Associated_CIE: {:#x}(={:#x}-{:#x})".format(start - cie_id, start, cie_id)
                    tmp_entries.append([pos, data[pos:new_pos], "cie_pointer", cie_id, extra_s])
                pos = new_pos

                version = 2
                fde_encoding = 0
                lsda_encoding = 0
                initial_location = 0
                vma_base = 0

                if cie_id == 0:  # CIE parsing
                    entries.append([offset, "CIE", ""])
                    entries += tmp_entries
                    tmp_entries = []

                    # parse version
                    new_pos, version = self.read_1ubyte(data, pos)
                    entries.append([pos, data[pos:new_pos], "version", version, ""])
                    pos = new_pos

                    # parse augmentation string
                    orig_pos = pos
                    augmentation = ""
                    while data[pos]:
                        augmentation += chr(data[pos])
                        pos += 1
                    pos += 1 # skip NUL
                    entries.append([orig_pos, data[orig_pos:pos], "augmentation_string", '"{:s}"'.format(augmentation), ""])

                    # parse ptr_size, segment_size
                    segment_size = 0
                    if version >= 4:
                        new_pos, ptr_size = self.raed_1ubyte(data, pos)
                        entries.append([pos, data[pos:new_pos], "ptr_size", ptr_size, ""])
                        pos = new_pos
                        new_pos, segment_size = self.read_1ubyte(data, pos)
                        entries.append([pos, data[pos:new_pos], "segment_size", segment_size, ""])
                        pos = new_pos

                    # parse code/data alignment factor
                    new_pos, code_alignment_factor = self.get_uleb128(data, pos)
                    entries.append([pos, data[pos:new_pos], "code_alignment_factor", code_alignment_factor, ""])
                    pos = new_pos
                    new_pos, data_alignment_factor = self.get_sleb128(data, pos)
                    entries.append([pos, data[pos:new_pos], "data_alignment_factor", data_alignment_factor, ""])
                    pos = new_pos

                    # parse augmentation data
                    if augmentation == "eh":
                        if self.elf.e_class == Elf.ELF_32_BITS:
                            new_pos, adjust = self.read_4ubyte(data, pos)
                        else:
                            new_pos, adjust = self.read_8ubyte(data, pos)
                        entries.append([pos, data[pos:new_pos], "eh_data", adjust, ""])
                        pos = new_pos

                    if version == 1:
                        new_pos, return_address_register = self.read_1ubyte(data, pos)
                        ra_reg_name = self.get_register_name(return_address_register)
                        extra_s = "Reg: {:s}".format(ra_reg_name)
                        entries.append([pos, data[pos:new_pos], "return_address_register", return_address_register, extra_s])
                        pos = new_pos
                    else:
                        new_pos, return_address_register = self.get_uleb128(data, pos)
                        ra_reg_name = self.get_register_name(return_address_register)
                        extra_s = "Reg: {:s}".format(ra_reg_name)
                        entries.append([pos, data[pos:new_pos], "return_address_register", return_address_register, extra_s])
                        pos = new_pos

                    if augmentation[0] == "z":
                        new_pos, augmentation_len = self.get_uleb128(data, pos)
                        entries.append([pos, data[pos:new_pos], "augmentation_len", augmentation_len, ""])
                        pos = new_pos

                        for cp in augmentation[1:]:
                            if cp == "R":
                                new_pos, fde_encoding = self.read_1ubyte(data, pos)
                                encoding_str = self.get_encoding_str(fde_encoding)
                                extra_s = "FDE address encoding: {:s}".format(encoding_str)
                                entries.append([pos, data[pos:new_pos], "augmentation_data(R)", fde_encoding, extra_s])
                                pos = new_pos
                            elif cp == "L":
                                new_pos, lsda_encoding = self.read_1ubyte(data, pos)
                                encoding_str = self.get_encoding_str(lsda_encoding)
                                extra_s = "LSDA pointer encoding: {:s}".format(encoding_str)
                                entries.append([pos, data[pos:new_pos], "augmentation_data(L)", lsda_encoding, extra_s])
                                pos = new_pos
                            elif cp == "P":
                                new_pos, p_encoding = self.read_1ubyte(data, pos)
                                encoding_str = self.get_encoding_str(p_encoding)
                                extra_s = "Personality pointer encoding: {:s}".format(encoding_str)
                                entries.append([pos, data[pos:new_pos], "augmentation_data(P)", p_encoding, extra_s])
                                pos = new_pos
                                new_pos, p_addr = self.read_encoded(p_encoding, data, pos)
                                if (p_encoding & 0x70) == self.DW_EH_PE_pcrel:
                                    p_addr += shdr.sh_offset + pos
                                    if self.is_pie:
                                        extra_s = "Personality pointer address: $codebase+{:#x}".format(load_base + p_addr)
                                    else:
                                        extra_s = "Personality pointer address: {:#x}".format(load_base + p_addr)
                                else:
                                    extra_s = "Personality pointer address"
                                entries.append([pos, data[pos:new_pos], "augmentation_data(P)", p_addr, extra_s])
                                pos = new_pos
                            else: # unknown
                                new_pos, x = self.read_1ubyte(data, pos)
                                entries.append([pos, data[pos:new_pos], "augmentation_data({:s})".format(cp), x, ""])
                                pos = new_pos
                    if ptr_size == 4 or ptr_size == 8:
                        _cie = {}
                        _cie["cie_offset"] = offset
                        _cie["augmentation"] = augmentation
                        _cie["fde_encoding"] = fde_encoding
                        _cie["lsda_encoding"] = lsda_encoding
                        _cie["address_size"] = ptr_size
                        _cie["code_alignment_factor"] = code_alignment_factor
                        _cie["data_alignment_factor"] = data_alignment_factor
                        Cie = collections.namedtuple("Cie", _cie.keys())
                        cie = Cie(*_cie.values())
                        cies.append(cie)

                else: # FDE parsing
                    cie = [x for x in cies if start - cie_id == x.cie_offset][0]

                    entries.append([offset, "FDE", ""])
                    entries += tmp_entries # unit_length, cie_pointer
                    tmp_entries = []

                    ptr_size = self.encoded_ptr_size(cie.fde_encoding, cie.address_size)
                    base = pos

                    # parse pc_begin
                    if ptr_size == 4:
                        new_pos, initial_location = self.read_4ubyte(data, pos)
                    elif ptr_size == 8:
                        new_pos, initial_location = self.read_8ubyte(data, pos)
                    if (cie.fde_encoding & 0x70) == self.DW_EH_PE_pcrel:
                        vma_base = shdr.sh_offset + base + initial_location
                        if ptr_size == 4:
                            vma_base &= 0xffffffff
                        elif ptr_size == 8:
                            vma_base &= 0xffffffffffffffff
                        if self.is_pie:
                            extra_s = "pc_begin vma: $codebase+{:#x}".format(load_base + vma_base)
                        else:
                            extra_s = "pc_begin vma: {:#x}".format(load_base + vma_base)
                        entries.append([pos, data[pos:new_pos], "pc_begin", vma_base, extra_s])
                    else:
                        entries.append([pos, data[pos:new_pos], "pc_begin", initial_location, ""])
                    pos = new_pos

                    # parse pc_range
                    if ptr_size == 4:
                        new_pos, pc_range = self.read_4ubyte(data, pos)
                    elif ptr_size == 8:
                        new_pos, pc_range = self.read_8ubyte(data, pos)
                    if (cie.fde_encoding & 0x70) == self.DW_EH_PE_pcrel:
                        end_off = vma_base + pc_range
                    else:
                        end_off = initial_location + pc_range
                    if ptr_size == 4:
                        end_off &= 0xffffffff
                    elif ptr_size == 8:
                        end_off &= 0xffffffffffffffff
                    if self.is_pie:
                        extra_s = "pc_end vma: $codebase+{:#x}".format(load_base + end_off)
                    else:
                        extra_s = "pc_end vma: {:#x}".format(load_base + end_off)
                    entries.append([pos, data[pos:new_pos], "pc_range", pc_range, extra_s])
                    pos = new_pos

                    # parse augmentation
                    if cie.augmentation[0] == "z":
                        new_pos, augmentation_len = self.get_uleb128(data, pos)
                        entries.append([pos, data[pos:new_pos], "augmentation_len", augmentation_len, ""])
                        pos = new_pos

                        aug_end = pos + augmentation_len
                        if augmentation_len:
                            for cp in cie.augmentation[1:]:
                                if cp == "L":
                                    new_pos, lsda_pointer = self.read_encoded(cie.lsda_encoding, data, pos)
                                    if (cie.lsda_encoding & 0x70) == self.DW_EH_PE_pcrel:
                                        lsda_pointer += shdr.sh_offset + pos
                                        if self.is_pie:
                                            extra_s = "LSDA pointer vma: $codebase+{:#x}".format(load_base + lsda_pointer)
                                        else:
                                            extra_s = "LSDA pointer vma: {:#x}".format(load_base + lsda_pointer)
                                        entries.append([pos, data[pos:new_pos], "augmentation_data(L)", lsda_pointer, extra_s])
                                    else:
                                        entries.append([pos, data[pos:new_pos], "augmentation_data(L)", lsda_pointer, "LSDA pointer"])
                                    pos = new_pos
                            if pos < aug_end:
                                entries.append([pos, data[pos:aug_end], "?", "", ""])
                            pos = aug_end

                # common
                entries += self.parse_cfa_program(data, pos, cie_end, vma_base, version, cie)
                pos = cie_end
        except Exception:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            entries.append(["Parse Error\n{}".format(exc_value)])
        return entries

    DW_CFA_advance_loc                  = 0x40
    DW_CFA_offset                       = 0x80
    DW_CFA_restore                      = 0xc0
    DW_CFA_nop                          = 0x00
    DW_CFA_set_loc                      = 0x01
    DW_CFA_advance_loc1                 = 0x02
    DW_CFA_advance_loc2                 = 0x03
    DW_CFA_advance_loc4                 = 0x04
    DW_CFA_offset_extended              = 0x05
    DW_CFA_restore_extended             = 0x06
    DW_CFA_undefined                    = 0x07
    DW_CFA_same_value                   = 0x08
    DW_CFA_register                     = 0x09
    DW_CFA_remember_state               = 0x0a
    DW_CFA_restore_state                = 0x0b
    DW_CFA_def_cfa                      = 0x0c
    DW_CFA_def_cfa_register             = 0x0d
    DW_CFA_def_cfa_offset               = 0x0e
    DW_CFA_def_cfa_expression           = 0x0f
    DW_CFA_expression                   = 0x10
    DW_CFA_offset_extended_sf           = 0x11
    DW_CFA_def_cfa_sf                   = 0x12
    DW_CFA_def_cfa_offset_sf            = 0x13
    DW_CFA_val_offset                   = 0x14
    DW_CFA_val_offset_sf                = 0x15
    DW_CFA_val_expression               = 0x16
    DW_CFA_low_user                     = 0x1c
    DW_CFA_MIPS_advance_loc8            = 0x1d
    DW_CFA_GNU_window_save              = 0x2d
    DW_CFA_AARCH64_negate_ra_state      = 0x2d # dup
    DW_CFA_GNU_args_size                = 0x2e
    DW_CFA_GNU_negative_offset_extended = 0x2f
    DW_CFA_high_user                    = 0x3f

    def get_register_name(self, reg):
        if self.elf.e_machine == Elf.EM_X86_64:
            REG_LIST = [
                "rax", "rdx", "rcx", "rbx", "rsi", "rdi", "rbp", "rsp",
                "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
                "rip", "xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5", "xmm6",
                "xmm7", "xmm8", "xmm9", "xmm10", "xmm11", "xmm12", "xmm13", "xmm14",
                "xmm15", "st0", "st1", "st2", "st3", "st4", "st5", "st6", "st7",
                "mm0", "mm1", "mm2", "mm3", "mm4", "mm5", "mm6", "mm7",
                "rflags", "es", "cs", "ss", "ds", "fs", "gs", "???",
                "???", "fs.base", "gs.base", "???", "???", "tr", "ldtr", "mxcsr",
                "fcw", "fsw",
            ]
        elif self.elf.e_machine == Elf.EM_386:
            REG_LIST = [
                "eax", "ecx", "edx", "rbx", "esp", "ebp", "esi", "edi",
                "eip", "eflags", "trapno", "st0", "st1", "st2", "st3", "st4",
                "st5", "st6", "st7", "???", "???", "xmm0", "xmm1", "xmm2",
                "xmm3", "xmm4", "xmm5", "xmm6", "xmm7", "mm0", "mm1", "mm2",
                "mm3", "mm4", "mm5", "mm6", "mm7", "fctrl", "fstat", "mxcsr",
                "es", "cs", "ss", "ds", "fs", "gs",
            ]
        elif self.elf.e_machine == Elf.EM_ARM:
            REG_LIST = [
                "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
                "r8", "r9", "r10", "r11", "r12", "sp", "lr", "pc",
                "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
            ] + ["???"] * 40 + [
                "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7",
                "s8", "s9", "s10", "s11", "s12", "s13", "s14", "s15",
                "s16", "s17", "s18", "s19", "s20", "s21", "s22", "s23",
                "s24", "s25", "s26", "s27", "s28", "s29", "s30", "s31",
                "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
                "wcgr0", "wcgr1", "wcgr2", "wcgr3", "wcgr4", "wcgr5", "wcgr6", "wcgr7",
                "wr0", "wr1", "wr2", "wr3", "wr4", "wr5", "wr6", "wr7",
                "wr8", "wr9", "wr10", "wr11", "wr12", "wr13", "wr14", "wr15",
                "spsr", "spsr_fiq", "spsr_irq", "spsr_abt", "spsr_und", "spsr_svc",
            ] + ["???"] * 10 + [
                "r8_usr", "r9_usr", "r10_usr", "r11_usr", "r12_usr", "r13_usr", "r14_usr", "r8_fiq",
                "r9_fiq", "r10_fiq", "r11_fiq", "r12_fiq", "r13_fiq", "r14_fiq", "r13_irq", "r14_irq",
                "r13_abt", "r14_abt", "r13_und", "r14_und", "r13_svc", "r14_svc",
            ] + ["???"] * 26 + [
                "wc0", "wc1", "wc2", "wc3", "wc4", "wc5", "wc6", "wc7",
            ]
        elif self.elf.e_machine == Elf.EM_AARCH64:
            REG_LIST = [
                "x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7",
                "x8", "x9", "x10", "x11", "x12", "x13", "x14", "x15",
                "x16", "x17", "x18", "x19", "x20", "x21", "x22", "x23",
                "x24", "x25", "x26", "x27", "x28", "x29", "x30", "sp",
                "???", "elr",
            ] + ["???"] * 30 + [
                "v0", "v1", "v2", "v3", "v4", "v5", "v6", "v7",
                "v8", "v9", "v10", "v11", "v12", "v13", "v14", "v15",
                "v16", "v17", "v18", "v19", "v20", "v21", "v22", "v23",
                "v24", "v25", "v26", "v27", "v28", "v29", "v30", "v31",
            ]
        else:
            # other arch is unimplemented
            return "r{:d}".format(reg)

        if reg < len(REG_LIST):
            return REG_LIST[reg]
        return "???"

    def parse_cfa_program(self, data, pos, pos_end, vma_base, version, cie):
        encoding = cie.fde_encoding
        ptr_size = cie.address_size
        code_align = cie.code_alignment_factor
        data_align = cie.data_alignment_factor
        pc = vma_base
        indent = " " * 4

        entries = []
        entries.append([pos, b"", "program", None, ""])
        try:
            while pos < pos_end:
                new_pos, opcode = self.read_1ubyte(data, pos)

                if opcode < self.DW_CFA_advance_loc:
                    if opcode == self.DW_CFA_nop:
                        entries.append([pos, data[pos:new_pos], indent + "nop", None, ""])
                    elif opcode == self.DW_CFA_set_loc:
                        new_pos, op1 = self.read_encoded(encoding, data, new_pos)
                        pc = vma_base + op1
                        entries.append([pos, data[pos:new_pos], indent + "set_loc {:#x} to {:#x}".format(op1, pc), None, ""])
                    elif opcode == self.DW_CFA_advance_loc1:
                        op1 = data[new_pos]
                        new_pos += 1
                        pc += op1 * code_align
                        entries.append([pos, data[pos:new_pos], indent + "advance_loc1 {:#x} to {:#x}".format(op1, pc), None, ""])
                    elif opcode == self.DW_CFA_advance_loc2:
                        new_pos, op1 = self.read_2ubyte(data, new_pos)
                        pc += op1 * code_align
                        entries.append([pos, data[pos:new_pos], indent + "advance_loc2 {:#x} to {:#x}".format(op1, pc), None, ""])
                    elif opcode == self.DW_CFA_advance_loc4:
                        new_pos, op1 = self.read_4ubyte(data, new_pos)
                        pc += op1 * code_align
                        entries.append([pos, data[pos:new_pos], indent + "advance_loc4 {:#x} to {:#x}".format(op1, pc), None, ""])
                    elif opcode == self.DW_CFA_offset_extended:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        off = op2 * data_align
                        entries.append([pos, data[pos:new_pos], indent + "offset_extended r{:d} ({:s}) at cfa{:+#x}".format(op1, regname, off), None, ""])
                    elif opcode == self.DW_CFA_restore_extended:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent + "restore_extended r{:d} ({:s})".fomart(op1, regname), None, ""])
                    elif opcode == self.DW_CFA_undefined:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent + "undefined r{:d} ({:s})".format(op1, regname), None, ""])
                    elif opcode == self.DW_CFA_same_value:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent + "same_value r{:d} ({:s})".format(op1, regname), None, ""])
                    elif opcode == self.DW_CFA_register:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        regname1 = self.get_register_name(op1)
                        regname2 = self.get_register_name(op2)
                        entries.append([pos, data[pos:new_pos], indent + "register r{:d} ({:s}) in r{:d} ({:s})".format(op1, regname1, op2, regname2), None, ""])
                    elif opcode == self.DW_CFA_remember_state:
                        entries.append([pos, data[pos:new_pos], indent + "remember_state", None, ""])
                    elif opcode == self.DW_CFA_restore_state:
                        entries.append([pos, data[pos:new_pos], indent + "restore_state", None, ""])
                    elif opcode == self.DW_CFA_def_cfa:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent + "def_cfa r{:d} ({:s}) at offset {:#x}".format(op1, regname, op2), None, ""])
                    elif opcode == self.DW_CFA_def_cfa_register:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent + "def_cfa_register r{:d} ({:s})".format(op1, regname), None, ""])
                    elif opcode == self.DW_CFA_def_cfa_offset:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        entries.append([pos, data[pos:new_pos], indent + "def_cfa_offset {:#x}".format(op1), None, ""])
                    elif opcode == self.DW_CFA_def_cfa_expression:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        entries.append([pos, data[pos:new_pos], indent + "def_cfa_expression {:#x}".format(op1), None, ""])
                        entries += self.parse_ops(version, ptr_size, op1, data, new_pos)
                        new_pos += op1
                    elif opcode == self.DW_CFA_expression:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent + "expression r{:d} ({:s})".format(op1, regname), None, ""])
                        entries += self.parse_ops(version, ptr_size, op2, data, new_pos)
                        new_pos += op2
                    elif opcode == self.DW_CFA_offset_extended_sf:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        off = op2 * data_align
                        entries.append([pos, data[pos:new_pos], indent + "offset_extended_sf r{:d} ({:s}) at cfa{:+#x}".format(op1, regname, off), None, ""])
                    elif opcode == self.DW_CFA_def_cfa_sf:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        off = op2 * data_align
                        entries.append([pos, data[pos:new_pos], indent + "def_cfa_sf r{:d} ({:s}) at offset {:#x}".format(op1, regname, off), None, ""])
                    elif opcode == self.DW_CFA_def_cfa_offset_sf:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        entries.append([pos, data[pos:new_pos], indent + "def_cfa_offset_sf {:#x}".format(op1 * data_align), None, ""])
                    elif opcode == self.DW_CFA_val_offset:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        off = op2 * data_align
                        entries.append([pos, data[pos:new_pos], indent + "val_offset {:#x} at offset {:#x}".format(op1, off), None, ""])
                    elif opcode == self.DW_CFA_val_offset_sf:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        off = op2 * data_align
                        entries.append([pos, data[pos:new_pos], indent + "val_offset_sf {:#x} at offset {:#x}".format(op1, off), None, ""])
                    elif opcode == self.DW_CFA_val_expression:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent + "val_expression r{:d} ({:s})".format(op1, regname), None, ""])
                        entries += self.parse_ops(version, ptr_size, op2, data, new_pos)
                        new_pos += op2
                    elif opcode == self.DW_CFA_MIPS_advance_loc8:
                        new_pos, op1 = self.read_8ubyte(data, new_pos)
                        pc += op1 * code_align
                        entries.append([pos, data[pos:new_pos], indent + "MIPS_advance_loc8 {:#x} to {:#x}".format(op1, pc), None, ""])
                    elif opcode == self.DW_CFA_GNU_window_save:
                        if self.elf.e_machine == Elf.EM_AARCH64:
                            entries.append([pos, data[pos:new_pos], indent + "AARCH64_negate_ra_state", None, ""])
                        else:
                            entries.append([pos, data[pos:new_pos], indent + "GNU_window_save", None, ""])
                    elif opcode == self.DW_CFA_GNU_args_size:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        entries.append([pos, data[pos:new_pos], indent + "args_size {:#x}".format(op1), None, ""])
                    else:
                        entries.append([pos, data[pos:new_pos], indent + "??? {:#x}".format(opcode), None, ""])
                elif opcode < self.DW_CFA_offset:
                    op1 = opcode & 0x3f
                    pc += op1 * code_align
                    entries.append([pos, data[pos:new_pos], indent + "advance_loc {:d} to {:#x}".format(op1, pc), None, ""])
                elif opcode < self.DW_CFA_restore:
                    op1 = opcode & 0x3f
                    new_pos, op2 = self.get_uleb128(data, new_pos)
                    regname = self.get_register_name(op1)
                    off = op2 * data_align
                    entries.append([pos, data[pos:new_pos], indent + "offset r{:d} ({:s}) at cfa{:+#x}".format(op1, regname, off), None, ""])
                else:
                    op1 = opcode & 0x3f
                    regname = self.get_register_name(op1)
                    entries.append([pos, data[pos:new_pos], indent + "restore r{:d}".format(op1), None, ""])
                pos = new_pos
        except Exception:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            entries.append(["Parse Error\n{}".format(exc_value)])
        return entries

    DW_OP_addr                 = 0x03  # Constant address
    DW_OP_deref                = 0x06  #
    DW_OP_const1u              = 0x08  # Unsigned 1-byte constant
    DW_OP_const1s              = 0x09  # Signed 1-byte constant
    DW_OP_const2u              = 0x0a  # Unsigned 2-byte constant
    DW_OP_const2s              = 0x0b  # Signed 2-byte constant
    DW_OP_const4u              = 0x0c  # Unsigned 4-byte constant
    DW_OP_const4s              = 0x0d  # Signed 4-byte constant
    DW_OP_const8u              = 0x0e  # Unsigned 8-byte constant
    DW_OP_const8s              = 0x0f  # Signed 8-byte constant
    DW_OP_constu               = 0x10  # Unsigned LEB128 constant
    DW_OP_consts               = 0x11  # Signed LEB128 constant
    DW_OP_dup                  = 0x12  #
    DW_OP_drop                 = 0x13  #
    DW_OP_over                 = 0x14  #
    DW_OP_pick                 = 0x15  # 1-byte stack index
    DW_OP_swap                 = 0x16  #
    DW_OP_rot                  = 0x17  #
    DW_OP_xderef               = 0x18  #
    DW_OP_abs                  = 0x19  #
    DW_OP_and                  = 0x1a  #
    DW_OP_div                  = 0x1b  #
    DW_OP_minus                = 0x1c  #
    DW_OP_mod                  = 0x1d  #
    DW_OP_mul                  = 0x1e  #
    DW_OP_neg                  = 0x1f  #
    DW_OP_not                  = 0x20  #
    DW_OP_or                   = 0x21  #
    DW_OP_plus                 = 0x22  #
    DW_OP_plus_uconst          = 0x23  # Unsigned LEB128 addend
    DW_OP_shl                  = 0x24  #
    DW_OP_shr                  = 0x25  #
    DW_OP_shra                 = 0x26  #
    DW_OP_xor                  = 0x27  #
    DW_OP_bra                  = 0x28  # Signed 2-byte constant
    DW_OP_eq                   = 0x29  #
    DW_OP_ge                   = 0x2a  #
    DW_OP_gt                   = 0x2b  #
    DW_OP_le                   = 0x2c  #
    DW_OP_lt                   = 0x2d  #
    DW_OP_ne                   = 0x2e  #
    DW_OP_skip                 = 0x2f  # Signed 2-byte constant
    DW_OP_lit0                 = 0x30  # Literal 0
    DW_OP_lit1                 = 0x31  # Literal 1
    DW_OP_lit2                 = 0x32  # Literal 2
    DW_OP_lit3                 = 0x33  # Literal 3
    DW_OP_lit4                 = 0x34  # Literal 4
    DW_OP_lit5                 = 0x35  # Literal 5
    DW_OP_lit6                 = 0x36  # Literal 6
    DW_OP_lit7                 = 0x37  # Literal 7
    DW_OP_lit8                 = 0x38  # Literal 8
    DW_OP_lit9                 = 0x39  # Literal 9
    DW_OP_lit10                = 0x3a  # Literal 10
    DW_OP_lit11                = 0x3b  # Literal 11
    DW_OP_lit12                = 0x3c  # Literal 12
    DW_OP_lit13                = 0x3d  # Literal 13
    DW_OP_lit14                = 0x3e  # Literal 14
    DW_OP_lit15                = 0x3f  # Literal 15
    DW_OP_lit16                = 0x40  # Literal 16
    DW_OP_lit17                = 0x41  # Literal 17
    DW_OP_lit18                = 0x42  # Literal 18
    DW_OP_lit19                = 0x43  # Literal 19
    DW_OP_lit20                = 0x44  # Literal 20
    DW_OP_lit21                = 0x45  # Literal 21
    DW_OP_lit22                = 0x46  # Literal 22
    DW_OP_lit23                = 0x47  # Literal 23
    DW_OP_lit24                = 0x48  # Literal 24
    DW_OP_lit25                = 0x49  # Literal 25
    DW_OP_lit26                = 0x4a  # Literal 26
    DW_OP_lit27                = 0x4b  # Literal 27
    DW_OP_lit28                = 0x4c  # Literal 28
    DW_OP_lit29                = 0x4d  # Literal 29
    DW_OP_lit30                = 0x4e  # Literal 30
    DW_OP_lit31                = 0x4f  # Literal 31
    DW_OP_reg0                 = 0x50  # Register 0
    DW_OP_reg1                 = 0x51  # Register 1
    DW_OP_reg2                 = 0x52  # Register 2
    DW_OP_reg3                 = 0x53  # Register 3
    DW_OP_reg4                 = 0x54  # Register 4
    DW_OP_reg5                 = 0x55  # Register 5
    DW_OP_reg6                 = 0x56  # Register 6
    DW_OP_reg7                 = 0x57  # Register 7
    DW_OP_reg8                 = 0x58  # Register 8
    DW_OP_reg9                 = 0x59  # Register 9
    DW_OP_reg10                = 0x5a  # Register 10
    DW_OP_reg11                = 0x5b  # Register 11
    DW_OP_reg12                = 0x5c  # Register 12
    DW_OP_reg13                = 0x5d  # Register 13
    DW_OP_reg14                = 0x5e  # Register 14
    DW_OP_reg15                = 0x5f  # Register 15
    DW_OP_reg16                = 0x60  # Register 16
    DW_OP_reg17                = 0x61  # Register 17
    DW_OP_reg18                = 0x62  # Register 18
    DW_OP_reg19                = 0x63  # Register 19
    DW_OP_reg20                = 0x64  # Register 20
    DW_OP_reg21                = 0x65  # Register 21
    DW_OP_reg22                = 0x66  # Register 22
    DW_OP_reg23                = 0x67  # Register 24
    DW_OP_reg24                = 0x68  # Register 24
    DW_OP_reg25                = 0x69  # Register 25
    DW_OP_reg26                = 0x6a  # Register 26
    DW_OP_reg27                = 0x6b  # Register 27
    DW_OP_reg28                = 0x6c  # Register 28
    DW_OP_reg29                = 0x6d  # Register 29
    DW_OP_reg30                = 0x6e  # Register 30
    DW_OP_reg31                = 0x6f  # Register 31
    DW_OP_breg0                = 0x70  # Base register 0
    DW_OP_breg1                = 0x71  # Base register 1
    DW_OP_breg2                = 0x72  # Base register 2
    DW_OP_breg3                = 0x73  # Base register 3
    DW_OP_breg4                = 0x74  # Base register 4
    DW_OP_breg5                = 0x75  # Base register 5
    DW_OP_breg6                = 0x76  # Base register 6
    DW_OP_breg7                = 0x77  # Base register 7
    DW_OP_breg8                = 0x78  # Base register 8
    DW_OP_breg9                = 0x79  # Base register 9
    DW_OP_breg10               = 0x7a  # Base register 10
    DW_OP_breg11               = 0x7b  # Base register 11
    DW_OP_breg12               = 0x7c  # Base register 12
    DW_OP_breg13               = 0x7d  # Base register 13
    DW_OP_breg14               = 0x7e  # Base register 14
    DW_OP_breg15               = 0x7f  # Base register 15
    DW_OP_breg16               = 0x80  # Base register 16
    DW_OP_breg17               = 0x81  # Base register 17
    DW_OP_breg18               = 0x82  # Base register 18
    DW_OP_breg19               = 0x83  # Base register 19
    DW_OP_breg20               = 0x84  # Base register 20
    DW_OP_breg21               = 0x85  # Base register 21
    DW_OP_breg22               = 0x86  # Base register 22
    DW_OP_breg23               = 0x87  # Base register 23
    DW_OP_breg24               = 0x88  # Base register 24
    DW_OP_breg25               = 0x89  # Base register 25
    DW_OP_breg26               = 0x8a  # Base register 26
    DW_OP_breg27               = 0x8b  # Base register 27
    DW_OP_breg28               = 0x8c  # Base register 28
    DW_OP_breg29               = 0x8d  # Base register 29
    DW_OP_breg30               = 0x8e  # Base register 30
    DW_OP_breg31               = 0x8f  # Base register 31
    DW_OP_regx                 = 0x90  # Unsigned LEB128 register
    DW_OP_fbreg                = 0x91  # Signed LEB128 offset
    DW_OP_bregx                = 0x92  # ULEB128 register followed by SLEB128 off
    DW_OP_piece                = 0x93  # ULEB128 size of piece addressed
    DW_OP_deref_size           = 0x94  # 1-byte size of data retrieved
    DW_OP_xderef_size          = 0x95  # 1-byte size of data retrieved
    DW_OP_nop                  = 0x96  #
    DW_OP_push_object_address  = 0x97  #
    DW_OP_call2                = 0x98  #
    DW_OP_call4                = 0x99  #
    DW_OP_call_ref             = 0x9a  #
    DW_OP_form_tls_address     = 0x9b  # TLS offset to address in current thread
    DW_OP_call_frame_cfa       = 0x9c  # CFA as determined by CFI
    DW_OP_bit_piece            = 0x9d  # ULEB128 size and ULEB128 offset in bits
    DW_OP_implicit_value       = 0x9e  # DW_FORM_block follows opcode
    DW_OP_stack_value          = 0x9f  # No operands, special like DW_OP_piece
    #
    DW_OP_implicit_pointer     = 0xa0  #
    DW_OP_addrx                = 0xa1  #
    DW_OP_constx               = 0xa2  #
    DW_OP_entry_value          = 0xa3  #
    DW_OP_const_type           = 0xa4  #
    DW_OP_regval_type          = 0xa5  #
    DW_OP_deref_type           = 0xa6  #
    DW_OP_xderef_type          = 0xa7  #
    DW_OP_convert              = 0xa8  #
    DW_OP_reinterpret          = 0xa9  #
    # GNU extensions
    DW_OP_GNU_push_tls_address = 0xe0  #
    DW_OP_GNU_uninit           = 0xf0  #
    DW_OP_GNU_encoded_addr     = 0xf1  #
    DW_OP_GNU_implicit_pointer = 0xf2  #
    DW_OP_GNU_entry_value      = 0xf3  #
    DW_OP_GNU_const_type       = 0xf4  #
    DW_OP_GNU_regval_type      = 0xf5  #
    DW_OP_GNU_deref_type       = 0xf6  #
    DW_OP_GNU_convert          = 0xf7  #
    DW_OP_GNU_reinterpret      = 0xf9  #
    DW_OP_GNU_parameter_ref    = 0xfa  #
    # GNU Debug Fission extensions
    DW_OP_GNU_addr_index       = 0xfb  #
    DW_OP_GNU_const_index      = 0xfc  #
    DW_OP_GNU_variable_value   = 0xfd  #
    DW_OP_lo_user              = 0xe0  # Implementation-defined range start
    DW_OP_hi_user              = 0xff  # Implementation-defined range end

    def dwarf_locexpr_opcode_string(self, code):
        DWARF_ONE_KNOWN_DW_OP = {
            self.DW_OP_GNU_addr_index       : "GNU_addr_index",
            self.DW_OP_GNU_const_index      : "GNU_const_index",
            self.DW_OP_GNU_const_type       : "GNU_const_type",
            self.DW_OP_GNU_convert          : "GNU_convert",
            self.DW_OP_GNU_deref_type       : "GNU_deref_type",
            self.DW_OP_GNU_encoded_addr     : "GNU_encoded_addr",
            self.DW_OP_GNU_entry_value      : "GNU_entry_value",
            self.DW_OP_GNU_implicit_pointer : "GNU_implicit_pointer",
            self.DW_OP_GNU_parameter_ref    : "GNU_parameter_ref",
            self.DW_OP_GNU_push_tls_address : "GNU_push_tls_address",
            self.DW_OP_GNU_regval_type      : "GNU_regval_type",
            self.DW_OP_GNU_reinterpret      : "GNU_reinterpret",
            self.DW_OP_GNU_uninit           : "GNU_uninit",
            self.DW_OP_GNU_variable_value   : "GNU_variable_value",
            self.DW_OP_abs                  : "abs",
            self.DW_OP_addr                 : "addr",
            self.DW_OP_addrx                : "addrx",
            self.DW_OP_and                  : "and",
            self.DW_OP_bit_piece            : "bit_piece",
            self.DW_OP_bra                  : "bra",
            self.DW_OP_breg0                : "breg0",
            self.DW_OP_breg1                : "breg1",
            self.DW_OP_breg2                : "breg2",
            self.DW_OP_breg3                : "breg3",
            self.DW_OP_breg4                : "breg4",
            self.DW_OP_breg5                : "breg5",
            self.DW_OP_breg6                : "breg6",
            self.DW_OP_breg7                : "breg7",
            self.DW_OP_breg8                : "breg8",
            self.DW_OP_breg9                : "breg9",
            self.DW_OP_breg10               : "breg10",
            self.DW_OP_breg11               : "breg11",
            self.DW_OP_breg12               : "breg12",
            self.DW_OP_breg13               : "breg13",
            self.DW_OP_breg14               : "breg14",
            self.DW_OP_breg15               : "breg15",
            self.DW_OP_breg16               : "breg16",
            self.DW_OP_breg17               : "breg17",
            self.DW_OP_breg18               : "breg18",
            self.DW_OP_breg19               : "breg19",
            self.DW_OP_breg20               : "breg20",
            self.DW_OP_breg21               : "breg21",
            self.DW_OP_breg22               : "breg22",
            self.DW_OP_breg23               : "breg23",
            self.DW_OP_breg24               : "breg24",
            self.DW_OP_breg25               : "breg25",
            self.DW_OP_breg26               : "breg26",
            self.DW_OP_breg27               : "breg27",
            self.DW_OP_breg28               : "breg28",
            self.DW_OP_breg29               : "breg29",
            self.DW_OP_breg30               : "breg30",
            self.DW_OP_breg31               : "breg31",
            self.DW_OP_bregx                : "bregx",
            self.DW_OP_call2                : "call2",
            self.DW_OP_call4                : "call4",
            self.DW_OP_call_frame_cfa       : "call_frame_cfa",
            self.DW_OP_call_ref             : "call_ref",
            self.DW_OP_const1s              : "const1s",
            self.DW_OP_const1u              : "const1u",
            self.DW_OP_const2s              : "const2s",
            self.DW_OP_const2u              : "const2u",
            self.DW_OP_const4s              : "const4s",
            self.DW_OP_const4u              : "const4u",
            self.DW_OP_const8s              : "const8s",
            self.DW_OP_const8u              : "const8u",
            self.DW_OP_const_type           : "const_type",
            self.DW_OP_consts               : "consts",
            self.DW_OP_constu               : "constu",
            self.DW_OP_constx               : "constx",
            self.DW_OP_convert              : "convert",
            self.DW_OP_deref                : "deref",
            self.DW_OP_deref_size           : "deref_size",
            self.DW_OP_deref_type           : "deref_type",
            self.DW_OP_div                  : "div",
            self.DW_OP_drop                 : "drop",
            self.DW_OP_dup                  : "dup",
            self.DW_OP_entry_value          : "entry_value",
            self.DW_OP_eq                   : "eq",
            self.DW_OP_fbreg                : "fbreg",
            self.DW_OP_form_tls_address     : "form_tls_address",
            self.DW_OP_ge                   : "ge",
            self.DW_OP_gt                   : "gt",
            self.DW_OP_implicit_pointer     : "implicit_pointer",
            self.DW_OP_implicit_value       : "implicit_value",
            self.DW_OP_le                   : "le",
            self.DW_OP_lit0                 : "lit0",
            self.DW_OP_lit1                 : "lit1",
            self.DW_OP_lit2                 : "lit2",
            self.DW_OP_lit3                 : "lit3",
            self.DW_OP_lit4                 : "lit4",
            self.DW_OP_lit5                 : "lit5",
            self.DW_OP_lit6                 : "lit6",
            self.DW_OP_lit7                 : "lit7",
            self.DW_OP_lit8                 : "lit8",
            self.DW_OP_lit9                 : "lit9",
            self.DW_OP_lit10                : "lit10",
            self.DW_OP_lit11                : "lit11",
            self.DW_OP_lit12                : "lit12",
            self.DW_OP_lit13                : "lit13",
            self.DW_OP_lit14                : "lit14",
            self.DW_OP_lit15                : "lit15",
            self.DW_OP_lit16                : "lit16",
            self.DW_OP_lit17                : "lit17",
            self.DW_OP_lit18                : "lit18",
            self.DW_OP_lit19                : "lit19",
            self.DW_OP_lit20                : "lit20",
            self.DW_OP_lit21                : "lit21",
            self.DW_OP_lit22                : "lit22",
            self.DW_OP_lit23                : "lit23",
            self.DW_OP_lit24                : "lit24",
            self.DW_OP_lit25                : "lit25",
            self.DW_OP_lit26                : "lit26",
            self.DW_OP_lit27                : "lit27",
            self.DW_OP_lit28                : "lit28",
            self.DW_OP_lit29                : "lit29",
            self.DW_OP_lit30                : "lit30",
            self.DW_OP_lit31                : "lit31",
            self.DW_OP_lt                   : "lt",
            self.DW_OP_minus                : "minus",
            self.DW_OP_mod                  : "mod",
            self.DW_OP_mul                  : "mul",
            self.DW_OP_ne                   : "ne",
            self.DW_OP_neg                  : "neg",
            self.DW_OP_nop                  : "nop",
            self.DW_OP_not                  : "not",
            self.DW_OP_or                   : "or",
            self.DW_OP_over                 : "over",
            self.DW_OP_pick                 : "pick",
            self.DW_OP_piece                : "piece",
            self.DW_OP_plus                 : "plus",
            self.DW_OP_plus_uconst          : "plus_uconst",
            self.DW_OP_push_object_address  : "push_object_address",
            self.DW_OP_reg0                 : "reg0",
            self.DW_OP_reg1                 : "reg1",
            self.DW_OP_reg2                 : "reg2",
            self.DW_OP_reg3                 : "reg3",
            self.DW_OP_reg4                 : "reg4",
            self.DW_OP_reg5                 : "reg5",
            self.DW_OP_reg6                 : "reg6",
            self.DW_OP_reg7                 : "reg7",
            self.DW_OP_reg8                 : "reg8",
            self.DW_OP_reg9                 : "reg9",
            self.DW_OP_reg10                : "reg10",
            self.DW_OP_reg11                : "reg11",
            self.DW_OP_reg12                : "reg12",
            self.DW_OP_reg13                : "reg13",
            self.DW_OP_reg14                : "reg14",
            self.DW_OP_reg15                : "reg15",
            self.DW_OP_reg16                : "reg16",
            self.DW_OP_reg17                : "reg17",
            self.DW_OP_reg18                : "reg18",
            self.DW_OP_reg19                : "reg19",
            self.DW_OP_reg20                : "reg20",
            self.DW_OP_reg21                : "reg21",
            self.DW_OP_reg22                : "reg22",
            self.DW_OP_reg23                : "reg23",
            self.DW_OP_reg24                : "reg24",
            self.DW_OP_reg25                : "reg25",
            self.DW_OP_reg26                : "reg26",
            self.DW_OP_reg27                : "reg27",
            self.DW_OP_reg28                : "reg28",
            self.DW_OP_reg29                : "reg29",
            self.DW_OP_reg30                : "reg30",
            self.DW_OP_reg31                : "reg31",
            self.DW_OP_regval_type          : "regval_type",
            self.DW_OP_regx                 : "regx",
            self.DW_OP_reinterpret          : "reinterpret",
            self.DW_OP_rot                  : "rot",
            self.DW_OP_shl                  : "shl",
            self.DW_OP_shr                  : "shr",
            self.DW_OP_shra                 : "shra",
            self.DW_OP_skip                 : "skip",
            self.DW_OP_stack_value          : "stack_value",
            self.DW_OP_swap                 : "swap",
            self.DW_OP_xderef               : "xderef",
            self.DW_OP_xderef_size          : "xderef_size",
            self.DW_OP_xderef_type          : "xderef_type",
            self.DW_OP_xor                  : "xor",
        }
        if code in DWARF_ONE_KNOWN_DW_OP:
            return DWARF_ONE_KNOWN_DW_OP[code]
        elif code >= self.DW_OP_lo_user:
            return "lo_user+{:#x}".format(code - self.DW_OP_lo_user)
        else:
            return "??? ({:#x})".format(code)

    def parse_ops(self, vers, addrsize, length, data, pos, indent_n=0):
        indent = " " * ((indent_n + 2) * 4)
        entries = []
        ref_size = addrsize if vers < 3 else 0

        if length == 0:
            entries.append([pos, b"", indent + "(empty)", None, ""])
            return entries

        offset = 0
        try:
            while length:
                new_pos, op = self.read_1ubyte(data, pos)
                op_name = self.dwarf_locexpr_opcode_string(op)

                if op in [self.DW_OP_addr]:
                    if addrsize == 4:
                        new_pos, d = self.read_4ubyte(data, new_pos)
                    elif addrsize == 8:
                        new_pos, d = self.read_8ubyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_call_ref, self.DW_OP_GNU_variable_value]:
                    if ref_size == 4:
                        new_pos, d = self.read_4ubyte(data, new_pos)
                    else:
                        new_pos, d = self.read_8ubyte(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_deref]:
                    typ = {4: "uint", 8: "ulong"}[addrsize]
                    extra_s = "pop; push *({:s}*)popped_value".format(typ)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_xderef]:
                    typ = {4: "uint", 8: "ulong"}[addrsize]
                    extra_s = "pop; pop; push *({:s}*)(popped_value2_as_segment:popped_value1)".format(typ)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_deref_size]:
                    new_pos, d = self.read_1ubyte(data, new_pos)
                    typ = {1: "uchar", 2: "ushort", 4: "uint", 8: "ulong"}[d]
                    extra_s = "pop; push *({:s}*)popped_value".format(typ)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_xderef_size]:
                    new_pos, d = self.read_1ubyte(data, new_pos)
                    typ = {1: "uchar", 2: "ushort", 4: "uint", 8: "ulong"}[d]
                    extra_s = "pop; pop; push *({:s}*)(popped_value2_as_segment:popped_value1)".forma(typ)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_pick]:
                    new_pos, d = self.read_1ubyte(data, new_pos)
                    extra_s = "push stack[{:d}]".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const1u]:
                    new_pos, d = self.read_1ubyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const2u]:
                    new_pos, d = self.read_2ubyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const4u]:
                    new_pos, d = self.read_4ubyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const8u]:
                    new_pos, d = self.read_8ubyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const1s]:
                    new_pos, d = self.read_1sbyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const2u]:
                    new_pos, d = self.read_2sbyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const4s]:
                    new_pos, d = self.read_4sbyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const8s]:
                    new_pos, d = self.read_8sbyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_piece, self.DW_OP_regx, self.DW_OP_plus_uconst]:
                    new_pos, d = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_constu]:
                    new_pos, d = self.get_uleb128(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_consts]:
                    new_pos, d = self.get_sleb128(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_addrx, self.DW_OP_GNU_addr_index, self.DW_OP_constx, self.DW_OP_GNU_const_index]:
                    new_pos, d = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} [{:#x}]".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_bit_piece]:
                    new_pos, d1 = self.get_uleb128(data, new_pos)
                    new_pos, d2 = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x},{:#x}".format(offset, op_name, d1, d2), None, ""])
                elif op in [self.DW_OP_lit0, self.DW_OP_lit1, self.DW_OP_lit2, self.DW_OP_lit3, self.DW_OP_lit4,
                            self.DW_OP_lit5, self.DW_OP_lit6, self.DW_OP_lit7, self.DW_OP_lit8, self.DW_OP_lit9,
                            self.DW_OP_lit10, self.DW_OP_lit11, self.DW_OP_lit12, self.DW_OP_lit13, self.DW_OP_lit14,
                            self.DW_OP_lit15, self.DW_OP_lit16, self.DW_OP_lit17, self.DW_OP_lit18, self.DW_OP_lit19,
                            self.DW_OP_lit20, self.DW_OP_lit21, self.DW_OP_lit22, self.DW_OP_lit23, self.DW_OP_lit24,
                            self.DW_OP_lit25, self.DW_OP_lit26, self.DW_OP_lit27, self.DW_OP_lit28, self.DW_OP_lit29,
                            self.DW_OP_lit30, self.DW_OP_lit31]:
                    extra_s = "push {:#x}".format(op - 0x30)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_reg0, self.DW_OP_reg1, self.DW_OP_reg2, self.DW_OP_reg3, self.DW_OP_reg4,
                            self.DW_OP_reg5, self.DW_OP_reg6, self.DW_OP_reg7, self.DW_OP_reg8, self.DW_OP_reg9,
                            self.DW_OP_reg10, self.DW_OP_reg11, self.DW_OP_reg12, self.DW_OP_reg13, self.DW_OP_reg14,
                            self.DW_OP_reg15, self.DW_OP_reg16, self.DW_OP_reg17, self.DW_OP_reg18, self.DW_OP_reg19,
                            self.DW_OP_reg20, self.DW_OP_reg21, self.DW_OP_reg22, self.DW_OP_reg23, self.DW_OP_reg24,
                            self.DW_OP_reg25, self.DW_OP_reg26, self.DW_OP_reg27, self.DW_OP_reg28, self.DW_OP_reg29,
                            self.DW_OP_reg30, self.DW_OP_reg31]:
                    regname = self.get_register_name(op - 0x50)
                    extra_s = "push {:s}".format(regname)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_breg0, self.DW_OP_breg1, self.DW_OP_breg2, self.DW_OP_breg3, self.DW_OP_breg4,
                            self.DW_OP_breg5, self.DW_OP_breg6, self.DW_OP_breg7, self.DW_OP_breg8, self.DW_OP_breg9,
                            self.DW_OP_breg10, self.DW_OP_breg11, self.DW_OP_breg12, self.DW_OP_breg13, self.DW_OP_breg14,
                            self.DW_OP_breg15, self.DW_OP_breg16, self.DW_OP_breg17, self.DW_OP_breg18, self.DW_OP_breg19,
                            self.DW_OP_breg20, self.DW_OP_breg21, self.DW_OP_breg22, self.DW_OP_breg23, self.DW_OP_breg24,
                            self.DW_OP_breg25, self.DW_OP_breg26, self.DW_OP_breg27, self.DW_OP_breg28, self.DW_OP_breg29,
                            self.DW_OP_breg30, self.DW_OP_breg31]:
                    new_pos, d = self.get_sleb128(data, new_pos)
                    regname = self.get_register_name(op - 0x70)
                    extra_s = "push {:s}{:+#x}".format(regname, d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_fbreg]:
                    new_pos, d = self.get_sleb128(data, new_pos)
                    regname = "push frame_base{:*#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_bregx]:
                    new_pos, d1 = self.get_uleb128(data, new_pos)
                    new_pos, d2 = self.get_sleb128(data, new_pos)
                    regname = self.get_register_name(d1)
                    extra_s = "push {:s}{:+#x}".format(regname, d2)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x},{:#x}".format(offset, op_name, d1, d2), None, extra_s])
                elif op in [self.DW_OP_call2]:
                    new_pos, d = self.read_2ubyte(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} [{:#x}]".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_call4]:
                    new_pos, d = self.read_4ubyte(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} [{:#x}]".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_bra]:
                    new_pos, d = self.read_2sbyte(data, new_pos)
                    d += offset + 3
                    extra_s = "pop; jmp to [{:#x}] if popped_value != 0".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} [{:#x}]".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_skip]:
                    new_pos, d = self.read_2sbyte(data, new_pos)
                    d += offset + 3
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} [{:#x}]".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_implicit_value]:
                    new_pos, d = self.get_uleb128(data, new_pos)
                    block_s = ' '.join(["{:02x}".format(x) for x in data[new_pos:new_pos + d]])
                    new_pos += d
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:s}".format(offset, op_name, block_s), None, ""])
                elif op in [self.DW_OP_implicit_pointer, self.DW_OP_GNU_implicit_pointer]:
                    if ref_size == 4:
                        new_pos, d1 = self.read_4ubyte(data, new_pos)
                    elif ref_size == 8:
                        new_pos, d1 = self.read_8ubyte(data, new_pos)
                    new_pos, d2 = self.get_sleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} [{:#x}] {:+#x}".format(offset, op_name, d1, d2), None, ""])
                elif op in [self.DW_OP_entry_value, self.DW_OP_GNU_entry_value]:
                    new_pos, d = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s}".format(offset, op_name), None, ""])
                    entries += self.parse_ops(vers, addrsize, d, data, new_pos, indent=indent + 1)
                    new_pos += d
                elif op in [self.DW_OP_const_type, self.DW_OP_GNU_const_type]:
                    new_pos, d1 = self.get_uleb128(data, new_pos)
                    new_pos, d2 = self.read_1ubyte(data, new_pos)
                    block_s = ' '.join(["{:02x}".format(x) for x in data[new_pos:new_pos + d2]])
                    new_pos += d2
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} [{:#x}] {:s}".format(offset, op_name, d1, block_s), None, ""])
                elif op in [self.DW_OP_regval_type, self.DW_OP_GNU_regval_type]:
                    new_pos, d1 = self.get_uleb128(data, new_pos)
                    new_pos, d2 = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x} [{:#x}]".format(offset, op_name, d1, d2), None, ""])
                elif op in [self.DW_OP_deref_type, self.DW_OP_GNU_deref_type]:
                    new_pos, d1 = self.read_1ubyte(data, new_pos)
                    new_pos, d2 = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x} [{:#x}]".format(offset, op_name, d1, d2), None, ""])
                elif op in [self.DW_OP_xderef_type]:
                    new_pos, d1 = self.read_1ubyte(data, new_pos)
                    new_pos, d2 = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x} [{:#x}]".format(offset, op_name, d1, d2), None, ""])
                elif op in [self.DW_OP_convert, self.DW_OP_GNU_convert, self.DW_OP_reinterpret, self.DW_OP_GNU_reinterpret]:
                    new_pos, d = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} [{:#x}]".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_GNU_parameter_ref]:
                    new_pos, d = self.read_4ubyte(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} [{:#x}]".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_drop]:
                    extra_s = "pop"
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_dup]:
                    extra_s = "push stack[0]"
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_over]:
                    extra_s = "push stack[1]"
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_swap]:
                    extra_s = "stack[0],stack[1] = stack[1],stack[0]"
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_rot]:
                    extra_s = "stack[0],stack[1],stack[2] = stack[1],stack[2],stack[0]"
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                else:
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s}".format(offset, op_name), None, ""])
                length -= new_pos - pos
                offset += new_pos - pos
                pos = new_pos
        except Exception:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            entries.append(["Parse Error\n{}".format(exc_value)])
        return entries

    def parse_gcc_except_table(self, gcc_except_table, eh_frame_entries):
        def get_lsda_info(eh_frame_entries):
            dic = {}
            is_fde = False
            for entry in eh_frame_entries:
                if len(entry) != 5:
                    continue
                pos, raw_data, name, value, extra = entry
                if name == "cie_pointer":
                    is_fde = True
                    continue
                if name == "cie_id":
                    is_fde = False
                    continue
                if is_fde:
                    if name == "pc_begin":
                        pc_begin = value
                        continue
                    if name != "augmentation_data(L)":
                        continue
                    dic[value - load_base] = pc_begin + load_base
            return dic

        section_base = gcc_except_table.offset
        data = gcc_except_table.data
        shdr = [s for s in self.elf.shdrs if s.sh_name == ".gcc_except_table"][0]
        load_base = [phdr for phdr in self.elf.phdrs if phdr.p_type == Phdr.PT_LOAD][0].p_vaddr
        ptr_size = 4 if self.elf.e_class == Elf.ELF_32_BITS else 8
        lsda_pos_info = get_lsda_info(eh_frame_entries)

        entries = []
        pos = 0
        lsda_table_cnt = 0

        try:
            lsda_pos_padding = 0
            while data[pos:]:
                # search LSDA start address
                if (section_base + pos) not in lsda_pos_info:
                    lsda_pos_padding += 1
                    pos += 1
                    continue

                # Found
                if lsda_pos_padding:
                    entries.append([pos - lsda_pos_padding, "Padding", ""])
                    entries.append([pos - lsda_pos_padding, data[pos - lsda_pos_padding:pos], "padding", "", ""])
                    lsda_pos_padding = 0

                entries.append([pos, "LSDA Table[{:4d}]".format(lsda_table_cnt), ""])
                lpstart = lsda_pos_info[section_base + pos]

                # parse lpstart_encoding
                new_pos, lpstart_encoding = self.read_1ubyte(data, pos)
                encoding_str = self.get_encoding_str(lpstart_encoding)
                entries.append([pos, data[pos:new_pos], "landing_pad_start_encoding", lpstart_encoding, "encoding: {:s}".format(encoding_str)])
                pos = new_pos

                # parse lpstart
                if lpstart_encoding != self.DW_EH_PE_omit:
                    new_pos, lpstart = self.read_encoded(lpstart_encoding, data, pos) # overwrite lpstart
                    entries.append([pos, data[pos:new_pos], "landing_pad_start", lpstart, ""])
                    pos = new_pos

                # parse ttype_encoding
                new_pos, ttype_encoding = self.read_1ubyte(data, pos)
                encoding_str = self.get_encoding_str(ttype_encoding)
                entries.append([pos, data[pos:new_pos], "ttype_encoding", ttype_encoding, "encoding: {:s}".format(encoding_str)])
                pos = new_pos

                # parse ttype_base_offset
                ttype_base = None
                if ttype_encoding != self.DW_EH_PE_omit:
                    new_pos, ttype_base_offset = self.get_uleb128(data, pos)
                    ttype_base = new_pos + ttype_base_offset
                    entries.append([pos, data[pos:new_pos], "ttype_base_offset", ttype_base_offset, "ttype_base: {:#x}".format(ttype_base)])
                    pos = new_pos

                # parse call_site_encoding
                new_pos, call_site_encoding = self.read_1ubyte(data, pos)
                encoding_str = self.get_encoding_str(call_site_encoding)
                entries.append([pos, data[pos:new_pos], "call_site_encoding", call_site_encoding, "encoding: {:s}".format(encoding_str)])
                pos = new_pos

                # parse call_site_table_len
                new_pos, call_site_table_len = self.get_uleb128(data, pos)
                entries.append([pos, data[pos:new_pos], "call_site_table_len", call_site_table_len, ""])
                pos = new_pos

                # parse call_site_table
                action_table_pos = pos + call_site_table_len
                table_cnt = 0
                max_action = 0
                while pos < action_table_pos:
                    entries.append([pos, "Call site table[{:4d}]".format(table_cnt), ""])

                    new_pos, call_site_start = self.read_encoded(call_site_encoding, data, pos)
                    if self.is_pie:
                        extra_s = "try-start vma: $codebase+{:#x}".format(lpstart + call_site_start)
                    else:
                        extra_s = "try-start vma: {:#x}".format(lpstart + call_site_start)
                    entries.append([pos, data[pos:new_pos], "call_site_start", call_site_start, extra_s])
                    pos = new_pos

                    new_pos, call_site_length = self.read_encoded(call_site_encoding, data, pos)
                    if self.is_pie:
                        extra_s = "try-end vma: $codebase+{:#x}".format(lpstart + call_site_start + call_site_length)
                    else:
                        extra_s = "try-end vma: {:#x}".format(lpstart + call_site_start + call_site_length)
                    entries.append([pos, data[pos:new_pos], "call_site_length", call_site_length, extra_s])
                    pos = new_pos

                    new_pos, call_site_lpad = self.read_encoded(call_site_encoding, data, pos)
                    if call_site_lpad == 0:
                        extra_s = ""
                    elif self.is_pie:
                        extra_s = "catch vma: $codebase+{:#x}".format(lpstart + call_site_lpad)
                    else:
                        extra_s = "catch vma: {:#x}".format(lpstart + call_site_lpad)
                    entries.append([pos, data[pos:new_pos], "landing_pad", call_site_lpad, extra_s])
                    pos = new_pos

                    new_pos, action = self.get_uleb128(data, pos)
                    max_action = max(action, max_action)
                    if action == 0:
                        extra_s = "no action"
                    else:
                        extra_s = "action: {:#x}".format(action_table_pos + action - 1)
                    entries.append([pos, data[pos:new_pos], "action", action, extra_s])
                    pos = new_pos

                    table_cnt += 1

                # parse action_table
                max_ar_filter = 0
                table_cnt = 0
                if max_action:
                    action_table_end_pos = action_table_pos + max_action + 1
                    while pos < action_table_end_pos:
                        entries.append([pos, "Action table[{:4d}]".format(table_cnt), ""])

                        new_pos, ar_filter = self.get_sleb128(data, pos)
                        if ar_filter == 0:
                            extra_s = "cleanup"
                        else:
                            enc_size = self.encoded_ptr_size(ttype_encoding, ptr_size)
                            extra_s = "catch typeinfo: {:#x}".format(ttype_base - ar_filter * enc_size)
                        entries.append([pos, data[pos:new_pos], "action_record_filter", ar_filter, extra_s])
                        max_ar_filter = max(ar_filter, max_ar_filter)
                        pos = new_pos

                        new_pos, ar_disp = self.get_sleb128(data, pos)
                        if ar_disp & 1:
                            extra_s = "-> Action Table[{:4d}]".format(table_cnt + (ar_disp + 1) // 2)
                        elif ar_disp:
                            extra_s = "-> ???"
                        else:
                            extra_s = "list end"
                        entries.append([pos, data[pos:new_pos], "action_record_next", ar_disp, extra_s])
                        pos = new_pos

                        table_cnt += 1

                # parse ttype_table
                if max_ar_filter > 0 and ttype_base is not None:
                    enc_size = self.encoded_ptr_size(ttype_encoding, ptr_size)
                    new_pos = ttype_base - max_ar_filter * enc_size
                    if pos != new_pos:
                        entries.append([pos, "Padding", ""])
                        entries.append([pos, data[pos:new_pos], "padding", "", ""])
                        pos = new_pos
                    current_ar_filter = max_ar_filter
                    while pos < ttype_base:
                        entries.append([pos, "TType table[{:4d}]".format(current_ar_filter), ""])
                        new_pos, ttype = self.read_encoded(ttype_encoding, data, pos)
                        if (ttype_encoding & 0x70) == self.DW_EH_PE_pcrel:
                            ttype_pointer = shdr.sh_offset + pos + ttype
                            if ttype:
                                if self.is_pie:
                                    extra_s = "TType pointer vma: $codebase+{:#x}".format(load_base + ttype_pointer)
                                else:
                                    extra_s = "TType pointer vma: {:#x}".format(load_base + ttype_pointer)
                            else:
                                extra_s = ""
                            entries.append([pos, data[pos:new_pos], "ttype", ttype, extra_s])
                        else:
                            entries.append([pos, data[pos:new_pos], "ttype", ttype, "TType pointer"])
                        pos = new_pos
                        current_ar_filter -= 1
                if ttype_base is not None:
                    entries.append([ttype_base, "TType table base (Stored upwards)", ""])

                # next LSDA
                if ttype_base is None:
                    pass
                else:
                    pos = ttype_base
                lsda_table_cnt += 1
        except Exception:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            entries.append(["Parse Error\n{}".format(exc_value)])
        return entries

    def read_section(self, section_name):
        for s in self.elf.shdrs:
            if s.sh_name != section_name:
                continue
            f = open(self.elf.filename, "rb")
            f.seek(s.sh_offset)
            data = f.read(s.sh_size)
            f.close()
            info("Found {} section".format(section_name))

            _dic = {"name": section_name, "offset": s.sh_offset, "data": data}
            Section = collections.namedtuple(section_name.lstrip("."), _dic.keys())
            return Section(*_dic.values())
        err("Not found {} section".format(section_name))
        return None

    @parse_args
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        local_filepath = None
        remote_filepath = None
        tmp_filepath = None
        self.hexdump = args.hexdump

        if args.remote:
            if not is_remote_debug():
                err("-r option is allowed only remote debug.")
                return

            if args.file:
                remote_filepath = args.file # if specified, assume it is remote
            elif gdb.current_progspace().filename:
                f = gdb.current_progspace().filename
                if f.startswith("target:"): # gdbserver
                    f = f[7:]
                remote_filepath = f
            elif get_pid(remote=True):
                remote_filepath = "/proc/{:d}/exe".format(get_pid(remote=True))
            else:
                err("File name could not be determined.")
                return

            data = read_remote_file(remote_filepath, as_byte=True) # qemu-user is failed here, it is ok
            if not data:
                err("Failed to read remote filepath")
                return
            tmp_fd, tmp_filepath = tempfile.mkstemp(dir=GEF_TEMP_DIR, suffix=".elf", prefix="dwarf-exception-handler-")
            os.write(tmp_fd, data)
            os.close(tmp_fd)
            local_filepath = tmp_filepath
            del data

        elif args.file:
            local_filepath = args.file

        elif args.file is None:
            if is_qemu_system():
                err("Argument-less calls are unsupported under qemu-system.")
                return
            local_filepath = get_filepath()

        if local_filepath is None:
            err("File name could not be determined.")
            return

        self.elf = get_elf_headers(local_filepath)
        if self.elf is None or not self.elf.is_valid():
            err("Failed to parse elf.")
            if tmp_filepath and os.path.exists(tmp_filepath):
                os.unlink(tmp_filepath)
            return

        self.is_pie = is_pie(local_filepath)

        # read section
        eh_frame_hdr = self.read_section(".eh_frame_hdr")
        if eh_frame_hdr is None:
            if tmp_filepath and os.path.exists(tmp_filepath):
                os.unlink(tmp_filepath)
            return
        eh_frame = self.read_section(".eh_frame")
        if eh_frame is None:
            if tmp_filepath and os.path.exists(tmp_filepath):
                os.unlink(tmp_filepath)
            return
        gcc_except_table = self.read_section(".gcc_except_table")
        if gcc_except_table is None:
            if tmp_filepath and os.path.exists(tmp_filepath):
                os.unlink(tmp_filepath)
            return

        # parse section
        out = []
        eh_frame_hdr_entries = self.parse_eh_frame_hdr(eh_frame_hdr)
        out += self.format_entry(eh_frame_hdr, eh_frame_hdr_entries)
        eh_frame_entries = self.parse_eh_frame(eh_frame)
        out += self.format_entry(eh_frame, eh_frame_entries)
        gcc_except_table_entries = self.parse_gcc_except_table(gcc_except_table, eh_frame_entries)
        out += self.format_entry(gcc_except_table, gcc_except_table_entries)

        # print
        gef_print('\n'.join(out), less=not args.no_pager)

        if tmp_filepath and os.path.exists(tmp_filepath):
            os.unlink(tmp_filepath)
        return


@register_command
class EntryPointBreakCommand(GenericCommand):
    """Tries to find best entry point and sets a temporary breakpoint on it. The command will test for
    well-known symbols for entry points, such as `main`, `_main`, `__libc_start_main`, etc. defined by
    the setting `entrypoint_symbols`."""
    _cmdline_ = "entry-break"
    _category_ = "01-b. Debugging Support - Breakpoint"
    _aliases_ = ["start"]

    parser = argparse.ArgumentParser(prog=_cmdline_, add_help=False)
    _syntax_ = parser.format_help()

    def __init__(self, *args, **kwargs):
        super().__init__()
        self.add_setting(
            "entrypoint_symbols",
            "main _main __libc_start_main __uClibc_main start _start __start", # __start is used by MIPS
            "Possible symbols for entry points",
        )
        return

    # Need not @parse_args because argparse can't stop interpreting argument for start.
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        fpath = get_filepath()
        if fpath is None:
            warn("No executable to debug, use `file` to load a binary")
            return

        if not os.access(fpath, os.X_OK):
            warn("The file '{}' is not executable.".format(fpath))
            return

        if is_alive():
            warn("gdb is already running")
            return

        bp = None
        entrypoints = self.get_setting("entrypoint_symbols").split()

        for sym in entrypoints:
            try:
                value = parse_address(sym)
                info("Breaking at '{:s}'".format(str(value)))
                bp = EntryBreakBreakpoint(sym)
                gdb.execute("run {}".format(" ".join(argv)))
                return

            except gdb.error as gdb_error:
                if 'The "remote" target does not support "run".' in str(gdb_error):
                    # this case can happen when doing remote debugging
                    gdb.execute("continue")
                    return
                continue

        # if here, clear the breakpoint if any set
        if bp:
            bp.delete()

        # break at entry point
        entry = get_entry_point()
        if entry is None:
            return

        if is_pie(fpath):
            self.set_init_tbreak_pie(entry, argv)
            try:
                gdb.execute("continue")
            except Exception:
                exc_type, exc_value, exc_traceback = sys.exc_info()
                err(exc_value)
            return

        self.set_init_tbreak(entry)
        gdb.execute("run {}".format(" ".join(argv)))
        return

    def set_init_tbreak(self, addr):
        info("Breaking at entry-point: {:#x}".format(addr))
        bp = EntryBreakBreakpoint("*{:#x}".format(addr))
        return bp

    def set_init_tbreak_pie(self, addr, argv):
        warn("PIC binary detected, retrieving text base address")
        gdb.execute("set stop-on-solib-events 1")
        hide_context()
        gdb.execute("run {}".format(" ".join(argv)))
        unhide_context()
        gdb.execute("set stop-on-solib-events 0")
        vmmap = get_process_maps()
        filepath = get_filepath(append_proc_root_prefix=False)
        base_address = [x.page_start for x in vmmap if x.path == filepath][0]
        return self.set_init_tbreak(base_address + addr)


@register_command
class NamedBreakpointCommand(GenericCommand):
    """Sets a breakpoint and assigns a name to it, which will be shown, when it's hit."""
    _cmdline_ = "named-break"
    _category_ = "01-b. Debugging Support - Breakpoint"
    _aliases_ = ["nb"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('name', metavar='NAME', help='the name you want to assign.')
    parser.add_argument('location', metavar='LOCATION', nargs='?', type=parse_address,
                        help='the address you want to set breakpoint. (default: current_arch.pc)')
    _syntax_ = parser.format_help()

    _example_ = "{:s} main *0x4008a9".format(_cmdline_)

    @parse_args
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        if args.location is not None:
            location = "*{:#x}".format(args.location)
        else:
            location = "*{:#x}".format(current_arch.pc)
        NamedBreakpoint(location, args.name)
        return


@register_command
class ContextCommand(GenericCommand):
    """Displays various information every time GDB hits a breakpoint."""
    _cmdline_ = "context"
    _category_ = "01-a. Debugging Support - Context"
    _aliases_ = ["ctx"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('commands', nargs='*', default=[],
                        choices=[[], 'legend', 'regs', 'stack', 'code', 'args', 'memory', 'source', 'trace', 'threads', 'extra'],
                        metavar='{legend,regs,stack,code,args,memory,source,trace,threads,extra}',
                        help='specifies which context to display.')
    _syntax_ = parser.format_help()

    old_registers = {}

    def __init__(self):
        super().__init__()
        self.add_setting("enable", True, "Enable/disable printing the context when breaking")
        self.add_setting("show_source_code_variable_values", True, "Show extra PC context info in the source code")
        self.add_setting("show_stack_raw", False, "Show the stack pane as raw hexdump (no dereference)")
        self.add_setting("show_registers_raw", False, "Show the registers pane with raw values (no dereference)")
        self.add_setting("show_opcodes_size", 8, "Number of bytes of opcodes to display next to the disassembly")
        self.add_setting("peek_calls", True, "Peek into calls")
        self.add_setting("peek_ret", True, "Peek at return address")
        self.add_setting("nb_lines_stack", 8, "Number of line in the stack pane")
        self.add_setting("nb_guessed_arguments", 6, "Number to display when guessing functions arguments")
        self.add_setting("grow_stack_down", False, "Order of stack downward starts at largest down to stack pointer")
        self.add_setting("nb_lines_backtrace", 10, "Number of line in the backtrace pane")
        self.add_setting("nb_lines_backtrace_before", 2, "Number of line in the backtrace pane before selected frame")
        self.add_setting("nb_lines_threads", -1, "Number of line in the threads pane")
        self.add_setting("nb_lines_code", 6, "Number of instruction after $pc")
        self.add_setting("nb_lines_code_prev", 3, "Number of instruction before $pc")
        self.add_setting("ignore_registers", "", "Space-separated list of registers not to display (e.g. '$cs $ds $gs')")
        self.add_setting("clear_screen", True, "Clear the screen before printing the context")
        default_legend = "legend regs stack code args source memory threads trace extra"
        self.add_setting("layout", default_legend, "Change the order/presence of the context sections")
        self.add_setting("libc_args", False, "Show libc function call args description")
        self.add_setting("libc_args_path", "", "Path to libc function call args json files, provided via gef-extras")
        self.add_setting("smart_cpp_function_name", False, "Print cpp function name without args if demangled")
        self.add_setting("use_native_x_command", False, "Use x/16i insted of gdb_disasembe/capstone")
        self.add_setting("use_capstone", False, "Use capstone as disassembler in the code pane (instead of GDB)")

        self.layout_mapping = {
            "legend" : self.show_legend,
            "regs"   : self.context_regs,
            "stack"  : self.context_stack,
            "code"   : self.context_code,
            "args"   : self.context_args,
            "memory" : self.context_memory,
            "source" : self.context_source,
            "trace"  : self.context_trace,
            "threads": self.context_threads,
            "extra"  : self.context_additional_information,
        }
        return

    def post_load(self):
        gef_on_continue_hook(self.update_registers)
        gef_on_continue_hook(self.empty_extra_messages)
        return

    def show_legend(self):
        if get_gef_setting("gef.disable_color") is not True:
            str_color = get_gef_setting("theme.dereference_string")
            code_addr_color = get_gef_setting("theme.address_code")
            stack_addr_color = get_gef_setting("theme.address_stack")
            heap_addr_color = get_gef_setting("theme.address_heap")
            changed_register_color = get_gef_setting("theme.registers_value_changed")

            gef_print("[ Legend: {} | {} | {} | {} | {} ]".format(
                Color.colorify("Modified register", changed_register_color),
                Color.colorify("Code", code_addr_color),
                Color.colorify("Heap", heap_addr_color),
                Color.colorify("Stack", stack_addr_color),
                Color.colorify("String", str_color)
            ))
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        if not self.get_setting("enable") or context_hidden:
            return

        if len(args.commands) > 0:
            current_layout = args.commands
        else:
            current_layout = self.get_setting("layout").strip().split()

        if not current_layout:
            return

        self.tty_rows, self.tty_columns = get_terminal_size()

        if self.get_setting("clear_screen") and len(args.commands) == 0:
            clear_screen()

        for section in current_layout:
            if section[0] == "-":
                continue
            try:
                self.layout_mapping[section]()
            except gdb.MemoryError as e:
                # a MemoryError will happen when $pc is corrupted (invalid address)
                err(str(e))
        self.context_title("")
        return

    def context_title(self, m):
        line_color = get_gef_setting("theme.context_title_line")
        msg_color = get_gef_setting("theme.context_title_message")

        if not m:
            gef_print(Color.colorify(HORIZONTAL_LINE * self.tty_columns, line_color))
            return

        trail_len = len(m) + 6
        title = ""
        width = max(self.tty_columns - trail_len, 0)
        title += Color.colorify("{:{padd}<{width}} ".format("", width=width, padd=HORIZONTAL_LINE), line_color)
        title += Color.colorify(m, msg_color)
        title += Color.colorify(" {:{padd}<4}".format("", padd=HORIZONTAL_LINE), line_color)
        gef_print(title)
        return

    def context_regs(self):
        self.context_title("registers")
        ignored_registers = set(self.get_setting("ignore_registers").split())

        if current_arch is None and is_remote_debug():
            err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            return

        if self.get_setting("show_registers_raw") is False:
            regs = set(current_arch.all_registers)
            printable_registers = " ".join(list(regs - ignored_registers))
            gdb.execute("registers {}".format(printable_registers))
            return

        widest = x = current_arch.get_aliased_registers_name_max()
        x += 5
        x += current_arch.ptrsize * 2
        nb = get_terminal_size()[1] // x
        i = 1
        line = ""
        changed_color = get_gef_setting("theme.registers_value_changed")
        regname_color = get_gef_setting("theme.registers_register_name")

        for regname in current_arch.all_registers:
            if regname in ignored_registers:
                continue

            try:
                reg = gdb.parse_and_eval(regname)
                if reg.type.code == gdb.TYPE_CODE_VOID:
                    continue

                new_value_type_flag = (reg.type.code == gdb.TYPE_CODE_FLAGS)
                new_value = int(reg)

            except (gdb.MemoryError, gdb.error):
                # If this exception is triggered, it means that the current register
                # is corrupted. Just use the register "raw" value (not eval-ed)
                new_value = get_register(regname)
                new_value_type_flag = False

            except Exception:
                new_value = 0
                new_value_type_flag = False

            padreg = current_arch.get_aliased_registers()[regname].ljust(widest, " ")
            old_value = self.old_registers.get(regname, 0)

            value = align_address(new_value)
            old_value = align_address(old_value)

            if value == old_value:
                line += "{}: ".format(Color.colorify(padreg, regname_color))
            else:
                line += "{}: ".format(Color.colorify(padreg, changed_color))
            if new_value_type_flag:
                line += "{:s} ".format(format_address_spaces(value))
            else:
                addr = lookup_address(align_address(int(value)))
                if addr.valid:
                    line += "{:s} ".format(str(addr))
                else:
                    line += "{:s} ".format(format_address_spaces(value))

            if i % nb == 0:
                gef_print(line)
                line = ""
            i += 1

        if line:
            gef_print(line)

        if current_arch.flag_register:
            gef_print("Flags: {:s}".format(current_arch.flag_register_to_human()))
        return

    def context_stack(self):
        self.context_title("stack")

        show_raw = self.get_setting("show_stack_raw")
        nb_lines = self.get_setting("nb_lines_stack")

        if current_arch is None and is_remote_debug():
            err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            return

        sp = current_arch.sp
        if sp is not None:
            try:
                if show_raw is True:
                    mem = read_memory(sp, 0x10 * nb_lines)
                    gef_print(hexdump(mem, base=sp))
                else:
                    gdb.execute("telescope {:#x} {:d} --no-pager".format(sp, nb_lines))
            except gdb.MemoryError:
                err("Cannot read memory from $SP (corrupted stack pointer?)")

        else:
            err("Failed to get value of $SP")
        return

    def addr_has_breakpoint(self, address, bp_locations):
        return any(hex(address) in b for b in bp_locations)

    def context_code(self):
        use_native_x_command = self.has_setting("use_native_x_command") and self.get_setting("use_native_x_command")
        nb_insn = self.get_setting("nb_lines_code")
        nb_insn_prev = self.get_setting("nb_lines_code_prev")
        use_capstone = self.has_setting("use_capstone") and self.get_setting("use_capstone")
        past_insns_color = get_gef_setting("theme.old_context")
        show_opcodes_size = self.has_setting("show_opcodes_size") and self.get_setting("show_opcodes_size")
        cur_insn_color = get_gef_setting("theme.disassemble_current_instruction")

        if current_arch is None and is_remote_debug():
            self.context_title("code")
            err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            return

        pc = current_arch.pc
        breakpoints = gdb.breakpoints() or []
        bp_locations = [b.location for b in breakpoints if b.location and b.location.startswith("*")]

        try:
            frame = gdb.selected_frame()
            arch_name = "{}:{}".format(current_arch.arch.lower(), current_arch.mode)
        except gdb.error:
            # For unknown reasons, gdb.selected_frame() may cause an error (often occurs during kernel startup).
            arch_name = "{}:{}".format(current_arch.arch.lower(), "???")

        self.context_title("code:{}".format(arch_name))
        if use_native_x_command:
            gdb.execute("x/16i {:#x}".format(current_arch.pc))
            return

        try:
            instruction_iterator = capstone_disassemble if use_capstone else gef_disassemble

            for insn in instruction_iterator(pc, nb_insn, nb_prev=nb_insn_prev):
                line = ""
                is_taken = False
                target = None
                delay_slot = None
                if self.addr_has_breakpoint(insn.address, bp_locations):
                    bp_prefix = Color.redify(BP_GLYPH)
                else:
                    bp_prefix = " "

                if show_opcodes_size == 0:
                    text = str(insn)
                else:
                    insn_fmt = "{{:{}o}}".format(show_opcodes_size)
                    text = insn_fmt.format(insn)

                # coloring by address against pc
                if insn.address < pc:
                    line += "{}{}{}".format(bp_prefix, " " * len(RIGHT_ARROW[1:]), Color.colorify(text, past_insns_color))

                elif insn.address == pc:
                    line += "{}{}".format(bp_prefix, Color.colorify("{:s}{:s}".format(RIGHT_ARROW[1:], text), cur_insn_color))

                    if current_arch.is_conditional_branch(insn):
                        is_taken, reason = current_arch.is_branch_taken(insn)
                        if is_taken:
                            target = self.get_branch_addr(insn)
                            reason = "[Reason: {:s}]".format(reason) if reason else ""
                            line += Color.colorify("\tTAKEN {:s}".format(reason), "bold green")
                            delay_slot = current_arch.has_delay_slot
                        else:
                            reason = "[Reason: !({:s})]".format(reason) if reason else ""
                            line += Color.colorify("\tNOT taken {:s}".format(reason), "bold red")
                    elif current_arch.is_jump(insn):
                        target = self.get_branch_addr(insn)
                        delay_slot = current_arch.has_delay_slot
                    elif current_arch.is_call(insn) and self.get_setting("peek_calls") is True:
                        target = self.get_branch_addr(insn)
                        delay_slot = current_arch.has_delay_slot
                    elif current_arch.is_ret(insn) and self.get_setting("peek_ret") is True:
                        target = current_arch.get_ra(insn, frame)
                        delay_slot = current_arch.has_ret_delay_slot

                else:
                    line += "{}{}{}".format(bp_prefix, " " * len(RIGHT_ARROW[1:]), text)

                gef_print(line)

                # add extra branch info
                if target:
                    # for delay slot
                    try:
                        if delay_slot:
                            next_insn = list(instruction_iterator(insn.address, 2))[-1]
                            if show_opcodes_size == 0:
                                text = str(next_insn)
                            else:
                                insn_fmt = "{{:{}o}}".format(show_opcodes_size)
                                text = insn_fmt.format(next_insn)
                            text = "{}{}{}".format(bp_prefix, " " * len(RIGHT_ARROW[1:]), text)
                            text += Color.colorify("\t Maybe delay-slot", "bold yellow")
                            gef_print(text)
                    except Exception:
                        pass

                    # branch target address

                    once = 0
                    try:
                        for i, tinsn in enumerate(instruction_iterator(target, nb_insn)):
                            if show_opcodes_size == 0:
                                text = str(tinsn)
                            else:
                                text = insn_fmt.format(tinsn)
                            text = "   {}  {}".format(DOWN_ARROW if i == 0 else " ", text)
                            if once == 0:
                                gef_print("")
                                once = 1
                            gef_print(text)
                        if once == 1:
                            gef_print("")
                    except Exception:
                        pass

            self.context_memory_access()
            self.context_memory_access2() # for x86/x64 - fs/gs
            self.context_memory_access3() # for x86/x64 - cs/ss/ds/es

        except gdb.MemoryError:
            err("Cannot disassemble from $PC")
        return

    def context_memory_access(self):
        if not (is_x86() or is_arm32() or is_arm64()):
            return

        inst_iter = gef_disassemble(current_arch.pc, 2)
        insn_here = inst_iter.__next__()
        if insn_here.operands == []:
            return

        insn = ','.join(insn_here.operands)
        insn = re.sub(r"<.+>", "", insn)
        r = re.findall(r"[^:](\[.+?\])", str(insn)) # Unsupported: seg:[reg]
        if not r:
            return

        insn_next = inst_iter.__next__()
        codesize = insn_next.address - insn_here.address

        for code in r:
            code = code[1:-1] # skip "[" and "]"

            if is_x86():
                # add "$" to resiter
                code = code.replace("+", " + ")
                code = code.replace("-", " - ")
                code = code.replace("*", " * ")
                code = code.replace("eiz", " 0 ") # $eiz is always 0x0
                code = code.split()
                code = ["$" + x if x.isalpha() or re.match(r"r\d+d?", x) else x for x in code]
                code = ''.join(code)
                # $rip/$eip points next instruction
                code_orig, code = code, code.replace("$rip", f"$rip+{codesize:#x}")

            elif is_arm32():
                # add "$" to resiter
                code = code.replace(" ", "")
                code = code.replace("#", "")
                code = code.replace("lsl", "<<")
                code = code.split(",")
                code = ["$" + x if x.isalpha() or re.match(r"r\d+", x) else x for x in code]
                if "<<" in code[-1]:
                    code = code[:-2] + ["(" + code[-2] + code[-1] + ")"]
                code = '+'.join(code)
                # $pc points next next instruction
                code_orig, code = code, code.replace("$pc", f"$pc+{codesize*2:#x}")

            elif is_arm64():
                # add "$" to resiter
                code = code.replace(" ", "")
                code = code.replace("#", "")
                code = code.replace("lsl", "<<").replace("sxtw", "<<").replace("uxtw", "<<")
                code = code.replace("xzr", " 0 ") # $xzr is always 0x0
                code = code.replace("wzr", " 0 ") # $wzr is always 0x0
                code = code.replace("wsp", " ($sp&0xffff) ") # $wsp is a half of $sp
                code = code.split(",")
                code = ["$" + x if x.isalpha() or re.match(r"[xw]\d+", x) else x for x in code]
                if "<<" == code[-1]:
                    code[-1] += "0"
                if "<<" in code[-1]:
                    code = code[:-2] + ["(" + code[-2] + code[-1] + ")"]
                code = '+'.join(code)
                # $pc points next next instruction
                code_orig, code = code, code.replace("$pc", f"$pc+{codesize*2:#x}")

            # print
            try:
                code = code.replace("$", "(long)$")
                addr = parse_address(code)
            except Exception:
                # some binary fails to resolve "(long)"
                addr = parse_address(code_orig)
            self.context_title(f"memory access: {code_orig} = {addr:#x}")
            gdb.execute(f"telescope {addr:#x} 4 --no-pager")
        return

    def context_memory_access2(self):
        if not is_x86():
            return

        inst_iter = gef_disassemble(current_arch.pc, 1)
        insn_here = inst_iter.__next__()
        if insn_here.operands == []:
            return

        insn = ','.join(insn_here.operands)
        insn = re.sub(r"<.+>", "", insn)

        r = re.findall(r"((fs|gs):\[?([^,\]]+)\]?)", str(insn))
        if r:
            code, fsgs, offset = r[0][0], r[0][1], r[0][2]
            tls = TlsCommand.getfs() if fsgs == "fs" else TlsCommand.getgs()
            offset = offset.replace("+", " + ")
            offset = offset.replace("-", " - ")
            offset = offset.replace("*", " * ")
            offset = offset.replace("eiz", " 0 ") # $eiz is always 0x0
            offset = offset.split()
            offset = ["$" + x if x.isalpha() or re.match(r"r\d+d?", x) else x for x in offset]
            offset = ''.join(offset)
            offset = parse_address(offset)
            mask = ((1 << 32) - 1) if is_32bit() else ((1 << 64) - 1)
            addr = (tls + offset) & mask
            self.context_title(f"memory access: {code} = {addr:#x}")
            gdb.execute(f"telescope {addr:#x} 4 --no-pager")
        return

    def context_memory_access3(self):
        if not is_x86():
            return

        inst_iter = gef_disassemble(current_arch.pc, 1)
        insn_here = inst_iter.__next__()
        if insn_here.operands == []:
            return

        insn = ','.join(insn_here.operands)
        insn = re.sub(r"<.+>", "", insn)

        r = re.findall(r"((es|ds|ss|cs):\[?([^,\]]+)\]?)", str(insn))
        for rr in r:
            code, addr = rr[0], rr[2]
            addr = addr.replace("+", " + ")
            addr = addr.replace("-", " - ")
            addr = addr.replace("*", " * ")
            addr = addr.replace("eiz", " 0 ") # $eiz is always 0x0
            addr = addr.split()
            addr = ["$" + x if x.isalpha() or re.match(r"r\d+d?", x) else x for x in addr]
            addr = ''.join(addr)
            addr = parse_address(addr)
            self.context_title(f"memory access: {code} = {addr:#x}")
            gdb.execute(f"telescope {addr:#x} 4 --no-pager")
        return

    @staticmethod
    def get_branch_addr(insn, to_str=False):
        ops = " ".join(insn.operands)
        ops = re.sub(r"<.*?>", "", ops)

        # x86/x64: call ... [rip+0x1111] # 0xAABBCCDD
        if " # 0x" in ops:
            addr = re.sub(r".*# (0x[a-fA-F0-9]*).*", r"\1", ops)
            ptr = to_unsigned_long(gdb.parse_and_eval(addr))
            try:
                if to_str:
                    return "{:#x}".format(read_int_from_memory(ptr))
                else:
                    return read_int_from_memory(ptr)
            except gdb.MemoryError:
                if to_str:
                    return "*{:#x}".format(ptr)
                else:
                    return None

        # x86/x64: call ... PTR [rbx]
        if is_x86():
            if " PTR [" in ops:
                addr = re.sub(r".* PTR \[(.+?)\].*", r"\1", ops)
                for gr in current_arch.gpr_registers:
                    addr = addr.replace(gr.replace("$", ""), gr)
                ptr = to_unsigned_long(gdb.parse_and_eval(addr))
                try:
                    if to_str:
                        return "{:#x}".format(read_int_from_memory(ptr))
                    else:
                        return read_int_from_memory(ptr)
                except gdb.MemoryError:
                    if to_str:
                        return "*{:#x}".format(ptr)
                    else:
                        return None

        # x64: call ... PTR fs:0x10
        if is_x86_64():
            if " PTR fs:" in ops:
                ofs = re.sub(r".* PTR fs:(0x[a-fA-F0-9]*).*", r"\1", ops)
                ofs = to_unsigned_long(gdb.parse_and_eval(ofs))
                fs = TlsCommand.getfs()
                try:
                    if to_str:
                        return "{:#x}".format(read_int_from_memory(fs + ofs))
                    else:
                        return read_int_from_memory(fs + ofs)
                except gdb.MemoryError:
                    if to_str:
                        return "*{:#x}".format(fs + ofs)
                    else:
                        return None

        # x86: call ... PTR gs:0x10
        if is_x86_32():
            if " PTR gs:" in ops:
                ofs = re.sub(r".* PTR gs:(0x[a-fA-F0-9]*).*", r"\1", ops)
                ofs = to_unsigned_long(gdb.parse_and_eval(ofs))
                gs = TlsCommand.getgs()
                try:
                    if to_str:
                        return "{:#x}".format(read_int_from_memory(gs + ofs))
                    else:
                        return read_int_from_memory(gs + ofs)
                except gdb.MemoryError:
                    if to_str:
                        return "*{:#x}".format(gs + ofs)
                    else:
                        return None

        # is there a immediate? (relative)
        # brlid  r15, -136
        # bneid  r4, -8    // 3ffe9848
        if is_microblaze():
            addr = re.sub(r"^.*\s+([-0-9]+)$", r"\1", ops.split("//")[0].strip())
            try:
                addr = int(addr) + insn.address
                if to_str:
                    return "{:#x}".format(addr)
                else:
                    return addr
            except Exception:
                pass

        # is there a immediate? (absolute)
        #   s390x:   bra    0x3ffdfc60
        #   s390x:   brasl  %r14, 0x1020b50
        #   RISCV:   jal    ra, 0x13894
        #   RISCV:   bgeu   t1, a2, 0x10350
        if "0x" in ops:
            addr = re.sub(r".*(0x[a-fA-F0-9]*).*", r"\1", ops)
            if to_str:
                return "{:#x}".format(to_unsigned_long(gdb.parse_and_eval(addr)))
            else:
                return to_unsigned_long(gdb.parse_and_eval(addr))

        # is there register(s)?
        #   x86/x64  call   rax
        #   s390x    basr   %lr, %r1
        #   sh4:     jsr    @r1
        #   alpha:   jmp    (t0)
        maybe_reg = insn.operands[-1].split()[0]
        if len(maybe_reg) <= 5 and maybe_reg[0] == "(" and maybe_reg[-1] == ")":
            maybe_reg = maybe_reg[1:-1]
        if get_register(maybe_reg):
            if to_str:
                return "{:#x}".format(get_register(maybe_reg))
            else:
                return get_register(maybe_reg)

        return None

    def context_args(self):
        if current_arch is None and is_remote_debug():
            err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            return

        insn = gef_current_instruction(current_arch.pc)
        if current_arch.is_syscall(insn):
            self.context_title("arguments")
            gdb.execute("syscall-args")
            return

        insn = gef_current_instruction(current_arch.pc)
        if not current_arch.is_call(insn):
            return

        ops = " ".join(insn.operands)
        # is there a symbol?
        if "<" in ops and ">" in ops:
            target = re.sub(r".*<([^\(> ]*).*", r"\1", ops)
        else:
            # no, try extract target address
            addr = self.get_branch_addr(insn, to_str=True)
            if addr is not None:
                target = addr
            else:
                # failed, use raw operands
                target = ' '.join(insn.operands)

        # print
        sym = gdb.lookup_global_symbol(target)
        if sym is None:
            self.print_guessed_arguments(target)
            return

        if sym.type.code != gdb.TYPE_CODE_FUNC:
            err("Symbol '{}' is not a function: type={}".format(target, sym.type.code))
            return

        self.print_arguments_from_symbol(target, sym)
        return

    def print_arguments_from_symbol(self, function_name, symbol):
        """If symbols were found, parse them and print the argument adequately."""
        args = []

        size2type = {
            1: "BYTE",
            2: "WORD",
            4: "DWORD",
            8: "QWORD",
        }

        for i, f in enumerate(symbol.type.fields()):
            _value = current_arch.get_ith_parameter(i, in_func=False)[1]
            if _value is None:
                break
            _value = to_string_dereference_from(_value)
            _name = f.name or "var_{}".format(i)
            _type = f.type.name or size2type[f.type.sizeof]
            args.append("{} {} = {}".format(_type, _name, _value))

        self.context_title("arguments")

        if not args:
            gef_print("{} (<void>)".format(function_name))
            return

        gef_print("{} (".format(function_name))
        gef_print("   " + ",\n   ".join(args))
        gef_print(")")
        return

    def print_guessed_arguments(self, function_name):
        """When no symbol, print six arguments."""
        arg_key_color = get_gef_setting("theme.registers_register_name")
        nb_argument = self.get_setting("nb_guessed_arguments")
        _arch_mode = "{}_{}".format(current_arch.arch.lower(), current_arch.mode)
        _function_name = None
        if function_name.endswith("@plt"):
            _function_name = function_name.split("@")[0]
            try:
                nb_argument = len(libc_args_definitions[_arch_mode][_function_name])
            except KeyError:
                pass

        args = []
        for i in range(nb_argument):
            try:
                _key, _value = current_arch.get_ith_parameter(i, in_func=False)
                _value = to_string_dereference_from(_value)
            except Exception:
                break
            try:
                libc_args_def = libc_args_definitions[_arch_mode][_function_name][_key]
                args.append("{} = {} (def: {})".format(Color.colorify(_key, arg_key_color), _value, libc_args_def))
            except KeyError:
                args.append("{} = {}".format(Color.colorify(_key, arg_key_color), _value))

        self.context_title("arguments (guessed)")
        gef_print("{:s}{:s} (".format(function_name, get_symbol_string(function_name)))
        if args:
            gef_print("   " + ",\n   ".join(args))
        gef_print(")")
        return

    def line_has_breakpoint(self, file_name, line_number, bp_locations):
        filename_line = "{}:{}".format(file_name, line_number)
        return any(filename_line in loc for loc in bp_locations)

    def context_source(self):
        try:
            pc = current_arch.pc
            symtabline = gdb.find_pc_line(pc)
            symtab = symtabline.symtab
            line_num = symtabline.line - 1 # we subtract one because line number returned by gdb start at 1
            if not symtab.is_valid():
                return

            fpath = symtab.fullname()
            with open(fpath, "r") as f:
                lines = [x.rstrip() for x in f.readlines()]

        except Exception:
            return

        file_base_name = os.path.basename(symtab.filename)
        breakpoints = gdb.breakpoints() or []
        bp_locations = [b.location for b in breakpoints if b.location and file_base_name in b.location]
        past_lines_color = get_gef_setting("theme.old_context")

        nb_line = self.get_setting("nb_lines_code")
        fn = symtab.filename
        title = "source:{}+{}".format(fn, line_num + 1)
        cur_line_color = get_gef_setting("theme.source_current_line")
        self.context_title(title)
        show_extra_info = self.get_setting("show_source_code_variable_values")

        for i in range(line_num - nb_line + 1, line_num + nb_line):
            if i < 0:
                continue

            bp_prefix = Color.redify(BP_GLYPH) if self.line_has_breakpoint(file_base_name, i + 1, bp_locations) else " "

            if i < line_num:
                past_line = Color.colorify("{:4d}   {:s}".format(i + 1, lines[i]), past_lines_color)
                gef_print("{:1s}{:2s}{:s}".format(bp_prefix, "", past_line))

            elif i == line_num:
                prefix = "{:1s}{:2s}{:4d}   ".format(bp_prefix, RIGHT_ARROW[1:-1], i + 1)
                leading = len(lines[i]) - len(lines[i].lstrip())
                if show_extra_info:
                    extra_info = self.get_pc_context_info(pc, lines[i])
                    for ext in extra_info:
                        gef_print("{}// {}".format(" " * (len(prefix) + leading), ext))
                gef_print(Color.colorify("{}{:s}".format(prefix, lines[i]), cur_line_color))

            elif i > line_num:
                try:
                    future_line = "{:4d}   {:s}".format(i + 1, lines[i])
                    gef_print("{:1s}{:2s}{:s}".format(bp_prefix, "", future_line))
                except IndexError:
                    break
        return

    def get_pc_context_info(self, pc, line):
        try:
            current_block = gdb.block_for_pc(pc)
            if not current_block or not current_block.is_valid():
                return ""
            m = collections.OrderedDict()
            while current_block and not current_block.is_static:
                for sym in current_block:
                    symbol = sym.name
                    if not sym.is_function and re.search(r"\W{}\W".format(symbol), line):
                        val = gdb.parse_and_eval(symbol)
                        if val.type.code in (gdb.TYPE_CODE_PTR, gdb.TYPE_CODE_ARRAY):
                            addr = int(val.address)
                            val = to_string_dereference_from(addr)
                        elif val.type.code == gdb.TYPE_CODE_INT:
                            val = hex(int(val))
                        else:
                            continue

                        if symbol not in m:
                            m[symbol] = val
                current_block = current_block.superblock

            if m:
                return ["{} = {}".format(Color.yellowify(a), b) for a, b in m.items()]
        except Exception:
            pass
        return []

    def context_trace(self):
        try:
            self.context_title("trace")

            nb_backtrace = self.get_setting("nb_lines_backtrace")
            if nb_backtrace <= 0:
                return

            # backward compat for gdb (gdb < 7.10)
            if not hasattr(gdb, "FrameDecorator"):
                gdb.execute("backtrace {:d}".format(nb_backtrace))
                return

            try:
                orig_frame = gdb.selected_frame()
                current_frame = gdb.newest_frame()
            except Exception:
                # For unknown reasons, gdb.selected_frame() may cause an error (often occurs during kernel startup).
                err("Faild to get frame information.")
                return

            frames = [current_frame]
            while current_frame != orig_frame:
                current_frame = current_frame.older()
                frames.append(current_frame)

            nb_backtrace_before = self.get_setting("nb_lines_backtrace_before")
            level = max(len(frames) - nb_backtrace_before - 1, 0)
            current_frame = frames[level]

            while current_frame:
                current_frame.select()
                if not current_frame.is_valid():
                    continue

                pc = current_frame.pc()
                name = Instruction.smartify_text(current_frame.name())
                items = []
                items.append("{:#x}".format(pc))
                if name:
                    frame_args = gdb.FrameDecorator.FrameDecorator(current_frame).frame_args() or []
                    m = Color.greenify(name)
                    fargs = ["{}={!s}".format(Color.yellowify(x.sym), x.sym.value(current_frame)) for x in frame_args]
                    m += "({})".format(", ".join(fargs))
                    items.append(m)
                else:
                    try:
                        insn = next(gef_disassemble(pc, 1))
                    except gdb.MemoryError:
                        break
                    items.append(Color.redify("{} {}".format(insn.mnemonic, ", ".join(insn.operands))))

                idx = Color.colorify("#{}".format(level), "bold green" if current_frame == orig_frame else "bold pink")
                gef_print("[{}] {}".format(idx, RIGHT_ARROW.join(items)))
                current_frame = current_frame.older()
                level += 1
                nb_backtrace -= 1
                if nb_backtrace == 0:
                    break

            orig_frame.select()
        except Exception:
            err("No such process")
        return

    def context_threads(self):
        def reason():
            res = gdb.execute("info program", to_string=True).splitlines()
            if not res:
                return "NOT RUNNING"

            for line in res:
                line = line.strip()
                if line.startswith("It stopped with signal "):
                    return line.replace("It stopped with signal ", "").split(",", 1)[0]
                if line == "The program being debugged is not being run.":
                    return "NOT RUNNING"
                if line == "It stopped at a breakpoint that has since been deleted.":
                    return "TEMPORARY BREAKPOINT"
                if line.startswith("It stopped at breakpoint "):
                    return "BREAKPOINT"
                if line == "It stopped after being stepped.":
                    return "SINGLE STEP"

            return "STOPPED"

        self.context_title("threads")

        threads = gdb.selected_inferior().threads()[::-1]
        idx = self.get_setting("nb_lines_threads")
        if idx > 0:
            threads = threads[0:idx]

        if idx == 0:
            return

        if not threads:
            err("No thread selected")
            return

        selected_thread = gdb.selected_thread()
        try:
            selected_frame = gdb.selected_frame()
        except Exception:
            # For unknown reasons, gdb.selected_frame() may cause an error (often occurs during kernel startup).
            selected_frame = None

        for i, thread in enumerate(threads):
            line = "[{:s}]".format(Color.colorify("#{:d}".format(i), "bold green" if thread == selected_thread else "bold pink"))
            line += " Id {:d}, ".format(thread.num)
            if thread.name:
                line += 'Name: "{:s}", '.format(thread.name)
            if thread.is_running():
                line += Color.colorify("running", "bold green")
            elif thread.is_stopped():
                line += Color.colorify("stopped", "bold red")
                try:
                    thread.switch()
                except Exception:
                    line += " - Failed to switch to this thread"
                    gef_print(line)
                    continue
                try:
                    frame = gdb.selected_frame()
                except Exception:
                    # For unknown reasons, gdb.selected_frame() may cause an error (often occurs during kernel startup).
                    # if failed, print thread information without frame (but with $pc).
                    line += " {:s} in".format(Color.colorify("{:#x}".format(get_register("$pc")), "blue"))
                    line += " {:s}".format(Color.colorify("unknown_frame", "bold yellow"))
                    line += ", reason: {}".format(Color.colorify(reason(), "bold pink"))
                    gef_print(line)
                    continue
                frame_name = Instruction.smartify_text(frame.name())
                line += " {:s} in".format(Color.colorify("{:#x}".format(frame.pc()), "blue"))
                line += " {:s}".format(Color.colorify(frame_name or "unknown_frame", "bold yellow"))
                line += ", reason: {}".format(Color.colorify(reason(), "bold pink"))
            elif thread.is_exited():
                line += Color.colorify("exited", "bold yellow")
            gef_print(line)

        selected_thread.switch()
        if selected_frame is not None:
            selected_frame.select()
        return

    def context_additional_information(self):
        if not __context_messages__:
            return

        self.context_title("extra")
        for level, text in __context_messages__:
            if level == "error":
                err(text)
            elif level == "warn":
                warn(text)
            elif level == "success":
                ok(text)
            else:
                info(text)
        return

    def context_memory(self):
        global __watches__
        for address, opt in sorted(__watches__.items()):
            count, fmt = opt[0:2]
            self.context_title("memory:{:#x}".format(address))
            if fmt == "pointers":
                gdb.execute("telescope {:#x} {:d} --no-pager".format(address, count))
            else:
                gdb.execute("hexdump {:s} {:#x} {:d} --no-pager".format(fmt, address, count))
        return

    @classmethod
    def update_registers(cls, event):
        try:
            for reg in current_arch.all_registers:
                try:
                    cls.old_registers[reg] = get_register(reg)
                except Exception:
                    cls.old_registers[reg] = 0
            return
        except Exception:
            return

    def empty_extra_messages(self, event):
        global __context_messages__
        __context_messages__ = []
        return


@register_command
class MemoryCommand(GenericCommand):
    """Add or remove address ranges to the memory view."""
    _cmdline_ = "memory"
    _category_ = "01-f. Debugging Support - Context Extension"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    subparsers = parser.add_subparsers(title='command', required=True)
    subparsers.add_parser('watch')
    subparsers.add_parser('unwatch')
    subparsers.add_parser('reset')
    subparsers.add_parser('list')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(prefix=True)
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()
        return


@register_command
class MemoryWatchCommand(GenericCommand):
    """Adds address ranges to the memory view."""
    _cmdline_ = "memory watch"
    _category_ = "01-f. Debugging Support - Context Extension"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('address', metavar='ADDRESS', type=parse_address,
                        help='the memory address you want to register for display in `context memory`.')
    parser.add_argument('count', metavar='COUNT', nargs='?', type=lambda x: int(x, 0), default=0x10,
                        help='the count of displayed units. (default: %(default)s)')
    parser.add_argument('unit', nargs='?', default="pointers",
                        choices=['byte', 'word', 'dword', 'qword', 'pointers'],
                        help='the size of unit. (default: %(default)s)')
    _syntax_ = parser.format_help()

    _example_ = "{:s} 0x603000 0x100 byte\n".format(_cmdline_)
    _example_ += "{:s} $sp".format(_cmdline_)

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        global __watches__

        __watches__[args.address] = (args.count, args.unit)
        ok("Adding memwatch to {:#x}".format(args.address))
        return


@register_command
class MemoryUnwatchCommand(GenericCommand):
    """Removes address ranges to the memory view."""
    _cmdline_ = "memory unwatch"
    _category_ = "01-f. Debugging Support - Context Extension"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('address', metavar='ADDRESS', type=parse_address,
                        help='the memory address you want to deregister for display in `context memory`.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} 0x603000\n".format(_cmdline_)
    _example_ += "{:s} $sp".format(_cmdline_)

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        global __watches__

        res = __watches__.pop(args.address, None)
        if not res:
            warn("You weren't watching {:#x}".format(args.address))
        else:
            ok("Removed memwatch of {:#x}".format(args.address))
        return


@register_command
class MemoryWatchResetCommand(GenericCommand):
    """Removes all watchpoints."""
    _cmdline_ = "memory reset"
    _category_ = "01-f. Debugging Support - Context Extension"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        global __watches__

        __watches__.clear()
        ok("Memory watches cleared")
        return


@register_command
class MemoryWatchListCommand(GenericCommand):
    """Lists all watchpoints to display in context layout."""
    _cmdline_ = "memory list"
    _category_ = "01-f. Debugging Support - Context Extension"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        global __watches__

        if not __watches__:
            info("No memory watches")
            return

        info("Memory watches:")
        for address, opt in sorted(__watches__.items()):
            gef_print("- {:#x} ({}, {})".format(address, opt[0], opt[1]))
        return


@register_command
class HexdumpCommand(GenericCommand):
    """Display the hexdump from the memory location specified."""
    _cmdline_ = "hexdump"
    _category_ = "03-b. Memory - View"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    subparsers = parser.add_subparsers(title='command', required=True)
    subparsers.add_parser('byte')
    subparsers.add_parser('word')
    subparsers.add_parser('dword')
    subparsers.add_parser('qword')
    _syntax_ = parser.format_help()

    def __init__(self, *args, **kwargs):
        prefix = kwargs.get("prefix", True)
        complete_type = kwargs.get("complete", gdb.COMPLETE_NONE)
        super().__init__(prefix=prefix, complete=complete_type)
        self.add_setting("always_show_ascii", True, "If true, hexdump will always display the ASCII dump")
        self.format = None
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        if not self.format:
            err("Incomplete command")
            return

        if args.phys:
            if not is_qemu_system():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
        self.phys_mode = args.phys

        if args.location:
            read_from = align_address(args.location)
        else:
            read_from = current_arch.sp

        if self.format == "byte":
            lines = self._hexdump_byte(read_from, args.count, args.full)
        else:
            lines = self._hexdump(read_from, args.count, self.format)

        if args.reverse:
            lines.reverse()

        if lines:
            gef_print("\n".join(lines), less=not args.no_pager)
        return

    def _hexdump_byte(self, read_from, read_len, full):
        read_from += self.repeat_count * read_len
        mem = self._read_memory(read_from, read_len)
        if mem is None:
            err("cannot access memory")
            return []
        lines_unmerged = hexdump(mem, show_symbol=False, base=read_from).splitlines()
        if full:
            return lines_unmerged

        # merge
        lines = []
        keep_asterisk = False
        for line in lines_unmerged:
            if lines == []:
                lines.append(line)
                continue
            if lines[-1].split("    ")[1] == line.split("    ")[1]:
                if not keep_asterisk:
                    keep_asterisk = True
            else:
                if keep_asterisk:
                    lines.append("*")
                    keep_asterisk = False
                lines.append(line)
        if keep_asterisk:
            lines.append("*")
        return lines

    def _read_memory(self, read_from, read_len):
        if read_len > 0x1000000: # Too large
            return None

        try:
            if self.phys_mode:
                mem = read_physmem(read_from, read_len)
            else:
                mem = read_memory(read_from, read_len)
            return mem
        except Exception:
            pass

        # If you get an error, you probably read outside a valid memory page.
        # Read in page size units.
        read_end = read_from + read_len
        read_end &= gef_getpagesize_mask()
        while read_end - read_from > 0:
            try:
                if self.phys_mode:
                    mem = read_physmem(read_from, read_end - read_from)
                else:
                    mem = read_memory(read_from, read_end - read_from)
                return mem
            except Exception:
                pass
            read_end -= gef_getpagesize()
        return None

    def _hexdump(self, start_addr, length, arrange_as):
        offset = self.repeat_count * length

        endianness = endian_str()

        base_address_color = get_gef_setting("theme.dereference_base_address")
        show_ascii = get_gef_setting("hexdump.always_show_ascii")

        formats = {
            "qword": ("Q", 8),
            "dword": ("I", 4),
            "word": ("H", 2),
        }

        spec, sz = formats[arrange_as]
        fmt_str = "{{base}}{v}+{{offset:#06x}}{v}{{idx:03d}}: {{sym}}{{val:#0{prec}x}}  {{text}}".format(v=VERTICAL_LINE, prec=sz * 2 + 2)
        fmt_pack = endianness + spec
        lines = []

        i = 0
        text = ""
        while i < length:
            cur_addr = start_addr + (i + offset) * sz
            sym = gdb_get_location_from_symbol(cur_addr)
            sym = "<{:s}+{:04x}> ".format(*sym) if sym else ""
            try:
                if self.phys_mode:
                    mem = read_physmem(cur_addr, sz)
                else:
                    mem = read_memory(cur_addr, sz)
            except Exception:
                break
            val = struct.unpack(fmt_pack, mem)[0]
            if show_ascii:
                text = "".join([chr(b) if 0x20 <= b < 0x7F else "." for b in mem])
            cur_addr_c = Color.colorify(format_address(cur_addr), base_address_color)
            line = fmt_str.format(base=cur_addr_c, offset=(i + offset) * sz, idx=i, sym=sym, val=val, text=text)
            lines.append(line)
            i += 1
        return lines


@register_command
class HexdumpQwordCommand(HexdumpCommand):
    """Display hexdump as QWORD from the memory location specifed."""
    _cmdline_ = "hexdump qword"
    _category_ = "03-b. Memory - View"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('location', metavar='LOCATION', nargs='?', type=parse_address,
                        help='the memory address you want to dump. (default: current_arch.sp)')
    parser.add_argument('count', metavar='COUNT', nargs='?', type=lambda x: int(x, 0), default=0x10,
                        help='the count of displayed units. (default: %(default)s)')
    parser.add_argument('--phys', action='store_true', help='treat the address as physical memory (qemu-system only).')
    parser.add_argument('--reverse', action='store_true', help='display in reverse order line by line.')
    parser.add_argument('-n', '--no-pager', action='store_true', help='do not use less.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} $rsp 16".format(_cmdline_)

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        self.format = "qword"
        return


@register_command
class HexdumpDwordCommand(HexdumpCommand):
    """Display hexdump as DWORD from the memory location specifed."""
    _cmdline_ = "hexdump dword"
    _category_ = "03-b. Memory - View"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('location', metavar='LOCATION', nargs='?', type=parse_address,
                        help='the memory address you want to dump. (default: current_arch.sp)')
    parser.add_argument('count', metavar='COUNT', nargs='?', type=lambda x: int(x, 0), default=0x10,
                        help='the count of displayed units. (default: %(default)s)')
    parser.add_argument('--phys', action='store_true', help='treat the address as physical memory (qemu-system only).')
    parser.add_argument('--reverse', action='store_true', help='display in reverse order line by line.')
    parser.add_argument('-n', '--no-pager', action='store_true', help='do not use less.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} $esp 16".format(_cmdline_)

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        self.format = "dword"
        return


@register_command
class HexdumpWordCommand(HexdumpCommand):
    """Display hexdump as WORD from the memory location specifed."""
    _cmdline_ = "hexdump word"
    _category_ = "03-b. Memory - View"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('location', metavar='LOCATION', nargs='?', type=parse_address,
                        help='the memory address you want to dump. (default: current_arch.sp)')
    parser.add_argument('count', metavar='COUNT', nargs='?', type=lambda x: int(x, 0), default=0x10,
                        help='the count of displayed units. (default: %(default)s)')
    parser.add_argument('--phys', action='store_true', help='treat the address as physical memory (qemu-system only).')
    parser.add_argument('--reverse', action='store_true', help='display in reverse order line by line.')
    parser.add_argument('-n', '--no-pager', action='store_true', help='do not use less.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} $rsp 16".format(_cmdline_)

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        self.format = "word"
        return


@register_command
class HexdumpByteCommand(HexdumpCommand):
    """Display hexdump as BYTE from the memory location specifed."""
    _cmdline_ = "hexdump byte"
    _category_ = "03-b. Memory - View"
    _aliases_ = ["xxd"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('location', metavar='LOCATION', nargs='?', type=parse_address,
                        help='the memory address you want to dump. (default: current_arch.sp)')
    parser.add_argument('count', metavar='COUNT', nargs='?', type=lambda x: int(x, 0), default=0x100,
                        help='the count of displayed units. (default: %(default)s)')
    parser.add_argument('--phys', action='store_true', help='treat the address as physical memory (qemu-system only).')
    parser.add_argument('--reverse', action='store_true', help='display in reverse order line by line.')
    parser.add_argument('--full', action='store_true', help='display the same line without omitting (byte mode only).')
    parser.add_argument('-n', '--no-pager', action='store_true', help='do not use less.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} $rsp 128\n".format(_cmdline_)
    _example_ += "{:s} $rsp 128 --full\n".format(_cmdline_)

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        self.format = "byte"
        return


@register_command
class PatchCommand(GenericCommand):
    """Write specified values to the specified address."""
    _cmdline_ = "patch"
    _category_ = "03-c. Memory - Patch"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    subparsers = parser.add_subparsers(title='command', required=True)
    subparsers.add_parser('byte')
    subparsers.add_parser('word')
    subparsers.add_parser('dword')
    subparsers.add_parser('qword')
    subparsers.add_parser('string')
    subparsers.add_parser('hexstring')
    subparsers.add_parser('pattern')
    subparsers.add_parser('nop')
    subparsers.add_parser('inf')
    subparsers.add_parser('trap')
    subparsers.add_parser('ret')
    subparsers.add_parser('syscall')
    subparsers.add_parser('history')
    subparsers.add_parser('revert')
    _syntax_ = parser.format_help()

    history = []

    def __init__(self, *args, **kwargs):
        prefix = kwargs.get("prefix", True)
        complete_type = kwargs.get("complete", gdb.COMPLETE_NONE)
        super().__init__(prefix=prefix, complete=complete_type)
        self.format = None
        return

    def patch(self, addr, data, length):
        try:
            before_data = read_memory(addr, length)
            write_memory(addr, data, length)
            after_data = read_memory(addr, length)
        except gdb.MemoryError:
            err("Failed to access memory")
            return
        if data != after_data:
            err("Failed to write memory (qemu doesn't support writing to code area?)")
            return
        history_info = {"addr": addr, "before_data": before_data, "after_data": after_data, "physmode": get_current_mmu_mode()}
        self.history.insert(0, history_info)
        ok("Patching {:d} bytes from {:s}".format(length, format_address(addr)))
        return

    # for qword, dword, word, byte sub-commands
    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        SUPPORTED_SIZES = {
            "qword": (8, "Q"),
            "dword": (4, "L"),
            "word": (2, "H"),
            "byte": (1, "B"),
        }
        if self.format not in SUPPORTED_SIZES:
            self.usage()
            return

        if args.phys:
            if not is_qemu_system():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            orig_mode = get_current_mmu_mode()

            if orig_mode == "virt":
                enable_phys()

        try:
            addr = args.location
            size, fcode = SUPPORTED_SIZES[self.format]

            if args.endian_reverse is False:
                d = "<" if is_little_endian() else ">"
            else:
                d = ">" if is_little_endian() else "<"

            for value in args.values:
                value = parse_address(value) & ((1 << size * 8) - 1)
                vstr = struct.pack(d + fcode, value)
                self.patch(addr, vstr, size)
                addr += size
        except Exception:
            self.usage()

        finally:
            if args.phys:
                if orig_mode == "virt":
                    disable_phys()
        return


@register_command
class PatchQwordCommand(PatchCommand):
    """Write specified QWORD to the specified address."""
    _cmdline_ = "patch qword"
    _category_ = "03-c. Memory - Patch"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument("-e", dest='endian_reverse', action='store_true', help='reverse endian. (default: %(default)s)')
    parser.add_argument('--phys', action='store_true', help='treat the address as physical memory (qemu-system only).')
    parser.add_argument('location', metavar='LOCATION', type=parse_address, help='the memory address you want to patch.')
    parser.add_argument('values', metavar='QWORD', nargs='*', help='the value you want to patch')
    _syntax_ = parser.format_help()

    _example_ = "{:s}    $rip 0x4142434445464748 # write `HGFEDCBA` to [rip]\n".format(_cmdline_)
    _example_ += "{:s} -e $rip 0x4142434445464748 # write `ABCDEFGH` to [rip]".format(_cmdline_)

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        self.format = "qword"
        return


@register_command
class PatchDwordCommand(PatchCommand):
    """Write specified DWORD to the specified address."""
    _cmdline_ = "patch dword"
    _category_ = "03-c. Memory - Patch"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument("-e", dest='endian_reverse', action='store_true', help='reverse endian. (default: %(default)s)')
    parser.add_argument('--phys', action='store_true', help='treat the address as physical memory (qemu-system only).')
    parser.add_argument('location', metavar='LOCATION', type=parse_address, help='the memory address you want to patch.')
    parser.add_argument('values', metavar='DWORD', nargs='*', help='the value you want to patch')
    _syntax_ = parser.format_help()

    _example_ = "{:s}    $rip 0x41424344 # write `DCBA` to [rip]\n".format(_cmdline_)
    _example_ += "{:s} -e $rip 0x41424344 # write `ABCD` to [rip]".format(_cmdline_)

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        self.format = "dword"
        return


@register_command
class PatchWordCommand(PatchCommand):
    """Write specified WORD to the specified address."""
    _cmdline_ = "patch word"
    _category_ = "03-c. Memory - Patch"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument("-e", dest='endian_reverse', action='store_true', help='reverse endian. (default: %(default)s)')
    parser.add_argument('--phys', action='store_true', help='treat the address as physical memory (qemu-system only).')
    parser.add_argument('location', metavar='LOCATION', type=parse_address, help='the memory address you want to patch.')
    parser.add_argument('values', metavar='WORD', nargs='*', help='the value you want to patch')
    _syntax_ = parser.format_help()

    _example_ = "{:s}    $rip 0x4142 # write `BA` to [rip]\n".format(_cmdline_)
    _example_ += "{:s} -e $rip 0x4142 # write `AB` to [rip]".format(_cmdline_)

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        self.format = "word"
        return


@register_command
class PatchByteCommand(PatchCommand):
    """Write specified BYTE to the specified address."""
    _cmdline_ = "patch byte"
    _category_ = "03-c. Memory - Patch"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument("-e", dest='endian_reverse', action='store_true', help='reverse endian. (default: %(default)s)')
    parser.add_argument('--phys', action='store_true', help='treat the address as physical memory (qemu-system only).')
    parser.add_argument('location', metavar='LOCATION', type=parse_address, help='the memory address you want to patch.')
    parser.add_argument('values', metavar='BYTE', nargs='*', help='the value you want to patch')
    _syntax_ = parser.format_help()

    _example_ = "{:s}    $rip 0x41 0x41 0x41 0x41 0x41\n".format(_cmdline_)
    _example_ += "{:s} -e $rip 0x41 0x41 0x41 0x41 0x41 # -e is ignored".format(_cmdline_)

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        self.format = "byte"
        return


@register_command
class PatchStringCommand(PatchCommand):
    """Write specified string to the specified memory location pointed by LOCATION."""
    _cmdline_ = "patch string"
    _category_ = "03-c. Memory - Patch"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--phys', action='store_true', help='treat the address as physical memory (qemu-system only).')
    parser.add_argument('location', metavar='LOCATION', type=parse_address, help='the memory address you want to patch.')
    parser.add_argument('vstr', metavar='"double backslash-escaped string"', type=lambda x: codecs.escape_decode(x)[0],
                        help='the string you want to patch.')
    parser.add_argument('length', metavar='LENGTH', nargs='?',
                        type=lambda x: int(x, 0), help='the length of repeat. (default: %(default)s)')
    _syntax_ = parser.format_help()

    _example_ = '{:s} $sp "AAAABBBB"\n'.format(_cmdline_)
    _example_ += '{:s} $sp "\\\\x41\\\\x41\\\\x41\\\\x41\\\\x42\\\\x42\\\\x42\\\\x42"'.format(_cmdline_)

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        if args.phys:
            if not is_qemu_system():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            orig_mode = get_current_mmu_mode()

            if orig_mode == "virt":
                enable_phys()

        if args.length:
            vstr = args.vstr * (args.length // len(args.vstr) + 1)
            vstr = vstr[:args.length]
        else:
            vstr = args.vstr

        self.patch(args.location, vstr, len(vstr))

        if args.phys:
            if orig_mode == "virt":
                disable_phys()
        return


@register_command
class PatchHexStringCommand(PatchCommand):
    """Write specified string to the specified memory location pointed by LOCATION."""
    _cmdline_ = "patch hexstring"
    _category_ = "03-c. Memory - Patch"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--phys', action='store_true', help='treat the address as physical memory (qemu-system only).')
    parser.add_argument('location', metavar='LOCATION', type=parse_address, help='the memory address you want to patch.')
    parser.add_argument('hstr', metavar='"hex-string"', type=lambda x: bytes.fromhex(x),
                        help='the string you want to patch.')
    parser.add_argument('length', metavar='LENGTH', nargs='?',
                        type=lambda x: int(x, 0), help='the length of repeat. (default: %(default)s)')
    _syntax_ = parser.format_help()

    _example_ = '{:s} $sp "4141414142424242"'.format(_cmdline_)

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        if args.phys:
            if not is_qemu_system():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            orig_mode = get_current_mmu_mode()

            if orig_mode == "virt":
                enable_phys()

        if args.length:
            hstr = args.hstr * (args.length // len(args.hstr) + 1)
            hstr = hstr[:args.length]
        else:
            hstr = args.hstr

        self.patch(args.location, hstr, len(hstr))

        if args.phys:
            if orig_mode == "virt":
                disable_phys()
        return


@register_command
class PatchPatternCommand(PatchCommand):
    """Write pattern string to the specified memory location pointed by LOCATION."""
    _cmdline_ = "patch pattern"
    _category_ = "03-c. Memory - Patch"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--phys', action='store_true', help='treat the address as physical memory (qemu-system only).')
    parser.add_argument('location', metavar='LOCATION', type=parse_address, help='the memory address you want to patch.')
    parser.add_argument('length', metavar='LENGTH', type=lambda x: int(x, 0), help='the length of repeat. (default: %(default)s)')
    _syntax_ = parser.format_help()

    _example_ = "{:s} $sp 128".format(_cmdline_)

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        if args.phys:
            if not is_qemu_system():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            orig_mode = get_current_mmu_mode()

            if orig_mode == "virt":
                enable_phys()

        pats = bytes(generate_cyclic_pattern(args.length))

        self.patch(args.location, pats, len(pats))

        if args.phys:
            if orig_mode == "virt":
                disable_phys()
        return


@register_command
class PatchNopCommand(PatchCommand):
    """Patch the instruction(s) pointed by parameters with NOP."""
    _cmdline_ = "patch nop"
    _category_ = "03-c. Memory - Patch"
    _aliases_ = ["nop"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--phys', action='store_true', help='treat the address as physical memory (qemu-system only).')
    parser.add_argument('location', metavar='LOCATION', nargs='?', type=parse_address,
                        help='the memory address you want to patch. (default: current_arch.pc)')
    group = parser.add_mutually_exclusive_group()
    group.add_argument('-b', dest='byte_length', type=lambda x: int(x, 0),
                       help='the patch length of byte (mutually exclusive with `-i`). (default: %(default)s)')
    group.add_argument('-i', dest='inst_count', type=lambda x: int(x, 0), default=1,
                       help='the patch length of instruction (mutually exclusive with `-b`). (default: 1)')
    _syntax_ = parser.format_help()

    _example_ = "{:s} $pc -i 2".format(_cmdline_)

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        return

    def get_insns_size(self, addr, num_insts):
        addr_after_n = gef_instruction_n(addr, num_insts)
        return addr_after_n.address - addr

    def patch_nop(self, addr, num_bytes):
        if num_bytes == 0:
            info("Not patching since num_bytes == 0")
            return

        if is_arm32() and current_arch.is_thumb() and addr & 1:
            addr -= 1

        nop_op_len = len(current_arch.nop_insn)

        if nop_op_len > num_bytes:
            err("Cannot patch instruction at {:#x} (nop_size is:{:d},insn_size is:{:d})".format(addr, nop_op_len, num_bytes))
            return

        count = num_bytes // nop_op_len
        patch_bytes = nop_op_len * count

        if patch_bytes != num_bytes:
            err("Cannot patch instruction at {:#x} (nop instruction does not evenly fit in requested size)".format(addr))
            return

        if is_big_endian():
            insn = current_arch.nop_insn[::-1]
        else:
            insn = current_arch.nop_insn

        self.patch(addr, insn * count, patch_bytes)
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        if current_arch.nop_insn is None:
            err("This command cannot work under this architecture.")
            return

        if args.phys:
            if not is_qemu_system():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            orig_mode = get_current_mmu_mode()

            if orig_mode == "virt":
                enable_phys()

        if args.location is None:
            location = current_arch.pc
        else:
            location = args.location

        try:
            if args.inst_count:
                num_bytes = self.get_insns_size(location, args.inst_count)
            else:
                num_bytes = args.byte_length
        except Exception:
            err("Failed to get patch bytes.")
            if args.phys:
                if orig_mode == "virt":
                    disable_phys()
            return

        try:
            self.patch_nop(location, num_bytes)
        except Exception:
            err("Failed to patch.")

        if args.phys:
            if orig_mode == "virt":
                disable_phys()
        return


@register_command
class PatchInfloopCommand(PatchCommand):
    """Patch the instruction(s) pointed by parameters with Infinity loop. Note: this command is architecture aware."""
    _cmdline_ = "patch inf"
    _category_ = "03-c. Memory - Patch"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--phys', action='store_true', help='treat the address as physical memory (qemu-system only).')
    parser.add_argument('location', metavar='LOCATION', nargs='?', type=parse_address,
                        help='the memory address you want to patch. (default: current_arch.pc)')
    _syntax_ = parser.format_help()

    _example_ = "{:s} $pc".format(_cmdline_)

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        return

    def patch_infloop(self, addr):
        if is_arm32() and current_arch.is_thumb() and addr & 1:
            addr -= 1

        if is_big_endian():
            insn = current_arch.infloop_insn[::-1]
            if current_arch.has_delay_slot:
                insn += current_arch.nop_insn[::-1]
        else:
            insn = current_arch.infloop_insn
            if current_arch.has_delay_slot:
                insn += current_arch.nop_insn

        self.patch(addr, insn, len(insn))
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        if current_arch.infloop_insn is None:
            err("This command cannot work under this architecture.")
            return

        if args.phys:
            if not is_qemu_system():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            orig_mode = get_current_mmu_mode()

            if orig_mode == "virt":
                enable_phys()

        if args.location is None:
            location = current_arch.pc
        else:
            location = args.location

        try:
            self.patch_infloop(location)
        except Exception:
            err("Failed to patch.")

        if args.phys:
            if orig_mode == "virt":
                disable_phys()
        return


@register_command
class PatchTrapCommand(PatchCommand):
    """Patch the instruction(s) pointed by parameters with BKPT."""
    _cmdline_ = "patch trap"
    _category_ = "03-c. Memory - Patch"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--phys', action='store_true', help='treat the address as physical memory (qemu-system only).')
    parser.add_argument('location', metavar='LOCATION', nargs='?', type=parse_address,
                        help='the memory address you want to patch. (default: current_arch.pc)')
    _syntax_ = parser.format_help()

    _example_ = "{:s} $pc".format(_cmdline_)

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        return

    def patch_trap(self, addr):
        if is_arm32() and current_arch.is_thumb() and addr & 1:
            addr -= 1

        if is_big_endian():
            insn = current_arch.trap_insn[::-1]
            if current_arch.has_delay_slot:
                insn += current_arch.nop_insn[::-1]
        else:
            insn = current_arch.trap_insn
            if current_arch.has_delay_slot:
                insn += current_arch.nop_insn

        self.patch(addr, insn, len(insn))
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        if current_arch.trap_insn is None:
            err("This command cannot work under this architecture.")
            return

        if args.phys:
            if not is_qemu_system():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            orig_mode = get_current_mmu_mode()

            if orig_mode == "virt":
                enable_phys()

        if args.location is None:
            location = current_arch.pc
        else:
            location = args.location

        try:
            self.patch_trap(location)
        except Exception:
            err("Failed to patch.")

        if args.phys:
            if orig_mode == "virt":
                disable_phys()
        return


@register_command
class PatchRetCommand(PatchCommand):
    """Patch the instruction(s) pointed by parameters with RET."""
    _cmdline_ = "patch ret"
    _category_ = "03-c. Memory - Patch"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--phys', action='store_true', help='treat the address as physical memory (qemu-system only).')
    parser.add_argument('location', metavar='LOCATION', nargs='?', type=parse_address,
                        help='the memory address you want to patch. (default: current_arch.pc)')
    _syntax_ = parser.format_help()

    _example_ = "{:s} $pc".format(_cmdline_)

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        return

    def patch_ret(self, addr):
        if is_arm32() and current_arch.is_thumb() and addr & 1:
            addr -= 1

        if is_big_endian():
            insn = current_arch.ret_insn[::-1]
            if current_arch.has_delay_slot:
                insn += current_arch.nop_insn[::-1]
        else:
            insn = current_arch.ret_insn
            if current_arch.has_delay_slot:
                insn += current_arch.nop_insn

        self.patch(addr, insn, len(insn))
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        if current_arch.ret_insn is None:
            err("This command cannot work under this architecture.")
            return

        if args.phys:
            if not is_qemu_system():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            orig_mode = get_current_mmu_mode()

            if orig_mode == "virt":
                enable_phys()

        if args.location is None:
            location = current_arch.pc
        else:
            location = args.location

        try:
            self.patch_ret(location)
        except Exception:
            err("Failed to patch.")

        if args.phys:
            if orig_mode == "virt":
                disable_phys()
        return


@register_command
class PatchSyscallCommand(PatchCommand):
    """Patch the instruction(s) pointed by parameters with syscall. Note: this command is architecture aware."""
    _cmdline_ = "patch syscall"
    _category_ = "03-c. Memory - Patch"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--phys', action='store_true', help='treat the address as physical memory (qemu-system only).')
    parser.add_argument('location', metavar='LOCATION', nargs='?', type=parse_address,
                        help='the memory address you want to patch. (default: current_arch.pc)')
    _syntax_ = parser.format_help()

    _example_ = "{:s} $pc".format(_cmdline_)

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        return

    def patch_syscall(self, addr):
        if is_arm32() and current_arch.is_thumb() and addr & 1:
            addr -= 1

        if is_big_endian():
            insn = current_arch.syscall_insn[::-1]
            if current_arch.has_syscall_delay_slot:
                insn += current_arch.nop_insn[::-1]
        else:
            insn = current_arch.syscall_insn
            if current_arch.has_syscall_delay_slot:
                insn += current_arch.nop_insn

        self.patch(addr, insn, len(insn))
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        if current_arch.syscall_insn is None:
            err("This command cannot work under this architecture.")
            return

        if args.phys:
            if not is_qemu_system():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            orig_mode = get_current_mmu_mode()

            if orig_mode == "virt":
                enable_phys()

        if args.location is None:
            location = current_arch.pc
        else:
            location = args.location

        try:
            self.patch_syscall(location)
        except Exception:
            err("Failed to patch.")

        if args.phys:
            if orig_mode == "virt":
                disable_phys()
        return


@register_command
class PatchHistoryCommand(PatchCommand):
    """Show patch history."""
    _cmdline_ = "patch history"
    _category_ = "03-c. Memory - Patch"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(prefix=False)
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        if self.history:
            gef_print("[NEW]")
            for i, hist in enumerate(self.history):
                b = ' '.join(["{:02x}".format(x) for x in hist["before_data"][:0x10]])
                if len(hist["before_data"]) > 0x10:
                    b += "..."
                a = ' '.join(["{:02x}".format(x) for x in hist["after_data"][:0x10]])
                if len(hist["after_data"]) > 0x10:
                    a += "..."
                sym = get_symbol_string(hist["addr"])
                i_str = Color.boldify("{:d}".format(i))
                gef_print("[{:s}] {:#x}{:s}: {:s} -> {:s}".format(i_str, hist["addr"], sym, b, a))
            gef_print("[OLD]")
        else:
            info("Patch history is empty.")
        return


@register_command
class PatchRevertCommand(PatchCommand):
    """Revert patch history."""
    _cmdline_ = "patch revert"
    _category_ = "03-c. Memory - Patch"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('revert_target', metavar='REVERT_TARGET_HISTORY', type=int,
                        help='the history index number you want to revert.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} 0 # revert to patch history stack[0]\n".format(_cmdline_)
    _example_ += "{:s} 3 # revert to patch history stack[3] ([0]-[2] are also reverted)".format(_cmdline_)

    def __init__(self):
        super().__init__(prefix=False)
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        if not (0 <= args.revert_target < len(self.history)):
            err("Invalid target index")
            gef_print(titlify("Patch history"))
            gdb.execute("patch history")
            return

        revert_count = args.revert_target + 1
        while self.history and revert_count > 0:
            hist = self.history.pop(0)
            b = ' '.join(["{:02x}".format(x) for x in hist["before_data"][:0x10]])
            if len(hist["before_data"]) > 0x10:
                b += "..."
            a = ' '.join(["{:02x}".format(x) for x in hist["after_data"][:0x10]])
            if len(hist["after_data"]) > 0x10:
                a += "..."
            sym = get_symbol_string(hist["addr"])
            info("revert {:#x}{:s}: {:s} -> {:s}".format(hist["addr"], sym, a, b))

            if is_supported_physmode():
                orig_mode = get_current_mmu_mode()
                if orig_mode == "virt" and hist["physmode"] == "phys":
                    enable_phys()
                elif orig_mode == "phys" and hist["physmode"] == "virt":
                    disable_phys()

            write_memory(hist["addr"], hist["before_data"], len(hist["before_data"]))

            if is_supported_physmode():
                if orig_mode == "virt" and get_current_mmu_mode() == "phys":
                    disable_phys()
                elif orig_mode == "phys" and get_current_mmu_mode() == "virt":
                    enable_phys()

            revert_count -= 1
        return


@functools.lru_cache(maxsize=None)
def get_dereference_from_blacklist():
    return eval(get_gef_setting("dereference.blacklist")) or []


@functools.lru_cache(maxsize=512)
def dereference_from(addr):
    """Create array like [Address(rax), Address(deref_of_rax), Address(deref_of_deref_of_rax), ..., str(msg)]"""

    if not is_alive():
        return [format_address(addr)]

    string_color = get_gef_setting("theme.dereference_string")
    max_recursion = get_gef_setting("dereference.max_recursion") or 4
    blacklist = get_dereference_from_blacklist()
    addr = lookup_address(align_address(int(addr)))
    msg = []
    seen_addrs = set()
    recursion = 0

    # parse pattern
    #   ... -> addr -> seen_address (loop)
    #   ... -> addr (blacklist)
    #   ... -> addr -> ...
    #   ... -> string
    #   ... -> value
    while recursion < max_recursion + 1: # +1 is to determine adding "..." or not
        # check loop
        #   ... -> addr -> seen_address (loop)
        if addr.value in seen_addrs:
            # If the address 0x0 is mapped, the loop is detected at the address 0x0.
            # but it is generally unnecessary information, so it is omitted.
            if addr.value != 0:
                msg.append("[loop detected]")
            return msg
        else:
            seen_addrs.add(addr.value)

        #   ... -> addr (blacklist)
        for baddr in blacklist:
            if baddr[0] <= addr.value < baddr[1]:
                msg.append(addr)
                msg.append("[blacklist detected]")
                return msg

        try:
            # Is this value a pointer or a value?
            # -- If it's a pointer, dereference
            # -- If it's a value, deref is None
            deref = addr.dereference()
        except Exception:
            # if addr is mapped to the HW device, an exception occurs. (not return None)
            # So we add the address to blacklilst -> exit
            start = addr.value & gef_getpagesize_mask()
            end = start + gef_getpagesize()
            err("Receive ignoring packets during access at {:#x}.".format(addr.value))
            err("Add {:#x}-{:#x} to blacklist addresses".format(start, end))
            new_blacklist = blacklist + [[start, end]]
            set_gef_setting("dereference.blacklist", new_blacklist, str, "dereference blacklist to avoid timeout")
            gdb.execute("gef save")
            info("blacklist saved to .gef.rc, edit manually to clear")
            info("try to exit. do restart")
            os._exit(0)

        # reach to max_recursion. add "..." instead of addr object
        if recursion == max_recursion:
            msg.append("...")
            return msg

        if deref is not None:
            # it can be referenced
            #   ... -> addr -> ...
            msg.append(addr)
            addr = lookup_address(deref)
            recursion += 1
            continue # goto next loop

        else:
            # if here, dereferencing addr has triggered a MemoryError, no need to go further
            # but we should check if it is string or value

            # try to parse the string from prev
            #   ... -> string
            if len(msg) > 0: # need address of string
                prev = msg[-1]
                if is_ascii_string(prev.value):
                    s = read_cstring_from_memory(prev.value)
                    if len(s) < get_memory_alignment():
                        txt = '{:s} ({:s}?)'.format(format_address(addr.value), Color.colorify(repr(s), string_color))
                    elif len(s) > GEF_MAX_STRING_LENGTH:
                        txt = Color.colorify('{:s}[...]'.format(repr(s[:GEF_MAX_STRING_LENGTH])), string_color)
                    else:
                        txt = Color.colorify('{:s}'.format(repr(s)), string_color)
                    msg.append(txt)
                    return msg

            # if not able to parse cleanly, simply use itself
            #   ... -> value
            msg.append(addr)
            return msg

    # something is wrong
    raise


@functools.lru_cache(maxsize=512)
def to_string_dereference_from(value, join_start_idx=0):
    """Create link list string like
    0xXXXXXXXX(value) -> 0xYYYYYYYY(deref) -> 0xZZZZZZZZ(deref_deref) -> '...'"""
    # dereference
    addrs = dereference_from(value)

    # value is not valid address
    if join_start_idx == 0 and len(addrs) == 1:
        return hex(value)

    # for example, 1st element is address and 2nd element is "[...]".
    # In this case we don't omit the 1st element even if join_start_idx==1
    if join_start_idx >= 1:
        try:
            if addrs[join_start_idx].startswith("["):
                join_start_idx -= 1
        except Exception:
            pass

    # create link list
    link = ""
    for addr in addrs[join_start_idx:]:
        if link:
            link += " {:s} ".format(RIGHT_ARROW)
        if isinstance(addr, Address):
            link += str(addr) + get_symbol_string(addr.value)
        else:
            link += addr # actually this is msg
    return link


@register_command
class DereferenceCommand(GenericCommand):
    """Dereference recursively from an address and display information.
    This acts like WinDBG `dps` command."""
    _cmdline_ = "dereference"
    _aliases_ = ["telescope"]
    _category_ = "01-a. Debugging Support - Context"
    _repeat_ = True

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('location', metavar='LOCATION', nargs='?', type=parse_address,
                        help='the memory address you want to dump. (default: current_arch.sp)')
    parser.add_argument('nb_lines', metavar='NB_LINES', nargs='?', type=lambda x: int(x, 0), default=0x10,
                        help='the count of lines. (default: %(default)s)')
    parser.add_argument('-n', '--no-pager', action='store_true', help='do not use less.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} $sp 20".format(_cmdline_)

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        self.add_setting("max_recursion", 4, "Maximum level of pointer recursion")
        self.add_setting("blacklist", "[]", "Dereference black address")
        return

    @staticmethod
    def pprint_dereferenced(addr, idx):
        base_address_color = get_gef_setting("theme.dereference_base_address")
        registers_color = get_gef_setting("theme.dereference_register_value")
        memalign = current_arch.ptrsize

        offset = idx * memalign
        current_address = align_address(addr + offset)

        # addrs: [Address(rax), Address(deref_of_rax), Address(deref_of_deref_of_rax), ..., str(msg)]
        addrs = dereference_from(current_address)
        if len(addrs) == 1: # cannot access this area
            raise

        # create address link list
        link = to_string_dereference_from(current_address, join_start_idx=1)

        # craete line of one entry
        addr_colored = Color.colorify(format_address(addrs[0].value), base_address_color)
        line = f"{addr_colored}{VERTICAL_LINE}+{offset:#06x}{VERTICAL_LINE}{idx:03d}: {link:{memalign * 2 + 2}s}"

        # add extra info
        current_address_value = read_int_from_memory(current_address)

        # retaddr info
        def get_frame_pcs():
            frames = []
            try:
                frame = gdb.newest_frame()
                while frame:
                    pc = frame.pc()
                    if pc == 0 or pc in frames:
                        break
                    frames.append(pc)
                    frame = frame.older()
            except Exception:
                pass
            return frames

        for i, frame_pc in enumerate(get_frame_pcs()):
            if current_address_value == frame_pc:
                m = " {:s} retaddr[{:d}]".format(LEFT_ARROW, i)
                line += Color.colorify(m, registers_color)

        # canary info
        res = gef_read_canary()
        if res:
            canary, location = res
            if current_address_value == canary:
                m = " {:s} canary".format(LEFT_ARROW)
                line += Color.colorify(m, registers_color)

        # register info
        def get_register_values():
            regs = []
            for regname in current_arch.all_registers:
                try:
                    regvalue = get_register(regname)
                except Exception:
                    continue
                regs.append([regname, regvalue])
            return regs

        m = ""
        for regname, regvalue in get_register_values():
            if current_address == regvalue:
                if m:
                    m += ", " + regname
                else:
                    m += regname
        if m:
            m = " {:s} {:s}".format(LEFT_ARROW, m)
            line += Color.colorify(m, registers_color)

        return line

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):

        if args.location is None:
            start_address = current_arch.sp
        else:
            start_address = args.location

        if get_gef_setting("context.grow_stack_down") is True:
            from_address = args.nb_lines * (self.repeat_count + 1) - 1
            to_address = self.repeat_count * args.nb_lines - 1
            step = -1
        else:
            from_address = 0 + self.repeat_count * args.nb_lines
            to_address = args.nb_lines * (self.repeat_count + 1)
            step = 1

        out = []
        for idx in range(from_address, to_address, step):
            try:
                line = DereferenceCommand.pprint_dereferenced(start_address, idx)
                out.append(line)
            except RuntimeError:
                # ex: nop DWORD PTR [rax+rax*1+0x0]
                msg = "Cannot access memory at address {:#x}".format(start_address + idx * current_arch.ptrsize)
                out.append("{} {}".format(Color.colorify("[!]", "bold red"), msg))
                break

        gef_print('\n'.join(out), less=not args.no_pager)
        return


@register_command
class ASLRCommand(GenericCommand):
    """View/modify the ASLR setting of GDB."""
    _cmdline_ = "aslr"
    _category_ = "02-f. Process Information - Security"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('command', nargs='?', default=None, choices=[None, 'on', 'off'], metavar='{on,off}',
                        help='set gdb aslr settings.')
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_not_qemu_system
    @only_if_gdb_target_local
    def do_invoke(self, args):
        self.dont_repeat()

        if args.command is None:
            ret = gdb.execute("show disable-randomization", to_string=True)
            i = ret.find("virtual address space is ")
            if i < 0:
                return
            msg = "ASLR is currently "
            if ret[i + 25:].strip() == "on.":
                msg += Color.redify("disabled")
            else:
                msg += Color.greenify("enabled")
            gef_print(msg)
        elif args.command == "on":
            info("Enabling ASLR")
            gdb.execute("set disable-randomization off")
        elif args.command == "off":
            info("Disabling ASLR")
            gdb.execute("set disable-randomization on")
        return


@register_command
class FollowCommand(GenericCommand):
    """View/modify the follow-fork-mode setting of GDB."""
    _cmdline_ = "follow"
    _category_ = "01-g. Debugging Support - Other"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('command', nargs='?', default=None, choices=[None, 'child', 'parent'], metavar='{child,parent}',
                        help='set gdb follow settings.')
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        if args.command is None:
            ret = gdb.execute("show follow-fork-mode", to_string=True)
            i = ret.find("\"child\"")
            if i >= 0:
                msg = "follow " + Color.redify("Child")
            else:
                msg = "follow " + Color.redify("Parent")
            gef_print(msg)
        elif args.command == "child":
            info("Follow child")
            gdb.execute("set follow-fork-mode child")
        elif args.command == "parent":
            info("Follow parent")
            gdb.execute("set follow-fork-mode parent")
        return


@register_command
class SmartCppFunctionNameCommand(GenericCommand):
    """Toggle the setting of `config context.smart_cpp_function_name`."""
    _cmdline_ = "smart-cpp-function-name"
    _category_ = "01-f. Debugging Support - Context Extension"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()

        setting = gdb.execute("gef config context.smart_cpp_function_name", to_string=True)
        if "False" in setting:
            gdb.execute("gef config context.smart_cpp_function_name true", to_string=True)
        else:
            gdb.execute("gef config context.smart_cpp_function_name false", to_string=True)
        return


@register_command
class VMMapCommand(GenericCommand):
    """Display a comprehensive layout of the virtual memory mapping."""
    _cmdline_ = "vmmap"
    _category_ = "02-c. Process Information - Memory/Section"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-v', dest='verbose', action='store_true', help='also display pointed registers.')
    parser.add_argument('--outer', action='store_true', help="display qemu-user's memory map instead of emulated process's memory map.")
    parser.add_argument('filter', metavar='FILTER', nargs='?', help='filter string')
    _syntax_ = parser.format_help()

    _example_ = "{:s} libc             # show only lines containing the string `libc`\n".format(_cmdline_)
    _example_ += "{:s} 0x555555577ab0   # show only lines included specified address\n".format(_cmdline_)
    _example_ += "{:s} --outer          # show qemu-user memory map; only valid in qemu-user mode\n".format(_cmdline_)
    _example_ += "{:s} -v               # show with registers".format(_cmdline_)

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        if is_qemu_system():
            info("Redirect to pagewalk")
            gdb.execute("pagewalk")
            return

        if args.outer and not is_qemu_usermode():
            err("Unsupported")
            return

        if is_qemu_usermode():
            # the memory map may be changed, so retry memory exploring in get_process_maps()
            reset_gef_caches(all=True)

        vmmap = get_process_maps(args.outer)
        if not vmmap:
            for line in gdb.execute('info files', to_string=True).splitlines():
                if line.startswith("Symbols from"):
                    break
            else:
                err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            err("No address mapping information found")
            return

        if not get_gef_setting("gef.disable_color"):
            self.show_legend()

        headers = ["Start", "End", "Size", "Offset", "Perm", "Path"]
        legend = "{:<{w}s}{:<{w}s}{:<{w}s}{:<{w}s}{:<4s} {:s}".format(*headers, w=get_memory_alignment() * 2 + 3)
        gef_print(Color.colorify(legend, get_gef_setting("theme.table_heading")))

        for entry in vmmap:
            if not args.filter:
                self.print_entry(entry, args.outer, args.verbose)
                continue
            if args.filter in entry.path:
                self.print_entry(entry, args.outer, args.verbose)
            elif self.is_integer(args.filter):
                addr = int(args.filter, 0)
                if addr >= entry.page_start and addr < entry.page_end:
                    self.print_entry(entry, args.outer, args.verbose)

        if is_qemu_usermode() and not args.outer:
            info("Searched from auxv, registers and stack values. There may be areas that cannot be detected.")
            info("Permission is based on ELF header or default value `rw-`. Dynamic permission changes cannot be detected.")
        return

    def print_entry(self, entry, outer, verbose):
        line_color = ""
        if entry.path == "[stack]":
            line_color = get_gef_setting("theme.address_stack")
        elif entry.path == "[heap]":
            line_color = get_gef_setting("theme.address_heap")
        elif entry.permission.value & Permission.READ and entry.permission.value & Permission.EXECUTE:
            line_color = get_gef_setting("theme.address_code")

        lines = []
        # if qemu-xxx(32bit arch) runs on x86-64 machine, memalign_size does not match get_memory_alignment()
        memalign_size = 8 if outer else None
        lines.append(Color.colorify(format_address(entry.page_start, memalign_size), line_color))
        lines.append(Color.colorify(format_address(entry.page_end, memalign_size), line_color))
        lines.append(Color.colorify(format_address(entry.size, memalign_size), line_color))
        lines.append(Color.colorify(format_address(entry.offset, memalign_size), line_color))

        if entry.permission.value == (Permission.READ | Permission.WRITE | Permission.EXECUTE):
            lines.append(Color.colorify(str(entry.permission), "underline " + line_color))
        else:
            lines.append(Color.colorify(str(entry.permission), line_color))

        lines.append(Color.colorify(entry.path, line_color))
        line = " ".join(lines)

        # register info
        if verbose:
            register_hints = []
            for regname in current_arch.all_registers:
                regvalue = get_register(regname)
                if entry.page_start <= regvalue < entry.page_end:
                    register_hints.append(regname)
            if register_hints:
                m = " {:s} {:s}".format(LEFT_ARROW, ", ".join(list(register_hints)))
                registers_color = get_gef_setting("theme.dereference_register_value")
                line += Color.colorify(m, registers_color)

        gef_print(line)
        return

    def show_legend(self):
        code_addr_color = get_gef_setting("theme.address_code")
        stack_addr_color = get_gef_setting("theme.address_stack")
        heap_addr_color = get_gef_setting("theme.address_heap")

        code = Color.colorify("Code", code_addr_color)
        heap = Color.colorify("Heap", heap_addr_color)
        stack = Color.colorify("Stack", stack_addr_color)

        gef_print("[ Legend:  {} | {} | {} ]".format(code, heap, stack))
        return

    def is_integer(self, n):
        try:
            int(n, 0)
        except ValueError:
            return False
        return True


@register_command
class XFilesCommand(GenericCommand):
    """Shows all libraries (and sections) loaded by binary."""
    _cmdline_ = "xfiles"
    _category_ = "02-c. Process Information - Memory/Section"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('filter', metavar='FILTER', nargs='*', help='regex filter string.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} libc\n".format(_cmdline_)
    _example_ += "{:s} got plt\n".format(_cmdline_)
    _example_ += "{:s} IO_vtables".format(_cmdline_)

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        headers = ["Start", "End", "Name", "File"]
        legend = "{:<{w}s}{:<{w}s}{:<21s} {:s}".format(*headers, w=get_memory_alignment() * 2 + 3)
        gef_print(Color.colorify(legend, get_gef_setting("theme.table_heading")))

        for xfile in get_info_files():
            lines = []
            lines.append(format_address(xfile.zone_start))
            lines.append(format_address(xfile.zone_end))
            lines.append("{:<21s}".format(xfile.name))
            lines.append(xfile.filename)
            line = " ".join(lines)

            if not args.filter:
                gef_print(line)
            else:
                for filt in args.filter:
                    if re.search(filt, line):
                        gef_print(line)
                        break
        return


@register_command
class XInfoCommand(GenericCommand):
    """Retrieve and display runtime information for the location(s) given as parameter."""
    _cmdline_ = "xinfo"
    _category_ = "02-c. Process Information - Memory/Section"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('location', metavar='LOCATION', nargs='+', type=parse_address,
                        help='the memory address you want to show the map information.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} $pc".format(_cmdline_)

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        for location in args.location:
            try:
                gef_print(titlify("xinfo: {:#x}".format(location)))
                self.infos(location)
            except gdb.error as gdb_error:
                err(str(gdb_error))
        return

    def infos(self, address):
        addr = lookup_address(address)
        if not addr.valid:
            warn("Cannot reach {:#x} in memory space".format(address))
            return

        sect = addr.section
        info = addr.info

        if sect:
            page_start = format_address(sect.page_start)
            page_end = format_address(sect.page_end)
            page_size = sect.page_end - sect.page_start
            gef_print("Page: {:s} {:s} {:s} (size={:#x})".format(page_start, RIGHT_ARROW, page_end, page_size))
            gef_print("Permissions: {}".format(sect.permission))
            gef_print("Pathname: {:s}".format(sect.path))
            gef_print("Offset (from page): {:#x}".format(addr.value - sect.page_start))
            if sect.inode:
                gef_print("Inode: {:s}".format(sect.inode))

        if info:
            zone_start = format_address(info.zone_start)
            zone_end = format_address(info.zone_end)
            gef_print("Segment: {:s} ({:s}-{:s})".format(info.name, zone_start, zone_end))
            gef_print("Offset (from segment): {:#x}".format(addr.value - info.zone_start))

        sym = gdb_get_location_from_symbol(address)
        if sym:
            name, offset = sym
            msg = "Symbol: {:s}".format(name)
            if offset:
                msg += "+{:d}".format(offset)
            gef_print(msg)

        return


@register_command
class XorMemoryCommand(GenericCommand):
    """XOR a block of memory, then display or patch it."""
    _cmdline_ = "xor-memory"
    _category_ = "03-d. Memory - Calculation"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    subparsers = parser.add_subparsers(title='command', required=True)
    subparsers.add_parser('display')
    subparsers.add_parser('patch')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(prefix=True)
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()
        return


@register_command
class XorMemoryDisplayCommand(GenericCommand):
    """Display a block of memory by xor-ing each byte with specified key. The key must be
    provided in hexadecimal format."""
    _cmdline_ = "xor-memory display"
    _category_ = "03-d. Memory - Calculation"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('location', metavar='LOCATION', type=parse_address,
                        help='the address of data you want to xor.')
    parser.add_argument('size', metavar='SIZE', type=parse_address,
                        help='the size of data you want to xor.')
    parser.add_argument('key', metavar='KEY', type=lambda x: bytes.fromhex(x),
                        help='the data you want to xor as key.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} $sp 16 41414141".format(_cmdline_)

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        start_addr = args.location
        end_addr = args.location + args.size
        try:
            block = read_memory(start_addr, args.size)
        except gdb.MemoryError:
            err("Failed to read memory")
            return
        info("Displaying XOR-ing {:#x}-{:#x} with {:s}".format(start_addr, end_addr, repr(args.key)))

        gef_print(titlify("Original block"))
        gef_print(hexdump(block, base=start_addr))

        gef_print(titlify("XOR-ed block"))
        xored_block = bytearray([x ^ y for x, y in zip(block, itertools.cycle(args.key))])
        gef_print(hexdump(xored_block, base=start_addr))
        return


@register_command
class XorMemoryPatchCommand(GenericCommand):
    """Patch a block of memory by xor-ing each byte with specified key. The key must be
    provided in hexadecimal format."""
    _cmdline_ = "xor-memory patch"
    _category_ = "03-d. Memory - Calculation"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('location', metavar='LOCATION', type=parse_address,
                        help='the address of data you want to xor.')
    parser.add_argument('size', metavar='SIZE', type=parse_address,
                        help='the size of data you want to xor.')
    parser.add_argument('key', metavar='KEY', type=lambda x: bytes.fromhex(x),
                        help='the data you want to xor as key.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} $sp 16 41414141".format(_cmdline_)

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        start_addr = args.location
        end_addr = args.location + args.size
        try:
            block = read_memory(start_addr, args.size)
        except gdb.MemoryError:
            err("Failed to read memory")
            return
        info("Patching XOR-ing {:#x}-{:#x} with '{:s}'".format(start_addr, end_addr, repr(args.key)))
        xored_block = bytearray([x ^ y for x, y in zip(block, itertools.cycle(args.key))])
        gdb.execute("patch hexstring {:#x} {:s}".format(start_addr, xored_block.hex()))
        return


@register_command
class PatternCommand(GenericCommand):
    """Create or search a De Bruijn cyclic pattern to facilitate determining the offset in memory."""
    _cmdline_ = "pattern"
    _category_ = "09-c. Misc - Generation"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    subparsers = parser.add_subparsers(title='command', required=True)
    subparsers.add_parser('create')
    subparsers.add_parser('search')
    _syntax_ = parser.format_help()

    def __init__(self, *args, **kwargs):
        super().__init__(prefix=True)
        self.add_setting("length", 1024, "Initial length of a cyclic buffer to generate")
        return

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()
        return


@register_command
class PatternCreateCommand(GenericCommand):
    """Generate a de Bruijn cyclic pattern. It will generate a pattern long of SIZE,
    incrementally varying of one byte at each generation. The length of each block is
    equal to sizeof(void*).
    Note: This algorithm is the same than the one used by pwntools library."""
    _cmdline_ = "pattern create"
    _category_ = "09-c. Misc - Generation"
    _aliases_ = ["pattc"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('size', metavar='SIZE', type=parse_address, nargs='?', help='the size of pattern. (default: 1024)')
    _syntax_ = parser.format_help()

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()

        if args.size:
            set_gef_setting("pattern.length", args.size)

        size = get_gef_setting("pattern.length")
        info("Generating a pattern of {:d} bytes".format(size))
        pattern_str = gef_pystring(generate_cyclic_pattern(size))
        gef_print(pattern_str)
        ok("Saved as '{:s}'".format(gef_convenience(pattern_str)))
        return


@register_command
class PatternSearchCommand(GenericCommand):
    """Search for the cyclic de Bruijn pattern generated by the `pattern create` command. The
    PATTERN argument can be a GDB symbol (such as a register name) or an hexadecimal value."""
    _cmdline_ = "pattern search"
    _category_ = "09-c. Misc - Generation"
    _aliases_ = ["patto"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('pattern', metavar='PATTERN', help='the pattern you want to offset search.')
    parser.add_argument('size', metavar='SIZE', type=parse_address, nargs='?', help='the size of pattern. (default: 1024)')
    _syntax_ = parser.format_help()

    _example_ = "{:s} $pc\n".format(_cmdline_)
    _example_ += "{:s} 0x61616164\n".format(_cmdline_)
    _example_ += "{:s} aaab".format(_cmdline_)

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        if args.size is None:
            size = get_gef_setting("pattern.length")
        else:
            size = args.size

        info("Searching '{:s}'".format(args.pattern))
        self.search(args.pattern, size)
        return

    def search(self, pattern, size):
        pattern_be, pattern_le = None, None

        # 1. check if it's a symbol (like "$sp" or "0x1337")
        symbol = safe_parse_and_eval(pattern)
        if symbol:
            addr = to_unsigned_long(symbol)
            dereferenced_value = dereference(addr)
            # 1-bis. try to dereference
            if dereferenced_value:
                addr = int(dereferenced_value)

            if current_arch.ptrsize == 4:
                pattern_be = struct.pack(">I", addr)
                pattern_le = struct.pack("<I", addr)
            else:
                pattern_be = struct.pack(">Q", addr)
                pattern_le = struct.pack("<Q", addr)

        else:
            # 2. assume it's a plain string
            pattern_be = gef_pybytes(pattern)
            pattern_le = gef_pybytes(pattern[::-1])

        pattern_be = pattern_be.strip(b"\0")
        pattern_le = pattern_le.strip(b"\0")

        cyclic_pattern = generate_cyclic_pattern(size)
        found = False
        off = cyclic_pattern.find(pattern_le)
        if off >= 0:
            fmt = "Found at offset {:d} (little-endian search) {:s}"
            ok(fmt.format(off, Color.colorify("likely", "bold red") if is_little_endian() else ""))
            found = True

        off = cyclic_pattern.find(pattern_be)
        if off >= 0:
            fmt = "Found at offset {:d} (big-endian search) {:s}"
            ok(fmt.format(off, Color.colorify("likely", "bold green") if is_big_endian() else ""))
            found = True

        if not found:
            err("Pattern '{}' not found".format(pattern))
        return


@register_command
class SropHintCommand(GenericCommand):
    """Hint for sigreturn oriented programming."""
    _cmdline_ = "srop-hint"
    _category_ = "09-d. Misc - Show Example"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-a', '--arch', choices=['x86', 'x64', 'arm', 'aarch64'],
                        help='the target architecture.')
    _syntax_ = parser.format_help()

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()

        if args.arch is None:
            if is_x86_64():
                mode = "x64"
            elif is_x86_32():
                mode = "x86"
            elif is_arm32():
                mode = "arm"
            elif is_arm64():
                mode = "aarch64"
            else:
                mode = "x64" # default
        else:
            mode = args.arch

        s = ""
        if mode == "x64":
            s += 'exp  = struct.pack("<Q", syscall)    # rax = 15 (rt_sigreturn)\n'
            s += 'exp += struct.pack("<Q", 0xcafebabe) # rt_sigframe.pretcode\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_flags\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_link\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_stack.ss_sp\n'
            s += 'exp += struct.pack("<I", 0x0)        # rt_sigframe.uc.uc_stack.ss_flags\n'
            s += 'exp += struct.pack("<I", 0x0)        # rt_sigframe.uc.uc_stack.ss_size\n'
            s += 'exp += struct.pack("<Q", 0x08)       # rt_sigframe.uc.uc_mcontext.r8\n'
            s += 'exp += struct.pack("<Q", 0x09)       # rt_sigframe.uc.uc_mcontext.r9\n'
            s += 'exp += struct.pack("<Q", 0x0a)       # rt_sigframe.uc.uc_mcontext.r10\n'
            s += 'exp += struct.pack("<Q", 0x0b)       # rt_sigframe.uc.uc_mcontext.r11\n'
            s += 'exp += struct.pack("<Q", 0x0c)       # rt_sigframe.uc.uc_mcontext.r12\n'
            s += 'exp += struct.pack("<Q", 0x0d)       # rt_sigframe.uc.uc_mcontext.r13\n'
            s += 'exp += struct.pack("<Q", 0x0e)       # rt_sigframe.uc.uc_mcontext.r14\n'
            s += 'exp += struct.pack("<Q", 0x0f)       # rt_sigframe.uc.uc_mcontext.r15\n'
            s += 'exp += struct.pack("<Q", 0x07)       # rt_sigframe.uc.uc_mcontext.rdi\n'
            s += 'exp += struct.pack("<Q", 0x06)       # rt_sigframe.uc.uc_mcontext.rsi\n'
            s += 'exp += struct.pack("<Q", 0x05)       # rt_sigframe.uc.uc_mcontext.rbp\n'
            s += 'exp += struct.pack("<Q", 0x02)       # rt_sigframe.uc.uc_mcontext.rbx\n'
            s += 'exp += struct.pack("<Q", 0x04)       # rt_sigframe.uc.uc_mcontext.rdx\n'
            s += 'exp += struct.pack("<Q", 0x01)       # rt_sigframe.uc.uc_mcontext.rax\n'
            s += 'exp += struct.pack("<Q", 0x03)       # rt_sigframe.uc.uc_mcontext.rcx\n'
            s += 'exp += struct.pack("<Q", 0xdeadface) # rt_sigframe.uc.uc_mcontext.rsp\n'
            s += 'exp += struct.pack("<Q", 0xdeadbeef) # rt_sigframe.uc.uc_mcontext.rip\n'
            s += 'exp += struct.pack("<Q", 0x00)       # rt_sigframe.uc.uc_mcontext.rflags\n'
            s += 'exp += struct.pack("<H", 0x33)       # rt_sigframe.uc.uc_mcontext.cs\n'
            s += 'exp += struct.pack("<H", 0x00)       # rt_sigframe.uc.uc_mcontext.gs\n'
            s += 'exp += struct.pack("<H", 0x00)       # rt_sigframe.uc.uc_mcontext.fs\n'
            s += 'exp += struct.pack("<H", 0x00)       # rt_sigframe.uc.uc_mcontext.__pad0\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_mcontext.err\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_mcontext.trapno\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_mcontext.oldmask\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_mcontext.cr2\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_mcontext.fpstate # fpu/xmm are not restored if NULL\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_mcontext.reserved[8]\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_sigmask\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.info\n'
        elif mode == "x86":
            s += 'exp  = struct.pack("<I", syscall)    # eax = 119 (sigreturn)\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.gs\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.fs\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.es\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.ds\n'
            s += 'exp += struct.pack("<I", 0x7)        # sigframe.sc.edi\n'
            s += 'exp += struct.pack("<I", 0x6)        # sigframe.sc.esi\n'
            s += 'exp += struct.pack("<I", 0x5)        # sigframe.sc.ebp\n'
            s += 'exp += struct.pack("<I", 0xdeadface) # sigframe.sc.esp\n'
            s += 'exp += struct.pack("<I", 0x2)        # sigframe.sc.ebx\n'
            s += 'exp += struct.pack("<I", 0x4)        # sigframe.sc.edx\n'
            s += 'exp += struct.pack("<I", 0x3)        # sigframe.sc.ecx\n'
            s += 'exp += struct.pack("<I", 0x1)        # sigframe.sc.eax\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.trapno\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.err\n'
            s += 'exp += struct.pack("<I", 0xdeadbeef) # sigframe.sc.eip\n'
            s += 'exp += struct.pack("<I", 0x23)       # sigframe.sc.cs # use 0x73 if 32bit native machine\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.eflags\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.esp_at_signal\n'
            s += 'exp += struct.pack("<I", 0x2b)       # sigframe.sc.ss # use 0x7b if 32bit native machine\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.fpstate # fpu/xmm are not restored if NULL\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.oldmask\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.cr2\n'
            s += '\n'
        elif mode == "arm":
            s += 'exp += struct.pack("<I", pop_r7_pc)  # pop {r7, pc};\n'
            s += 'exp += struct.pack("<I", 119)        # r7 = 119 (sigreturn)\n'
            s += 'exp += struct.pack("<I", call_svc)   #\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_flags\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_link\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_stack.ss_sp\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_stack.ss_flags\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_stack.ss_size\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_mcontext.trapno\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_mcontext.error_code\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_mcontext.oldmask\n'
            s += 'exp += struct.pack("<I", 0x00)       # sigframe.uc.uc_mcontext.arm_r0\n'
            s += 'exp += struct.pack("<I", 0x01)       # sigframe.uc.uc_mcontext.arm_r1\n'
            s += 'exp += struct.pack("<I", 0x02)       # sigframe.uc.uc_mcontext.arm_r2\n'
            s += 'exp += struct.pack("<I", 0x03)       # sigframe.uc.uc_mcontext.arm_r3\n'
            s += 'exp += struct.pack("<I", 0x04)       # sigframe.uc.uc_mcontext.arm_r4\n'
            s += 'exp += struct.pack("<I", 0x05)       # sigframe.uc.uc_mcontext.arm_r5\n'
            s += 'exp += struct.pack("<I", 0x06)       # sigframe.uc.uc_mcontext.arm_r6\n'
            s += 'exp += struct.pack("<I", 0x07)       # sigframe.uc.uc_mcontext.arm_r7\n'
            s += 'exp += struct.pack("<I", 0x08)       # sigframe.uc.uc_mcontext.arm_r8\n'
            s += 'exp += struct.pack("<I", 0x09)       # sigframe.uc.uc_mcontext.arm_r9\n'
            s += 'exp += struct.pack("<I", 0x0a)       # sigframe.uc.uc_mcontext.arm_r10\n'
            s += 'exp += struct.pack("<I", 0x0b)       # sigframe.uc.uc_mcontext.arm_fp\n'
            s += 'exp += struct.pack("<I", 0x0c)       # sigframe.uc.uc_mcontext.arm_ip\n'
            s += 'exp += struct.pack("<I", 0xdeadface) # sigframe.uc.uc_mcontext.arm_sp\n'
            s += 'exp += struct.pack("<I", 0x0d)       # sigframe.uc.uc_mcontext.arm_lr\n'
            s += 'exp += struct.pack("<I", 0xdeadbeef) # sigframe.uc.uc_mcontext.arm_pc\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_mcontext.arm_cpsr\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_mcontext.fault_address\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_sigmask\n'
        elif mode == "aarch64":
            s += 'exp += struct.pack("<Q", ldp_x8_x9)  # ldp x8, x9, [sp], #16; ret x9;\n'
            s += 'exp += struct.pack("<Q", 139)        # x8 = 139\n'
            s += 'exp += struct.pack("<Q", call_svc)   # \n'
            s += 'exp += struct.pack("<I", 0x0)*32     # rt_sigframe.info\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_flags\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_link\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_stack.ss_sp\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_stack.ss_flags\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_stack.ss_size\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_stack.__unused\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_sigmask\n'
            s += 'exp += struct.pack("<B", 0x0)*120    # rt_sigframe.uc.__unused[120]\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_mcontext.fault_address\n'
            s += 'exp += struct.pack("<Q", 0x00)       # rt_sigframe.uc.uc_mcontext.regs[31].x0\n'
            s += 'exp += struct.pack("<Q", 0x01)       # rt_sigframe.uc.uc_mcontext.regs[31].x1\n'
            s += 'exp += struct.pack("<Q", 0x02)       # rt_sigframe.uc.uc_mcontext.regs[31].x2\n'
            s += 'exp += struct.pack("<Q", 0x03)       # rt_sigframe.uc.uc_mcontext.regs[31].x3\n'
            s += 'exp += struct.pack("<Q", 0x04)       # rt_sigframe.uc.uc_mcontext.regs[31].x4\n'
            s += 'exp += struct.pack("<Q", 0x05)       # rt_sigframe.uc.uc_mcontext.regs[31].x5\n'
            s += 'exp += struct.pack("<Q", 0x06)       # rt_sigframe.uc.uc_mcontext.regs[31].x6\n'
            s += 'exp += struct.pack("<Q", 0x07)       # rt_sigframe.uc.uc_mcontext.regs[31].x7\n'
            s += 'exp += struct.pack("<Q", 0x08)       # rt_sigframe.uc.uc_mcontext.regs[31].x8\n'
            s += 'exp += struct.pack("<Q", 0x09)       # rt_sigframe.uc.uc_mcontext.regs[31].x9\n'
            s += 'exp += struct.pack("<Q", 0x0a)       # rt_sigframe.uc.uc_mcontext.regs[31].x10\n'
            s += 'exp += struct.pack("<Q", 0x0b)       # rt_sigframe.uc.uc_mcontext.regs[31].x11\n'
            s += 'exp += struct.pack("<Q", 0x0c)       # rt_sigframe.uc.uc_mcontext.regs[31].x12\n'
            s += 'exp += struct.pack("<Q", 0x0d)       # rt_sigframe.uc.uc_mcontext.regs[31].x13\n'
            s += 'exp += struct.pack("<Q", 0x0e)       # rt_sigframe.uc.uc_mcontext.regs[31].x14\n'
            s += 'exp += struct.pack("<Q", 0x0f)       # rt_sigframe.uc.uc_mcontext.regs[31].x15\n'
            s += 'exp += struct.pack("<Q", 0x10)       # rt_sigframe.uc.uc_mcontext.regs[31].x16\n'
            s += 'exp += struct.pack("<Q", 0x11)       # rt_sigframe.uc.uc_mcontext.regs[31].x17\n'
            s += 'exp += struct.pack("<Q", 0x12)       # rt_sigframe.uc.uc_mcontext.regs[31].x18\n'
            s += 'exp += struct.pack("<Q", 0x13)       # rt_sigframe.uc.uc_mcontext.regs[31].x19\n'
            s += 'exp += struct.pack("<Q", 0x14)       # rt_sigframe.uc.uc_mcontext.regs[31].x20\n'
            s += 'exp += struct.pack("<Q", 0x15)       # rt_sigframe.uc.uc_mcontext.regs[31].x21\n'
            s += 'exp += struct.pack("<Q", 0x16)       # rt_sigframe.uc.uc_mcontext.regs[31].x22\n'
            s += 'exp += struct.pack("<Q", 0x17)       # rt_sigframe.uc.uc_mcontext.regs[31].x23\n'
            s += 'exp += struct.pack("<Q", 0x18)       # rt_sigframe.uc.uc_mcontext.regs[31].x24\n'
            s += 'exp += struct.pack("<Q", 0x19)       # rt_sigframe.uc.uc_mcontext.regs[31].x25\n'
            s += 'exp += struct.pack("<Q", 0x1a)       # rt_sigframe.uc.uc_mcontext.regs[31].x26\n'
            s += 'exp += struct.pack("<Q", 0x1b)       # rt_sigframe.uc.uc_mcontext.regs[31].x27\n'
            s += 'exp += struct.pack("<Q", 0x1c)       # rt_sigframe.uc.uc_mcontext.regs[31].x28\n'
            s += 'exp += struct.pack("<Q", 0x1d)       # rt_sigframe.uc.uc_mcontext.regs[31].x29\n'
            s += 'exp += struct.pack("<Q", 0x1e)       # rt_sigframe.uc.uc_mcontext.regs[31].x30\n'
            s += 'exp += struct.pack("<Q", 0xdeadface) # rt_sigframe.uc.uc_mcontext.sp\n'
            s += 'exp += struct.pack("<Q", 0xdeadbeef) # rt_sigframe.uc.uc_mcontext.pc\n'
            s += 'exp += struct.pack("<Q", 0x00)       # rt_sigframe.uc.uc_mcontext.pstate\n'
        gef_print(s.rstrip())
        return


@register_command
class Ret2dlHintCommand(GenericCommand):
    """Hint for return-to-dl-resolve."""
    _cmdline_ = "ret2dl-hint"
    _category_ = "09-d. Misc - Show Example"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()

        s = ""
        s += "  +---.got/.got.plt @ itself-------+\n"
        s += "  | GOT[0]: _DYNAMIC               |\n"
        s += "  | GOT[1]: link_map               |\n"
        s += "  | GOT[2]: _dl_runtime_resolve@ld |\n"
        s += "  | GOT[3]: func1                  |\n"
        s += "  | GOT[4]: func2                  |\n"
        s += "  | GOT[5]: func3                  |\n"
        s += "  | ...                            |\n"
        s += "  +--------------------------------+\n"
        s += "\n"
        s += "If `link_map` and `_dl_runtime_resolve` are non-zero, just use them.\n"
        s += "If they are zero, you have to resolve them from DT_DEBUG entry of _DYNAMIC.\n"
        s += "\n"
        s += "  +---_DYNAMIC @ itself------+     +---> +---r_debug--------+\n"
        s += "  | QWORD tag                |     |     | QWORD r_version  |\n"
        s += "  | QWORD value              |     |     | QWORD link_map   | <-- HERE\n"
        s += "  +--------------------------+     |     | QWORD r_brk      |\n"
        s += "  | ...                      |     |     | QWORD r_ldbase   |\n"
        s += "  +--------------------------+     |     +------------------+\n"
        s += "  | QWORD tag(0x15:DT_DEBUG) |     |\n"
        s += "  | QWORD value              |-----+\n"
        s += "  +--------------------------+\n"
        s += "\n"
        s += "  (binary itself)              (libc.so)                    (ld-linux.so)\n"
        s += "  +---link_map---+     +-----> +---link_map---+     +-----> +---link_map---+\n"
        s += "  | QWORD l_addr |     |       | QWORD l_addr |     |       | QWORD l_addr |\n"
        s += "  | QWORD l_name |     |       | QWORD l_name |     |       | QWORD l_name |\n"
        s += "  | QWORD l_ld   |     |       | QWORD l_ld   |---+ |       | QWORD l_ld   |\n"
        s += "  | QWORD l_next |-----+       | QWORD l_next |---|-+       | QWORD l_next |\n"
        s += "  | QWORD l_prev |             | QWORD l_prev |   |         | QWORD l_prev |\n"
        s += "  +--------------+             +--------------+   |         +--------------+\n"
        s += "                                                  |\n"
        s += "        +-----------------------------------------+\n"
        s += "        |\n"
        s += "        +--> +---_DYNAMIC @ libc--------+     +---> +---.got/.got.plt @ libc---------+\n"
        s += "             | QWORD tag                |     |     | GOT[0]: _DYNAMIC               |\n"
        s += "             | QWORD value              |     |     | GOT[1]: link_map               |\n"
        s += "             +--------------------------+     |     | GOT[2]: _dl_runtime_resolve@ld | <-- HERE\n"
        s += "             | ...                      |     |     | GOT[3]: func1                  |\n"
        s += "             +--------------------------+     |     | GOT[4]: func2                  |\n"
        s += "             | QWORD tag(0x3:DT_PLTGOT) |     |     | GOT[5]: func3                  |\n"
        s += "             | QWORD value              |-----+     | ...                            |\n"
        s += "             +--------------------------+           +--------------------------------+\n"
        s += "\n"
        s += "\n"
        s += "  _dl_runtime_resolve@.plt.got(link_map, reloc_arg)\n"
        s += "    -> _dl_fixup@ld(link_map, reloc_arg)\n"
        s += "                                   |\n"
        s += "                                   |\n"
        if is_32bit():
            s = s.replace("QWORD", "DWORD")
            s += "  +-------reloc_arg as offset------+\n"
            s += "  |\n"
            s += "  |      +---.rel.plt-----------------------+                           +---.dynsym----------+          +---.dynstr-------+\n"
            s += "  |      | DWORD r_offset                   |                           | DWORD st_name      |          | char[] symbol   |\n"
            s += "  |      | DWORD r_info                     |                           | DWORD st_value     |     +--->| char[] symbol   |\n"
            s += "  |      +----------------------------------+                           | DWORD st_size      |     |    | char[] symbol   |\n"
            s += "  +----> | DWORD r_offset(=writable area)   |   (r_info>>8) * 0x18      | BYTE  st_info      |     |    | char[] symbol   |\n"
            s += "         | DWORD r_info(=(dynsym_idx<<8)|7) |-------------+             | BYTE  st_other     |     |    | ...             |\n"
            s += "         +----------------------------------+             |             | WORD  st_shndx     |     |    +-----------------+\n"
            s += "         | ...                              |             +------------>+--------------------+     |\n"
            s += "         +----------------------------------+                           | DWORD st_name      |-----+\n"
            s += "                                                                        | DWORD st_value     |\n"
            s += "                                                                        | DWORD st_size      |\n"
            s += "                                                                        | BYTE  st_info      |\n"
            s += "                                                                        | BYTE  st_other(=0) |\n"
            s += "                                                                        | WORD  st_shndx     |\n"
            s += "                                                                        +--------------------+\n"
            s += "                                                                        | ...                |\n"
            s += "                                                                        +--------------------+\n"
        else:
            s += "  +---reloc_arg * 0x18 as offset---+\n"
            s += "  |\n"
            s += "  |      +---.rela.plt----------------------+                           +---.dynsym----------+          +---.dynstr-------+\n"
            s += "  |      | QWORD r_offset                   |                           | DWORD st_name      |          | char[] symbol   |\n"
            s += "  |      | QWORD r_info                     |                           | BYTE  st_info      |     +--->| char[] symbol   |\n"
            s += "  |      | QWORD r_addend                   |                           | BYTE  st_other     |     |    | char[] symbol   |\n"
            s += "  +----> +----------------------------------+                           | WORD  st_shndx     |     |    | char[] symbol   |\n"
            s += "         | QWORD r_offset(=writable area)   |   (r_info>>32) * 0x18     | QWORD st_value     |     |    | ...             |\n"
            s += "         | QWORD r_info(=(dynsym_idx<<32)|7)|-------------+             | QWORD st_size      |     |    +-----------------+\n"
            s += "         | QWORD r_addend                   |             +------------>+--------------------+     |\n"
            s += "         +----------------------------------+                           | DWORD st_name      |-----+\n"
            s += "         | ...                              |                           | BYTE  st_info      |\n"
            s += "         +----------------------------------+                           | BYTE  st_other(=0) |\n"
            s += "                                                                        | WORD  st_shndx     |\n"
            s += "                                                                        | QWORD st_value     |\n"
            s += "                                                                        | QWORD st_size      |\n"
            s += "                                                                        +--------------------+\n"
            s += "                                                                        | ...                |\n"
            s += "                                                                        +--------------------+\n"
        s += "\n"
        s += "Use `dynamic` and `link-map` to display the structure.\n"
        gef_print(s.rstrip())
        return


@register_command
class LinkMapCommand(GenericCommand):
    """Dump link_map with iterating."""
    _cmdline_ = "link-map"
    _category_ = "02-e. Process Information - Complex Structure Information"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    group = parser.add_mutually_exclusive_group()
    group.add_argument('-e', dest='elf_address', type=parse_address, help='the elf address you want to parse.')
    group.add_argument('-l', dest='link_map_address', type=parse_address, help='the link_map address you want to parse.')
    _syntax_ = parser.format_help()

    _example_ = "{:s}                   # dump itself\n".format(_cmdline_)
    _example_ += "{:s} -e 0x555555554000 # dump specified address as elf\n".format(_cmdline_)
    _example_ += "{:s} -l 0x7ffff7ffe2e0 # dump specified address as link_map".format(_cmdline_)

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def dump_link_map(self, link_map):
        if link_map is None:
            info("link_map is 0.")
            return

        section = process_lookup_address(link_map)
        info("link_map: {:#x} [{:s}]".format(link_map, str(section.permission)))

        current = link_map
        while True:
            addr = current
            l_addr = read_int_from_memory(current)
            current += current_arch.ptrsize
            l_name = read_int_from_memory(current)
            name = read_cstring_from_memory(l_name)
            current += current_arch.ptrsize
            l_ld = read_int_from_memory(current)
            current += current_arch.ptrsize
            l_next = read_int_from_memory(current)
            current += current_arch.ptrsize
            l_prev = read_int_from_memory(current)
            current += current_arch.ptrsize

            if not name:
                name = "(binary itself)"
            gef_print(titlify(name))
            if is_32bit():
                gef_print("{:#010x}:  {:#010x} {:#010x}  |  load_address, name".format(addr, l_addr, l_name))
                gef_print("{:#010x}:  {:#010x} {:#010x}  |  dynamic, next".format(addr + current_arch.ptrsize * 2, l_ld, l_next))
                gef_print("{:#010x}:  {:#010x} {:10s}  |  prev".format(addr + current_arch.ptrsize * 4, l_prev, ""))
            else:
                gef_print("{:#018x}:  {:#018x} {:#018x}  |  load_address, name".format(addr, l_addr, l_name))
                gef_print("{:#018x}:  {:#018x} {:#018x}  |  dynamic, next".format(addr + current_arch.ptrsize * 2, l_ld, l_next))
                gef_print("{:#018x}:  {:#018x} {:18s}  |  prev".format(addr + current_arch.ptrsize * 4, l_prev, ""))

            if l_next == 0:
                break
            current = l_next
        return

    @staticmethod
    def get_link_map(filename_or_addr, silent=False):
        current = dynamic = DynamicCommand.get_dynamic(filename_or_addr, silent)
        while True:
            tag = read_int_from_memory(current)
            current += current_arch.ptrsize
            val = read_int_from_memory(current)
            current += current_arch.ptrsize
            if tag not in DynamicCommand.DT_TABLE:
                link_map = None
                if not silent:
                    info("Not found link_map")
                break
            if DynamicCommand.DT_TABLE[tag] == "DT_DEBUG":
                dt_debug = val
                val_addr = current - current_arch.ptrsize
                if not silent:
                    info("_DYNAMIC+{:#x}(=DT_DEBUG): {:#x} -> {:#x}".format(val_addr - dynamic, val_addr, dt_debug))
                link_map = read_int_from_memory(dt_debug + current_arch.ptrsize)
                if not silent:
                    info("DT_DEBUG+{:#x}: {:#x} -> {:#x}".format(current_arch.ptrsize, dt_debug + current_arch.ptrsize, link_map))
                break
        return link_map

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        filename = None

        if args.link_map_address:
            link_map = args.link_map_address

        elif args.elf_address:
            try:
                link_map = self.get_link_map(args.elf_address)
            except Exception:
                err("Failed to get link_map.")
                return
        else:
            filename = get_filepath()
            if filename is None:
                err("Failed to get filename.")
                return

            if not os.path.exists(filename):
                err("{:s} is not found.".format(filename))
                return

            if is_static(filename):
                info("The binary is static build. There is no link_map.")
                return

            try:
                link_map = self.get_link_map(filename)
            except Exception:
                err("Failed to get link_map.")
                return

        try:
            self.dump_link_map(link_map)
        except Exception:
            err("Failed to parse link_map.")
        return


@register_command
class DynamicCommand(GenericCommand):
    """Display current status of the _DYNAMIC area."""
    _cmdline_ = "dynamic"
    _category_ = "02-e. Process Information - Complex Structure Information"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    group = parser.add_mutually_exclusive_group()
    group.add_argument('-f', dest='filename', help='the filename you want to parse.')
    group.add_argument('-e', dest='elf_address', type=parse_address, help='the elf address you want to parse.')
    group.add_argument('-d', dest='dynamic_address', type=parse_address, help='the dynamic address you want to parse.')
    _syntax_ = parser.format_help()

    _example_ = "{:s}                                        # dump itself\n".format(_cmdline_)
    _example_ += "{:s} -f /usr/lib/x86_64-linux-gnu/libc.so.6 # dump specified binary\n".format(_cmdline_)
    _example_ += "{:s} -e 0x555555554000                      # dump specified address as elf\n".format(_cmdline_)
    _example_ += "{:s} -d 0x555555575a98                      # dump specified address as dynamic".format(_cmdline_)

    DT_TABLE = {
        0: "DT_NULL",
        1: "DT_NEEDED",
        2: "DT_PLTRELSZ",
        3: "DT_PLTGOT",
        4: "DT_HASH",
        5: "DT_STRTAB",
        6: "DT_SYMTAB",
        7: "DT_RELA",
        8: "DT_RELASZ",
        9: "DT_RELAENT",
        10: "DT_STRSZ",
        11: "DT_SYMENT",
        12: "DT_INIT",
        13: "DT_FINI",
        14: "DT_SONAME",
        15: "DT_RPATH",
        16: "DT_SYMBOLIC",
        17: "DT_REL",
        18: "DT_RELSZ",
        19: "DT_RELENT",
        20: "DT_PLTREL",
        21: "DT_DEBUG",
        22: "DT_TEXTREL",
        23: "DT_JMPREL",
        24: "DT_BIND_NOW",
        25: "DT_INIT_ARRAY",
        26: "DT_FINI_ARRAY",
        27: "DT_INIT_ARRAYSZ",
        28: "DT_FINI_ARRAYSZ",
        29: "DT_RUNPATH",
        30: "DT_FLAGS",
        #32: "DT_ENCODING", # unspecified
        32: "DT_PREINIT_ARRAY",
        33: "DT_PREINIT_ARRAYSZ",
        34: "DT_SYMTAB_SHNDX",
        35: "DT_RELRSZ",
        36: "DT_RELR",
        37: "DT_RELRENT",
        #0x6000000d: "DT_LOOS", # unspecified
        0x6000000e: "DT_SUNW_RTLDINF",
        0x6000000f: "DT_ANDROID_REL",
        0x60000010: "DT_ANDROID_RELSZ",
        0x60000011: "DT_ANDROID_RELA",
        0x60000012: "DT_ANDROID_RELASZ",
        0x6fffe000: "DT_ANDROID_RELR",
        0x6fffe001: "DT_ANDROID_RELRSZ",
        0x6fffe003: "DT_ANDROID_RELRENT",
        0x6fffe005: "DT_ANDROID_RELRCOUNT",
        #0x6ffff000: "DT_HIOS", # unspecified
        #0x6ffffd00: "DT_VALRNGLO", # unspecified
        0x6ffffdf5: "DT_GNU_PRELINKED",
        0x6ffffdf6: "DT_GNU_CONFLICTSZ",
        0x6ffffdf7: "DT_GNU_LIBLISTSZ",
        0x6ffffdf8: "DT_CHECKSUM",
        0x6ffffdf9: "DT_PLTPADSZ",
        0x6ffffdfa: "DT_MOVEENT",
        0x6ffffdfb: "DT_MOVESZ",
        0x6ffffdfc: "DT_FEATURE_1",
        0x6ffffdfd: "DT_POSFLAG_1",
        0x6ffffdfe: "DT_SYMINSZ",
        0x6ffffdff: "DT_SYMINENT",
        #0x6ffffdff: "DT_VALRNGHI", # unspecified
        #0x6ffffe00: "DT_ADDRRNGLO", # unspecified
        0x6ffffef5: "DT_GNU_HASH",
        0x6ffffef6: "DT_TLSDESC_PLT",
        0x6ffffef7: "DT_TLSDESC_GOT",
        0x6ffffef8: "DT_GNU_CONFLICT",
        0x6ffffef9: "DT_GNU_LIBLIST",
        0x6ffffefa: "DT_CONFIG",
        0x6ffffefb: "DT_DEPAUDIT",
        0x6ffffefc: "DT_AUDIT",
        0x6ffffefd: "DT_PLTPAD",
        0x6ffffefe: "DT_MOVETAB",
        0x6ffffeff: "DT_SYMINFO",
        #0x6ffffeff: "DT_ADDRRNGHI", # unspecified
        0x6ffffff0: "DT_VERSYM",
        0x6ffffff9: "DT_RELACOUNT",
        0x6ffffffa: "DT_RELCOUNT",
        0x6ffffffb: "DT_FLAGS_1",
        0x6ffffffc: "DT_VERDEF",
        0x6ffffffd: "DT_VERDEFNUM",
        0x6ffffffe: "DT_VERNEED",
        0x6fffffff: "DT_VERNEEDNUM",
        #0x70000000: "DT_LOPROC", # unspecified
        0x70000001: "DT_SPARC_REGISTER",
        0x7ffffffd: "DT_AUXILIARY",
        0x7ffffffe: "DT_USED",
        0x7fffffff: "DT_FILTER",
        #0x7fffffff: "DT_HIPROC", # unspecified
    }

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_FILENAME)
        return

    def dump_dynamic(self, dynamic):
        if dynamic is None:
            info("_DYNAMIC is not found.")
            return

        current = dynamic
        while True:
            addr = current
            tag = read_int_from_memory(current)
            current += current_arch.ptrsize
            val = read_int_from_memory(current)
            current += current_arch.ptrsize

            if tag not in self.DT_TABLE:
                break

            if is_32bit():
                gef_print("{:#010x}:  {:#010x} {:#010x}  |  tag:{:s}".format(addr, tag, val, self.DT_TABLE[tag]))
            else:
                gef_print("{:#018x}:  {:#018x} {:#018x}  |  tag:{:s}".format(addr, tag, val, self.DT_TABLE[tag]))
        return

    @staticmethod
    def get_dynamic(filename_or_addr, silent=False):
        if not silent:
            if isinstance(filename_or_addr, str):
                info("filename: {:s}".format(filename_or_addr))
            else:
                info("address: {:#x}".format(filename_or_addr))

        elf = Elf(filename_or_addr)
        phdrs = [phdr for phdr in elf.phdrs if phdr.p_type == Phdr.PT_DYNAMIC]
        if len(phdrs) == 0:
            return None

        if isinstance(filename_or_addr, str):
            if is_pie(filename_or_addr):
                load_base = get_section_base_address(filename_or_addr)
                dynamic = phdrs[0].p_vaddr + load_base
            else:
                dynamic = phdrs[0].p_vaddr
        else:
            if phdrs[0].p_vaddr < filename_or_addr:
                dynamic = phdrs[0].p_vaddr + filename_or_addr
            else:
                dynamic = phdrs[0].p_vaddr

        if not silent:
            section = process_lookup_address(dynamic)
            info("_DNYAMIC: {:#x} [{:s}]".format(dynamic, str(section.permission)))
        return dynamic

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        filename = None

        if args.dynamic_address:
            dynamic = args.dynamic_address

        elif args.elf_address:
            try:
                dynamic = self.get_dynamic(args.elf_address)
            except Exception:
                err("Failed to get _DYNAMIC.")
                return

        else:
            if args.filename:
                filename = args.filename
            else:
                filename = get_filepath()
                if filename is None:
                    err("Failed to get filename.")
                    return

            if not os.path.exists(filename):
                err("{:s} is not found.".format(filename))
                return

            if is_static(filename):
                info("The binary is static build. There is no _DYNAMIC.")
                return

            if get_section_base_address(filename) is None:
                err("{:s} is not loeaded.".format(filename))
                return

            try:
                dynamic = self.get_dynamic(filename)
            except Exception:
                err("Failed to get _DYNAMIC.")
                return

        try:
            self.dump_dynamic(dynamic)
        except Exception:
            err("Failed to parse _DYNAMIC.")
        return


@register_command
class DestructorDumpCommand(GenericCommand):
    """Display registered destructor functions."""
    _cmdline_ = "dtor-dump"
    _category_ = "02-e. Process Information - Complex Structure Information"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    def ror(self, val, bits, arch_bits):
        new_val = (val >> bits) | (val << (arch_bits - bits))
        mask = (1 << arch_bits) - 1
        return new_val & mask

    def decode_function(self, fn):
        if is_x86_64():
            decoded_fn = self.ror(fn, 17, 64) ^ self.cookie
        elif is_x86_32():
            decoded_fn = self.ror(fn, 9, 32) ^ self.cookie
        elif is_arm32() or is_arm64():
            decoded_fn = fn ^ self.cookie
        return decoded_fn

    def perm(self, addr):
        try:
            return "[{:s}]".format(str(lookup_address(addr).section.permission))
        except Exception:
            return "[???]"

    def dump_tls_dtors(self):
        if not self.tls:
            err("TLS is not found")
            return

        if is_x86_64():
            head_p = self.tls - 0x60
        elif is_x86_32():
            head_p = self.tls - 0x3c
        elif is_arm32():
            head_p = self.tls + 0x20
        elif is_arm64():
            head_p = self.tls + 0x40

        current = head = read_int_from_memory(head_p)
        if head:
            fmt = "{:s}: {:#x}{:s}: {:#x}{:s}"
            gef_print(fmt.format("tls_dtor_list", head_p, self.perm(head_p), head, self.perm(head)))
        else:
            fmt = "{:s}: {:#x}{:s}: {:#x}"
            gef_print(fmt.format("tls_dtor_list", head_p, self.perm(head_p), head))

        ptrsize = current_arch.ptrsize

        def read_fns(addr):
            func = read_int_from_memory(current)
            obj = read_int_from_memory(current + ptrsize * 1)
            link_map = read_int_from_memory(current + ptrsize * 2)
            next_ = read_int_from_memory(current + ptrsize * 3)
            return func, obj, link_map, next_

        while current:
            try:
                func, obj, link_map, next_ = read_fns(current)
            except Exception:
                err("Memory access error at {:#x}".format(current))
                break

            decoded_fn = self.decode_function(func)
            sym = get_symbol_string(decoded_fn)
            decoded_fn_s = Color.boldify("{:#x}".format(decoded_fn))

            if is_valid_addr(decoded_fn):
                valid_msg = Color.colorify("valid", "bold green")
            else:
                valid_msg = Color.colorify("invalid", "bold red")

            fmt = "    -> func:     {:#x}{:s}: {:#x} (={:s}{:s}) [{:s}]"
            gef_print(fmt.format(current, self.perm(current), func, decoded_fn_s, sym, valid_msg))
            fmt = "       obj:      {:#x}{:s}: {:#x}"
            gef_print(fmt.format(current + ptrsize * 1, self.perm(current + ptrsize * 1), obj))
            fmt = "       link_map: {:#x}{:s}: {:#x}"
            gef_print(fmt.format(current + ptrsize * 2, self.perm(current + ptrsize * 2), link_map))
            fmt = "       next:     {:#x}{:s}: {:#x}"
            gef_print(fmt.format(current + ptrsize * 3, self.perm(current + ptrsize * 3), next_))
            current = next_
        return

    def dump_exit_funcs(self, name):
        try:
            head_p = parse_address("&" + name)
        except Exception:
            err("Not found symbol ({:s})".format(name))
            return

        current = head = read_int_from_memory(head_p)
        gef_print("{:s}: {:#x}{:s}: {:#x}{:s}".format(name, head_p, self.perm(head_p), head, self.perm(head)))
        if not current:
            return

        ptrsize = current_arch.ptrsize

        next_ = read_int_from_memory(current)
        idx = read_int_from_memory(current + ptrsize)
        current += ptrsize * 2
        gef_print("    -> next:  {:#x}{:s}: {:#x}".format(head + ptrsize * 0, self.perm(head + ptrsize * 0), next_))
        gef_print("       idx:   {:#x}{:s}: {:#x}".format(head + ptrsize * 1, self.perm(head + ptrsize * 1), idx))

        def read_fns(addr):
            flavor = read_int_from_memory(addr)
            fn = read_int_from_memory(addr + ptrsize * 1)
            arg = read_int_from_memory(addr + ptrsize * 2)
            dso_handle = read_int_from_memory(addr + ptrsize * 3)
            return flavor, fn, arg, dso_handle

        fns_size = ptrsize * 4 # flavor, fn, arg, dso_handle

        if is_32bit():
            mask = (1 << 32) - 1
        else:
            mask = (1 << 64) - 1

        for i in range(idx, -1, -1):
            addr = (current + fns_size * i) & mask
            try:
                flavor, fn, arg, dso_handle = read_fns(addr)
            except Exception:
                err("Memory access error at {:#x}".format(addr))
                break
            if fn == 0:
                continue
            decoded_fn = self.decode_function(fn)
            sym = get_symbol_string(decoded_fn)
            decoded_fn_s = Color.boldify("{:#x}".format(decoded_fn))

            if is_valid_addr(decoded_fn):
                valid_msg = Color.colorify("valid", "bold green")
            else:
                valid_msg = Color.colorify("invalid", "bold red")

            fns = "       fns[{:#x}]:{:#x}{:s}:".format(i, addr, self.perm(addr))
            gef_print("{} flavor:{:#x}".format(fns, flavor))
            gef_print("{} func:{:#x} (={:s}{:s}) [{:s}]".format(" " * len(fns), fn, decoded_fn_s, sym, valid_msg))
            gef_print("{} arg:{:#x}".format(" " * len(fns), arg))
            gef_print("{} dso_handle:{:#x}".format(" " * len(fns), dso_handle))
        return

    def yield_link_map(self):
        current = LinkMapCommand.get_link_map(get_filepath(), silent=True)
        while current:
            _dic = {}
            _dic["load_address"] = read_int_from_memory(current)
            name_ptr = read_int_from_memory(current + current_arch.ptrsize * 1)
            _dic["name"] = _dic["name_org"] = read_cstring_from_memory(name_ptr)
            if _dic["name_org"] == "":
                _dic["name"] = "{:s}".format(get_filepath())
            _dic["dynamic"] = read_int_from_memory(current + current_arch.ptrsize * 2)
            _dic["next"] = read_int_from_memory(current + current_arch.ptrsize * 3)
            LinkMap = collections.namedtuple("LinkMap", _dic.keys())
            link_map = LinkMap(*_dic.values())
            yield link_map
            current = _dic["next"]

    def dump_sections_not_array(self, section_name):
        if not is_static(get_filepath()):
            for link_map in self.yield_link_map():
                if not os.path.exists(link_map.name):
                    continue
                elf = Elf(link_map.name)
                try:
                    shdr = [s for s in elf.shdrs if s.sh_name == section_name][0]
                except Exception:
                    continue
                if is_pie(link_map.name):
                    addr = shdr.sh_addr + link_map.load_address
                else:
                    addr = shdr.sh_addr
                gef_print(link_map.name)
                sym = get_symbol_string(addr)
                func_s = Color.boldify("{:#x}".format(addr))
                gef_print("    -> {:s}{:s}".format(func_s, sym))
        else:
            elf = Elf(get_filepath())
            try:
                shdr = [s for s in elf.shdrs if s.sh_name == section_name][0]
            except Exception:
                err("Not found {:s} section".format(section_name))
                return
            addr = shdr.sh_addr
            gef_print(get_filepath())
            sym = get_symbol_string(addr)
            func_s = Color.boldify("{:#x}".format(addr))
            gef_print("    -> {:s}{:s}".format(func_s, sym))
        return

    def dump_sections(self, section_name):
        if not is_static(get_filepath()):
            for link_map in self.yield_link_map():
                if not os.path.exists(link_map.name):
                    continue
                elf = Elf(link_map.name)
                try:
                    shdr = [s for s in elf.shdrs if s.sh_name == section_name][0]
                except Exception:
                    continue
                entries = []
                for i in range(shdr.sh_size // current_arch.ptrsize):
                    if is_pie(link_map.name):
                        addr = shdr.sh_addr + link_map.load_address + current_arch.ptrsize * i
                    else:
                        addr = shdr.sh_addr + current_arch.ptrsize * i
                    func = read_int_from_memory(addr)
                    if is_32bit() and func in [0, 0xffffffff]:
                        continue
                    if is_64bit() and func in [0, 0xffffffffffffffff]:
                        continue
                    entries.append([addr, func])
                if not entries:
                    continue
                gef_print(link_map.name)
                for addr, func in entries:
                    sym = get_symbol_string(func)
                    func_s = Color.boldify("{:#x}".format(func))
                    gef_print("    -> {:#x}{:s}: {:s}{:s}".format(addr, self.perm(addr), func_s, sym))
        else:
            elf = Elf(get_filepath())
            try:
                shdr = [s for s in elf.shdrs if s.sh_name == section_name][0]
            except Exception:
                err("Not found {:s} section".format(section_name))
                return
            entries = []
            for i in range(shdr.sh_size // current_arch.ptrsize):
                addr = shdr.sh_addr + current_arch.ptrsize * i
                func = read_int_from_memory(addr)
                if is_32bit() and func in [0, 0xffffffff]:
                    continue
                if is_64bit() and func in [0, 0xffffffffffffffff]:
                    continue
                entries.append([addr, func])
            if not entries:
                err("Not found valid entry")
                return
            gef_print(get_filepath())
            for addr, func in entries:
                sym = get_symbol_string(func)
                func_s = Color.boldify("{:#x}".format(func))
                gef_print("    -> {:#x}{:s}: {:s}{:s}".format(addr, self.perm(addr), func_s, sym))
        return

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, args):
        self.dont_repeat()

        # init
        if is_x86_64():
            self.tls = TlsCommand.getfs()
            self.cookie = read_int_from_memory(self.tls + 0x30)
        elif is_x86_32():
            self.tls = TlsCommand.getgs()
            self.cookie = read_int_from_memory(self.tls + 0x18)
        elif is_arm32() or is_arm64():
            if is_arm32():
                try:
                    self.tls = parse_address("(unsigned int)__aeabi_read_tp()")
                except Exception:
                    err("Not found symbol (__aeabi_read_tp)")
                    return
            else:
                try:
                    self.tls = get_register("$TPIDR_EL0")
                except Exception:
                    err("Fail reading $TPIDR_EL0 register")
                    return
            try:
                cookie_ptr = parse_address("&__pointer_chk_guard_local")
            except Exception:
                err("Not found symbol (__pointer_chk_guard_local)")
                return
            self.cookie = read_int_from_memory(cookie_ptr)

        # dump
        gef_print(titlify("tls_dtor_list: registered by __cxa_thread_atexit_impl()"))
        self.dump_tls_dtors()

        gef_print(titlify("__exit_funcs: registered by atexit(), on_exit()"))
        self.dump_exit_funcs("__exit_funcs")

        gef_print(titlify("__quick_exit_funcs: registered by at_quick_exit()"))
        self.dump_exit_funcs("__quick_exit_funcs")

        gef_print(titlify(".fini_array"))
        self.dump_sections(".fini_array")

        gef_print(titlify(".fini"))
        self.dump_sections_not_array(".fini")

        gef_print(titlify(".dtors"))
        self.dump_sections(".dtors")

        gef_print(titlify("__libc_atexit"))
        self.dump_sections("__libc_atexit")
        return


@register_command
class GotCommand(GenericCommand):
    """Display current status of the got/plt inside the process."""
    _cmdline_ = "got"
    _category_ = "02-e. Process Information - Complex Structure Information"
    _aliases_ = ["plt"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-f', dest='file', help='the filename you want to parse.')
    parser.add_argument('-e', dest='elf_address', type=parse_address, help='the elf address you want to parse.')
    parser.add_argument('-r', dest='remote', action='store_true', help='parse remote binary if download feature is available.')
    parser.add_argument('-v', dest='verbose', action='store_true', help='verbose output.')
    parser.add_argument('filter', metavar='FILTER', nargs='*', help='filter string')
    _syntax_ = parser.format_help()

    _example_ = "{:s} read print                              # filter specified keyword\n".format(_cmdline_)
    _example_ += "{:s} -f /usr/lib/x86_64-linux-gnu/libc.so.6 # target the library's GOT\n".format(_cmdline_)
    _example_ += "{:s} -f /bin/ls -e 0x4000000000             # use specified address, it is useful under qemu".format(_cmdline_)

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_FILENAME)
        self.add_setting("function_resolved", "green", "Line color of the got command output if the function has been resolved")
        self.add_setting("function_not_resolved", "yellow", "Line color of the got command output if the function has not been resolved")
        return

    def get_jmp_slots(self):
        try:
            cmd = [self.readelf, "--relocs", "--wide", self.filename]
            lines = gef_execute_external(cmd, as_list=True)
        except Exception:
            lines = []

        output = {}
        section_name = None
        reloc_count = 0
        for line in lines:
            # get section
            r = re.findall("Relocation section '(.+?)' ", line)
            if r:
                section_name = r[0]
                continue

            # GOT entry pattern 1
            if "JUMP_SLOT" in line:
                type = "JUMP_SLOT"
                address, _, _, _, name = line.split()[:5]
                address = int(address, 16)
                name = name.split("@")[0]
            # GOT entry pattern 2 (?)
            elif 'GLOB_DAT' in line:
                type = "GLOB_DAT"
                address, _, _, _, name = line.split()[:5]
                address = int(address, 16)
                name = name.split("@")[0]
            # GOT entry pattern 3 (?)
            elif "IRELATIVE" in line:
                type = "IRELATIVE"
                if is_x86_32():
                    address = line.split()[0]
                    address = int(address, 16)
                    name = "*ABS*"
                else:
                    address, _, _, addend = line.split()[:4]
                    address = int(address, 16)
                    name = "*ABS*+{:#x}".format(int(addend, 16))
            # Not GOT entry
            else:
                continue

            # count up reloc_arg
            if section_name in [".rel.plt", ".rela.plt"] and not checksec(self.filename)["Static"]:
                reloc_arg = reloc_count * [1, 8][is_x86_32()]
                reloc_count += 1
            else:
                reloc_arg = None

            # fix address
            if checksec(self.filename)["PIE"]:
                address += self.base_address

            # save
            array = output.get(type, [])
            output[type] = array + [[address, name, section_name, type, reloc_arg]]

        # flatten
        a = output.get("JUMP_SLOT", [])
        b = output.get("IRELATIVE", [])
        c = output.get("GLOB_DAT", [])
        return a + b + c

    def get_plt_addresses(self):
        try:
            cmd = [self.objdump, "-j", ".plt", "-j", ".plt.sec", "-j", ".plt.got", "-d", self.filename]
            lines = gef_execute_external(cmd, as_list=True)
        except Exception:
            lines = []

        output = {}
        for line in lines:
            # get function name
            r = re.findall(r"^([0-9a-f]+) <(.+)@plt>:", line)
            if not r:
                continue
            address, func_name = int(r[0][0], 16), r[0][1]

            # fix addreess
            if checksec(self.filename)["PIE"]:
                address += self.base_address

            # save
            # Since DT_REL (used at i386) has no r_addend, the information of identification does not exist.
            # So there are multiple "*ABS*" entries, keep them in a list.
            array = output.get(func_name, [])
            output[func_name] = array + [address]

        return output

    def get_plt_range(self):
        # The PLT range is required to determine whether the information in the GOT is resolved or not.
        elf = get_elf_headers(self.filename)
        sections = [x for x in elf.shdrs if x.sh_name in [".plt", ".plt.got", ".plt.sec"]]
        if len(sections) == 0:
            return 0, 0
        plt_begin = min([x.sh_addr for x in sections])
        plt_end = max([x.sh_addr + x.sh_size for x in sections])

        # fix address
        if checksec(self.filename)["PIE"]:
            plt_begin += self.base_address
            plt_end += self.base_address

        return plt_begin, plt_end

    def perm(self, addr):
        try:
            return "[{:s}]".format(str(lookup_address(addr).section.permission))
        except Exception:
            return "[???]"

    def get_shdr_range(self):
        elf = get_elf_headers(self.filename)
        ranges = []
        for shdr in elf.shdrs:
            sh_start = shdr.sh_addr
            sh_end = shdr.sh_addr + shdr.sh_size
            if checksec(self.filename)["PIE"]:
                sh_start += self.base_address
                sh_end += self.base_address
            ranges.append([shdr.sh_name, sh_start, sh_end])
        return ranges

    def get_section_name(self, addr):
        ranges = self.get_shdr_range()
        for name, start, end in ranges:
            if start <= addr < end:
                return name
        else:
            return "???"

    def get_section_sym(self, addr):
        ranges = self.get_shdr_range()
        for name, start, end in ranges:
            if start <= addr < end:
                return " <{:s}+{:#x}>".format(name, addr - start)
        else:
            return ""

    def print_plt_got(self):
        # retrieve jump slots using readelf
        jmpslots = self.get_jmp_slots()

        # retrieve plt address using objdump
        plts = self.get_plt_addresses()

        # retrieve the end of plt from elf parsing
        plt_begin, plt_end = self.get_plt_range()

        # print legend
        if self.verbose:
            fmt = "{:>9s} {:s} {:>14s} @ {:12s} {:>8s} {:>9s} {:s} {:>14s} @ {:12s} {:>8s} {:s}"
            legend = [
                "TYPE", VERTICAL_LINE,
                "PLT", "Section", "Offset", "reloc_arg", VERTICAL_LINE,
                "GOT", "Section", "Offset", "Symbol -> GOTvalue",
            ]
        else:
            fmt = "{:>14s} {:s} {:>14s} {:s}"
            legend = [
                "PLT", VERTICAL_LINE, "GOT", "Symbol -> GOTvalue",
            ]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))

        # link each PLT entries and each GOT entries
        # and create lines for output
        resolved_info = []
        for got_address, name, section_name, type, reloc_arg in jmpslots:
            # resolve PLT from GOT name
            if section_name != ".rel.plt" and name == "*ABS*": # i386 special case
                plt_address = []
            else: # in many other case
                plt_address = plts.get(name, [])
            if plt_address:
                plt_address = plt_address.pop(0)

            # resolve offset from absolute address
            got_offset = got_address - self.base_address
            if plt_address:
                plt_offset = plt_address - self.base_address

            # read the address of the function
            try:
                got_value = read_int_from_memory(got_address)
            except gdb.error:
                err("Memory access error")
                return

            # resolve got value's symbol
            if got_value == 0:
                got_value_sym = ""
            elif plt_begin <= got_value < plt_end: # Non-PIE
                got_value_sym = self.get_section_sym(got_value)
            elif plt_begin - self.base_address <= got_value < plt_end - self.base_address: # PIE
                got_value_sym = self.get_section_sym(got_value)
            else:
                got_value_sym = get_symbol_string(got_value)

            # different colors if the function has been resolved or not
            if got_value == 0:
                color = self.get_setting("function_resolved") # something is wrong
            elif plt_begin <= got_value < plt_end: # Non-PIE
                color = self.get_setting("function_not_resolved") # function hasn't already been resolved
            elif plt_begin - self.base_address <= got_value < plt_end - self.base_address: # PIE
                color = self.get_setting("function_not_resolved") # function hasn't already been resolved
            else:
                color = self.get_setting("function_resolved") # function has already been resolved

            # reloc_arg
            if reloc_arg is None:
                reloc_arg_info = "{:>9s}".format("-")
            else:
                reloc_arg_info = "{:#9x}".format(reloc_arg)

            # make plt info
            if self.verbose:
                if plt_address:
                    plt_section = self.get_section_name(plt_address) + self.perm(plt_address)
                    plt_info = "{:#14x} @{:13s} {:#8x} {:9s}".format(plt_address, plt_section, plt_offset, reloc_arg_info)
                else:
                    plt_info = "{:>14s}  {:13s} {:>8s} {:9s}".format("Not found", "", "", reloc_arg_info)
            else:
                if plt_address:
                    plt_info = "{:#14x}".format(plt_address)
                else:
                    plt_info = "{:>14s}".format("Not found")

            # make got info
            if self.verbose:
                got_section = self.get_section_name(got_address) + self.perm(got_address)
                got_value_c = Color.colorify("{:s} {:s} {:#x}{:s}".format(name, RIGHT_ARROW, got_value, got_value_sym), color)
                got_info = "{:#14x} @{:13s} {:#8x} {:s}".format(got_address, got_section, got_offset, got_value_c)
            else:
                got_value_c = Color.colorify("{:s} {:s} {:#x}{:s}".format(name, RIGHT_ARROW, got_value, got_value_sym), color)
                got_info = "{:#14x} {:s}".format(got_address, got_value_c)

            # make line
            if self.verbose:
                line = "{:>9s} {:s} {:s} {:s} {:s}".format(type, VERTICAL_LINE, plt_info, VERTICAL_LINE, got_info)
            else:
                line = "{:s} {:s} {:s}".format(plt_info, VERTICAL_LINE, got_info)

            # save
            resolved_info.append([got_address, section_name, line])

        # sort by GOT address
        resolved_info = sorted(resolved_info)

        # print
        prev_section = None
        for got_address, section_name, line in sorted(resolved_info):
            # print section name
            if prev_section != section_name:
                gef_print(titlify(section_name))
            prev_section = section_name
            # if we have a filter let's skip the entries that are not requested
            if self.filter:
                if not any([pattern in line for pattern in self.filter]):
                    continue
            gef_print(line)
        return

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        # setup readelf/objdump
        try:
            self.readelf = which("readelf")
            self.objdump = which("objdump")
        except FileNotFoundError as e:
            err("{}".format(e))
            return

        local_filepath = None
        vmmap_filepath = None
        remote_filepath = None
        tmp_filepath = None

        if args.remote:
            if not is_remote_debug():
                err("-r option is allowed only remote debug.")
                return

            if args.file:
                remote_filepath = args.file # if specified, assume it is remote
                vmmap_filepath = args.file
            elif gdb.current_progspace().filename:
                f = gdb.current_progspace().filename
                if f.startswith("target:"): # gdbserver
                    f = f[7:]
                remote_filepath = f
                vmmap_filepath = f
            elif get_pid(remote=True):
                remote_filepath = "/proc/{:d}/exe".format(get_pid(remote=True))
            else:
                err("File name could not be determined.")
                return

            data = read_remote_file(remote_filepath, as_byte=True) # qemu-user is failed here, it is ok
            if not data:
                err("Failed to read remote filepath")
                return
            tmp_fd, tmp_filepath = tempfile.mkstemp(dir=GEF_TEMP_DIR, suffix=".elf", prefix="got-")
            os.write(tmp_fd, data)
            os.close(tmp_fd)
            local_filepath = tmp_filepath
            del data

        elif args.file:
            local_filepath = args.file

        elif args.file is None:
            local_filepath = get_filepath() # /proc/<PID>/root/path/to/binary if another mnt namespace
            vmmap_filepath = get_filepath(append_proc_root_prefix=False)

        if local_filepath is None:
            err("File name could not be determined.")
            return

        if not os.path.exists(local_filepath):
            err("{:s} does not exist".format(local_filepath))
            return

        if remote_filepath:
            print_filename = "{:s} (remote: {:s})".format(local_filepath, remote_filepath)
        else:
            print_filename = local_filepath
        gef_print(titlify("PLT / GOT - {:s}".format(print_filename)))

        # get base address
        if args.elf_address:
            base_address = args.elf_address
        else:
            vmmap = get_process_maps()
            target_filepath = vmmap_filepath or local_filepath
            try:
                base_address = min([x.page_start for x in vmmap if x.path == target_filepath])
            except Exception:
                err("Not found {:s} in memory".format(target_filepath))
                return

        # get the filtering parameter
        self.filter = args.filter or []
        self.filename = local_filepath
        self.base_address = base_address
        self.verbose = args.verbose

        # doit
        self.print_plt_got()

        if tmp_filepath and os.path.exists(tmp_filepath):
            os.unlink(tmp_filepath)
        return


@register_command
class FormatStringSearchCommand(GenericCommand):
    """The helper to search exploitable format-string."""
    _cmdline_ = "format-string-helper"
    _category_ = "01-g. Debugging Support - Other"
    _aliases_ = ["fmtstr-helper"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()

        dangerous_functions = {
            "printf": 0,                # int printf(const char *fmt, ...);
            "fprintf": 1,               # int fprintf(FILE *stream, const char *fmt, ...);
            "dprintf": 1,               # int dprintf(int fd, const char *fmt, ...);
            "sprintf": 1,               # int sprintf(char *str, const char *fmt, ...);
            "asprintf": 1,              # int asprintf(char **strp, const char *fmt, ...);
            "snprintf": 2,              # int snprintf(char *str, size_t size, const char *fmt, ...);
            "wprintf": 0,               # int wprintf(const wchar_t *fmt, ...);
            "fwprintf": 1,              # int fwprintf(FILE *stream, const wchar_t *fmt, ...);
            "swprintf": 2,              # int swprintf(wchar_t *str, size_t n, const wchar_t *fmt, ...);
            "obstack_printf": 1,        # int obstack_printf(struct obstack *obstack, const char *fmt, ...);
            "__printf_chk": 1,          # int __printf_chk(int flag, const char *fmt);
            "__fprintf_chk": 2,         # int __fprintf_chk(FILE *stream, int flag, const char *fmt, ...);
            "__dprintf_chk": 2,         # int __dprintf_chk(int d, int flags, const char *fmt, ...)
            "__sprintf_chk": 3,         # int __sprintf_chk(char *str, int flag, size_t strlen, const char *fmt, ...);
            "__asprintf_chk": 2,        # int __asprintf_chk(char **strp, int flag, const char *fmt, ...)
            "__snprintf_chk": 4,        # int __snprintf_chk(char *str, size_t maxlen, int flag, size_t strlen, const char *fmt, ...);
            "__wprintf_chk": 1,         # int __wprintf_chk(int flag, const wchar_t *format, ...);
            "__fwprintf_chk": 2,        # int __fwprintf_chk(FILE *stream, int flag, const wchar_t *format, ...);
            "__swprintf_chk": 4,        # int __swprintf_chk(wchar_t *str, size_t maxlen, int flag, size_t slen, const wchar_t *fmt, ...);
            "__obstack_printf_chk": 2,  # int __obstack_printf_chk(struct obstack *obstack, int flag, const char *fmt, ...);

            "vprintf": 0,               # int vprintf(const char *fmt, va_list ap);
            "vfprintf": 1,              # int vfprintf(FILE *stream, const char *fmt, va_list ap);
            "vdprintf": 1,              # int vdprintf(int fd, const char *fmt, va_list ap);
            "vsprintf": 1,              # int vsprintf(char *str, const char *fmt, va_list ap);
            "vasprintf": 1,             # int vasprintf(char **strp, const char *fmt, va_list ap);
            "vsnprintf": 2,             # int vsnprintf(char *str, size_t size, const char *fmt, va_list ap);
            "vwprintf": 0,              # int vwprintf(const wchar_t *fmt, va_list ap);
            "vfwprintf": 1,             # int vfwprintf(FILE *stream, const wchar_t *fmt, va_list ap);
            "vswprintf": 2,             # int vswprintf(wchar_t *str, size_t maxlen, const wchar_t *fmt, va_list ap);
            "obstack_vprintf": 1,       # int obstack_vprintf(struct obstack *obstack, const char *fmt, va_list ap);
            "__vprintf_chk": 1,         # int __vprintf_chk(int flag, const char *fmt, va_list ap);
            "__vfprintf_chk": 2,        # int __vfprintf_chk(FILE *stream, int flag, const char *fmt, va_list ap);
            "__vdprintf_chk": 2,        # int __vdprintf_chk(int d, int flag, const char *fmt, va_list ap);
            "__vsprintf_chk": 3,        # int __vsprintf_chk(char *str, int flag, size_t slen, const char *fmt, va_list ap);
            "__vasprintf_chk": 2,       # int __vasprintf_chk(char **strp, int flag, const char *fmt, va_list ap);
            "__vsnprintf_chk": 4,       # int __vsnprintf_chk(char *str, size_t maxlen, int flag, size_t slen, const char *fmt, va_list ap);
            "__vwprintf_chk": 1,        # int __vwprintf_chk(int flag, const wchar_t *fmt, va_list ap);
            "__vfwprintf_chk": 2,       # int __vfwprintf_chk(FILE *stream, int flag, const wchar_t *fmt, va_list ap);
            "__vswprintf_chk": 4,       # int __vswprintf_chk(wchar_t *str, size_t maxlen, int flag, size_t slen, const wchar_t *fmt, va_list ap);
            "__obstack_vprintf_chk": 2, # int __obstack_vprintf_chk(struct obstack *obstack, int flag, const char *fmt, va_list ap);

            "syslog": 1,                # void syslog(int priority, const char *fmt, ...);
            "vsyslog": 1,               # void vsyslog(int priority, const char *fmt, va_list ap);
            "__syslog_chk": 2,          # void __syslog_chk(int priority, int flag, const char *fmt, ...);
            "__vsyslog_chk": 2,         # void __vsyslog_chk(int priority, int flag, const char *fmt, va_list ap);

            "scanf": 0,                 # int scanf(const char *fmt, ...);
            "fscanf": 1,                # int fscanf(FILE *stream, const char *fmt, ...);
            "sscanf": 1,                # int sscanf(const char *str, const char *fmt, ...);
            "wscanf": 0,                # int wscanf(const wchar_t *fmt, ...);
            "fwscanf": 1,               # int fwscanf(FILE *stream, const wchar_t *fmt, ...);
            "swscanf": 1,               # int swscanf(const wchar_t *ws, const wchar_t *fmt, ...);

            "vscanf": 0,                # int vscanf(const char *fmt, va_list ap);
            "vfscanf": 1,               # int vfscanf(FILE *stream, const char *fmt, va_list ap);
            "vsscanf": 1,               # int vsscanf(const char *str, const char *fmt, va_list ap);
            "vwscanf": 0,               # int vwscanf(const wchar_t *fmt, va_list ap);
            "vfwscanf": 1,              # int vfwscanf(FILE *stream, const wchar_t *fmt, va_list ap);
            "vswscanf": 1,              # int vswscanf(const wchar_t *s, const wchar_t *fmt, va_list ap);

            "warn": 0,                  # void warn(const char *fmt, ...);
            "warnx": 0,                 # void warnx(const char *fmt, ...);
            "err": 1,                   # void err(int status, const char *fmt, ...);
            "errx": 1,                  # void errx(int status, const char *fmt, ...);

            "vwarn": 0,                 # void vwarn(const char *fmt, va_list ap);
            "vwarnx": 0,                # void vwarnx(const char *fmt, va_list ap);
            "verr": 1,                  # void verr(int status, const char *fmt, va_list ap);
            "verrx": 1,                 # void verrx(int status, const char *fmt, va_list ap);

            "error": 2,                 # void error(int status, int errnum, const char *fmt, ...);
            "error_at_line": 4,         # void error_at_line(int status, int errnum, const char *filename, uint linenum, const char *fmt, ...);

            "argp_error": 1,            # void argp_error(const struct argp_state *state, const char *fmt, ...);
            "argp_failure": 3,          # void argp_failure(const struct argp_state *state, int status, int errnum, const char *fmt, ...);

            "xasprintf": 0,             # char* xasprintf(const char *fmt, ...);
            "xvasprintf": 0,            # char* xvasprintf(const char *fmt, va_list ap);
        }

        bp_count = 0
        for func_name, num_arg in dangerous_functions.items():
            if safe_parse_and_eval(func_name) is None:
                continue
            gef_print(func_name + ": ", end="")
            FormatStringBreakpoint(func_name, num_arg)
            bp_count += 1

        ok("Enabled {:d}/{:d} FormatStringBreakpoint".format(bp_count, len(dangerous_functions)))
        return


@register_command
class HeapAnalysisCommand(GenericCommand):
    """Trace malloc/free to check heap integrity for NULL free, Use-after-Free, Double Free, Heap overlap."""
    _cmdline_ = "heap-analysis-helper"
    _category_ = "06-a. Heap - Glibc"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument("--show", action='store_true', help='show the tracked allocations.')
    parser.add_argument("--config", action='store_true', help='show the config for settings.')
    _syntax_ = parser.format_help()

    def __init__(self, *args, **kwargs):
        super().__init__()
        self.add_setting("check_free_null", False, "Break execution when a free(NULL) is encountered")
        self.add_setting("check_double_free", True, "Break execution when a double free is encountered")
        self.add_setting("check_weird_free", True, "Break execution when free() is called against a non-tracked pointer")
        self.add_setting("check_uaf", True, "Break execution when a possible Use-after-Free condition is found")
        self.add_setting("check_heap_overlap", True, "Break execution when a possible overlap in allocation is found")
        self.bp_malloc = None
        self.bp_calloc = None
        self.bp_free = None
        self.bp_realloc = None
        return

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    @experimental_feature
    def do_invoke(self, args):
        self.dont_repeat()

        if args.show:
            self.dump_tracked_allocations()
            return

        if args.config:
            gdb.execute("gef config heap-analysis-helper.check_free_null")
            gdb.execute("gef config heap-analysis-helper.check_double_free")
            gdb.execute("gef config heap-analysis-helper.check_weird_free")
            gdb.execute("gef config heap-analysis-helper.check_uaf")
            gdb.execute("gef config heap-analysis-helper.check_heap_overlap")
            return

        self.setup()
        return

    def setup(self):
        ok("Tracking malloc() & calloc()")
        self.bp_malloc = TraceMallocBreakpoint("__libc_malloc")
        self.bp_calloc = TraceMallocBreakpoint("__libc_calloc")
        ok("Tracking free()")
        self.bp_free = TraceFreeBreakpoint()
        ok("Tracking realloc()")
        self.bp_realloc = TraceReallocBreakpoint()

        ok("Disabling hardware watchpoints (this may increase the latency)")
        gdb.execute("set can-use-hw-watchpoints 0")

        info("Dynamic breakpoints correctly setup, GEF will break execution if a possible vulnerabity is found.")
        msg = "{}: The heap analysis slows down the execution noticeably."
        warn(msg.format(Color.colorify("Note", "bold underline yellow")))

        # when inferior quits, we need to clean everything for a next execution
        gef_on_exit_hook(self.clean)
        return

    def dump_tracked_allocations(self):
        global __heap_allocated_list__, __heap_freed_list__, __heap_uaf_watchpoints__

        if __heap_allocated_list__:
            ok("Tracked as in-use chunks:")
            for addr, sz in __heap_allocated_list__:
                gef_print("{:#x} = malloc({:d})".format(addr, sz))
        else:
            ok("No malloc() chunk tracked")

        if __heap_freed_list__:
            ok("Tracked as free-ed chunks:")
            for addr, sz in __heap_freed_list__:
                gef_print("free({:#x})".format(addr))
        else:
            ok("No free() chunk tracked")
        return

    def clean(self, event):
        global __heap_allocated_list__, __heap_freed_list__, __heap_uaf_watchpoints__

        ok("{} - Cleaning up".format(Color.colorify("Heap-Analysis", "bold yellow")))
        for bp in [self.bp_malloc, self.bp_calloc, self.bp_free, self.bp_realloc]:
            if hasattr(bp, "retbp") and bp.retbp:
                try:
                    bp.retbp.delete()
                except RuntimeError:
                    # in some cases, gdb was found failing to correctly remove the retbp
                    # but they can be safely ignored since the debugging session is over
                    pass

            bp.delete()

        for wp in __heap_uaf_watchpoints__:
            wp.delete()

        __heap_allocated_list__ = []
        __heap_freed_list__ = []
        __heap_uaf_watchpoints__ = []

        ok("{} - Re-enabling hardware watchpoints".format(Color.colorify("Heap-Analysis", "bold yellow")))
        gdb.execute("set can-use-hw-watchpoints 1")

        gef_on_exit_unhook(self.clean)
        return


@register_command
class SyscallSearchCommand(GenericCommand):
    """Search the syscall number for specified architecture."""
    _cmdline_ = "syscall-search"
    _category_ = "05-b. Syscall - Search"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-a', dest='arch', help='specify the architecture. (default: current_arch.arch)')
    parser.add_argument('-m', dest='mode', help='specify the mode. (default: current_arch.mode)')
    parser.add_argument('-v', dest='verbose', action='store_true', help='display prototype of syscall.')
    parser.add_argument('search_pattern', metavar='SYSCALL_NAME|SYSCALL_NUM',
                        help='syscall name or number you want to search. Regex is available.')
    _syntax_ = parser.format_help()

    _example_ = '{:s} -a X86 -m 64                 "^writev?" # amd64\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m 32                 "^writev?" # i386 on amd64\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m N32                "^writev?" # i386 native\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM64 -m ARM              "^writev?" # arm64\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m 32                 "^writev?" # arm32 on arm64\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m N32                "^writev?" # arm32 native\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS32            "^writev?" # mips32\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS64            "^writev?" # mips64\n'.format(_cmdline_)
    _example_ += '{:s} -a PPC -m PPC32              "^writev?" # ppc32\n'.format(_cmdline_)
    _example_ += '{:s} -a PPC -m PPC64              "^writev?" # ppc64\n'.format(_cmdline_)
    _example_ += '{:s} -a SPARC -m SPARC32          "^writev?" # sparc32\n'.format(_cmdline_)
    _example_ += '{:s} -a SPARC -m SPARC64          "^writev?" # sparc64\n'.format(_cmdline_)
    _example_ += '{:s} -a RISCV -m RISCV32          "^writev?" # riscv32\n'.format(_cmdline_)
    _example_ += '{:s} -a RISCV -m RISCV64          "^writev?" # riscv64\n'.format(_cmdline_)
    _example_ += '{:s} -a S390X -m S390X            "^writev?" # s390x\n'.format(_cmdline_)
    _example_ += '{:s} -a SH4 -m SH4                "^writev?" # sh4\n'.format(_cmdline_)
    _example_ += '{:s} -a M68K -m M68K              "^writev?" # m68k\n'.format(_cmdline_)
    _example_ += '{:s} -a ALPHA -m ALPHA            "^writev?" # alpha\n'.format(_cmdline_)
    _example_ += '{:s} -a HPPA -m HPPA32            "^writev?" # hppa32\n'.format(_cmdline_)
    _example_ += '{:s} -a HPPA -m HPPA64            "^writev?" # hppa64\n'.format(_cmdline_)
    _example_ += '{:s} -a OR1K -m OR1K              "^writev?" # or1k\n'.format(_cmdline_)
    _example_ += '{:s} -a NIOS2 -m NIOS2            "^writev?" # nios2\n'.format(_cmdline_)
    _example_ += '{:s} -a MICROBLAZE -m MICROBLAZE  "^writev?" # microblaze\n'.format(_cmdline_)
    _example_ += '{:s} -a XTENSA -m XTENSA          "^writev?" # xtensa\n'.format(_cmdline_)
    _example_ += '{:s} -a CRIS -m CRIS              "^writev?" # cris'.format(_cmdline_)

    def print_legend(self):
        if self.verbose:
            headers = ["NR", "Name", "Parameter"]
            gef_print(Color.colorify("{:<25} {:<25} {}".format(*headers), get_gef_setting("theme.table_heading")))
        else:
            headers = ["NR", "Name"]
            gef_print(Color.colorify("{:<25} {:<25}".format(*headers), get_gef_setting("theme.table_heading")))
        return

    def print_syscall(self, syscall_table, syscall_num, syscall_name_pattern):
        gef_print(titlify("arch={:s}, mode={:s}".format(syscall_table.arch, syscall_table.mode)))
        gef_print(Color.colorify("{:<17}{:s}".format("Syscall-num", "Syscall-name"), get_gef_setting("theme.table_heading")))
        for key, entry in syscall_table.table.items():
            nr = key
            if not re.search(syscall_name_pattern, entry.name):
                continue
            if syscall_num is not None and nr != syscall_num:
                continue
            params = ""
            if self.verbose:
                params = "(" + ', '.join([param.param for param in entry.params]) + ");"
            gef_print("NR={:<#14x}{:s}{:s}".format(nr, Color.boldify(entry.name), params))
        return

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()

        self.verbose = args.verbose

        syscall_num = None
        syscall_name_pattern = ".*"

        try:
            syscall_num = int(args.search_pattern, 0)
        except ValueError:
            syscall_name_pattern = args.search_pattern

        try:
            syscall_table = get_syscall_table(args.arch, args.mode)
        except Exception:
            self.usage()
            return

        self.print_syscall(syscall_table, syscall_num, syscall_name_pattern)
        return


# System call table (linux-6.0.10)

# [How to make]
# clang-format-14 --style='{BasedOnStyle: Google, ColumnLimit: 1000}' FILENAME | grep ^asmlinkage
#   `!` at the beginning of the line: manually fixed the argument information
#   `#` at the beginning of the line: excluded for reasons such as duplication

# include/linux/syscalls.h
syscall_defs = """
asmlinkage long sys_io_setup(unsigned nr_reqs, aio_context_t __user *ctx);
asmlinkage long sys_io_destroy(aio_context_t ctx);
!asmlinkage long sys_io_submit(aio_context_t ctx_id, long nr, struct iocb __user * __user *iocbpp);
asmlinkage long sys_io_cancel(aio_context_t ctx_id, struct iocb __user *iocb, struct io_event __user *result);
asmlinkage long sys_io_getevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events, struct __kernel_timespec __user *timeout);
asmlinkage long sys_io_getevents_time32(__u32 ctx_id, __s32 min_nr, __s32 nr, struct io_event __user *events, struct old_timespec32 __user *timeout);
asmlinkage long sys_io_pgetevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events, struct __kernel_timespec __user *timeout, const struct __aio_sigset *sig);
asmlinkage long sys_io_pgetevents_time32(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events, struct old_timespec32 __user *timeout, const struct __aio_sigset *sig);
asmlinkage long sys_io_uring_setup(u32 entries, struct io_uring_params __user *p);
asmlinkage long sys_io_uring_enter(unsigned int fd, u32 to_submit, u32 min_complete, u32 flags, const void __user *argp, size_t argsz);
asmlinkage long sys_io_uring_register(unsigned int fd, unsigned int op, void __user *arg, unsigned int nr_args);
asmlinkage long sys_setxattr(const char __user *path, const char __user *name, const void __user *value, size_t size, int flags);
asmlinkage long sys_lsetxattr(const char __user *path, const char __user *name, const void __user *value, size_t size, int flags);
asmlinkage long sys_fsetxattr(int fd, const char __user *name, const void __user *value, size_t size, int flags);
asmlinkage long sys_getxattr(const char __user *path, const char __user *name, void __user *value, size_t size);
asmlinkage long sys_lgetxattr(const char __user *path, const char __user *name, void __user *value, size_t size);
asmlinkage long sys_fgetxattr(int fd, const char __user *name, void __user *value, size_t size);
asmlinkage long sys_listxattr(const char __user *path, char __user *list, size_t size);
asmlinkage long sys_llistxattr(const char __user *path, char __user *list, size_t size);
asmlinkage long sys_flistxattr(int fd, char __user *list, size_t size);
asmlinkage long sys_removexattr(const char __user *path, const char __user *name);
asmlinkage long sys_lremovexattr(const char __user *path, const char __user *name);
asmlinkage long sys_fremovexattr(int fd, const char __user *name);
asmlinkage long sys_getcwd(char __user *buf, unsigned long size);
asmlinkage long sys_lookup_dcookie(u64 cookie64, char __user *buf, size_t len);
asmlinkage long sys_eventfd2(unsigned int count, int flags);
asmlinkage long sys_epoll_create1(int flags);
asmlinkage long sys_epoll_ctl(int epfd, int op, int fd, struct epoll_event __user *event);
asmlinkage long sys_epoll_pwait(int epfd, struct epoll_event __user *events, int maxevents, int timeout, const sigset_t __user *sigmask, size_t sigsetsize);
asmlinkage long sys_epoll_pwait2(int epfd, struct epoll_event __user *events, int maxevents, const struct __kernel_timespec __user *timeout, const sigset_t __user *sigmask, size_t sigsetsize);
asmlinkage long sys_dup(unsigned int fildes);
asmlinkage long sys_dup3(unsigned int oldfd, unsigned int newfd, int flags);
asmlinkage long sys_fcntl(unsigned int fd, unsigned int cmd, unsigned long arg);
asmlinkage long sys_fcntl64(unsigned int fd, unsigned int cmd, unsigned long arg);
asmlinkage long sys_inotify_init1(int flags);
asmlinkage long sys_inotify_add_watch(int fd, const char __user *path, u32 mask);
asmlinkage long sys_inotify_rm_watch(int fd, __s32 wd);
asmlinkage long sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg);
asmlinkage long sys_ioprio_set(int which, int who, int ioprio);
asmlinkage long sys_ioprio_get(int which, int who);
asmlinkage long sys_flock(unsigned int fd, unsigned int cmd);
asmlinkage long sys_mknodat(int dfd, const char __user *filename, umode_t mode, unsigned dev);
asmlinkage long sys_mkdirat(int dfd, const char __user *pathname, umode_t mode);
asmlinkage long sys_unlinkat(int dfd, const char __user *pathname, int flag);
asmlinkage long sys_symlinkat(const char __user *oldname, int newdfd, const char __user *newname);
asmlinkage long sys_linkat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname, int flags);
asmlinkage long sys_renameat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname);
asmlinkage long sys_umount(char __user *name, int flags);
asmlinkage long sys_mount(char __user *dev_name, char __user *dir_name, char __user *type, unsigned long flags, void __user *data);
asmlinkage long sys_pivot_root(const char __user *new_root, const char __user *put_old);
asmlinkage long sys_statfs(const char __user *path, struct statfs __user *buf);
asmlinkage long sys_statfs64(const char __user *path, size_t sz, struct statfs64 __user *buf);
asmlinkage long sys_fstatfs(unsigned int fd, struct statfs __user *buf);
asmlinkage long sys_fstatfs64(unsigned int fd, size_t sz, struct statfs64 __user *buf);
asmlinkage long sys_truncate(const char __user *path, long length);
asmlinkage long sys_ftruncate(unsigned int fd, unsigned long length);
asmlinkage long sys_truncate64(const char __user *path, loff_t length);
asmlinkage long sys_ftruncate64(unsigned int fd, loff_t length);
asmlinkage long sys_fallocate(int fd, int mode, loff_t offset, loff_t len);
asmlinkage long sys_faccessat(int dfd, const char __user *filename, int mode);
asmlinkage long sys_faccessat2(int dfd, const char __user *filename, int mode, int flags);
asmlinkage long sys_chdir(const char __user *filename);
asmlinkage long sys_fchdir(unsigned int fd);
asmlinkage long sys_chroot(const char __user *filename);
asmlinkage long sys_fchmod(unsigned int fd, umode_t mode);
asmlinkage long sys_fchmodat(int dfd, const char __user *filename, umode_t mode);
asmlinkage long sys_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group, int flag);
asmlinkage long sys_fchown(unsigned int fd, uid_t user, gid_t group);
asmlinkage long sys_openat(int dfd, const char __user *filename, int flags, umode_t mode);
asmlinkage long sys_openat2(int dfd, const char __user *filename, struct open_how *how, size_t size);
asmlinkage long sys_close(unsigned int fd);
asmlinkage long sys_close_range(unsigned int fd, unsigned int max_fd, unsigned int flags);
asmlinkage long sys_vhangup(void);
asmlinkage long sys_pipe2(int __user *fildes, int flags);
asmlinkage long sys_quotactl(unsigned int cmd, const char __user *special, qid_t id, void __user *addr);
asmlinkage long sys_quotactl_fd(unsigned int fd, unsigned int cmd, qid_t id, void __user *addr);
asmlinkage long sys_getdents64(unsigned int fd, struct linux_dirent64 __user *dirent, unsigned int count);
asmlinkage long sys_llseek(unsigned int fd, unsigned long offset_high, unsigned long offset_low, loff_t __user *result, unsigned int whence);
asmlinkage long sys_lseek(unsigned int fd, off_t offset, unsigned int whence);
asmlinkage long sys_read(unsigned int fd, char __user *buf, size_t count);
asmlinkage long sys_write(unsigned int fd, const char __user *buf, size_t count);
asmlinkage long sys_readv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);
asmlinkage long sys_writev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);
asmlinkage long sys_pread64(unsigned int fd, char __user *buf, size_t count, loff_t pos);
asmlinkage long sys_pwrite64(unsigned int fd, const char __user *buf, size_t count, loff_t pos);
asmlinkage long sys_preadv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h);
asmlinkage long sys_pwritev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h);
asmlinkage long sys_sendfile64(int out_fd, int in_fd, loff_t __user *offset, size_t count);
!asmlinkage long sys_pselect6(int n, fd_set __user *inp, fd_set __user *outp, fd_set __user *exp, struct __kernel_timespec __user *tsp, void __user *sig);
!asmlinkage long sys_pselect6_time32(int n, fd_set __user *inp, fd_set __user *outp, fd_set __user *exp, struct old_timespec32 __user *tsp, void __user *sig);
!asmlinkage long sys_ppoll(struct pollfd __user *ufds, unsigned int nfds, struct __kernel_timespec __user *tsp, const sigset_t __user *sigmask, size_t sigsetsize);
!asmlinkage long sys_ppoll_time32(struct pollfd __user *ufds, unsigned int nfds, struct old_timespec32 __user *tsp, const sigset_t __user *sigmask, size_t sigsetsize);
asmlinkage long sys_signalfd4(int ufd, sigset_t __user *user_mask, size_t sizemask, int flags);
asmlinkage long sys_vmsplice(int fd, const struct iovec __user *iov, unsigned long nr_segs, unsigned int flags);
asmlinkage long sys_splice(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len, unsigned int flags);
asmlinkage long sys_tee(int fdin, int fdout, size_t len, unsigned int flags);
asmlinkage long sys_readlinkat(int dfd, const char __user *path, char __user *buf, int bufsiz);
asmlinkage long sys_newfstatat(int dfd, const char __user *filename, struct stat __user *statbuf, int flag);
asmlinkage long sys_newfstat(unsigned int fd, struct stat __user *statbuf);
asmlinkage long sys_fstat64(unsigned long fd, struct stat64 __user *statbuf);
asmlinkage long sys_fstatat64(int dfd, const char __user *filename, struct stat64 __user *statbuf, int flag);
asmlinkage long sys_sync(void);
asmlinkage long sys_fsync(unsigned int fd);
asmlinkage long sys_fdatasync(unsigned int fd);
asmlinkage long sys_sync_file_range2(int fd, unsigned int flags, loff_t offset, loff_t nbytes);
asmlinkage long sys_sync_file_range(int fd, loff_t offset, loff_t nbytes, unsigned int flags);
asmlinkage long sys_timerfd_create(int clockid, int flags);
asmlinkage long sys_timerfd_settime(int ufd, int flags, const struct __kernel_itimerspec __user *utmr, struct __kernel_itimerspec __user *otmr);
asmlinkage long sys_timerfd_gettime(int ufd, struct __kernel_itimerspec __user *otmr);
asmlinkage long sys_timerfd_gettime32(int ufd, struct old_itimerspec32 __user *otmr);
asmlinkage long sys_timerfd_settime32(int ufd, int flags, const struct old_itimerspec32 __user *utmr, struct old_itimerspec32 __user *otmr);
asmlinkage long sys_utimensat(int dfd, const char __user *filename, struct __kernel_timespec __user *utimes, int flags);
asmlinkage long sys_utimensat_time32(unsigned int dfd, const char __user *filename, struct old_timespec32 __user *t, int flags);
asmlinkage long sys_acct(const char __user *name);
asmlinkage long sys_capget(cap_user_header_t header, cap_user_data_t dataptr);
asmlinkage long sys_capset(cap_user_header_t header, const cap_user_data_t data);
asmlinkage long sys_personality(unsigned int personality);
asmlinkage long sys_exit(int error_code);
asmlinkage long sys_exit_group(int error_code);
asmlinkage long sys_waitid(int which, pid_t pid, struct siginfo __user *infop, int options, struct rusage __user *ru);
asmlinkage long sys_set_tid_address(int __user *tidptr);
asmlinkage long sys_unshare(unsigned long unshare_flags);
asmlinkage long sys_futex(u32 __user *uaddr, int op, u32 val, const struct __kernel_timespec __user *utime, u32 __user *uaddr2, u32 val3);
asmlinkage long sys_futex_time32(u32 __user *uaddr, int op, u32 val, const struct old_timespec32 __user *utime, u32 __user *uaddr2, u32 val3);
asmlinkage long sys_get_robust_list(int pid, struct robust_list_head __user *__user *head_ptr, size_t __user *len_ptr);
asmlinkage long sys_set_robust_list(struct robust_list_head __user *head, size_t len);
asmlinkage long sys_futex_waitv(struct futex_waitv *waiters, unsigned int nr_futexes, unsigned int flags, struct __kernel_timespec __user *timeout, clockid_t clockid);
asmlinkage long sys_nanosleep(struct __kernel_timespec __user *rqtp, struct __kernel_timespec __user *rmtp);
asmlinkage long sys_nanosleep_time32(struct old_timespec32 __user *rqtp, struct old_timespec32 __user *rmtp);
asmlinkage long sys_getitimer(int which, struct __kernel_old_itimerval __user *value);
asmlinkage long sys_setitimer(int which, struct __kernel_old_itimerval __user *value, struct __kernel_old_itimerval __user *ovalue);
asmlinkage long sys_kexec_load(unsigned long entry, unsigned long nr_segments, struct kexec_segment __user *segments, unsigned long flags);
asmlinkage long sys_init_module(void __user *umod, unsigned long len, const char __user *uargs);
asmlinkage long sys_delete_module(const char __user *name_user, unsigned int flags);
asmlinkage long sys_timer_create(clockid_t which_clock, struct sigevent __user *timer_event_spec, timer_t __user *created_timer_id);
asmlinkage long sys_timer_gettime(timer_t timer_id, struct __kernel_itimerspec __user *setting);
asmlinkage long sys_timer_getoverrun(timer_t timer_id);
asmlinkage long sys_timer_settime(timer_t timer_id, int flags, const struct __kernel_itimerspec __user *new_setting, struct __kernel_itimerspec __user *old_setting);
asmlinkage long sys_timer_delete(timer_t timer_id);
asmlinkage long sys_clock_settime(clockid_t which_clock, const struct __kernel_timespec __user *tp);
asmlinkage long sys_clock_gettime(clockid_t which_clock, struct __kernel_timespec __user *tp);
asmlinkage long sys_clock_getres(clockid_t which_clock, struct __kernel_timespec __user *tp);
asmlinkage long sys_clock_nanosleep(clockid_t which_clock, int flags, const struct __kernel_timespec __user *rqtp, struct __kernel_timespec __user *rmtp);
asmlinkage long sys_timer_gettime32(timer_t timer_id, struct old_itimerspec32 __user *setting);
asmlinkage long sys_timer_settime32(timer_t timer_id, int flags, struct old_itimerspec32 __user *new, struct old_itimerspec32 __user *old);
asmlinkage long sys_clock_settime32(clockid_t which_clock, struct old_timespec32 __user *tp);
asmlinkage long sys_clock_gettime32(clockid_t which_clock, struct old_timespec32 __user *tp);
asmlinkage long sys_clock_getres_time32(clockid_t which_clock, struct old_timespec32 __user *tp);
asmlinkage long sys_clock_nanosleep_time32(clockid_t which_clock, int flags, struct old_timespec32 __user *rqtp, struct old_timespec32 __user *rmtp);
asmlinkage long sys_syslog(int type, char __user *buf, int len);
asmlinkage long sys_ptrace(long request, long pid, unsigned long addr, unsigned long data);
asmlinkage long sys_sched_setparam(pid_t pid, struct sched_param __user *param);
asmlinkage long sys_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param);
asmlinkage long sys_sched_getscheduler(pid_t pid);
asmlinkage long sys_sched_getparam(pid_t pid, struct sched_param __user *param);
asmlinkage long sys_sched_setaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);
asmlinkage long sys_sched_getaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);
asmlinkage long sys_sched_yield(void);
asmlinkage long sys_sched_get_priority_max(int policy);
asmlinkage long sys_sched_get_priority_min(int policy);
asmlinkage long sys_sched_rr_get_interval(pid_t pid, struct __kernel_timespec __user *interval);
asmlinkage long sys_sched_rr_get_interval_time32(pid_t pid, struct old_timespec32 __user *interval);
asmlinkage long sys_restart_syscall(void);
asmlinkage long sys_kill(pid_t pid, int sig);
asmlinkage long sys_tkill(pid_t pid, int sig);
asmlinkage long sys_tgkill(pid_t tgid, pid_t pid, int sig);
asmlinkage long sys_sigaltstack(const struct sigaltstack __user *uss, struct sigaltstack __user *uoss);
asmlinkage long sys_rt_sigsuspend(sigset_t __user *unewset, size_t sigsetsize);
!asmlinkage long sys_rt_sigaction(int sig, const struct sigaction __user *act, struct sigaction __user *oact, size_t sigsetsize);
asmlinkage long sys_rt_sigprocmask(int how, sigset_t __user *set, sigset_t __user *oset, size_t sigsetsize);
asmlinkage long sys_rt_sigpending(sigset_t __user *set, size_t sigsetsize);
asmlinkage long sys_rt_sigtimedwait(const sigset_t __user *uthese, siginfo_t __user *uinfo, const struct __kernel_timespec __user *uts, size_t sigsetsize);
asmlinkage long sys_rt_sigtimedwait_time32(const sigset_t __user *uthese, siginfo_t __user *uinfo, const struct old_timespec32 __user *uts, size_t sigsetsize);
asmlinkage long sys_rt_sigqueueinfo(pid_t pid, int sig, siginfo_t __user *uinfo);
asmlinkage long sys_setpriority(int which, int who, int niceval);
asmlinkage long sys_getpriority(int which, int who);
asmlinkage long sys_reboot(int magic1, int magic2, unsigned int cmd, void __user *arg);
asmlinkage long sys_setregid(gid_t rgid, gid_t egid);
asmlinkage long sys_setgid(gid_t gid);
asmlinkage long sys_setreuid(uid_t ruid, uid_t euid);
asmlinkage long sys_setuid(uid_t uid);
asmlinkage long sys_setresuid(uid_t ruid, uid_t euid, uid_t suid);
asmlinkage long sys_getresuid(uid_t __user *ruid, uid_t __user *euid, uid_t __user *suid);
asmlinkage long sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid);
asmlinkage long sys_getresgid(gid_t __user *rgid, gid_t __user *egid, gid_t __user *sgid);
asmlinkage long sys_setfsuid(uid_t uid);
asmlinkage long sys_setfsgid(gid_t gid);
asmlinkage long sys_times(struct tms __user *tbuf);
asmlinkage long sys_setpgid(pid_t pid, pid_t pgid);
asmlinkage long sys_getpgid(pid_t pid);
asmlinkage long sys_getsid(pid_t pid);
asmlinkage long sys_setsid(void);
asmlinkage long sys_getgroups(int gidsetsize, gid_t __user *grouplist);
asmlinkage long sys_setgroups(int gidsetsize, gid_t __user *grouplist);
asmlinkage long sys_newuname(struct new_utsname __user *name);
asmlinkage long sys_sethostname(char __user *name, int len);
asmlinkage long sys_setdomainname(char __user *name, int len);
asmlinkage long sys_getrlimit(unsigned int resource, struct rlimit __user *rlim);
asmlinkage long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim);
asmlinkage long sys_getrusage(int who, struct rusage __user *ru);
asmlinkage long sys_umask(int mask);
asmlinkage long sys_prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);
asmlinkage long sys_getcpu(unsigned __user *cpu, unsigned __user *node, struct getcpu_cache __user *cache);
asmlinkage long sys_gettimeofday(struct __kernel_old_timeval __user *tv, struct timezone __user *tz);
asmlinkage long sys_settimeofday(struct __kernel_old_timeval __user *tv, struct timezone __user *tz);
asmlinkage long sys_adjtimex(struct __kernel_timex __user *txc_p);
asmlinkage long sys_adjtimex_time32(struct old_timex32 __user *txc_p);
asmlinkage long sys_getpid(void);
asmlinkage long sys_getppid(void);
asmlinkage long sys_getuid(void);
asmlinkage long sys_geteuid(void);
asmlinkage long sys_getgid(void);
asmlinkage long sys_getegid(void);
asmlinkage long sys_gettid(void);
asmlinkage long sys_sysinfo(struct sysinfo __user *info);
asmlinkage long sys_mq_open(const char __user *name, int oflag, umode_t mode, struct mq_attr __user *attr);
asmlinkage long sys_mq_unlink(const char __user *name);
asmlinkage long sys_mq_timedsend(mqd_t mqdes, const char __user *msg_ptr, size_t msg_len, unsigned int msg_prio, const struct __kernel_timespec __user *abs_timeout);
asmlinkage long sys_mq_timedreceive(mqd_t mqdes, char __user *msg_ptr, size_t msg_len, unsigned int __user *msg_prio, const struct __kernel_timespec __user *abs_timeout);
asmlinkage long sys_mq_notify(mqd_t mqdes, const struct sigevent __user *notification);
asmlinkage long sys_mq_getsetattr(mqd_t mqdes, const struct mq_attr __user *mqstat, struct mq_attr __user *omqstat);
asmlinkage long sys_mq_timedreceive_time32(mqd_t mqdes, char __user *u_msg_ptr, unsigned int msg_len, unsigned int __user *u_msg_prio, const struct old_timespec32 __user *u_abs_timeout);
asmlinkage long sys_mq_timedsend_time32(mqd_t mqdes, const char __user *u_msg_ptr, unsigned int msg_len, unsigned int msg_prio, const struct old_timespec32 __user *u_abs_timeout);
asmlinkage long sys_msgget(key_t key, int msgflg);
asmlinkage long sys_old_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);
asmlinkage long sys_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);
asmlinkage long sys_msgrcv(int msqid, struct msgbuf __user *msgp, size_t msgsz, long msgtyp, int msgflg);
asmlinkage long sys_msgsnd(int msqid, struct msgbuf __user *msgp, size_t msgsz, int msgflg);
asmlinkage long sys_semget(key_t key, int nsems, int semflg);
asmlinkage long sys_semctl(int semid, int semnum, int cmd, unsigned long arg);
asmlinkage long sys_old_semctl(int semid, int semnum, int cmd, unsigned long arg);
asmlinkage long sys_semtimedop(int semid, struct sembuf __user *sops, unsigned nsops, const struct __kernel_timespec __user *timeout);
asmlinkage long sys_semtimedop_time32(int semid, struct sembuf __user *sops, unsigned nsops, const struct old_timespec32 __user *timeout);
asmlinkage long sys_semop(int semid, struct sembuf __user *sops, unsigned nsops);
asmlinkage long sys_shmget(key_t key, size_t size, int flag);
asmlinkage long sys_old_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);
asmlinkage long sys_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);
asmlinkage long sys_shmat(int shmid, char __user *shmaddr, int shmflg);
asmlinkage long sys_shmdt(char __user *shmaddr);
!asmlinkage long sys_socket(int family, int type, int protocol);
!asmlinkage long sys_socketpair(int family, int type, int protocol, int __user *usockvec);
!asmlinkage long sys_bind(int fd, struct sockaddr __user *umyaddr, int addrlen);
!asmlinkage long sys_listen(int fd, int backlog);
!asmlinkage long sys_accept(int fd, struct sockaddr __user *upeer_sockaddr, int __user *upeer_addrlen);
!asmlinkage long sys_connect(int fd, struct sockaddr __user *uservaddr, int addrlen);
!asmlinkage long sys_getsockname(int fd, struct sockaddr __user *usockaddr, int __user *usockaddr_len);
!asmlinkage long sys_getpeername(int fd, struct sockaddr __user *usockaddr, int __user *usockaddr_len);
!asmlinkage long sys_sendto(int fd, void __user *buff, size_t len, unsigned int flags, struct sockaddr __user *addr, int addr_len);
!asmlinkage long sys_recvfrom(int fd, void __user *ubuf, size_t size, unsigned int flags, struct sockaddr __user *addr, int __user *addr_len);
asmlinkage long sys_setsockopt(int fd, int level, int optname, char __user *optval, int optlen);
asmlinkage long sys_getsockopt(int fd, int level, int optname, char __user *optval, int __user *optlen);
!asmlinkage long sys_shutdown(int fd, int how);
asmlinkage long sys_sendmsg(int fd, struct user_msghdr __user *msg, unsigned flags);
asmlinkage long sys_recvmsg(int fd, struct user_msghdr __user *msg, unsigned flags);
asmlinkage long sys_readahead(int fd, loff_t offset, size_t count);
asmlinkage long sys_brk(unsigned long brk);
asmlinkage long sys_munmap(unsigned long addr, size_t len);
asmlinkage long sys_mremap(unsigned long addr, unsigned long old_len, unsigned long new_len, unsigned long flags, unsigned long new_addr);
asmlinkage long sys_add_key(const char __user *_type, const char __user *_description, const void __user *_payload, size_t plen, key_serial_t destringid);
asmlinkage long sys_request_key(const char __user *_type, const char __user *_description, const char __user *_callout_info, key_serial_t destringid);
asmlinkage long sys_keyctl(int cmd, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);
#asmlinkage long sys_clone(unsigned long, unsigned long, int __user *, unsigned long, int __user *);
#asmlinkage long sys_clone(unsigned long, unsigned long, int, int __user *, int __user *, unsigned long);
#asmlinkage long sys_clone(unsigned long, unsigned long, int __user *, int __user *, unsigned long);
asmlinkage long sys_clone3(struct clone_args __user *uargs, size_t size);
asmlinkage long sys_execve(const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp);
asmlinkage long sys_fadvise64_64(int fd, loff_t offset, loff_t len, int advice);
asmlinkage long sys_swapon(const char __user *specialfile, int swap_flags);
asmlinkage long sys_swapoff(const char __user *specialfile);
asmlinkage long sys_mprotect(unsigned long start, size_t len, unsigned long prot);
asmlinkage long sys_msync(unsigned long start, size_t len, int flags);
asmlinkage long sys_mlock(unsigned long start, size_t len);
asmlinkage long sys_munlock(unsigned long start, size_t len);
asmlinkage long sys_mlockall(int flags);
asmlinkage long sys_munlockall(void);
asmlinkage long sys_mincore(unsigned long start, size_t len, unsigned char __user *vec);
asmlinkage long sys_madvise(unsigned long start, size_t len, int behavior);
asmlinkage long sys_process_madvise(int pidfd, const struct iovec __user *vec, size_t vlen, int behavior, unsigned int flags);
asmlinkage long sys_process_mrelease(int pidfd, unsigned int flags);
asmlinkage long sys_remap_file_pages(unsigned long start, unsigned long size, unsigned long prot, unsigned long pgoff, unsigned long flags);
asmlinkage long sys_mbind(unsigned long start, unsigned long len, unsigned long mode, const unsigned long __user *nmask, unsigned long maxnode, unsigned flags);
asmlinkage long sys_get_mempolicy(int __user *policy, unsigned long __user *nmask, unsigned long maxnode, unsigned long addr, unsigned long flags);
asmlinkage long sys_set_mempolicy(int mode, const unsigned long __user *nmask, unsigned long maxnode);
asmlinkage long sys_migrate_pages(pid_t pid, unsigned long maxnode, const unsigned long __user *from, const unsigned long __user *to);
asmlinkage long sys_move_pages(pid_t pid, unsigned long nr_pages, const void __user *__user *pages, const int __user *nodes, int __user *status, int flags);
asmlinkage long sys_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t __user *uinfo);
asmlinkage long sys_perf_event_open(struct perf_event_attr __user *attr_uptr, pid_t pid, int cpu, int group_fd, unsigned long flags);
!asmlinkage long sys_accept4(int fd, struct sockaddr __user *upeer_sockaddr, int __user *upeer_addrlen, int flags);
asmlinkage long sys_recvmmsg(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags, struct __kernel_timespec __user *timeout);
asmlinkage long sys_recvmmsg_time32(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags, struct old_timespec32 __user *timeout);
asmlinkage long sys_wait4(pid_t pid, int __user *stat_addr, int options, struct rusage __user *ru);
asmlinkage long sys_prlimit64(pid_t pid, unsigned int resource, const struct rlimit64 __user *new_rlim, struct rlimit64 __user *old_rlim);
asmlinkage long sys_fanotify_init(unsigned int flags, unsigned int event_f_flags);
asmlinkage long sys_fanotify_mark(int fanotify_fd, unsigned int flags, u64 mask, int fd, const char __user *pathname);
asmlinkage long sys_name_to_handle_at(int dfd, const char __user *name, struct file_handle __user *handle, int __user *mnt_id, int flag);
asmlinkage long sys_open_by_handle_at(int mountdirfd, struct file_handle __user *handle, int flags);
asmlinkage long sys_clock_adjtime(clockid_t which_clock, struct __kernel_timex __user *tx);
asmlinkage long sys_clock_adjtime32(clockid_t which_clock, struct old_timex32 __user *tx);
asmlinkage long sys_syncfs(int fd);
asmlinkage long sys_setns(int fd, int nstype);
asmlinkage long sys_pidfd_open(pid_t pid, unsigned int flags);
asmlinkage long sys_sendmmsg(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags);
asmlinkage long sys_process_vm_readv(pid_t pid, const struct iovec __user *lvec, unsigned long liovcnt, const struct iovec __user *rvec, unsigned long riovcnt, unsigned long flags);
asmlinkage long sys_process_vm_writev(pid_t pid, const struct iovec __user *lvec, unsigned long liovcnt, const struct iovec __user *rvec, unsigned long riovcnt, unsigned long flags);
asmlinkage long sys_kcmp(pid_t pid1, pid_t pid2, int type, unsigned long idx1, unsigned long idx2);
asmlinkage long sys_finit_module(int fd, const char __user *uargs, int flags);
asmlinkage long sys_sched_setattr(pid_t pid, struct sched_attr __user *attr, unsigned int flags);
asmlinkage long sys_sched_getattr(pid_t pid, struct sched_attr __user *attr, unsigned int size, unsigned int flags);
asmlinkage long sys_renameat2(int olddfd, const char __user *oldname, int newdfd, const char __user *newname, unsigned int flags);
asmlinkage long sys_seccomp(unsigned int op, unsigned int flags, void __user *uargs);
asmlinkage long sys_getrandom(char __user *buf, size_t count, unsigned int flags);
asmlinkage long sys_memfd_create(const char __user *uname_ptr, unsigned int flags);
asmlinkage long sys_bpf(int cmd, union bpf_attr *attr, unsigned int size);
asmlinkage long sys_execveat(int dfd, const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp, int flags);
asmlinkage long sys_userfaultfd(int flags);
asmlinkage long sys_membarrier(int cmd, unsigned int flags, int cpu_id);
asmlinkage long sys_mlock2(unsigned long start, size_t len, int flags);
asmlinkage long sys_copy_file_range(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len, unsigned int flags);
asmlinkage long sys_preadv2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h, rwf_t flags);
asmlinkage long sys_pwritev2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h, rwf_t flags);
asmlinkage long sys_pkey_mprotect(unsigned long start, size_t len, unsigned long prot, int pkey);
asmlinkage long sys_pkey_alloc(unsigned long flags, unsigned long init_val);
asmlinkage long sys_pkey_free(int pkey);
asmlinkage long sys_statx(int dfd, const char __user *path, unsigned flags, unsigned mask, struct statx __user *buffer);
asmlinkage long sys_rseq(struct rseq __user *rseq, uint32_t rseq_len, int flags, uint32_t sig);
asmlinkage long sys_open_tree(int dfd, const char __user *path, unsigned flags);
asmlinkage long sys_move_mount(int from_dfd, const char __user *from_path, int to_dfd, const char __user *to_path, unsigned int ms_flags);
asmlinkage long sys_mount_setattr(int dfd, const char __user *path, unsigned int flags, struct mount_attr __user *uattr, size_t usize);
asmlinkage long sys_fsopen(const char __user *fs_name, unsigned int flags);
asmlinkage long sys_fsconfig(int fs_fd, unsigned int cmd, const char __user *key, const void __user *value, int aux);
asmlinkage long sys_fsmount(int fs_fd, unsigned int flags, unsigned int ms_flags);
asmlinkage long sys_fspick(int dfd, const char __user *path, unsigned int flags);
asmlinkage long sys_pidfd_send_signal(int pidfd, int sig, siginfo_t __user *info, unsigned int flags);
asmlinkage long sys_pidfd_getfd(int pidfd, int fd, unsigned int flags);
asmlinkage long sys_landlock_create_ruleset(const struct landlock_ruleset_attr __user *attr, size_t size, __u32 flags);
asmlinkage long sys_landlock_add_rule(int ruleset_fd, enum landlock_rule_type rule_type, const void __user *rule_attr, __u32 flags);
asmlinkage long sys_landlock_restrict_self(int ruleset_fd, __u32 flags);
asmlinkage long sys_memfd_secret(unsigned int flags);
asmlinkage long sys_set_mempolicy_home_node(unsigned long start, unsigned long len, unsigned long home_node, unsigned long flags);
asmlinkage long sys_ioperm(unsigned long from, unsigned long num, int on);
asmlinkage long sys_pciconfig_read(unsigned long bus, unsigned long dfn, unsigned long off, unsigned long len, void __user *buf);
asmlinkage long sys_pciconfig_write(unsigned long bus, unsigned long dfn, unsigned long off, unsigned long len, void __user *buf);
asmlinkage long sys_pciconfig_iobase(long which, unsigned long bus, unsigned long devfn);
asmlinkage long sys_spu_run(int fd, __u32 __user *unpc, __u32 __user *ustatus);
asmlinkage long sys_spu_create(const char __user *name, unsigned int flags, umode_t mode, int fd);
asmlinkage long sys_open(const char __user *filename, int flags, umode_t mode);
asmlinkage long sys_link(const char __user *oldname, const char __user *newname);
asmlinkage long sys_unlink(const char __user *pathname);
asmlinkage long sys_mknod(const char __user *filename, umode_t mode, unsigned dev);
asmlinkage long sys_chmod(const char __user *filename, umode_t mode);
asmlinkage long sys_chown(const char __user *filename, uid_t user, gid_t group);
asmlinkage long sys_mkdir(const char __user *pathname, umode_t mode);
asmlinkage long sys_rmdir(const char __user *pathname);
asmlinkage long sys_lchown(const char __user *filename, uid_t user, gid_t group);
asmlinkage long sys_access(const char __user *filename, int mode);
asmlinkage long sys_rename(const char __user *oldname, const char __user *newname);
asmlinkage long sys_symlink(const char __user *old, const char __user *new);
asmlinkage long sys_stat64(const char __user *filename, struct stat64 __user *statbuf);
asmlinkage long sys_lstat64(const char __user *filename, struct stat64 __user *statbuf);
asmlinkage long sys_pipe(int __user *fildes);
asmlinkage long sys_dup2(unsigned int oldfd, unsigned int newfd);
asmlinkage long sys_epoll_create(int size);
asmlinkage long sys_inotify_init(void);
asmlinkage long sys_eventfd(unsigned int count);
asmlinkage long sys_signalfd(int ufd, sigset_t __user *user_mask, size_t sizemask);
asmlinkage long sys_sendfile(int out_fd, int in_fd, off_t __user *offset, size_t count);
asmlinkage long sys_newstat(const char __user *filename, struct stat __user *statbuf);
asmlinkage long sys_newlstat(const char __user *filename, struct stat __user *statbuf);
asmlinkage long sys_fadvise64(int fd, loff_t offset, size_t len, int advice);
asmlinkage long sys_alarm(unsigned int seconds);
asmlinkage long sys_getpgrp(void);
asmlinkage long sys_pause(void);
asmlinkage long sys_time(__kernel_old_time_t __user *tloc);
asmlinkage long sys_time32(old_time32_t __user *tloc);
asmlinkage long sys_utime(char __user *filename, struct utimbuf __user *times);
asmlinkage long sys_utimes(char __user *filename, struct __kernel_old_timeval __user *utimes);
asmlinkage long sys_futimesat(int dfd, const char __user *filename, struct __kernel_old_timeval __user *utimes);
asmlinkage long sys_futimesat_time32(unsigned int dfd, const char __user *filename, struct old_timeval32 __user *t);
asmlinkage long sys_utime32(const char __user *filename, struct old_utimbuf32 __user *t);
asmlinkage long sys_utimes_time32(const char __user *filename, struct old_timeval32 __user *t);
asmlinkage long sys_creat(const char __user *pathname, umode_t mode);
asmlinkage long sys_getdents(unsigned int fd, struct linux_dirent __user *dirent, unsigned int count);
asmlinkage long sys_select(int n, fd_set __user *inp, fd_set __user *outp, fd_set __user *exp, struct __kernel_old_timeval __user *tvp);
asmlinkage long sys_poll(struct pollfd __user *ufds, unsigned int nfds, int timeout);
asmlinkage long sys_epoll_wait(int epfd, struct epoll_event __user *events, int maxevents, int timeout);
asmlinkage long sys_ustat(unsigned dev, struct ustat __user *ubuf);
asmlinkage long sys_vfork(void);
asmlinkage long sys_recv(int, void __user *, size_t, unsigned);
asmlinkage long sys_send(int, void __user *, size_t, unsigned);
asmlinkage long sys_oldumount(char __user *name);
asmlinkage long sys_uselib(const char __user *library);
asmlinkage long sys_sysfs(int option, unsigned long arg1, unsigned long arg2);
asmlinkage long sys_fork(void);
asmlinkage long sys_stime(__kernel_old_time_t __user *tptr);
asmlinkage long sys_stime32(old_time32_t __user *tptr);
asmlinkage long sys_sigpending(old_sigset_t __user *uset);
asmlinkage long sys_sigprocmask(int how, old_sigset_t __user *set, old_sigset_t __user *oset);
asmlinkage long sys_sigsuspend(old_sigset_t mask);
#asmlinkage long sys_sigsuspend(int unused1, int unused2, old_sigset_t mask);
asmlinkage long sys_sigaction(int, const struct old_sigaction __user *, struct old_sigaction __user *);
asmlinkage long sys_sgetmask(void);
asmlinkage long sys_ssetmask(int newmask);
asmlinkage long sys_signal(int sig, __sighandler_t handler);
asmlinkage long sys_nice(int increment);
asmlinkage long sys_kexec_file_load(int kernel_fd, int initrd_fd, unsigned long cmdline_len, const char __user *cmdline_ptr, unsigned long flags);
asmlinkage long sys_waitpid(pid_t pid, int __user *stat_addr, int options);
asmlinkage long sys_chown16(const char __user *filename, old_uid_t user, old_gid_t group);
asmlinkage long sys_lchown16(const char __user *filename, old_uid_t user, old_gid_t group);
asmlinkage long sys_fchown16(unsigned int fd, old_uid_t user, old_gid_t group);
asmlinkage long sys_setregid16(old_gid_t rgid, old_gid_t egid);
asmlinkage long sys_setgid16(old_gid_t gid);
asmlinkage long sys_setreuid16(old_uid_t ruid, old_uid_t euid);
asmlinkage long sys_setuid16(old_uid_t uid);
asmlinkage long sys_setresuid16(old_uid_t ruid, old_uid_t euid, old_uid_t suid);
asmlinkage long sys_getresuid16(old_uid_t __user *ruid, old_uid_t __user *euid, old_uid_t __user *suid);
asmlinkage long sys_setresgid16(old_gid_t rgid, old_gid_t egid, old_gid_t sgid);
asmlinkage long sys_getresgid16(old_gid_t __user *rgid, old_gid_t __user *egid, old_gid_t __user *sgid);
asmlinkage long sys_setfsuid16(old_uid_t uid);
asmlinkage long sys_setfsgid16(old_gid_t gid);
asmlinkage long sys_getgroups16(int gidsetsize, old_gid_t __user *grouplist);
asmlinkage long sys_setgroups16(int gidsetsize, old_gid_t __user *grouplist);
asmlinkage long sys_getuid16(void);
asmlinkage long sys_geteuid16(void);
asmlinkage long sys_getgid16(void);
asmlinkage long sys_getegid16(void);
asmlinkage long sys_socketcall(int call, unsigned long __user *args);
asmlinkage long sys_stat(const char __user *filename, struct __old_kernel_stat __user *statbuf);
asmlinkage long sys_lstat(const char __user *filename, struct __old_kernel_stat __user *statbuf);
asmlinkage long sys_fstat(unsigned int fd, struct __old_kernel_stat __user *statbuf);
asmlinkage long sys_readlink(const char __user *path, char __user *buf, int bufsiz);
asmlinkage long sys_old_select(struct sel_arg_struct __user *arg);
asmlinkage long sys_old_readdir(unsigned int, struct old_linux_dirent __user *, unsigned int);
asmlinkage long sys_gethostname(char __user *name, int len);
asmlinkage long sys_uname(struct old_utsname __user *);
asmlinkage long sys_olduname(struct oldold_utsname __user *);
asmlinkage long sys_old_getrlimit(unsigned int resource, struct rlimit __user *rlim);
asmlinkage long sys_ipc(unsigned int call, int first, unsigned long second, unsigned long third, void __user *ptr, long fifth);
asmlinkage long sys_mmap_pgoff(unsigned long addr, unsigned long len, unsigned long prot, unsigned long flags, unsigned long fd, unsigned long pgoff);
asmlinkage long sys_old_mmap(struct mmap_arg_struct __user *arg);
#asmlinkage long sys_ni_syscall(void);
"""

# include/linux/compat.h
syscall_defs_compat = """
asmlinkage long compat_sys_io_setup(unsigned nr_reqs, u32 __user *ctx32p);
asmlinkage long compat_sys_io_submit(compat_aio_context_t ctx_id, int nr, u32 __user *iocb);
asmlinkage long compat_sys_io_pgetevents(compat_aio_context_t ctx_id, compat_long_t min_nr, compat_long_t nr, struct io_event __user *events, struct old_timespec32 __user *timeout, const struct __compat_aio_sigset __user *usig);
asmlinkage long compat_sys_io_pgetevents_time64(compat_aio_context_t ctx_id, compat_long_t min_nr, compat_long_t nr, struct io_event __user *events, struct __kernel_timespec __user *timeout, const struct __compat_aio_sigset __user *usig);
asmlinkage long compat_sys_lookup_dcookie(u32, u32, char __user *, compat_size_t);
asmlinkage long compat_sys_epoll_pwait(int epfd, struct epoll_event __user *events, int maxevents, int timeout, const compat_sigset_t __user *sigmask, compat_size_t sigsetsize);
asmlinkage long compat_sys_epoll_pwait2(int epfd, struct epoll_event __user *events, int maxevents, const struct __kernel_timespec __user *timeout, const compat_sigset_t __user *sigmask, compat_size_t sigsetsize);
asmlinkage long compat_sys_fcntl(unsigned int fd, unsigned int cmd, compat_ulong_t arg);
asmlinkage long compat_sys_fcntl64(unsigned int fd, unsigned int cmd, compat_ulong_t arg);
asmlinkage long compat_sys_ioctl(unsigned int fd, unsigned int cmd, compat_ulong_t arg);
asmlinkage long compat_sys_statfs(const char __user *pathname, struct compat_statfs __user *buf);
asmlinkage long compat_sys_statfs64(const char __user *pathname, compat_size_t sz, struct compat_statfs64 __user *buf);
asmlinkage long compat_sys_fstatfs(unsigned int fd, struct compat_statfs __user *buf);
asmlinkage long compat_sys_fstatfs64(unsigned int fd, compat_size_t sz, struct compat_statfs64 __user *buf);
asmlinkage long compat_sys_truncate(const char __user *, compat_off_t);
asmlinkage long compat_sys_ftruncate(unsigned int, compat_ulong_t);
asmlinkage long compat_sys_openat(int dfd, const char __user *filename, int flags, umode_t mode);
asmlinkage long compat_sys_getdents(unsigned int fd, struct compat_linux_dirent __user *dirent, unsigned int count);
asmlinkage long compat_sys_lseek(unsigned int, compat_off_t, unsigned int);
asmlinkage ssize_t compat_sys_preadv(compat_ulong_t fd, const struct iovec __user *vec, compat_ulong_t vlen, u32 pos_low, u32 pos_high);
asmlinkage ssize_t compat_sys_pwritev(compat_ulong_t fd, const struct iovec __user *vec, compat_ulong_t vlen, u32 pos_low, u32 pos_high);
asmlinkage long compat_sys_preadv64(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, loff_t pos);
asmlinkage long compat_sys_pwritev64(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, loff_t pos);
asmlinkage long compat_sys_sendfile(int out_fd, int in_fd, compat_off_t __user *offset, compat_size_t count);
asmlinkage long compat_sys_sendfile64(int out_fd, int in_fd, compat_loff_t __user *offset, compat_size_t count);
asmlinkage long compat_sys_pselect6_time32(int n, compat_ulong_t __user *inp, compat_ulong_t __user *outp, compat_ulong_t __user *exp, struct old_timespec32 __user *tsp, void __user *sig);
asmlinkage long compat_sys_pselect6_time64(int n, compat_ulong_t __user *inp, compat_ulong_t __user *outp, compat_ulong_t __user *exp, struct __kernel_timespec __user *tsp, void __user *sig);
asmlinkage long compat_sys_ppoll_time32(struct pollfd __user *ufds, unsigned int nfds, struct old_timespec32 __user *tsp, const compat_sigset_t __user *sigmask, compat_size_t sigsetsize);
asmlinkage long compat_sys_ppoll_time64(struct pollfd __user *ufds, unsigned int nfds, struct __kernel_timespec __user *tsp, const compat_sigset_t __user *sigmask, compat_size_t sigsetsize);
asmlinkage long compat_sys_signalfd4(int ufd, const compat_sigset_t __user *sigmask, compat_size_t sigsetsize, int flags);
asmlinkage long compat_sys_newfstatat(unsigned int dfd, const char __user *filename, struct compat_stat __user *statbuf, int flag);
asmlinkage long compat_sys_newfstat(unsigned int fd, struct compat_stat __user *statbuf);
!asmlinkage long compat_sys_waitid(int which, compat_pid_t pid, struct compat_siginfo __user *waitid, int options, struct compat_rusage __user *uru);
asmlinkage long compat_sys_set_robust_list(struct compat_robust_list_head __user *head, compat_size_t len);
asmlinkage long compat_sys_get_robust_list(int pid, compat_uptr_t __user *head_ptr, compat_size_t __user *len_ptr);
asmlinkage long compat_sys_getitimer(int which, struct old_itimerval32 __user *it);
asmlinkage long compat_sys_setitimer(int which, struct old_itimerval32 __user *in, struct old_itimerval32 __user *out);
!asmlinkage long compat_sys_kexec_load(compat_ulong_t entry, compat_ulong_t nr_segments, struct compat_kexec_segment __user *segments, compat_ulong_t flags);
asmlinkage long compat_sys_timer_create(clockid_t which_clock, struct compat_sigevent __user *timer_event_spec, timer_t __user *created_timer_id);
asmlinkage long compat_sys_ptrace(compat_long_t request, compat_long_t pid, compat_long_t addr, compat_long_t data);
asmlinkage long compat_sys_sched_setaffinity(compat_pid_t pid, unsigned int len, compat_ulong_t __user *user_mask_ptr);
asmlinkage long compat_sys_sched_getaffinity(compat_pid_t pid, unsigned int len, compat_ulong_t __user *user_mask_ptr);
asmlinkage long compat_sys_sigaltstack(const compat_stack_t __user *uss_ptr, compat_stack_t __user *uoss_ptr);
asmlinkage long compat_sys_rt_sigsuspend(compat_sigset_t __user *unewset, compat_size_t sigsetsize);
!asmlinkage long compat_sys_rt_sigaction(int sig, const struct compat_sigaction __user *act, struct compat_sigaction __user *oact, compat_size_t sigsetsize);
asmlinkage long compat_sys_rt_sigprocmask(int how, compat_sigset_t __user *set, compat_sigset_t __user *oset, compat_size_t sigsetsize);
asmlinkage long compat_sys_rt_sigpending(compat_sigset_t __user *uset, compat_size_t sigsetsize);
asmlinkage long compat_sys_rt_sigtimedwait_time32(compat_sigset_t __user *uthese, struct compat_siginfo __user *uinfo, struct old_timespec32 __user *uts, compat_size_t sigsetsize);
asmlinkage long compat_sys_rt_sigtimedwait_time64(compat_sigset_t __user *uthese, struct compat_siginfo __user *uinfo, struct __kernel_timespec __user *uts, compat_size_t sigsetsize);
asmlinkage long compat_sys_rt_sigqueueinfo(compat_pid_t pid, int sig, struct compat_siginfo __user *uinfo);
asmlinkage long compat_sys_times(struct compat_tms __user *tbuf);
asmlinkage long compat_sys_getrlimit(unsigned int resource, struct compat_rlimit __user *rlim);
asmlinkage long compat_sys_setrlimit(unsigned int resource, struct compat_rlimit __user *rlim);
asmlinkage long compat_sys_getrusage(int who, struct compat_rusage __user *ru);
asmlinkage long compat_sys_gettimeofday(struct old_timeval32 __user *tv, struct timezone __user *tz);
asmlinkage long compat_sys_settimeofday(struct old_timeval32 __user *tv, struct timezone __user *tz);
asmlinkage long compat_sys_sysinfo(struct compat_sysinfo __user *info);
asmlinkage long compat_sys_mq_open(const char __user *u_name, int oflag, compat_mode_t mode, struct compat_mq_attr __user *u_attr);
asmlinkage long compat_sys_mq_notify(mqd_t mqdes, const struct compat_sigevent __user *u_notification);
asmlinkage long compat_sys_mq_getsetattr(mqd_t mqdes, const struct compat_mq_attr __user *u_mqstat, struct compat_mq_attr __user *u_omqstat);
asmlinkage long compat_sys_msgctl(int first, int second, void __user *uptr);
asmlinkage long compat_sys_msgrcv(int msqid, compat_uptr_t msgp, compat_ssize_t msgsz, compat_long_t msgtyp, int msgflg);
asmlinkage long compat_sys_msgsnd(int msqid, compat_uptr_t msgp, compat_ssize_t msgsz, int msgflg);
asmlinkage long compat_sys_semctl(int semid, int semnum, int cmd, int arg);
asmlinkage long compat_sys_shmctl(int first, int second, void __user *uptr);
asmlinkage long compat_sys_shmat(int shmid, compat_uptr_t shmaddr, int shmflg);
asmlinkage long compat_sys_recvfrom(int fd, void __user *buf, compat_size_t len, unsigned flags, struct sockaddr __user *addr, int __user *addrlen);
asmlinkage long compat_sys_sendmsg(int fd, struct compat_msghdr __user *msg, unsigned flags);
asmlinkage long compat_sys_recvmsg(int fd, struct compat_msghdr __user *msg, unsigned int flags);
asmlinkage long compat_sys_keyctl(u32 option, u32 arg2, u32 arg3, u32 arg4, u32 arg5);
asmlinkage long compat_sys_execve(const char __user *filename, const compat_uptr_t __user *argv, const compat_uptr_t __user *envp);
asmlinkage long compat_sys_rt_tgsigqueueinfo(compat_pid_t tgid, compat_pid_t pid, int sig, struct compat_siginfo __user *uinfo);
asmlinkage long compat_sys_recvmmsg_time64(int fd, struct compat_mmsghdr __user *mmsg, unsigned vlen, unsigned int flags, struct __kernel_timespec __user *timeout);
asmlinkage long compat_sys_recvmmsg_time32(int fd, struct compat_mmsghdr __user *mmsg, unsigned vlen, unsigned int flags, struct old_timespec32 __user *timeout);
asmlinkage long compat_sys_wait4(compat_pid_t pid, compat_uint_t __user *stat_addr, int options, struct compat_rusage __user *ru);
asmlinkage long compat_sys_fanotify_mark(int, unsigned int, __u32, __u32, int, const char __user *);
asmlinkage long compat_sys_open_by_handle_at(int mountdirfd, struct file_handle __user *handle, int flags);
asmlinkage long compat_sys_sendmmsg(int fd, struct compat_mmsghdr __user *mmsg, unsigned vlen, unsigned int flags);
asmlinkage long compat_sys_execveat(int dfd, const char __user *filename, const compat_uptr_t __user *argv, const compat_uptr_t __user *envp, int flags);
asmlinkage ssize_t compat_sys_preadv2(compat_ulong_t fd, const struct iovec __user *vec, compat_ulong_t vlen, u32 pos_low, u32 pos_high, rwf_t flags);
asmlinkage ssize_t compat_sys_pwritev2(compat_ulong_t fd, const struct iovec __user *vec, compat_ulong_t vlen, u32 pos_low, u32 pos_high, rwf_t flags);
asmlinkage long compat_sys_preadv64v2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, loff_t pos, rwf_t flags);
asmlinkage long compat_sys_pwritev64v2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, loff_t pos, rwf_t flags);
asmlinkage long compat_sys_open(const char __user *filename, int flags, umode_t mode);
asmlinkage long compat_sys_signalfd(int ufd, const compat_sigset_t __user *sigmask, compat_size_t sigsetsize);
asmlinkage long compat_sys_newstat(const char __user *filename, struct compat_stat __user *statbuf);
asmlinkage long compat_sys_newlstat(const char __user *filename, struct compat_stat __user *statbuf);
asmlinkage long compat_sys_select(int n, compat_ulong_t __user *inp, compat_ulong_t __user *outp, compat_ulong_t __user *exp, struct old_timeval32 __user *tvp);
asmlinkage long compat_sys_ustat(unsigned dev, struct compat_ustat __user *u32);
asmlinkage long compat_sys_recv(int fd, void __user *buf, compat_size_t len, unsigned flags);
asmlinkage long compat_sys_old_readdir(unsigned int fd, struct compat_old_linux_dirent __user *, unsigned int count);
asmlinkage long compat_sys_old_select(struct compat_sel_arg_struct __user *arg);
asmlinkage long compat_sys_ipc(u32, int, int, u32, compat_uptr_t, u32);
asmlinkage long compat_sys_sigpending(compat_old_sigset_t __user *set);
asmlinkage long compat_sys_sigprocmask(int how, compat_old_sigset_t __user *nset, compat_old_sigset_t __user *oset);
asmlinkage long compat_sys_sigaction(int sig, const struct compat_old_sigaction __user *act, struct compat_old_sigaction __user *oact);
asmlinkage long compat_sys_socketcall(int call, u32 __user *args);
asmlinkage long compat_sys_truncate64(const char __user *pathname, compat_arg_u64(len));
asmlinkage long compat_sys_ftruncate64(unsigned int fd, compat_arg_u64(len));
asmlinkage long compat_sys_fallocate(int fd, int mode, compat_arg_u64(offset), compat_arg_u64(len));
asmlinkage long compat_sys_pread64(unsigned int fd, char __user *buf, size_t count, compat_arg_u64(pos));
asmlinkage long compat_sys_pwrite64(unsigned int fd, const char __user *buf, size_t count, compat_arg_u64(pos));
asmlinkage long compat_sys_sync_file_range(int fd, compat_arg_u64(pos), compat_arg_u64(nbytes), unsigned int flags);
asmlinkage long compat_sys_fadvise64_64(int fd, compat_arg_u64(pos), compat_arg_u64(len), int advice);
asmlinkage long compat_sys_readahead(int fd, compat_arg_u64(offset), size_t count);
"""


def parse_common_syscall_defs():
    sc_defs = [
        syscall_defs,
        syscall_defs_compat,
    ]
    dic = {}
    for defs in sc_defs:
        for line in defs.splitlines():
            if line == "":
                continue
            if line.startswith("#"):
                continue
            m = re.search(r"asmlinkage\s+(?:long|ssize_t)\s+(\S+)\((.+?)\);", line)
            if not m:
                continue
            name, args = m.group(1), m.group(2)
            args = [x.strip() for x in args.split(",")]
            if name in dic:
                err("duplicate: {:s}".format(name))
                raise
            if len(args) == 1 and args[0] == "void":
                dic[name] = []
            else:
                dic[name] = args
    return dic


# x86_64
# - arch/x86/entry/syscalls/syscall_64.tbl
x64_syscall_tbl = """
#
# 64-bit system call numbers and entry vectors
#
# The format is:
# <number> <abi> <name> <entry point>
#
# The __x64_sys_*() stubs are created on-the-fly for sys_*() system calls
#
# The abi is "common", "64" or "x32" for this file.
#
0       common  read                    sys_read
1       common  write                   sys_write
2       common  open                    sys_open
3       common  close                   sys_close
4       common  stat                    sys_newstat
5       common  fstat                   sys_newfstat
6       common  lstat                   sys_newlstat
7       common  poll                    sys_poll
8       common  lseek                   sys_lseek
9       common  mmap                    sys_mmap
10      common  mprotect                sys_mprotect
11      common  munmap                  sys_munmap
12      common  brk                     sys_brk
13      64      rt_sigaction            sys_rt_sigaction
14      common  rt_sigprocmask          sys_rt_sigprocmask
15      64      rt_sigreturn            sys_rt_sigreturn
16      64      ioctl                   sys_ioctl
17      common  pread64                 sys_pread64
18      common  pwrite64                sys_pwrite64
19      64      readv                   sys_readv
20      64      writev                  sys_writev
21      common  access                  sys_access
22      common  pipe                    sys_pipe
23      common  select                  sys_select
24      common  sched_yield             sys_sched_yield
25      common  mremap                  sys_mremap
26      common  msync                   sys_msync
27      common  mincore                 sys_mincore
28      common  madvise                 sys_madvise
29      common  shmget                  sys_shmget
30      common  shmat                   sys_shmat
31      common  shmctl                  sys_shmctl
32      common  dup                     sys_dup
33      common  dup2                    sys_dup2
34      common  pause                   sys_pause
35      common  nanosleep               sys_nanosleep
36      common  getitimer               sys_getitimer
37      common  alarm                   sys_alarm
38      common  setitimer               sys_setitimer
39      common  getpid                  sys_getpid
40      common  sendfile                sys_sendfile64
41      common  socket                  sys_socket
42      common  connect                 sys_connect
43      common  accept                  sys_accept
44      common  sendto                  sys_sendto
45      64      recvfrom                sys_recvfrom
46      64      sendmsg                 sys_sendmsg
47      64      recvmsg                 sys_recvmsg
48      common  shutdown                sys_shutdown
49      common  bind                    sys_bind
50      common  listen                  sys_listen
51      common  getsockname             sys_getsockname
52      common  getpeername             sys_getpeername
53      common  socketpair              sys_socketpair
54      64      setsockopt              sys_setsockopt
55      64      getsockopt              sys_getsockopt
56      common  clone                   sys_clone
57      common  fork                    sys_fork
58      common  vfork                   sys_vfork
59      64      execve                  sys_execve
60      common  exit                    sys_exit
61      common  wait4                   sys_wait4
62      common  kill                    sys_kill
63      common  uname                   sys_newuname
64      common  semget                  sys_semget
65      common  semop                   sys_semop
66      common  semctl                  sys_semctl
67      common  shmdt                   sys_shmdt
68      common  msgget                  sys_msgget
69      common  msgsnd                  sys_msgsnd
70      common  msgrcv                  sys_msgrcv
71      common  msgctl                  sys_msgctl
72      common  fcntl                   sys_fcntl
73      common  flock                   sys_flock
74      common  fsync                   sys_fsync
75      common  fdatasync               sys_fdatasync
76      common  truncate                sys_truncate
77      common  ftruncate               sys_ftruncate
78      common  getdents                sys_getdents
79      common  getcwd                  sys_getcwd
80      common  chdir                   sys_chdir
81      common  fchdir                  sys_fchdir
82      common  rename                  sys_rename
83      common  mkdir                   sys_mkdir
84      common  rmdir                   sys_rmdir
85      common  creat                   sys_creat
86      common  link                    sys_link
87      common  unlink                  sys_unlink
88      common  symlink                 sys_symlink
89      common  readlink                sys_readlink
90      common  chmod                   sys_chmod
91      common  fchmod                  sys_fchmod
92      common  chown                   sys_chown
93      common  fchown                  sys_fchown
94      common  lchown                  sys_lchown
95      common  umask                   sys_umask
96      common  gettimeofday            sys_gettimeofday
97      common  getrlimit               sys_getrlimit
98      common  getrusage               sys_getrusage
99      common  sysinfo                 sys_sysinfo
100     common  times                   sys_times
101     64      ptrace                  sys_ptrace
102     common  getuid                  sys_getuid
103     common  syslog                  sys_syslog
104     common  getgid                  sys_getgid
105     common  setuid                  sys_setuid
106     common  setgid                  sys_setgid
107     common  geteuid                 sys_geteuid
108     common  getegid                 sys_getegid
109     common  setpgid                 sys_setpgid
110     common  getppid                 sys_getppid
111     common  getpgrp                 sys_getpgrp
112     common  setsid                  sys_setsid
113     common  setreuid                sys_setreuid
114     common  setregid                sys_setregid
115     common  getgroups               sys_getgroups
116     common  setgroups               sys_setgroups
117     common  setresuid               sys_setresuid
118     common  getresuid               sys_getresuid
119     common  setresgid               sys_setresgid
120     common  getresgid               sys_getresgid
121     common  getpgid                 sys_getpgid
122     common  setfsuid                sys_setfsuid
123     common  setfsgid                sys_setfsgid
124     common  getsid                  sys_getsid
125     common  capget                  sys_capget
126     common  capset                  sys_capset
127     64      rt_sigpending           sys_rt_sigpending
128     64      rt_sigtimedwait         sys_rt_sigtimedwait
129     64      rt_sigqueueinfo         sys_rt_sigqueueinfo
130     common  rt_sigsuspend           sys_rt_sigsuspend
131     64      sigaltstack             sys_sigaltstack
132     common  utime                   sys_utime
133     common  mknod                   sys_mknod
134     64      uselib
135     common  personality             sys_personality
136     common  ustat                   sys_ustat
137     common  statfs                  sys_statfs
138     common  fstatfs                 sys_fstatfs
139     common  sysfs                   sys_sysfs
140     common  getpriority             sys_getpriority
141     common  setpriority             sys_setpriority
142     common  sched_setparam          sys_sched_setparam
143     common  sched_getparam          sys_sched_getparam
144     common  sched_setscheduler      sys_sched_setscheduler
145     common  sched_getscheduler      sys_sched_getscheduler
146     common  sched_get_priority_max  sys_sched_get_priority_max
147     common  sched_get_priority_min  sys_sched_get_priority_min
148     common  sched_rr_get_interval   sys_sched_rr_get_interval
149     common  mlock                   sys_mlock
150     common  munlock                 sys_munlock
151     common  mlockall                sys_mlockall
152     common  munlockall              sys_munlockall
153     common  vhangup                 sys_vhangup
154     common  modify_ldt              sys_modify_ldt
155     common  pivot_root              sys_pivot_root
156     64      _sysctl                 sys_ni_syscall
157     common  prctl                   sys_prctl
158     common  arch_prctl              sys_arch_prctl
159     common  adjtimex                sys_adjtimex
160     common  setrlimit               sys_setrlimit
161     common  chroot                  sys_chroot
162     common  sync                    sys_sync
163     common  acct                    sys_acct
164     common  settimeofday            sys_settimeofday
165     common  mount                   sys_mount
166     common  umount2                 sys_umount
167     common  swapon                  sys_swapon
168     common  swapoff                 sys_swapoff
169     common  reboot                  sys_reboot
170     common  sethostname             sys_sethostname
171     common  setdomainname           sys_setdomainname
172     common  iopl                    sys_iopl
173     common  ioperm                  sys_ioperm
174     64      create_module
175     common  init_module             sys_init_module
176     common  delete_module           sys_delete_module
177     64      get_kernel_syms
178     64      query_module
179     common  quotactl                sys_quotactl
180     64      nfsservctl
181     common  getpmsg
182     common  putpmsg
183     common  afs_syscall
184     common  tuxcall
185     common  security
186     common  gettid                  sys_gettid
187     common  readahead               sys_readahead
188     common  setxattr                sys_setxattr
189     common  lsetxattr               sys_lsetxattr
190     common  fsetxattr               sys_fsetxattr
191     common  getxattr                sys_getxattr
192     common  lgetxattr               sys_lgetxattr
193     common  fgetxattr               sys_fgetxattr
194     common  listxattr               sys_listxattr
195     common  llistxattr              sys_llistxattr
196     common  flistxattr              sys_flistxattr
197     common  removexattr             sys_removexattr
198     common  lremovexattr            sys_lremovexattr
199     common  fremovexattr            sys_fremovexattr
200     common  tkill                   sys_tkill
201     common  time                    sys_time
202     common  futex                   sys_futex
203     common  sched_setaffinity       sys_sched_setaffinity
204     common  sched_getaffinity       sys_sched_getaffinity
205     64      set_thread_area
206     64      io_setup                sys_io_setup
207     common  io_destroy              sys_io_destroy
208     common  io_getevents            sys_io_getevents
209     64      io_submit               sys_io_submit
210     common  io_cancel               sys_io_cancel
211     64      get_thread_area
212     common  lookup_dcookie          sys_lookup_dcookie
213     common  epoll_create            sys_epoll_create
214     64      epoll_ctl_old
215     64      epoll_wait_old
216     common  remap_file_pages        sys_remap_file_pages
217     common  getdents64              sys_getdents64
218     common  set_tid_address         sys_set_tid_address
219     common  restart_syscall         sys_restart_syscall
220     common  semtimedop              sys_semtimedop
221     common  fadvise64               sys_fadvise64
222     64      timer_create            sys_timer_create
223     common  timer_settime           sys_timer_settime
224     common  timer_gettime           sys_timer_gettime
225     common  timer_getoverrun        sys_timer_getoverrun
226     common  timer_delete            sys_timer_delete
227     common  clock_settime           sys_clock_settime
228     common  clock_gettime           sys_clock_gettime
229     common  clock_getres            sys_clock_getres
230     common  clock_nanosleep         sys_clock_nanosleep
231     common  exit_group              sys_exit_group
232     common  epoll_wait              sys_epoll_wait
233     common  epoll_ctl               sys_epoll_ctl
234     common  tgkill                  sys_tgkill
235     common  utimes                  sys_utimes
236     64      vserver
237     common  mbind                   sys_mbind
238     common  set_mempolicy           sys_set_mempolicy
239     common  get_mempolicy           sys_get_mempolicy
240     common  mq_open                 sys_mq_open
241     common  mq_unlink               sys_mq_unlink
242     common  mq_timedsend            sys_mq_timedsend
243     common  mq_timedreceive         sys_mq_timedreceive
244     64      mq_notify               sys_mq_notify
245     common  mq_getsetattr           sys_mq_getsetattr
246     64      kexec_load              sys_kexec_load
247     64      waitid                  sys_waitid
248     common  add_key                 sys_add_key
249     common  request_key             sys_request_key
250     common  keyctl                  sys_keyctl
251     common  ioprio_set              sys_ioprio_set
252     common  ioprio_get              sys_ioprio_get
253     common  inotify_init            sys_inotify_init
254     common  inotify_add_watch       sys_inotify_add_watch
255     common  inotify_rm_watch        sys_inotify_rm_watch
256     common  migrate_pages           sys_migrate_pages
257     common  openat                  sys_openat
258     common  mkdirat                 sys_mkdirat
259     common  mknodat                 sys_mknodat
260     common  fchownat                sys_fchownat
261     common  futimesat               sys_futimesat
262     common  newfstatat              sys_newfstatat
263     common  unlinkat                sys_unlinkat
264     common  renameat                sys_renameat
265     common  linkat                  sys_linkat
266     common  symlinkat               sys_symlinkat
267     common  readlinkat              sys_readlinkat
268     common  fchmodat                sys_fchmodat
269     common  faccessat               sys_faccessat
270     common  pselect6                sys_pselect6
271     common  ppoll                   sys_ppoll
272     common  unshare                 sys_unshare
273     64      set_robust_list         sys_set_robust_list
274     64      get_robust_list         sys_get_robust_list
275     common  splice                  sys_splice
276     common  tee                     sys_tee
277     common  sync_file_range         sys_sync_file_range
278     64      vmsplice                sys_vmsplice
279     64      move_pages              sys_move_pages
280     common  utimensat               sys_utimensat
281     common  epoll_pwait             sys_epoll_pwait
282     common  signalfd                sys_signalfd
283     common  timerfd_create          sys_timerfd_create
284     common  eventfd                 sys_eventfd
285     common  fallocate               sys_fallocate
286     common  timerfd_settime         sys_timerfd_settime
287     common  timerfd_gettime         sys_timerfd_gettime
288     common  accept4                 sys_accept4
289     common  signalfd4               sys_signalfd4
290     common  eventfd2                sys_eventfd2
291     common  epoll_create1           sys_epoll_create1
292     common  dup3                    sys_dup3
293     common  pipe2                   sys_pipe2
294     common  inotify_init1           sys_inotify_init1
295     64      preadv                  sys_preadv
296     64      pwritev                 sys_pwritev
297     64      rt_tgsigqueueinfo       sys_rt_tgsigqueueinfo
298     common  perf_event_open         sys_perf_event_open
299     64      recvmmsg                sys_recvmmsg
300     common  fanotify_init           sys_fanotify_init
301     common  fanotify_mark           sys_fanotify_mark
302     common  prlimit64               sys_prlimit64
303     common  name_to_handle_at       sys_name_to_handle_at
304     common  open_by_handle_at       sys_open_by_handle_at
305     common  clock_adjtime           sys_clock_adjtime
306     common  syncfs                  sys_syncfs
307     64      sendmmsg                sys_sendmmsg
308     common  setns                   sys_setns
309     common  getcpu                  sys_getcpu
310     64      process_vm_readv        sys_process_vm_readv
311     64      process_vm_writev       sys_process_vm_writev
312     common  kcmp                    sys_kcmp
313     common  finit_module            sys_finit_module
314     common  sched_setattr           sys_sched_setattr
315     common  sched_getattr           sys_sched_getattr
316     common  renameat2               sys_renameat2
317     common  seccomp                 sys_seccomp
318     common  getrandom               sys_getrandom
319     common  memfd_create            sys_memfd_create
320     common  kexec_file_load         sys_kexec_file_load
321     common  bpf                     sys_bpf
322     64      execveat                sys_execveat
323     common  userfaultfd             sys_userfaultfd
324     common  membarrier              sys_membarrier
325     common  mlock2                  sys_mlock2
326     common  copy_file_range         sys_copy_file_range
327     64      preadv2                 sys_preadv2
328     64      pwritev2                sys_pwritev2
329     common  pkey_mprotect           sys_pkey_mprotect
330     common  pkey_alloc              sys_pkey_alloc
331     common  pkey_free               sys_pkey_free
332     common  statx                   sys_statx
333     common  io_pgetevents           sys_io_pgetevents
334     common  rseq                    sys_rseq
# don't use numbers 387 through 423, add new calls after the last
# 'common' entry
424     common  pidfd_send_signal       sys_pidfd_send_signal
425     common  io_uring_setup          sys_io_uring_setup
426     common  io_uring_enter          sys_io_uring_enter
427     common  io_uring_register       sys_io_uring_register
428     common  open_tree               sys_open_tree
429     common  move_mount              sys_move_mount
430     common  fsopen                  sys_fsopen
431     common  fsconfig                sys_fsconfig
432     common  fsmount                 sys_fsmount
433     common  fspick                  sys_fspick
434     common  pidfd_open              sys_pidfd_open
435     common  clone3                  sys_clone3
436     common  close_range             sys_close_range
437     common  openat2                 sys_openat2
438     common  pidfd_getfd             sys_pidfd_getfd
439     common  faccessat2              sys_faccessat2
440     common  process_madvise         sys_process_madvise
441     common  epoll_pwait2            sys_epoll_pwait2
442     common  mount_setattr           sys_mount_setattr
443     common  quotactl_fd             sys_quotactl_fd
444     common  landlock_create_ruleset sys_landlock_create_ruleset
445     common  landlock_add_rule       sys_landlock_add_rule
446     common  landlock_restrict_self  sys_landlock_restrict_self
447     common  memfd_secret            sys_memfd_secret
448     common  process_mrelease        sys_process_mrelease
449     common  futex_waitv             sys_futex_waitv
450     common  set_mempolicy_home_node sys_set_mempolicy_home_node

#
# Due to a historical design error, certain syscalls are numbered differently
# in x32 as compared to native x86_64.  These syscalls have numbers 512-547.
# Do not add new syscalls to this range.  Numbers 548 and above are available
# for non-x32 use.
#
512     x32     rt_sigaction            compat_sys_rt_sigaction
513     x32     rt_sigreturn            compat_sys_x32_rt_sigreturn
514     x32     ioctl                   compat_sys_ioctl
515     x32     readv                   sys_readv
516     x32     writev                  sys_writev
517     x32     recvfrom                compat_sys_recvfrom
518     x32     sendmsg                 compat_sys_sendmsg
519     x32     recvmsg                 compat_sys_recvmsg
520     x32     execve                  compat_sys_execve
521     x32     ptrace                  compat_sys_ptrace
522     x32     rt_sigpending           compat_sys_rt_sigpending
523     x32     rt_sigtimedwait         compat_sys_rt_sigtimedwait_time64
524     x32     rt_sigqueueinfo         compat_sys_rt_sigqueueinfo
525     x32     sigaltstack             compat_sys_sigaltstack
526     x32     timer_create            compat_sys_timer_create
527     x32     mq_notify               compat_sys_mq_notify
528     x32     kexec_load              compat_sys_kexec_load
529     x32     waitid                  compat_sys_waitid
530     x32     set_robust_list         compat_sys_set_robust_list
531     x32     get_robust_list         compat_sys_get_robust_list
532     x32     vmsplice                sys_vmsplice
533     x32     move_pages              sys_move_pages
534     x32     preadv                  compat_sys_preadv64
535     x32     pwritev                 compat_sys_pwritev64
536     x32     rt_tgsigqueueinfo       compat_sys_rt_tgsigqueueinfo
537     x32     recvmmsg                compat_sys_recvmmsg_time64
538     x32     sendmmsg                compat_sys_sendmmsg
539     x32     process_vm_readv        sys_process_vm_readv
540     x32     process_vm_writev       sys_process_vm_writev
541     x32     setsockopt              sys_setsockopt
542     x32     getsockopt              sys_getsockopt
543     x32     io_setup                compat_sys_io_setup
544     x32     io_submit               compat_sys_io_submit
545     x32     execveat                compat_sys_execveat
546     x32     preadv2                 compat_sys_preadv64v2
547     x32     pwritev2                compat_sys_pwritev64v2
# This is the end of the legacy x32 range.  Numbers 548 and above are
# not special and are not to be used for x32-specific syscalls.
"""


# i386 (native / compat(emulated))
# - arch/x86/entry/syscalls/syscall_32.tbl
x86_syscall_tbl = """
#
# 32-bit system call numbers and entry vectors
#
# The format is:
# <number> <abi> <name> <entry point> <compat entry point>
#
# The __ia32_sys and __ia32_compat_sys stubs are created on-the-fly for
# sys_*() system calls and compat_sys_*() compat system calls if
# IA32_EMULATION is defined, and expect struct pt_regs *regs as their only
# parameter.
#
# The abi is always "i386" for this file.
#
0       i386    restart_syscall         sys_restart_syscall
1       i386    exit                    sys_exit
2       i386    fork                    sys_fork
3       i386    read                    sys_read
4       i386    write                   sys_write
5       i386    open                    sys_open                        compat_sys_open
6       i386    close                   sys_close
7       i386    waitpid                 sys_waitpid
8       i386    creat                   sys_creat
9       i386    link                    sys_link
10      i386    unlink                  sys_unlink
11      i386    execve                  sys_execve                      compat_sys_execve
12      i386    chdir                   sys_chdir
13      i386    time                    sys_time32
14      i386    mknod                   sys_mknod
15      i386    chmod                   sys_chmod
16      i386    lchown                  sys_lchown16
17      i386    break
18      i386    oldstat                 sys_stat
19      i386    lseek                   sys_lseek                       compat_sys_lseek
20      i386    getpid                  sys_getpid
21      i386    mount                   sys_mount
22      i386    umount                  sys_oldumount
23      i386    setuid                  sys_setuid16
24      i386    getuid                  sys_getuid16
25      i386    stime                   sys_stime32
26      i386    ptrace                  sys_ptrace                      compat_sys_ptrace
27      i386    alarm                   sys_alarm
28      i386    oldfstat                sys_fstat
29      i386    pause                   sys_pause
30      i386    utime                   sys_utime32
31      i386    stty
32      i386    gtty
33      i386    access                  sys_access
34      i386    nice                    sys_nice
35      i386    ftime
36      i386    sync                    sys_sync
37      i386    kill                    sys_kill
38      i386    rename                  sys_rename
39      i386    mkdir                   sys_mkdir
40      i386    rmdir                   sys_rmdir
41      i386    dup                     sys_dup
42      i386    pipe                    sys_pipe
43      i386    times                   sys_times                       compat_sys_times
44      i386    prof
45      i386    brk                     sys_brk
46      i386    setgid                  sys_setgid16
47      i386    getgid                  sys_getgid16
48      i386    signal                  sys_signal
49      i386    geteuid                 sys_geteuid16
50      i386    getegid                 sys_getegid16
51      i386    acct                    sys_acct
52      i386    umount2                 sys_umount
53      i386    lock
54      i386    ioctl                   sys_ioctl                       compat_sys_ioctl
55      i386    fcntl                   sys_fcntl                       compat_sys_fcntl64
56      i386    mpx
57      i386    setpgid                 sys_setpgid
58      i386    ulimit
59      i386    oldolduname             sys_olduname
60      i386    umask                   sys_umask
61      i386    chroot                  sys_chroot
62      i386    ustat                   sys_ustat                       compat_sys_ustat
63      i386    dup2                    sys_dup2
64      i386    getppid                 sys_getppid
65      i386    getpgrp                 sys_getpgrp
66      i386    setsid                  sys_setsid
67      i386    sigaction               sys_sigaction                   compat_sys_sigaction
68      i386    sgetmask                sys_sgetmask
69      i386    ssetmask                sys_ssetmask
70      i386    setreuid                sys_setreuid16
71      i386    setregid                sys_setregid16
72      i386    sigsuspend              sys_sigsuspend
73      i386    sigpending              sys_sigpending                  compat_sys_sigpending
74      i386    sethostname             sys_sethostname
75      i386    setrlimit               sys_setrlimit                   compat_sys_setrlimit
76      i386    getrlimit               sys_old_getrlimit               compat_sys_old_getrlimit
77      i386    getrusage               sys_getrusage                   compat_sys_getrusage
78      i386    gettimeofday            sys_gettimeofday                compat_sys_gettimeofday
79      i386    settimeofday            sys_settimeofday                compat_sys_settimeofday
80      i386    getgroups               sys_getgroups16
81      i386    setgroups               sys_setgroups16
82      i386    select                  sys_old_select                  compat_sys_old_select
83      i386    symlink                 sys_symlink
84      i386    oldlstat                sys_lstat
85      i386    readlink                sys_readlink
86      i386    uselib                  sys_uselib
87      i386    swapon                  sys_swapon
88      i386    reboot                  sys_reboot
89      i386    readdir                 sys_old_readdir                 compat_sys_old_readdir
90      i386    mmap                    sys_old_mmap                    compat_sys_ia32_mmap
91      i386    munmap                  sys_munmap
92      i386    truncate                sys_truncate                    compat_sys_truncate
93      i386    ftruncate               sys_ftruncate                   compat_sys_ftruncate
94      i386    fchmod                  sys_fchmod
95      i386    fchown                  sys_fchown16
96      i386    getpriority             sys_getpriority
97      i386    setpriority             sys_setpriority
98      i386    profil
99      i386    statfs                  sys_statfs                      compat_sys_statfs
100     i386    fstatfs                 sys_fstatfs                     compat_sys_fstatfs
101     i386    ioperm                  sys_ioperm
102     i386    socketcall              sys_socketcall                  compat_sys_socketcall
103     i386    syslog                  sys_syslog
104     i386    setitimer               sys_setitimer                   compat_sys_setitimer
105     i386    getitimer               sys_getitimer                   compat_sys_getitimer
106     i386    stat                    sys_newstat                     compat_sys_newstat
107     i386    lstat                   sys_newlstat                    compat_sys_newlstat
108     i386    fstat                   sys_newfstat                    compat_sys_newfstat
109     i386    olduname                sys_uname
110     i386    iopl                    sys_iopl
111     i386    vhangup                 sys_vhangup
112     i386    idle
113     i386    vm86old                 sys_vm86old                     sys_ni_syscall
114     i386    wait4                   sys_wait4                       compat_sys_wait4
115     i386    swapoff                 sys_swapoff
116     i386    sysinfo                 sys_sysinfo                     compat_sys_sysinfo
117     i386    ipc                     sys_ipc                         compat_sys_ipc
118     i386    fsync                   sys_fsync
119     i386    sigreturn               sys_sigreturn                   compat_sys_sigreturn
120     i386    clone                   sys_clone                       compat_sys_ia32_clone
121     i386    setdomainname           sys_setdomainname
122     i386    uname                   sys_newuname
123     i386    modify_ldt              sys_modify_ldt
124     i386    adjtimex                sys_adjtimex_time32
125     i386    mprotect                sys_mprotect
126     i386    sigprocmask             sys_sigprocmask                 compat_sys_sigprocmask
127     i386    create_module
128     i386    init_module             sys_init_module
129     i386    delete_module           sys_delete_module
130     i386    get_kernel_syms
131     i386    quotactl                sys_quotactl
132     i386    getpgid                 sys_getpgid
133     i386    fchdir                  sys_fchdir
134     i386    bdflush                 sys_ni_syscall
135     i386    sysfs                   sys_sysfs
136     i386    personality             sys_personality
137     i386    afs_syscall
138     i386    setfsuid                sys_setfsuid16
139     i386    setfsgid                sys_setfsgid16
140     i386    _llseek                 sys_llseek
141     i386    getdents                sys_getdents                    compat_sys_getdents
142     i386    _newselect              sys_select                      compat_sys_select
143     i386    flock                   sys_flock
144     i386    msync                   sys_msync
145     i386    readv                   sys_readv
146     i386    writev                  sys_writev
147     i386    getsid                  sys_getsid
148     i386    fdatasync               sys_fdatasync
149     i386    _sysctl                 sys_ni_syscall
150     i386    mlock                   sys_mlock
151     i386    munlock                 sys_munlock
152     i386    mlockall                sys_mlockall
153     i386    munlockall              sys_munlockall
154     i386    sched_setparam          sys_sched_setparam
155     i386    sched_getparam          sys_sched_getparam
156     i386    sched_setscheduler      sys_sched_setscheduler
157     i386    sched_getscheduler      sys_sched_getscheduler
158     i386    sched_yield             sys_sched_yield
159     i386    sched_get_priority_max  sys_sched_get_priority_max
160     i386    sched_get_priority_min  sys_sched_get_priority_min
161     i386    sched_rr_get_interval   sys_sched_rr_get_interval_time32
162     i386    nanosleep               sys_nanosleep_time32
163     i386    mremap                  sys_mremap
164     i386    setresuid               sys_setresuid16
165     i386    getresuid               sys_getresuid16
166     i386    vm86                    sys_vm86                        sys_ni_syscall
167     i386    query_module
168     i386    poll                    sys_poll
169     i386    nfsservctl
170     i386    setresgid               sys_setresgid16
171     i386    getresgid               sys_getresgid16
172     i386    prctl                   sys_prctl
173     i386    rt_sigreturn            sys_rt_sigreturn                compat_sys_rt_sigreturn
174     i386    rt_sigaction            sys_rt_sigaction                compat_sys_rt_sigaction
175     i386    rt_sigprocmask          sys_rt_sigprocmask              compat_sys_rt_sigprocmask
176     i386    rt_sigpending           sys_rt_sigpending               compat_sys_rt_sigpending
177     i386    rt_sigtimedwait         sys_rt_sigtimedwait_time32      compat_sys_rt_sigtimedwait_time32
178     i386    rt_sigqueueinfo         sys_rt_sigqueueinfo             compat_sys_rt_sigqueueinfo
179     i386    rt_sigsuspend           sys_rt_sigsuspend               compat_sys_rt_sigsuspend
180     i386    pread64                 sys_ia32_pread64
181     i386    pwrite64                sys_ia32_pwrite64
182     i386    chown                   sys_chown16
183     i386    getcwd                  sys_getcwd
184     i386    capget                  sys_capget
185     i386    capset                  sys_capset
186     i386    sigaltstack             sys_sigaltstack                 compat_sys_sigaltstack
187     i386    sendfile                sys_sendfile                    compat_sys_sendfile
188     i386    getpmsg
189     i386    putpmsg
190     i386    vfork                   sys_vfork
191     i386    ugetrlimit              sys_getrlimit                   compat_sys_getrlimit
192     i386    mmap2                   sys_mmap_pgoff
193     i386    truncate64              sys_ia32_truncate64
194     i386    ftruncate64             sys_ia32_ftruncate64
195     i386    stat64                  sys_stat64                      compat_sys_ia32_stat64
196     i386    lstat64                 sys_lstat64                     compat_sys_ia32_lstat64
197     i386    fstat64                 sys_fstat64                     compat_sys_ia32_fstat64
198     i386    lchown32                sys_lchown
199     i386    getuid32                sys_getuid
200     i386    getgid32                sys_getgid
201     i386    geteuid32               sys_geteuid
202     i386    getegid32               sys_getegid
203     i386    setreuid32              sys_setreuid
204     i386    setregid32              sys_setregid
205     i386    getgroups32             sys_getgroups
206     i386    setgroups32             sys_setgroups
207     i386    fchown32                sys_fchown
208     i386    setresuid32             sys_setresuid
209     i386    getresuid32             sys_getresuid
210     i386    setresgid32             sys_setresgid
211     i386    getresgid32             sys_getresgid
212     i386    chown32                 sys_chown
213     i386    setuid32                sys_setuid
214     i386    setgid32                sys_setgid
215     i386    setfsuid32              sys_setfsuid
216     i386    setfsgid32              sys_setfsgid
217     i386    pivot_root              sys_pivot_root
218     i386    mincore                 sys_mincore
219     i386    madvise                 sys_madvise
220     i386    getdents64              sys_getdents64
221     i386    fcntl64                 sys_fcntl64                     compat_sys_fcntl64
# 222 is unused
# 223 is unused
224     i386    gettid                  sys_gettid
225     i386    readahead               sys_ia32_readahead
226     i386    setxattr                sys_setxattr
227     i386    lsetxattr               sys_lsetxattr
228     i386    fsetxattr               sys_fsetxattr
229     i386    getxattr                sys_getxattr
230     i386    lgetxattr               sys_lgetxattr
231     i386    fgetxattr               sys_fgetxattr
232     i386    listxattr               sys_listxattr
233     i386    llistxattr              sys_llistxattr
234     i386    flistxattr              sys_flistxattr
235     i386    removexattr             sys_removexattr
236     i386    lremovexattr            sys_lremovexattr
237     i386    fremovexattr            sys_fremovexattr
238     i386    tkill                   sys_tkill
239     i386    sendfile64              sys_sendfile64
240     i386    futex                   sys_futex_time32
241     i386    sched_setaffinity       sys_sched_setaffinity           compat_sys_sched_setaffinity
242     i386    sched_getaffinity       sys_sched_getaffinity           compat_sys_sched_getaffinity
243     i386    set_thread_area         sys_set_thread_area
244     i386    get_thread_area         sys_get_thread_area
245     i386    io_setup                sys_io_setup                    compat_sys_io_setup
246     i386    io_destroy              sys_io_destroy
247     i386    io_getevents            sys_io_getevents_time32
248     i386    io_submit               sys_io_submit                   compat_sys_io_submit
249     i386    io_cancel               sys_io_cancel
250     i386    fadvise64               sys_ia32_fadvise64
# 251 is available for reuse (was briefly sys_set_zone_reclaim)
252     i386    exit_group              sys_exit_group
253     i386    lookup_dcookie          sys_lookup_dcookie              compat_sys_lookup_dcookie
254     i386    epoll_create            sys_epoll_create
255     i386    epoll_ctl               sys_epoll_ctl
256     i386    epoll_wait              sys_epoll_wait
257     i386    remap_file_pages        sys_remap_file_pages
258     i386    set_tid_address         sys_set_tid_address
259     i386    timer_create            sys_timer_create                compat_sys_timer_create
260     i386    timer_settime           sys_timer_settime32
261     i386    timer_gettime           sys_timer_gettime32
262     i386    timer_getoverrun        sys_timer_getoverrun
263     i386    timer_delete            sys_timer_delete
264     i386    clock_settime           sys_clock_settime32
265     i386    clock_gettime           sys_clock_gettime32
266     i386    clock_getres            sys_clock_getres_time32
267     i386    clock_nanosleep         sys_clock_nanosleep_time32
268     i386    statfs64                sys_statfs64                    compat_sys_statfs64
269     i386    fstatfs64               sys_fstatfs64                   compat_sys_fstatfs64
270     i386    tgkill                  sys_tgkill
271     i386    utimes                  sys_utimes_time32
272     i386    fadvise64_64            sys_ia32_fadvise64_64
273     i386    vserver
274     i386    mbind                   sys_mbind
275     i386    get_mempolicy           sys_get_mempolicy
276     i386    set_mempolicy           sys_set_mempolicy
277     i386    mq_open                 sys_mq_open                     compat_sys_mq_open
278     i386    mq_unlink               sys_mq_unlink
279     i386    mq_timedsend            sys_mq_timedsend_time32
280     i386    mq_timedreceive         sys_mq_timedreceive_time32
281     i386    mq_notify               sys_mq_notify                   compat_sys_mq_notify
282     i386    mq_getsetattr           sys_mq_getsetattr               compat_sys_mq_getsetattr
283     i386    kexec_load              sys_kexec_load                  compat_sys_kexec_load
284     i386    waitid                  sys_waitid                      compat_sys_waitid
# 285 sys_setaltroot
286     i386    add_key                 sys_add_key
287     i386    request_key             sys_request_key
288     i386    keyctl                  sys_keyctl                      compat_sys_keyctl
289     i386    ioprio_set              sys_ioprio_set
290     i386    ioprio_get              sys_ioprio_get
291     i386    inotify_init            sys_inotify_init
292     i386    inotify_add_watch       sys_inotify_add_watch
293     i386    inotify_rm_watch        sys_inotify_rm_watch
294     i386    migrate_pages           sys_migrate_pages
295     i386    openat                  sys_openat                      compat_sys_openat
296     i386    mkdirat                 sys_mkdirat
297     i386    mknodat                 sys_mknodat
298     i386    fchownat                sys_fchownat
299     i386    futimesat               sys_futimesat_time32
300     i386    fstatat64               sys_fstatat64                   compat_sys_ia32_fstatat64
301     i386    unlinkat                sys_unlinkat
302     i386    renameat                sys_renameat
303     i386    linkat                  sys_linkat
304     i386    symlinkat               sys_symlinkat
305     i386    readlinkat              sys_readlinkat
306     i386    fchmodat                sys_fchmodat
307     i386    faccessat               sys_faccessat
308     i386    pselect6                sys_pselect6_time32             compat_sys_pselect6_time32
309     i386    ppoll                   sys_ppoll_time32                compat_sys_ppoll_time32
310     i386    unshare                 sys_unshare
311     i386    set_robust_list         sys_set_robust_list             compat_sys_set_robust_list
312     i386    get_robust_list         sys_get_robust_list             compat_sys_get_robust_list
313     i386    splice                  sys_splice
314     i386    sync_file_range         sys_ia32_sync_file_range
315     i386    tee                     sys_tee
316     i386    vmsplice                sys_vmsplice
317     i386    move_pages              sys_move_pages
318     i386    getcpu                  sys_getcpu
319     i386    epoll_pwait             sys_epoll_pwait
320     i386    utimensat               sys_utimensat_time32
321     i386    signalfd                sys_signalfd                    compat_sys_signalfd
322     i386    timerfd_create          sys_timerfd_create
323     i386    eventfd                 sys_eventfd
324     i386    fallocate               sys_ia32_fallocate
325     i386    timerfd_settime         sys_timerfd_settime32
326     i386    timerfd_gettime         sys_timerfd_gettime32
327     i386    signalfd4               sys_signalfd4                   compat_sys_signalfd4
328     i386    eventfd2                sys_eventfd2
329     i386    epoll_create1           sys_epoll_create1
330     i386    dup3                    sys_dup3
331     i386    pipe2                   sys_pipe2
332     i386    inotify_init1           sys_inotify_init1
333     i386    preadv                  sys_preadv                      compat_sys_preadv
334     i386    pwritev                 sys_pwritev                     compat_sys_pwritev
335     i386    rt_tgsigqueueinfo       sys_rt_tgsigqueueinfo           compat_sys_rt_tgsigqueueinfo
336     i386    perf_event_open         sys_perf_event_open
337     i386    recvmmsg                sys_recvmmsg_time32             compat_sys_recvmmsg_time32
338     i386    fanotify_init           sys_fanotify_init
339     i386    fanotify_mark           sys_fanotify_mark               compat_sys_fanotify_mark
340     i386    prlimit64               sys_prlimit64
341     i386    name_to_handle_at       sys_name_to_handle_at
342     i386    open_by_handle_at       sys_open_by_handle_at           compat_sys_open_by_handle_at
343     i386    clock_adjtime           sys_clock_adjtime32
344     i386    syncfs                  sys_syncfs
345     i386    sendmmsg                sys_sendmmsg                    compat_sys_sendmmsg
346     i386    setns                   sys_setns
347     i386    process_vm_readv        sys_process_vm_readv
348     i386    process_vm_writev       sys_process_vm_writev
349     i386    kcmp                    sys_kcmp
350     i386    finit_module            sys_finit_module
351     i386    sched_setattr           sys_sched_setattr
352     i386    sched_getattr           sys_sched_getattr
353     i386    renameat2               sys_renameat2
354     i386    seccomp                 sys_seccomp
355     i386    getrandom               sys_getrandom
356     i386    memfd_create            sys_memfd_create
357     i386    bpf                     sys_bpf
358     i386    execveat                sys_execveat                    compat_sys_execveat
359     i386    socket                  sys_socket
360     i386    socketpair              sys_socketpair
361     i386    bind                    sys_bind
362     i386    connect                 sys_connect
363     i386    listen                  sys_listen
364     i386    accept4                 sys_accept4
365     i386    getsockopt              sys_getsockopt                  sys_getsockopt
366     i386    setsockopt              sys_setsockopt                  sys_setsockopt
367     i386    getsockname             sys_getsockname
368     i386    getpeername             sys_getpeername
369     i386    sendto                  sys_sendto
370     i386    sendmsg                 sys_sendmsg                     compat_sys_sendmsg
371     i386    recvfrom                sys_recvfrom                    compat_sys_recvfrom
372     i386    recvmsg                 sys_recvmsg                     compat_sys_recvmsg
373     i386    shutdown                sys_shutdown
374     i386    userfaultfd             sys_userfaultfd
375     i386    membarrier              sys_membarrier
376     i386    mlock2                  sys_mlock2
377     i386    copy_file_range         sys_copy_file_range
378     i386    preadv2                 sys_preadv2                     compat_sys_preadv2
379     i386    pwritev2                sys_pwritev2                    compat_sys_pwritev2
380     i386    pkey_mprotect           sys_pkey_mprotect
381     i386    pkey_alloc              sys_pkey_alloc
382     i386    pkey_free               sys_pkey_free
383     i386    statx                   sys_statx
384     i386    arch_prctl              sys_arch_prctl                  compat_sys_arch_prctl
385     i386    io_pgetevents           sys_io_pgetevents_time32        compat_sys_io_pgetevents
386     i386    rseq                    sys_rseq
393     i386    semget                  sys_semget
394     i386    semctl                  sys_semctl                      compat_sys_semctl
395     i386    shmget                  sys_shmget
396     i386    shmctl                  sys_shmctl                      compat_sys_shmctl
397     i386    shmat                   sys_shmat                       compat_sys_shmat
398     i386    shmdt                   sys_shmdt
399     i386    msgget                  sys_msgget
400     i386    msgsnd                  sys_msgsnd                      compat_sys_msgsnd
401     i386    msgrcv                  sys_msgrcv                      compat_sys_msgrcv
402     i386    msgctl                  sys_msgctl                      compat_sys_msgctl
403     i386    clock_gettime64         sys_clock_gettime
404     i386    clock_settime64         sys_clock_settime
405     i386    clock_adjtime64         sys_clock_adjtime
406     i386    clock_getres_time64     sys_clock_getres
407     i386    clock_nanosleep_time64  sys_clock_nanosleep
408     i386    timer_gettime64         sys_timer_gettime
409     i386    timer_settime64         sys_timer_settime
410     i386    timerfd_gettime64       sys_timerfd_gettime
411     i386    timerfd_settime64       sys_timerfd_settime
412     i386    utimensat_time64        sys_utimensat
413     i386    pselect6_time64         sys_pselect6                    compat_sys_pselect6_time64
414     i386    ppoll_time64            sys_ppoll                       compat_sys_ppoll_time64
416     i386    io_pgetevents_time64    sys_io_pgetevents
417     i386    recvmmsg_time64         sys_recvmmsg                    compat_sys_recvmmsg_time64
418     i386    mq_timedsend_time64     sys_mq_timedsend
419     i386    mq_timedreceive_time64  sys_mq_timedreceive
420     i386    semtimedop_time64       sys_semtimedop
421     i386    rt_sigtimedwait_time64  sys_rt_sigtimedwait             compat_sys_rt_sigtimedwait_time64
422     i386    futex_time64            sys_futex
423     i386    sched_rr_get_interval_time64    sys_sched_rr_get_interval
424     i386    pidfd_send_signal       sys_pidfd_send_signal
425     i386    io_uring_setup          sys_io_uring_setup
426     i386    io_uring_enter          sys_io_uring_enter
427     i386    io_uring_register       sys_io_uring_register
428     i386    open_tree               sys_open_tree
429     i386    move_mount              sys_move_mount
430     i386    fsopen                  sys_fsopen
431     i386    fsconfig                sys_fsconfig
432     i386    fsmount                 sys_fsmount
433     i386    fspick                  sys_fspick
434     i386    pidfd_open              sys_pidfd_open
435     i386    clone3                  sys_clone3
436     i386    close_range             sys_close_range
437     i386    openat2                 sys_openat2
438     i386    pidfd_getfd             sys_pidfd_getfd
439     i386    faccessat2              sys_faccessat2
440     i386    process_madvise         sys_process_madvise
441     i386    epoll_pwait2            sys_epoll_pwait2                compat_sys_epoll_pwait2
442     i386    mount_setattr           sys_mount_setattr
443     i386    quotactl_fd             sys_quotactl_fd
444     i386    landlock_create_ruleset sys_landlock_create_ruleset
445     i386    landlock_add_rule       sys_landlock_add_rule
446     i386    landlock_restrict_self  sys_landlock_restrict_self
447     i386    memfd_secret            sys_memfd_secret
448     i386    process_mrelease        sys_process_mrelease
449     i386    futex_waitv             sys_futex_waitv
450     i386    set_mempolicy_home_node         sys_set_mempolicy_home_node
"""


# ARM64
#
# [How to make]
# cd /path/to/linux-6.*/
# gcc -I `pwd`/include/uapi/ -E -D__SYSCALL=SYSCALL arch/arm64/include/uapi/asm/unistd.h \
# | grep ^SYSCALL | sed -e 's/SYSCALL(//;s/[,)]//g' > /tmp/a
# grep -oP "__NR\S+\s+\d+$" include/uapi/asm-generic/unistd.h | grep -v __NR_sync_file_range2 > /tmp/b
# join -2 2 -o 1.1,1.10,2.1,1.2 -e arm64 /tmp/a /tmp/b | sed -e 's/\(__NR_\|__NR3264_\)//g' | column -t
#
arm64_syscall_tbl = """
0    arm64  io_setup                 sys_io_setup
1    arm64  io_destroy               sys_io_destroy
2    arm64  io_submit                sys_io_submit
3    arm64  io_cancel                sys_io_cancel
4    arm64  io_getevents             sys_io_getevents
5    arm64  setxattr                 sys_setxattr
6    arm64  lsetxattr                sys_lsetxattr
7    arm64  fsetxattr                sys_fsetxattr
8    arm64  getxattr                 sys_getxattr
9    arm64  lgetxattr                sys_lgetxattr
10   arm64  fgetxattr                sys_fgetxattr
11   arm64  listxattr                sys_listxattr
12   arm64  llistxattr               sys_llistxattr
13   arm64  flistxattr               sys_flistxattr
14   arm64  removexattr              sys_removexattr
15   arm64  lremovexattr             sys_lremovexattr
16   arm64  fremovexattr             sys_fremovexattr
17   arm64  getcwd                   sys_getcwd
18   arm64  lookup_dcookie           sys_lookup_dcookie
19   arm64  eventfd2                 sys_eventfd2
20   arm64  epoll_create1            sys_epoll_create1
21   arm64  epoll_ctl                sys_epoll_ctl
22   arm64  epoll_pwait              sys_epoll_pwait
23   arm64  dup                      sys_dup
24   arm64  dup3                     sys_dup3
25   arm64  fcntl                    sys_fcntl
26   arm64  inotify_init1            sys_inotify_init1
27   arm64  inotify_add_watch        sys_inotify_add_watch
28   arm64  inotify_rm_watch         sys_inotify_rm_watch
29   arm64  ioctl                    sys_ioctl
30   arm64  ioprio_set               sys_ioprio_set
31   arm64  ioprio_get               sys_ioprio_get
32   arm64  flock                    sys_flock
33   arm64  mknodat                  sys_mknodat
34   arm64  mkdirat                  sys_mkdirat
35   arm64  unlinkat                 sys_unlinkat
36   arm64  symlinkat                sys_symlinkat
37   arm64  linkat                   sys_linkat
38   arm64  renameat                 sys_renameat
39   arm64  umount2                  sys_umount
40   arm64  mount                    sys_mount
41   arm64  pivot_root               sys_pivot_root
42   arm64  nfsservctl               sys_ni_syscall
43   arm64  statfs                   sys_statfs
44   arm64  fstatfs                  sys_fstatfs
45   arm64  truncate                 sys_truncate
46   arm64  ftruncate                sys_ftruncate
47   arm64  fallocate                sys_fallocate
48   arm64  faccessat                sys_faccessat
49   arm64  chdir                    sys_chdir
50   arm64  fchdir                   sys_fchdir
51   arm64  chroot                   sys_chroot
52   arm64  fchmod                   sys_fchmod
53   arm64  fchmodat                 sys_fchmodat
54   arm64  fchownat                 sys_fchownat
55   arm64  fchown                   sys_fchown
56   arm64  openat                   sys_openat
57   arm64  close                    sys_close
58   arm64  vhangup                  sys_vhangup
59   arm64  pipe2                    sys_pipe2
60   arm64  quotactl                 sys_quotactl
61   arm64  getdents64               sys_getdents64
62   arm64  lseek                    sys_lseek
63   arm64  read                     sys_read
64   arm64  write                    sys_write
65   arm64  readv                    sys_readv
66   arm64  writev                   sys_writev
67   arm64  pread64                  sys_pread64
68   arm64  pwrite64                 sys_pwrite64
69   arm64  preadv                   sys_preadv
70   arm64  pwritev                  sys_pwritev
71   arm64  sendfile                 sys_sendfile64
72   arm64  pselect6                 sys_pselect6
73   arm64  ppoll                    sys_ppoll
74   arm64  signalfd4                sys_signalfd4
75   arm64  vmsplice                 sys_vmsplice
76   arm64  splice                   sys_splice
77   arm64  tee                      sys_tee
78   arm64  readlinkat               sys_readlinkat
79   arm64  fstatat                  sys_newfstatat
80   arm64  fstat                    sys_newfstat
81   arm64  sync                     sys_sync
82   arm64  fsync                    sys_fsync
83   arm64  fdatasync                sys_fdatasync
84   arm64  sync_file_range          sys_sync_file_range
85   arm64  timerfd_create           sys_timerfd_create
86   arm64  timerfd_settime          sys_timerfd_settime
87   arm64  timerfd_gettime          sys_timerfd_gettime
88   arm64  utimensat                sys_utimensat
89   arm64  acct                     sys_acct
90   arm64  capget                   sys_capget
91   arm64  capset                   sys_capset
92   arm64  personality              sys_personality
93   arm64  exit                     sys_exit
94   arm64  exit_group               sys_exit_group
95   arm64  waitid                   sys_waitid
96   arm64  set_tid_address          sys_set_tid_address
97   arm64  unshare                  sys_unshare
98   arm64  futex                    sys_futex
99   arm64  set_robust_list          sys_set_robust_list
100  arm64  get_robust_list          sys_get_robust_list
101  arm64  nanosleep                sys_nanosleep
102  arm64  getitimer                sys_getitimer
103  arm64  setitimer                sys_setitimer
104  arm64  kexec_load               sys_kexec_load
105  arm64  init_module              sys_init_module
106  arm64  delete_module            sys_delete_module
107  arm64  timer_create             sys_timer_create
108  arm64  timer_gettime            sys_timer_gettime
109  arm64  timer_getoverrun         sys_timer_getoverrun
110  arm64  timer_settime            sys_timer_settime
111  arm64  timer_delete             sys_timer_delete
112  arm64  clock_settime            sys_clock_settime
113  arm64  clock_gettime            sys_clock_gettime
114  arm64  clock_getres             sys_clock_getres
115  arm64  clock_nanosleep          sys_clock_nanosleep
116  arm64  syslog                   sys_syslog
117  arm64  ptrace                   sys_ptrace
118  arm64  sched_setparam           sys_sched_setparam
119  arm64  sched_setscheduler       sys_sched_setscheduler
120  arm64  sched_getscheduler       sys_sched_getscheduler
121  arm64  sched_getparam           sys_sched_getparam
122  arm64  sched_setaffinity        sys_sched_setaffinity
123  arm64  sched_getaffinity        sys_sched_getaffinity
124  arm64  sched_yield              sys_sched_yield
125  arm64  sched_get_priority_max   sys_sched_get_priority_max
126  arm64  sched_get_priority_min   sys_sched_get_priority_min
127  arm64  sched_rr_get_interval    sys_sched_rr_get_interval
128  arm64  restart_syscall          sys_restart_syscall
129  arm64  kill                     sys_kill
130  arm64  tkill                    sys_tkill
131  arm64  tgkill                   sys_tgkill
132  arm64  sigaltstack              sys_sigaltstack
133  arm64  rt_sigsuspend            sys_rt_sigsuspend
134  arm64  rt_sigaction             sys_rt_sigaction
135  arm64  rt_sigprocmask           sys_rt_sigprocmask
136  arm64  rt_sigpending            sys_rt_sigpending
137  arm64  rt_sigtimedwait          sys_rt_sigtimedwait
138  arm64  rt_sigqueueinfo          sys_rt_sigqueueinfo
139  arm64  rt_sigreturn             sys_rt_sigreturn
140  arm64  setpriority              sys_setpriority
141  arm64  getpriority              sys_getpriority
142  arm64  reboot                   sys_reboot
143  arm64  setregid                 sys_setregid
144  arm64  setgid                   sys_setgid
145  arm64  setreuid                 sys_setreuid
146  arm64  setuid                   sys_setuid
147  arm64  setresuid                sys_setresuid
148  arm64  getresuid                sys_getresuid
149  arm64  setresgid                sys_setresgid
150  arm64  getresgid                sys_getresgid
151  arm64  setfsuid                 sys_setfsuid
152  arm64  setfsgid                 sys_setfsgid
153  arm64  times                    sys_times
154  arm64  setpgid                  sys_setpgid
155  arm64  getpgid                  sys_getpgid
156  arm64  getsid                   sys_getsid
157  arm64  setsid                   sys_setsid
158  arm64  getgroups                sys_getgroups
159  arm64  setgroups                sys_setgroups
160  arm64  uname                    sys_newuname
161  arm64  sethostname              sys_sethostname
162  arm64  setdomainname            sys_setdomainname
163  arm64  getrlimit                sys_getrlimit
164  arm64  setrlimit                sys_setrlimit
165  arm64  getrusage                sys_getrusage
166  arm64  umask                    sys_umask
167  arm64  prctl                    sys_prctl
168  arm64  getcpu                   sys_getcpu
169  arm64  gettimeofday             sys_gettimeofday
170  arm64  settimeofday             sys_settimeofday
171  arm64  adjtimex                 sys_adjtimex
172  arm64  getpid                   sys_getpid
173  arm64  getppid                  sys_getppid
174  arm64  getuid                   sys_getuid
175  arm64  geteuid                  sys_geteuid
176  arm64  getgid                   sys_getgid
177  arm64  getegid                  sys_getegid
178  arm64  gettid                   sys_gettid
179  arm64  sysinfo                  sys_sysinfo
180  arm64  mq_open                  sys_mq_open
181  arm64  mq_unlink                sys_mq_unlink
182  arm64  mq_timedsend             sys_mq_timedsend
183  arm64  mq_timedreceive          sys_mq_timedreceive
184  arm64  mq_notify                sys_mq_notify
185  arm64  mq_getsetattr            sys_mq_getsetattr
186  arm64  msgget                   sys_msgget
187  arm64  msgctl                   sys_msgctl
188  arm64  msgrcv                   sys_msgrcv
189  arm64  msgsnd                   sys_msgsnd
190  arm64  semget                   sys_semget
191  arm64  semctl                   sys_semctl
192  arm64  semtimedop               sys_semtimedop
193  arm64  semop                    sys_semop
194  arm64  shmget                   sys_shmget
195  arm64  shmctl                   sys_shmctl
196  arm64  shmat                    sys_shmat
197  arm64  shmdt                    sys_shmdt
198  arm64  socket                   sys_socket
199  arm64  socketpair               sys_socketpair
200  arm64  bind                     sys_bind
201  arm64  listen                   sys_listen
202  arm64  accept                   sys_accept
203  arm64  connect                  sys_connect
204  arm64  getsockname              sys_getsockname
205  arm64  getpeername              sys_getpeername
206  arm64  sendto                   sys_sendto
207  arm64  recvfrom                 sys_recvfrom
208  arm64  setsockopt               sys_setsockopt
209  arm64  getsockopt               sys_getsockopt
210  arm64  shutdown                 sys_shutdown
211  arm64  sendmsg                  sys_sendmsg
212  arm64  recvmsg                  sys_recvmsg
213  arm64  readahead                sys_readahead
214  arm64  brk                      sys_brk
215  arm64  munmap                   sys_munmap
216  arm64  mremap                   sys_mremap
217  arm64  add_key                  sys_add_key
218  arm64  request_key              sys_request_key
219  arm64  keyctl                   sys_keyctl
220  arm64  clone                    sys_clone
221  arm64  execve                   sys_execve
222  arm64  mmap                     sys_mmap
223  arm64  fadvise64                sys_fadvise64_64
224  arm64  swapon                   sys_swapon
225  arm64  swapoff                  sys_swapoff
226  arm64  mprotect                 sys_mprotect
227  arm64  msync                    sys_msync
228  arm64  mlock                    sys_mlock
229  arm64  munlock                  sys_munlock
230  arm64  mlockall                 sys_mlockall
231  arm64  munlockall               sys_munlockall
232  arm64  mincore                  sys_mincore
233  arm64  madvise                  sys_madvise
234  arm64  remap_file_pages         sys_remap_file_pages
235  arm64  mbind                    sys_mbind
236  arm64  get_mempolicy            sys_get_mempolicy
237  arm64  set_mempolicy            sys_set_mempolicy
238  arm64  migrate_pages            sys_migrate_pages
239  arm64  move_pages               sys_move_pages
240  arm64  rt_tgsigqueueinfo        sys_rt_tgsigqueueinfo
241  arm64  perf_event_open          sys_perf_event_open
242  arm64  accept4                  sys_accept4
243  arm64  recvmmsg                 sys_recvmmsg
260  arm64  wait4                    sys_wait4
261  arm64  prlimit64                sys_prlimit64
262  arm64  fanotify_init            sys_fanotify_init
263  arm64  fanotify_mark            sys_fanotify_mark
264  arm64  name_to_handle_at        sys_name_to_handle_at
265  arm64  open_by_handle_at        sys_open_by_handle_at
266  arm64  clock_adjtime            sys_clock_adjtime
267  arm64  syncfs                   sys_syncfs
268  arm64  setns                    sys_setns
269  arm64  sendmmsg                 sys_sendmmsg
270  arm64  process_vm_readv         sys_process_vm_readv
271  arm64  process_vm_writev        sys_process_vm_writev
272  arm64  kcmp                     sys_kcmp
273  arm64  finit_module             sys_finit_module
274  arm64  sched_setattr            sys_sched_setattr
275  arm64  sched_getattr            sys_sched_getattr
276  arm64  renameat2                sys_renameat2
277  arm64  seccomp                  sys_seccomp
278  arm64  getrandom                sys_getrandom
279  arm64  memfd_create             sys_memfd_create
280  arm64  bpf                      sys_bpf
281  arm64  execveat                 sys_execveat
282  arm64  userfaultfd              sys_userfaultfd
283  arm64  membarrier               sys_membarrier
284  arm64  mlock2                   sys_mlock2
285  arm64  copy_file_range          sys_copy_file_range
286  arm64  preadv2                  sys_preadv2
287  arm64  pwritev2                 sys_pwritev2
288  arm64  pkey_mprotect            sys_pkey_mprotect
289  arm64  pkey_alloc               sys_pkey_alloc
290  arm64  pkey_free                sys_pkey_free
291  arm64  statx                    sys_statx
292  arm64  io_pgetevents            sys_io_pgetevents
293  arm64  rseq                     sys_rseq
294  arm64  kexec_file_load          sys_kexec_file_load
424  arm64  pidfd_send_signal        sys_pidfd_send_signal
425  arm64  io_uring_setup           sys_io_uring_setup
426  arm64  io_uring_enter           sys_io_uring_enter
427  arm64  io_uring_register        sys_io_uring_register
428  arm64  open_tree                sys_open_tree
429  arm64  move_mount               sys_move_mount
430  arm64  fsopen                   sys_fsopen
431  arm64  fsconfig                 sys_fsconfig
432  arm64  fsmount                  sys_fsmount
433  arm64  fspick                   sys_fspick
434  arm64  pidfd_open               sys_pidfd_open
435  arm64  clone3                   sys_clone3
436  arm64  close_range              sys_close_range
437  arm64  openat2                  sys_openat2
438  arm64  pidfd_getfd              sys_pidfd_getfd
439  arm64  faccessat2               sys_faccessat2
440  arm64  process_madvise          sys_process_madvise
441  arm64  epoll_pwait2             sys_epoll_pwait2
442  arm64  mount_setattr            sys_mount_setattr
443  arm64  quotactl_fd              sys_quotactl_fd
444  arm64  landlock_create_ruleset  sys_landlock_create_ruleset
445  arm64  landlock_add_rule        sys_landlock_add_rule
446  arm64  landlock_restrict_self   sys_landlock_restrict_self
447  arm64  memfd_secret             sys_memfd_secret
448  arm64  process_mrelease         sys_process_mrelease
449  arm64  futex_waitv              sys_futex_waitv
450  arm64  set_mempolicy_home_node  sys_set_mempolicy_home_node
"""


# ARM (compat(emulated))
#
# [How to make]
# cd /path/to/linux-6.*/
# gcc -E -D__SYSCALL=SYSCALL arch/arm64/include/asm/unistd32.h \
# | grep ^SYSCALL | sed -e 's/SYSCALL(//;s/[,)]//g' > /tmp/a
# grep -oP "__NR\S+\s+\d+" arch/arm64/include/asm/unistd32.h > /tmp/b
# join -2 2 -o 1.1,1.10,2.1,1.2 -e arm /tmp/a /tmp/b | sed -e 's/__NR_//g' | column -t
#
arm_compat_syscall_tbl = """
0    arm  restart_syscall               sys_restart_syscall
1    arm  exit                          sys_exit
2    arm  fork                          sys_fork
3    arm  read                          sys_read
4    arm  write                         sys_write
5    arm  open                          compat_sys_open
6    arm  close                         sys_close
8    arm  creat                         sys_creat
9    arm  link                          sys_link
10   arm  unlink                        sys_unlink
11   arm  execve                        compat_sys_execve
12   arm  chdir                         sys_chdir
14   arm  mknod                         sys_mknod
15   arm  chmod                         sys_chmod
16   arm  lchown                        sys_lchown16
19   arm  lseek                         compat_sys_lseek
20   arm  getpid                        sys_getpid
21   arm  mount                         sys_mount
23   arm  setuid                        sys_setuid16
24   arm  getuid                        sys_getuid16
26   arm  ptrace                        compat_sys_ptrace
29   arm  pause                         sys_pause
33   arm  access                        sys_access
34   arm  nice                          sys_nice
36   arm  sync                          sys_sync
37   arm  kill                          sys_kill
38   arm  rename                        sys_rename
39   arm  mkdir                         sys_mkdir
40   arm  rmdir                         sys_rmdir
41   arm  dup                           sys_dup
42   arm  pipe                          sys_pipe
43   arm  times                         compat_sys_times
45   arm  brk                           sys_brk
46   arm  setgid                        sys_setgid16
47   arm  getgid                        sys_getgid16
49   arm  geteuid                       sys_geteuid16
50   arm  getegid                       sys_getegid16
51   arm  acct                          sys_acct
52   arm  umount2                       sys_umount
54   arm  ioctl                         compat_sys_ioctl
55   arm  fcntl                         compat_sys_fcntl
57   arm  setpgid                       sys_setpgid
60   arm  umask                         sys_umask
61   arm  chroot                        sys_chroot
62   arm  ustat                         compat_sys_ustat
63   arm  dup2                          sys_dup2
64   arm  getppid                       sys_getppid
65   arm  getpgrp                       sys_getpgrp
66   arm  setsid                        sys_setsid
67   arm  sigaction                     compat_sys_sigaction
70   arm  setreuid                      sys_setreuid16
71   arm  setregid                      sys_setregid16
72   arm  sigsuspend                    sys_sigsuspend
73   arm  sigpending                    compat_sys_sigpending
74   arm  sethostname                   sys_sethostname
75   arm  setrlimit                     compat_sys_setrlimit
77   arm  getrusage                     compat_sys_getrusage
78   arm  gettimeofday                  compat_sys_gettimeofday
79   arm  settimeofday                  compat_sys_settimeofday
80   arm  getgroups                     sys_getgroups16
81   arm  setgroups                     sys_setgroups16
83   arm  symlink                       sys_symlink
85   arm  readlink                      sys_readlink
86   arm  uselib                        sys_uselib
87   arm  swapon                        sys_swapon
88   arm  reboot                        sys_reboot
91   arm  munmap                        sys_munmap
92   arm  truncate                      compat_sys_truncate
93   arm  ftruncate                     compat_sys_ftruncate
94   arm  fchmod                        sys_fchmod
95   arm  fchown                        sys_fchown16
96   arm  getpriority                   sys_getpriority
97   arm  setpriority                   sys_setpriority
99   arm  statfs                        compat_sys_statfs
100  arm  fstatfs                       compat_sys_fstatfs
103  arm  syslog                        sys_syslog
104  arm  setitimer                     compat_sys_setitimer
105  arm  getitimer                     compat_sys_getitimer
106  arm  stat                          compat_sys_newstat
107  arm  lstat                         compat_sys_newlstat
108  arm  fstat                         compat_sys_newfstat
111  arm  vhangup                       sys_vhangup
114  arm  wait4                         compat_sys_wait4
115  arm  swapoff                       sys_swapoff
116  arm  sysinfo                       compat_sys_sysinfo
118  arm  fsync                         sys_fsync
119  arm  sigreturn                     compat_sys_sigreturn
120  arm  clone                         sys_clone
121  arm  setdomainname                 sys_setdomainname
122  arm  uname                         sys_newuname
124  arm  adjtimex                      sys_adjtimex_time32
125  arm  mprotect                      sys_mprotect
126  arm  sigprocmask                   compat_sys_sigprocmask
128  arm  init_module                   sys_init_module
129  arm  delete_module                 sys_delete_module
131  arm  quotactl                      sys_quotactl
132  arm  getpgid                       sys_getpgid
133  arm  fchdir                        sys_fchdir
134  arm  bdflush                       sys_ni_syscall
135  arm  sysfs                         sys_sysfs
136  arm  personality                   sys_personality
138  arm  setfsuid                      sys_setfsuid16
139  arm  setfsgid                      sys_setfsgid16
140  arm  _llseek                       sys_llseek
141  arm  getdents                      compat_sys_getdents
142  arm  _newselect                    compat_sys_select
143  arm  flock                         sys_flock
144  arm  msync                         sys_msync
145  arm  readv                         sys_readv
146  arm  writev                        sys_writev
147  arm  getsid                        sys_getsid
148  arm  fdatasync                     sys_fdatasync
150  arm  mlock                         sys_mlock
151  arm  munlock                       sys_munlock
152  arm  mlockall                      sys_mlockall
153  arm  munlockall                    sys_munlockall
154  arm  sched_setparam                sys_sched_setparam
155  arm  sched_getparam                sys_sched_getparam
156  arm  sched_setscheduler            sys_sched_setscheduler
157  arm  sched_getscheduler            sys_sched_getscheduler
158  arm  sched_yield                   sys_sched_yield
159  arm  sched_get_priority_max        sys_sched_get_priority_max
160  arm  sched_get_priority_min        sys_sched_get_priority_min
161  arm  sched_rr_get_interval         sys_sched_rr_get_interval_time32
162  arm  nanosleep                     sys_nanosleep_time32
163  arm  mremap                        sys_mremap
164  arm  setresuid                     sys_setresuid16
165  arm  getresuid                     sys_getresuid16
168  arm  poll                          sys_poll
169  arm  nfsservctl                    sys_ni_syscall
170  arm  setresgid                     sys_setresgid16
171  arm  getresgid                     sys_getresgid16
172  arm  prctl                         sys_prctl
173  arm  rt_sigreturn                  compat_sys_rt_sigreturn
174  arm  rt_sigaction                  compat_sys_rt_sigaction
175  arm  rt_sigprocmask                compat_sys_rt_sigprocmask
176  arm  rt_sigpending                 compat_sys_rt_sigpending
177  arm  rt_sigtimedwait               compat_sys_rt_sigtimedwait_time32
178  arm  rt_sigqueueinfo               compat_sys_rt_sigqueueinfo
179  arm  rt_sigsuspend                 compat_sys_rt_sigsuspend
180  arm  pread64                       compat_sys_aarch32_pread64
181  arm  pwrite64                      compat_sys_aarch32_pwrite64
182  arm  chown                         sys_chown16
183  arm  getcwd                        sys_getcwd
184  arm  capget                        sys_capget
185  arm  capset                        sys_capset
186  arm  sigaltstack                   compat_sys_sigaltstack
187  arm  sendfile                      compat_sys_sendfile
190  arm  vfork                         sys_vfork
191  arm  ugetrlimit                    compat_sys_getrlimit
192  arm  mmap2                         compat_sys_aarch32_mmap2
193  arm  truncate64                    compat_sys_aarch32_truncate64
194  arm  ftruncate64                   compat_sys_aarch32_ftruncate64
195  arm  stat64                        sys_stat64
196  arm  lstat64                       sys_lstat64
197  arm  fstat64                       sys_fstat64
198  arm  lchown32                      sys_lchown
199  arm  getuid32                      sys_getuid
200  arm  getgid32                      sys_getgid
201  arm  geteuid32                     sys_geteuid
202  arm  getegid32                     sys_getegid
203  arm  setreuid32                    sys_setreuid
204  arm  setregid32                    sys_setregid
205  arm  getgroups32                   sys_getgroups
206  arm  setgroups32                   sys_setgroups
207  arm  fchown32                      sys_fchown
208  arm  setresuid32                   sys_setresuid
209  arm  getresuid32                   sys_getresuid
210  arm  setresgid32                   sys_setresgid
211  arm  getresgid32                   sys_getresgid
212  arm  chown32                       sys_chown
213  arm  setuid32                      sys_setuid
214  arm  setgid32                      sys_setgid
215  arm  setfsuid32                    sys_setfsuid
216  arm  setfsgid32                    sys_setfsgid
217  arm  getdents64                    sys_getdents64
218  arm  pivot_root                    sys_pivot_root
219  arm  mincore                       sys_mincore
220  arm  madvise                       sys_madvise
221  arm  fcntl64                       compat_sys_fcntl64
224  arm  gettid                        sys_gettid
225  arm  readahead                     compat_sys_aarch32_readahead
226  arm  setxattr                      sys_setxattr
227  arm  lsetxattr                     sys_lsetxattr
228  arm  fsetxattr                     sys_fsetxattr
229  arm  getxattr                      sys_getxattr
230  arm  lgetxattr                     sys_lgetxattr
231  arm  fgetxattr                     sys_fgetxattr
232  arm  listxattr                     sys_listxattr
233  arm  llistxattr                    sys_llistxattr
234  arm  flistxattr                    sys_flistxattr
235  arm  removexattr                   sys_removexattr
236  arm  lremovexattr                  sys_lremovexattr
237  arm  fremovexattr                  sys_fremovexattr
238  arm  tkill                         sys_tkill
239  arm  sendfile64                    sys_sendfile64
240  arm  futex                         sys_futex_time32
241  arm  sched_setaffinity             compat_sys_sched_setaffinity
242  arm  sched_getaffinity             compat_sys_sched_getaffinity
243  arm  io_setup                      compat_sys_io_setup
244  arm  io_destroy                    sys_io_destroy
245  arm  io_getevents                  sys_io_getevents_time32
246  arm  io_submit                     compat_sys_io_submit
247  arm  io_cancel                     sys_io_cancel
248  arm  exit_group                    sys_exit_group
249  arm  lookup_dcookie                compat_sys_lookup_dcookie
250  arm  epoll_create                  sys_epoll_create
251  arm  epoll_ctl                     sys_epoll_ctl
252  arm  epoll_wait                    sys_epoll_wait
253  arm  remap_file_pages              sys_remap_file_pages
256  arm  set_tid_address               sys_set_tid_address
257  arm  timer_create                  compat_sys_timer_create
258  arm  timer_settime                 sys_timer_settime32
259  arm  timer_gettime                 sys_timer_gettime32
260  arm  timer_getoverrun              sys_timer_getoverrun
261  arm  timer_delete                  sys_timer_delete
262  arm  clock_settime                 sys_clock_settime32
263  arm  clock_gettime                 sys_clock_gettime32
264  arm  clock_getres                  sys_clock_getres_time32
265  arm  clock_nanosleep               sys_clock_nanosleep_time32
266  arm  statfs64                      compat_sys_aarch32_statfs64
267  arm  fstatfs64                     compat_sys_aarch32_fstatfs64
268  arm  tgkill                        sys_tgkill
269  arm  utimes                        sys_utimes_time32
270  arm  arm_fadvise64_64              compat_sys_aarch32_fadvise64_64
271  arm  pciconfig_iobase              sys_pciconfig_iobase
272  arm  pciconfig_read                sys_pciconfig_read
273  arm  pciconfig_write               sys_pciconfig_write
274  arm  mq_open                       compat_sys_mq_open
275  arm  mq_unlink                     sys_mq_unlink
276  arm  mq_timedsend                  sys_mq_timedsend_time32
277  arm  mq_timedreceive               sys_mq_timedreceive_time32
278  arm  mq_notify                     compat_sys_mq_notify
279  arm  mq_getsetattr                 compat_sys_mq_getsetattr
280  arm  waitid                        compat_sys_waitid
281  arm  socket                        sys_socket
282  arm  bind                          sys_bind
283  arm  connect                       sys_connect
284  arm  listen                        sys_listen
285  arm  accept                        sys_accept
286  arm  getsockname                   sys_getsockname
287  arm  getpeername                   sys_getpeername
288  arm  socketpair                    sys_socketpair
289  arm  send                          sys_send
290  arm  sendto                        sys_sendto
291  arm  recv                          compat_sys_recv
292  arm  recvfrom                      compat_sys_recvfrom
293  arm  shutdown                      sys_shutdown
294  arm  setsockopt                    sys_setsockopt
295  arm  getsockopt                    sys_getsockopt
296  arm  sendmsg                       compat_sys_sendmsg
297  arm  recvmsg                       compat_sys_recvmsg
298  arm  semop                         sys_semop
299  arm  semget                        sys_semget
300  arm  semctl                        compat_sys_old_semctl
301  arm  msgsnd                        compat_sys_msgsnd
302  arm  msgrcv                        compat_sys_msgrcv
303  arm  msgget                        sys_msgget
304  arm  msgctl                        compat_sys_old_msgctl
305  arm  shmat                         compat_sys_shmat
306  arm  shmdt                         sys_shmdt
307  arm  shmget                        sys_shmget
308  arm  shmctl                        compat_sys_old_shmctl
309  arm  add_key                       sys_add_key
310  arm  request_key                   sys_request_key
311  arm  keyctl                        compat_sys_keyctl
312  arm  semtimedop                    sys_semtimedop_time32
313  arm  vserver                       sys_ni_syscall
314  arm  ioprio_set                    sys_ioprio_set
315  arm  ioprio_get                    sys_ioprio_get
316  arm  inotify_init                  sys_inotify_init
317  arm  inotify_add_watch             sys_inotify_add_watch
318  arm  inotify_rm_watch              sys_inotify_rm_watch
319  arm  mbind                         sys_mbind
320  arm  get_mempolicy                 sys_get_mempolicy
321  arm  set_mempolicy                 sys_set_mempolicy
322  arm  openat                        compat_sys_openat
323  arm  mkdirat                       sys_mkdirat
324  arm  mknodat                       sys_mknodat
325  arm  fchownat                      sys_fchownat
326  arm  futimesat                     sys_futimesat_time32
327  arm  fstatat64                     sys_fstatat64
328  arm  unlinkat                      sys_unlinkat
329  arm  renameat                      sys_renameat
330  arm  linkat                        sys_linkat
331  arm  symlinkat                     sys_symlinkat
332  arm  readlinkat                    sys_readlinkat
333  arm  fchmodat                      sys_fchmodat
334  arm  faccessat                     sys_faccessat
335  arm  pselect6                      compat_sys_pselect6_time32
336  arm  ppoll                         compat_sys_ppoll_time32
337  arm  unshare                       sys_unshare
338  arm  set_robust_list               compat_sys_set_robust_list
339  arm  get_robust_list               compat_sys_get_robust_list
340  arm  splice                        sys_splice
341  arm  sync_file_range2              compat_sys_aarch32_sync_file_range2
342  arm  tee                           sys_tee
343  arm  vmsplice                      sys_vmsplice
344  arm  move_pages                    sys_move_pages
345  arm  getcpu                        sys_getcpu
346  arm  epoll_pwait                   compat_sys_epoll_pwait
347  arm  kexec_load                    compat_sys_kexec_load
348  arm  utimensat                     sys_utimensat_time32
349  arm  signalfd                      compat_sys_signalfd
350  arm  timerfd_create                sys_timerfd_create
351  arm  eventfd                       sys_eventfd
352  arm  fallocate                     compat_sys_aarch32_fallocate
353  arm  timerfd_settime               sys_timerfd_settime32
354  arm  timerfd_gettime               sys_timerfd_gettime32
355  arm  signalfd4                     compat_sys_signalfd4
356  arm  eventfd2                      sys_eventfd2
357  arm  epoll_create1                 sys_epoll_create1
358  arm  dup3                          sys_dup3
359  arm  pipe2                         sys_pipe2
360  arm  inotify_init1                 sys_inotify_init1
361  arm  preadv                        compat_sys_preadv
362  arm  pwritev                       compat_sys_pwritev
363  arm  rt_tgsigqueueinfo             compat_sys_rt_tgsigqueueinfo
364  arm  perf_event_open               sys_perf_event_open
365  arm  recvmmsg                      compat_sys_recvmmsg_time32
366  arm  accept4                       sys_accept4
367  arm  fanotify_init                 sys_fanotify_init
368  arm  fanotify_mark                 compat_sys_fanotify_mark
369  arm  prlimit64                     sys_prlimit64
370  arm  name_to_handle_at             sys_name_to_handle_at
371  arm  open_by_handle_at             compat_sys_open_by_handle_at
372  arm  clock_adjtime                 sys_clock_adjtime32
373  arm  syncfs                        sys_syncfs
374  arm  sendmmsg                      compat_sys_sendmmsg
375  arm  setns                         sys_setns
376  arm  process_vm_readv              sys_process_vm_readv
377  arm  process_vm_writev             sys_process_vm_writev
378  arm  kcmp                          sys_kcmp
379  arm  finit_module                  sys_finit_module
380  arm  sched_setattr                 sys_sched_setattr
381  arm  sched_getattr                 sys_sched_getattr
382  arm  renameat2                     sys_renameat2
383  arm  seccomp                       sys_seccomp
384  arm  getrandom                     sys_getrandom
385  arm  memfd_create                  sys_memfd_create
386  arm  bpf                           sys_bpf
387  arm  execveat                      compat_sys_execveat
388  arm  userfaultfd                   sys_userfaultfd
389  arm  membarrier                    sys_membarrier
390  arm  mlock2                        sys_mlock2
391  arm  copy_file_range               sys_copy_file_range
392  arm  preadv2                       compat_sys_preadv2
393  arm  pwritev2                      compat_sys_pwritev2
394  arm  pkey_mprotect                 sys_pkey_mprotect
395  arm  pkey_alloc                    sys_pkey_alloc
396  arm  pkey_free                     sys_pkey_free
397  arm  statx                         sys_statx
398  arm  rseq                          sys_rseq
399  arm  io_pgetevents                 compat_sys_io_pgetevents
400  arm  migrate_pages                 sys_migrate_pages
401  arm  kexec_file_load               sys_kexec_file_load
403  arm  clock_gettime64               sys_clock_gettime
404  arm  clock_settime64               sys_clock_settime
405  arm  clock_adjtime64               sys_clock_adjtime
406  arm  clock_getres_time64           sys_clock_getres
407  arm  clock_nanosleep_time64        sys_clock_nanosleep
408  arm  timer_gettime64               sys_timer_gettime
409  arm  timer_settime64               sys_timer_settime
410  arm  timerfd_gettime64             sys_timerfd_gettime
411  arm  timerfd_settime64             sys_timerfd_settime
412  arm  utimensat_time64              sys_utimensat
413  arm  pselect6_time64               compat_sys_pselect6_time64
414  arm  ppoll_time64                  compat_sys_ppoll_time64
416  arm  io_pgetevents_time64          sys_io_pgetevents
417  arm  recvmmsg_time64               compat_sys_recvmmsg_time64
418  arm  mq_timedsend_time64           sys_mq_timedsend
419  arm  mq_timedreceive_time64        sys_mq_timedreceive
420  arm  semtimedop_time64             sys_semtimedop
421  arm  rt_sigtimedwait_time64        compat_sys_rt_sigtimedwait_time64
422  arm  futex_time64                  sys_futex
423  arm  sched_rr_get_interval_time64  sys_sched_rr_get_interval
424  arm  pidfd_send_signal             sys_pidfd_send_signal
425  arm  io_uring_setup                sys_io_uring_setup
426  arm  io_uring_enter                sys_io_uring_enter
427  arm  io_uring_register             sys_io_uring_register
428  arm  open_tree                     sys_open_tree
429  arm  move_mount                    sys_move_mount
430  arm  fsopen                        sys_fsopen
431  arm  fsconfig                      sys_fsconfig
432  arm  fsmount                       sys_fsmount
433  arm  fspick                        sys_fspick
434  arm  pidfd_open                    sys_pidfd_open
435  arm  clone3                        sys_clone3
436  arm  close_range                   sys_close_range
437  arm  openat2                       sys_openat2
438  arm  pidfd_getfd                   sys_pidfd_getfd
439  arm  faccessat2                    sys_faccessat2
440  arm  process_madvise               sys_process_madvise
441  arm  epoll_pwait2                  compat_sys_epoll_pwait2
442  arm  mount_setattr                 sys_mount_setattr
443  arm  quotactl_fd                   sys_quotactl_fd
444  arm  landlock_create_ruleset       sys_landlock_create_ruleset
445  arm  landlock_add_rule             sys_landlock_add_rule
446  arm  landlock_restrict_self        sys_landlock_restrict_self
448  arm  process_mrelease              sys_process_mrelease
449  arm  futex_waitv                   sys_futex_waitv
450  arm  set_mempolicy_home_node       sys_set_mempolicy_home_node
"""

# ARM (native)
# - arch/arm/tools/syscall.tbl
arm_native_syscall_tbl = """
#
# Linux system call numbers and entry vectors
#
# The format is:
# <num> <abi>   <name>                  [<entry point>                  [<oabi compat entry point>]]
#
# Where abi is:
#  common - for system calls shared between oabi and eabi (may have compat)
#  oabi   - for oabi-only system calls (may have compat)
#  eabi   - for eabi-only system calls
#
# For each syscall number, "common" is mutually exclusive with oabi and eabi
#
0       common  restart_syscall         sys_restart_syscall
1       common  exit                    sys_exit
2       common  fork                    sys_fork
3       common  read                    sys_read
4       common  write                   sys_write
5       common  open                    sys_open
6       common  close                   sys_close
# 7 was sys_waitpid
8       common  creat                   sys_creat
9       common  link                    sys_link
10      common  unlink                  sys_unlink
11      common  execve                  sys_execve
12      common  chdir                   sys_chdir
13      oabi    time                    sys_time32
14      common  mknod                   sys_mknod
15      common  chmod                   sys_chmod
16      common  lchown                  sys_lchown16
# 17 was sys_break
# 18 was sys_stat
19      common  lseek                   sys_lseek
20      common  getpid                  sys_getpid
21      common  mount                   sys_mount
22      oabi    umount                  sys_oldumount
23      common  setuid                  sys_setuid16
24      common  getuid                  sys_getuid16
25      oabi    stime                   sys_stime32
26      common  ptrace                  sys_ptrace
27      oabi    alarm                   sys_alarm
# 28 was sys_fstat
29      common  pause                   sys_pause
30      oabi    utime                   sys_utime32
# 31 was sys_stty
# 32 was sys_gtty
33      common  access                  sys_access
34      common  nice                    sys_nice
# 35 was sys_ftime
36      common  sync                    sys_sync
37      common  kill                    sys_kill
38      common  rename                  sys_rename
39      common  mkdir                   sys_mkdir
40      common  rmdir                   sys_rmdir
41      common  dup                     sys_dup
42      common  pipe                    sys_pipe
43      common  times                   sys_times
# 44 was sys_prof
45      common  brk                     sys_brk
46      common  setgid                  sys_setgid16
47      common  getgid                  sys_getgid16
# 48 was sys_signal
49      common  geteuid                 sys_geteuid16
50      common  getegid                 sys_getegid16
51      common  acct                    sys_acct
52      common  umount2                 sys_umount
# 53 was sys_lock
54      common  ioctl                   sys_ioctl
55      common  fcntl                   sys_fcntl
# 56 was sys_mpx
57      common  setpgid                 sys_setpgid
# 58 was sys_ulimit
# 59 was sys_olduname
60      common  umask                   sys_umask
61      common  chroot                  sys_chroot
62      common  ustat                   sys_ustat
63      common  dup2                    sys_dup2
64      common  getppid                 sys_getppid
65      common  getpgrp                 sys_getpgrp
66      common  setsid                  sys_setsid
67      common  sigaction               sys_sigaction
# 68 was sys_sgetmask
# 69 was sys_ssetmask
70      common  setreuid                sys_setreuid16
71      common  setregid                sys_setregid16
72      common  sigsuspend              sys_sigsuspend
73      common  sigpending              sys_sigpending
74      common  sethostname             sys_sethostname
75      common  setrlimit               sys_setrlimit
# Back compat 2GB limited rlimit
76      oabi    getrlimit               sys_old_getrlimit
77      common  getrusage               sys_getrusage
78      common  gettimeofday            sys_gettimeofday
79      common  settimeofday            sys_settimeofday
80      common  getgroups               sys_getgroups16
81      common  setgroups               sys_setgroups16
82      oabi    select                  sys_old_select
83      common  symlink                 sys_symlink
# 84 was sys_lstat
85      common  readlink                sys_readlink
86      common  uselib                  sys_uselib
87      common  swapon                  sys_swapon
88      common  reboot                  sys_reboot
89      oabi    readdir                 sys_old_readdir
90      oabi    mmap                    sys_old_mmap
91      common  munmap                  sys_munmap
92      common  truncate                sys_truncate
93      common  ftruncate               sys_ftruncate
94      common  fchmod                  sys_fchmod
95      common  fchown                  sys_fchown16
96      common  getpriority             sys_getpriority
97      common  setpriority             sys_setpriority
# 98 was sys_profil
99      common  statfs                  sys_statfs
100     common  fstatfs                 sys_fstatfs
# 101 was sys_ioperm
102     oabi    socketcall              sys_socketcall          sys_oabi_socketcall
103     common  syslog                  sys_syslog
104     common  setitimer               sys_setitimer
105     common  getitimer               sys_getitimer
106     common  stat                    sys_newstat
107     common  lstat                   sys_newlstat
108     common  fstat                   sys_newfstat
# 109 was sys_uname
# 110 was sys_iopl
111     common  vhangup                 sys_vhangup
# 112 was sys_idle
# syscall to call a syscall!
113     oabi    syscall                 sys_syscall
114     common  wait4                   sys_wait4
115     common  swapoff                 sys_swapoff
116     common  sysinfo                 sys_sysinfo
117     oabi    ipc                     sys_ipc                 sys_oabi_ipc
118     common  fsync                   sys_fsync
119     common  sigreturn               sys_sigreturn_wrapper
120     common  clone                   sys_clone
121     common  setdomainname           sys_setdomainname
122     common  uname                   sys_newuname
# 123 was sys_modify_ldt
124     common  adjtimex                sys_adjtimex_time32
125     common  mprotect                sys_mprotect
126     common  sigprocmask             sys_sigprocmask
# 127 was sys_create_module
128     common  init_module             sys_init_module
129     common  delete_module           sys_delete_module
# 130 was sys_get_kernel_syms
131     common  quotactl                sys_quotactl
132     common  getpgid                 sys_getpgid
133     common  fchdir                  sys_fchdir
134     common  bdflush                 sys_ni_syscall
135     common  sysfs                   sys_sysfs
136     common  personality             sys_personality
# 137 was sys_afs_syscall
138     common  setfsuid                sys_setfsuid16
139     common  setfsgid                sys_setfsgid16
140     common  _llseek                 sys_llseek
141     common  getdents                sys_getdents
142     common  _newselect              sys_select
143     common  flock                   sys_flock
144     common  msync                   sys_msync
145     common  readv                   sys_readv
146     common  writev                  sys_writev
147     common  getsid                  sys_getsid
148     common  fdatasync               sys_fdatasync
149     common  _sysctl                 sys_ni_syscall
150     common  mlock                   sys_mlock
151     common  munlock                 sys_munlock
152     common  mlockall                sys_mlockall
153     common  munlockall              sys_munlockall
154     common  sched_setparam          sys_sched_setparam
155     common  sched_getparam          sys_sched_getparam
156     common  sched_setscheduler      sys_sched_setscheduler
157     common  sched_getscheduler      sys_sched_getscheduler
158     common  sched_yield             sys_sched_yield
159     common  sched_get_priority_max  sys_sched_get_priority_max
160     common  sched_get_priority_min  sys_sched_get_priority_min
161     common  sched_rr_get_interval   sys_sched_rr_get_interval_time32
162     common  nanosleep               sys_nanosleep_time32
163     common  mremap                  sys_mremap
164     common  setresuid               sys_setresuid16
165     common  getresuid               sys_getresuid16
# 166 was sys_vm86
# 167 was sys_query_module
168     common  poll                    sys_poll
169     common  nfsservctl
170     common  setresgid               sys_setresgid16
171     common  getresgid               sys_getresgid16
172     common  prctl                   sys_prctl
173     common  rt_sigreturn            sys_rt_sigreturn_wrapper
174     common  rt_sigaction            sys_rt_sigaction
175     common  rt_sigprocmask          sys_rt_sigprocmask
176     common  rt_sigpending           sys_rt_sigpending
177     common  rt_sigtimedwait         sys_rt_sigtimedwait_time32
178     common  rt_sigqueueinfo         sys_rt_sigqueueinfo
179     common  rt_sigsuspend           sys_rt_sigsuspend
180     common  pread64                 sys_pread64             sys_oabi_pread64
181     common  pwrite64                sys_pwrite64            sys_oabi_pwrite64
182     common  chown                   sys_chown16
183     common  getcwd                  sys_getcwd
184     common  capget                  sys_capget
185     common  capset                  sys_capset
186     common  sigaltstack             sys_sigaltstack
187     common  sendfile                sys_sendfile
# 188 reserved
# 189 reserved
190     common  vfork                   sys_vfork
# SuS compliant getrlimit
191     common  ugetrlimit              sys_getrlimit
192     common  mmap2                   sys_mmap2
193     common  truncate64              sys_truncate64          sys_oabi_truncate64
194     common  ftruncate64             sys_ftruncate64         sys_oabi_ftruncate64
195     common  stat64                  sys_stat64              sys_oabi_stat64
196     common  lstat64                 sys_lstat64             sys_oabi_lstat64
197     common  fstat64                 sys_fstat64             sys_oabi_fstat64
198     common  lchown32                sys_lchown
199     common  getuid32                sys_getuid
200     common  getgid32                sys_getgid
201     common  geteuid32               sys_geteuid
202     common  getegid32               sys_getegid
203     common  setreuid32              sys_setreuid
204     common  setregid32              sys_setregid
205     common  getgroups32             sys_getgroups
206     common  setgroups32             sys_setgroups
207     common  fchown32                sys_fchown
208     common  setresuid32             sys_setresuid
209     common  getresuid32             sys_getresuid
210     common  setresgid32             sys_setresgid
211     common  getresgid32             sys_getresgid
212     common  chown32                 sys_chown
213     common  setuid32                sys_setuid
214     common  setgid32                sys_setgid
215     common  setfsuid32              sys_setfsuid
216     common  setfsgid32              sys_setfsgid
217     common  getdents64              sys_getdents64
218     common  pivot_root              sys_pivot_root
219     common  mincore                 sys_mincore
220     common  madvise                 sys_madvise
221     common  fcntl64                 sys_fcntl64             sys_oabi_fcntl64
# 222 for tux
# 223 is unused
224     common  gettid                  sys_gettid
225     common  readahead               sys_readahead           sys_oabi_readahead
226     common  setxattr                sys_setxattr
227     common  lsetxattr               sys_lsetxattr
228     common  fsetxattr               sys_fsetxattr
229     common  getxattr                sys_getxattr
230     common  lgetxattr               sys_lgetxattr
231     common  fgetxattr               sys_fgetxattr
232     common  listxattr               sys_listxattr
233     common  llistxattr              sys_llistxattr
234     common  flistxattr              sys_flistxattr
235     common  removexattr             sys_removexattr
236     common  lremovexattr            sys_lremovexattr
237     common  fremovexattr            sys_fremovexattr
238     common  tkill                   sys_tkill
239     common  sendfile64              sys_sendfile64
240     common  futex                   sys_futex_time32
241     common  sched_setaffinity       sys_sched_setaffinity
242     common  sched_getaffinity       sys_sched_getaffinity
243     common  io_setup                sys_io_setup
244     common  io_destroy              sys_io_destroy
245     common  io_getevents            sys_io_getevents_time32
246     common  io_submit               sys_io_submit
247     common  io_cancel               sys_io_cancel
248     common  exit_group              sys_exit_group
249     common  lookup_dcookie          sys_lookup_dcookie
250     common  epoll_create            sys_epoll_create
251     common  epoll_ctl               sys_epoll_ctl           sys_oabi_epoll_ctl
252     common  epoll_wait              sys_epoll_wait
253     common  remap_file_pages        sys_remap_file_pages
# 254 for set_thread_area
# 255 for get_thread_area
256     common  set_tid_address         sys_set_tid_address
257     common  timer_create            sys_timer_create
258     common  timer_settime           sys_timer_settime32
259     common  timer_gettime           sys_timer_gettime32
260     common  timer_getoverrun        sys_timer_getoverrun
261     common  timer_delete            sys_timer_delete
262     common  clock_settime           sys_clock_settime32
263     common  clock_gettime           sys_clock_gettime32
264     common  clock_getres            sys_clock_getres_time32
265     common  clock_nanosleep         sys_clock_nanosleep_time32
266     common  statfs64                sys_statfs64_wrapper
267     common  fstatfs64               sys_fstatfs64_wrapper
268     common  tgkill                  sys_tgkill
269     common  utimes                  sys_utimes_time32
270     common  arm_fadvise64_64        sys_arm_fadvise64_64
271     common  pciconfig_iobase        sys_pciconfig_iobase
272     common  pciconfig_read          sys_pciconfig_read
273     common  pciconfig_write         sys_pciconfig_write
274     common  mq_open                 sys_mq_open
275     common  mq_unlink               sys_mq_unlink
276     common  mq_timedsend            sys_mq_timedsend_time32
277     common  mq_timedreceive         sys_mq_timedreceive_time32
278     common  mq_notify               sys_mq_notify
279     common  mq_getsetattr           sys_mq_getsetattr
280     common  waitid                  sys_waitid
281     common  socket                  sys_socket
282     common  bind                    sys_bind                sys_oabi_bind
283     common  connect                 sys_connect             sys_oabi_connect
284     common  listen                  sys_listen
285     common  accept                  sys_accept
286     common  getsockname             sys_getsockname
287     common  getpeername             sys_getpeername
288     common  socketpair              sys_socketpair
289     common  send                    sys_send
290     common  sendto                  sys_sendto              sys_oabi_sendto
291     common  recv                    sys_recv
292     common  recvfrom                sys_recvfrom
293     common  shutdown                sys_shutdown
294     common  setsockopt              sys_setsockopt
295     common  getsockopt              sys_getsockopt
296     common  sendmsg                 sys_sendmsg             sys_oabi_sendmsg
297     common  recvmsg                 sys_recvmsg
298     common  semop                   sys_semop               sys_oabi_semop
299     common  semget                  sys_semget
300     common  semctl                  sys_old_semctl
301     common  msgsnd                  sys_msgsnd
302     common  msgrcv                  sys_msgrcv
303     common  msgget                  sys_msgget
304     common  msgctl                  sys_old_msgctl
305     common  shmat                   sys_shmat
306     common  shmdt                   sys_shmdt
307     common  shmget                  sys_shmget
308     common  shmctl                  sys_old_shmctl
309     common  add_key                 sys_add_key
310     common  request_key             sys_request_key
311     common  keyctl                  sys_keyctl
312     common  semtimedop              sys_semtimedop_time32   sys_oabi_semtimedop
313     common  vserver
314     common  ioprio_set              sys_ioprio_set
315     common  ioprio_get              sys_ioprio_get
316     common  inotify_init            sys_inotify_init
317     common  inotify_add_watch       sys_inotify_add_watch
318     common  inotify_rm_watch        sys_inotify_rm_watch
319     common  mbind                   sys_mbind
320     common  get_mempolicy           sys_get_mempolicy
321     common  set_mempolicy           sys_set_mempolicy
322     common  openat                  sys_openat
323     common  mkdirat                 sys_mkdirat
324     common  mknodat                 sys_mknodat
325     common  fchownat                sys_fchownat
326     common  futimesat               sys_futimesat_time32
327     common  fstatat64               sys_fstatat64           sys_oabi_fstatat64
328     common  unlinkat                sys_unlinkat
329     common  renameat                sys_renameat
330     common  linkat                  sys_linkat
331     common  symlinkat               sys_symlinkat
332     common  readlinkat              sys_readlinkat
333     common  fchmodat                sys_fchmodat
334     common  faccessat               sys_faccessat
335     common  pselect6                sys_pselect6_time32
336     common  ppoll                   sys_ppoll_time32
337     common  unshare                 sys_unshare
338     common  set_robust_list         sys_set_robust_list
339     common  get_robust_list         sys_get_robust_list
340     common  splice                  sys_splice
341     common  arm_sync_file_range     sys_sync_file_range2
342     common  tee                     sys_tee
343     common  vmsplice                sys_vmsplice
344     common  move_pages              sys_move_pages
345     common  getcpu                  sys_getcpu
346     common  epoll_pwait             sys_epoll_pwait
347     common  kexec_load              sys_kexec_load
348     common  utimensat               sys_utimensat_time32
349     common  signalfd                sys_signalfd
350     common  timerfd_create          sys_timerfd_create
351     common  eventfd                 sys_eventfd
352     common  fallocate               sys_fallocate
353     common  timerfd_settime         sys_timerfd_settime32
354     common  timerfd_gettime         sys_timerfd_gettime32
355     common  signalfd4               sys_signalfd4
356     common  eventfd2                sys_eventfd2
357     common  epoll_create1           sys_epoll_create1
358     common  dup3                    sys_dup3
359     common  pipe2                   sys_pipe2
360     common  inotify_init1           sys_inotify_init1
361     common  preadv                  sys_preadv
362     common  pwritev                 sys_pwritev
363     common  rt_tgsigqueueinfo       sys_rt_tgsigqueueinfo
364     common  perf_event_open         sys_perf_event_open
365     common  recvmmsg                sys_recvmmsg_time32
366     common  accept4                 sys_accept4
367     common  fanotify_init           sys_fanotify_init
368     common  fanotify_mark           sys_fanotify_mark
369     common  prlimit64               sys_prlimit64
370     common  name_to_handle_at       sys_name_to_handle_at
371     common  open_by_handle_at       sys_open_by_handle_at
372     common  clock_adjtime           sys_clock_adjtime32
373     common  syncfs                  sys_syncfs
374     common  sendmmsg                sys_sendmmsg
375     common  setns                   sys_setns
376     common  process_vm_readv        sys_process_vm_readv
377     common  process_vm_writev       sys_process_vm_writev
378     common  kcmp                    sys_kcmp
379     common  finit_module            sys_finit_module
380     common  sched_setattr           sys_sched_setattr
381     common  sched_getattr           sys_sched_getattr
382     common  renameat2               sys_renameat2
383     common  seccomp                 sys_seccomp
384     common  getrandom               sys_getrandom
385     common  memfd_create            sys_memfd_create
386     common  bpf                     sys_bpf
387     common  execveat                sys_execveat
388     common  userfaultfd             sys_userfaultfd
389     common  membarrier              sys_membarrier
390     common  mlock2                  sys_mlock2
391     common  copy_file_range         sys_copy_file_range
392     common  preadv2                 sys_preadv2
393     common  pwritev2                sys_pwritev2
394     common  pkey_mprotect           sys_pkey_mprotect
395     common  pkey_alloc              sys_pkey_alloc
396     common  pkey_free               sys_pkey_free
397     common  statx                   sys_statx
398     common  rseq                    sys_rseq
399     common  io_pgetevents           sys_io_pgetevents_time32
400     common  migrate_pages           sys_migrate_pages
401     common  kexec_file_load         sys_kexec_file_load
# 402 is unused
403     common  clock_gettime64                 sys_clock_gettime
404     common  clock_settime64                 sys_clock_settime
405     common  clock_adjtime64                 sys_clock_adjtime
406     common  clock_getres_time64             sys_clock_getres
407     common  clock_nanosleep_time64          sys_clock_nanosleep
408     common  timer_gettime64                 sys_timer_gettime
409     common  timer_settime64                 sys_timer_settime
410     common  timerfd_gettime64               sys_timerfd_gettime
411     common  timerfd_settime64               sys_timerfd_settime
412     common  utimensat_time64                sys_utimensat
413     common  pselect6_time64                 sys_pselect6
414     common  ppoll_time64                    sys_ppoll
416     common  io_pgetevents_time64            sys_io_pgetevents
417     common  recvmmsg_time64                 sys_recvmmsg
418     common  mq_timedsend_time64             sys_mq_timedsend
419     common  mq_timedreceive_time64          sys_mq_timedreceive
420     common  semtimedop_time64               sys_semtimedop
421     common  rt_sigtimedwait_time64          sys_rt_sigtimedwait
422     common  futex_time64                    sys_futex
423     common  sched_rr_get_interval_time64    sys_sched_rr_get_interval
424     common  pidfd_send_signal               sys_pidfd_send_signal
425     common  io_uring_setup                  sys_io_uring_setup
426     common  io_uring_enter                  sys_io_uring_enter
427     common  io_uring_register               sys_io_uring_register
428     common  open_tree                       sys_open_tree
429     common  move_mount                      sys_move_mount
430     common  fsopen                          sys_fsopen
431     common  fsconfig                        sys_fsconfig
432     common  fsmount                         sys_fsmount
433     common  fspick                          sys_fspick
434     common  pidfd_open                      sys_pidfd_open
435     common  clone3                          sys_clone3
436     common  close_range                     sys_close_range
437     common  openat2                         sys_openat2
438     common  pidfd_getfd                     sys_pidfd_getfd
439     common  faccessat2                      sys_faccessat2
440     common  process_madvise                 sys_process_madvise
441     common  epoll_pwait2                    sys_epoll_pwait2
442     common  mount_setattr                   sys_mount_setattr
443     common  quotactl_fd                     sys_quotactl_fd
444     common  landlock_create_ruleset         sys_landlock_create_ruleset
445     common  landlock_add_rule               sys_landlock_add_rule
446     common  landlock_restrict_self          sys_landlock_restrict_self
# 447 reserved for memfd_secret
448     common  process_mrelease                sys_process_mrelease
449     common  futex_waitv                     sys_futex_waitv
450     common  set_mempolicy_home_node         sys_set_mempolicy_home_node
"""


# MIPS o32 (backward compatible ABI, present in /lib)
# - arch/mips/kernel/syscalls/syscall_o32.tbl
mips_o32_syscall_tbl = """
# system call numbers and entry vectors for mips
#
# The format is:
# <number> <abi> <name> <entry point> <compat entry point>
#
# The <abi> is always "o32" for this file.
#
0       o32     syscall                         sys_syscall                     sys32_syscall
1       o32     exit                            sys_exit
2       o32     fork                            __sys_fork
3       o32     read                            sys_read
4       o32     write                           sys_write
5       o32     open                            sys_open                        compat_sys_open
6       o32     close                           sys_close
7       o32     waitpid                         sys_waitpid
8       o32     creat                           sys_creat
9       o32     link                            sys_link
10      o32     unlink                          sys_unlink
11      o32     execve                          sys_execve                      compat_sys_execve
12      o32     chdir                           sys_chdir
13      o32     time                            sys_time32
14      o32     mknod                           sys_mknod
15      o32     chmod                           sys_chmod
16      o32     lchown                          sys_lchown
17      o32     break                           sys_ni_syscall
# 18 was sys_stat
18      o32     unused18                        sys_ni_syscall
19      o32     lseek                           sys_lseek
20      o32     getpid                          sys_getpid
21      o32     mount                           sys_mount
22      o32     umount                          sys_oldumount
23      o32     setuid                          sys_setuid
24      o32     getuid                          sys_getuid
25      o32     stime                           sys_stime32
26      o32     ptrace                          sys_ptrace                      compat_sys_ptrace
27      o32     alarm                           sys_alarm
# 28 was sys_fstat
28      o32     unused28                        sys_ni_syscall
29      o32     pause                           sys_pause
30      o32     utime                           sys_utime32
31      o32     stty                            sys_ni_syscall
32      o32     gtty                            sys_ni_syscall
33      o32     access                          sys_access
34      o32     nice                            sys_nice
35      o32     ftime                           sys_ni_syscall
36      o32     sync                            sys_sync
37      o32     kill                            sys_kill
38      o32     rename                          sys_rename
39      o32     mkdir                           sys_mkdir
40      o32     rmdir                           sys_rmdir
41      o32     dup                             sys_dup
42      o32     pipe                            sysm_pipe
43      o32     times                           sys_times                       compat_sys_times
44      o32     prof                            sys_ni_syscall
45      o32     brk                             sys_brk
46      o32     setgid                          sys_setgid
47      o32     getgid                          sys_getgid
48      o32     signal                          sys_ni_syscall
49      o32     geteuid                         sys_geteuid
50      o32     getegid                         sys_getegid
51      o32     acct                            sys_acct
52      o32     umount2                         sys_umount
53      o32     lock                            sys_ni_syscall
54      o32     ioctl                           sys_ioctl                       compat_sys_ioctl
55      o32     fcntl                           sys_fcntl                       compat_sys_fcntl
56      o32     mpx                             sys_ni_syscall
57      o32     setpgid                         sys_setpgid
58      o32     ulimit                          sys_ni_syscall
59      o32     unused59                        sys_olduname
60      o32     umask                           sys_umask
61      o32     chroot                          sys_chroot
62      o32     ustat                           sys_ustat                       compat_sys_ustat
63      o32     dup2                            sys_dup2
64      o32     getppid                         sys_getppid
65      o32     getpgrp                         sys_getpgrp
66      o32     setsid                          sys_setsid
67      o32     sigaction                       sys_sigaction                   sys_32_sigaction
68      o32     sgetmask                        sys_sgetmask
69      o32     ssetmask                        sys_ssetmask
70      o32     setreuid                        sys_setreuid
71      o32     setregid                        sys_setregid
72      o32     sigsuspend                      sys_sigsuspend                  sys32_sigsuspend
73      o32     sigpending                      sys_sigpending                  compat_sys_sigpending
74      o32     sethostname                     sys_sethostname
75      o32     setrlimit                       sys_setrlimit                   compat_sys_setrlimit
76      o32     getrlimit                       sys_getrlimit                   compat_sys_getrlimit
77      o32     getrusage                       sys_getrusage                   compat_sys_getrusage
78      o32     gettimeofday                    sys_gettimeofday                compat_sys_gettimeofday
79      o32     settimeofday                    sys_settimeofday                compat_sys_settimeofday
80      o32     getgroups                       sys_getgroups
81      o32     setgroups                       sys_setgroups
# 82 was old_select
82      o32     reserved82                      sys_ni_syscall
83      o32     symlink                         sys_symlink
# 84 was sys_lstat
84      o32     unused84                        sys_ni_syscall
85      o32     readlink                        sys_readlink
86      o32     uselib                          sys_uselib
87      o32     swapon                          sys_swapon
88      o32     reboot                          sys_reboot
89      o32     readdir                         sys_old_readdir                 compat_sys_old_readdir
90      o32     mmap                            sys_mips_mmap
91      o32     munmap                          sys_munmap
92      o32     truncate                        sys_truncate                    compat_sys_truncate
93      o32     ftruncate                       sys_ftruncate                   compat_sys_ftruncate
94      o32     fchmod                          sys_fchmod
95      o32     fchown                          sys_fchown
96      o32     getpriority                     sys_getpriority
97      o32     setpriority                     sys_setpriority
98      o32     profil                          sys_ni_syscall
99      o32     statfs                          sys_statfs                      compat_sys_statfs
100     o32     fstatfs                         sys_fstatfs                     compat_sys_fstatfs
101     o32     ioperm                          sys_ni_syscall
102     o32     socketcall                      sys_socketcall                  compat_sys_socketcall
103     o32     syslog                          sys_syslog
104     o32     setitimer                       sys_setitimer                   compat_sys_setitimer
105     o32     getitimer                       sys_getitimer                   compat_sys_getitimer
106     o32     stat                            sys_newstat                     compat_sys_newstat
107     o32     lstat                           sys_newlstat                    compat_sys_newlstat
108     o32     fstat                           sys_newfstat                    compat_sys_newfstat
109     o32     unused109                       sys_uname
110     o32     iopl                            sys_ni_syscall
111     o32     vhangup                         sys_vhangup
112     o32     idle                            sys_ni_syscall
113     o32     vm86                            sys_ni_syscall
114     o32     wait4                           sys_wait4                       compat_sys_wait4
115     o32     swapoff                         sys_swapoff
116     o32     sysinfo                         sys_sysinfo                     compat_sys_sysinfo
117     o32     ipc                             sys_ipc                         compat_sys_ipc
118     o32     fsync                           sys_fsync
119     o32     sigreturn                       sys_sigreturn                   sys32_sigreturn
120     o32     clone                           __sys_clone
121     o32     setdomainname                   sys_setdomainname
122     o32     uname                           sys_newuname
123     o32     modify_ldt                      sys_ni_syscall
124     o32     adjtimex                        sys_adjtimex_time32
125     o32     mprotect                        sys_mprotect
126     o32     sigprocmask                     sys_sigprocmask                 compat_sys_sigprocmask
127     o32     create_module                   sys_ni_syscall
128     o32     init_module                     sys_init_module
129     o32     delete_module                   sys_delete_module
130     o32     get_kernel_syms                 sys_ni_syscall
131     o32     quotactl                        sys_quotactl
132     o32     getpgid                         sys_getpgid
133     o32     fchdir                          sys_fchdir
134     o32     bdflush                         sys_ni_syscall
135     o32     sysfs                           sys_sysfs
136     o32     personality                     sys_personality                 sys_32_personality
137     o32     afs_syscall                     sys_ni_syscall
138     o32     setfsuid                        sys_setfsuid
139     o32     setfsgid                        sys_setfsgid
140     o32     _llseek                         sys_llseek                      sys_32_llseek
141     o32     getdents                        sys_getdents                    compat_sys_getdents
142     o32     _newselect                      sys_select                      compat_sys_select
143     o32     flock                           sys_flock
144     o32     msync                           sys_msync
145     o32     readv                           sys_readv
146     o32     writev                          sys_writev
147     o32     cacheflush                      sys_cacheflush
148     o32     cachectl                        sys_cachectl
149     o32     sysmips                         __sys_sysmips
150     o32     unused150                       sys_ni_syscall
151     o32     getsid                          sys_getsid
152     o32     fdatasync                       sys_fdatasync
153     o32     _sysctl                         sys_ni_syscall
154     o32     mlock                           sys_mlock
155     o32     munlock                         sys_munlock
156     o32     mlockall                        sys_mlockall
157     o32     munlockall                      sys_munlockall
158     o32     sched_setparam                  sys_sched_setparam
159     o32     sched_getparam                  sys_sched_getparam
160     o32     sched_setscheduler              sys_sched_setscheduler
161     o32     sched_getscheduler              sys_sched_getscheduler
162     o32     sched_yield                     sys_sched_yield
163     o32     sched_get_priority_max          sys_sched_get_priority_max
164     o32     sched_get_priority_min          sys_sched_get_priority_min
165     o32     sched_rr_get_interval           sys_sched_rr_get_interval_time32
166     o32     nanosleep                       sys_nanosleep_time32
167     o32     mremap                          sys_mremap
168     o32     accept                          sys_accept
169     o32     bind                            sys_bind
170     o32     connect                         sys_connect
171     o32     getpeername                     sys_getpeername
172     o32     getsockname                     sys_getsockname
173     o32     getsockopt                      sys_getsockopt                  sys_getsockopt
174     o32     listen                          sys_listen
175     o32     recv                            sys_recv                        compat_sys_recv
176     o32     recvfrom                        sys_recvfrom                    compat_sys_recvfrom
177     o32     recvmsg                         sys_recvmsg                     compat_sys_recvmsg
178     o32     send                            sys_send
179     o32     sendmsg                         sys_sendmsg                     compat_sys_sendmsg
180     o32     sendto                          sys_sendto
181     o32     setsockopt                      sys_setsockopt                  sys_setsockopt
182     o32     shutdown                        sys_shutdown
183     o32     socket                          sys_socket
184     o32     socketpair                      sys_socketpair
185     o32     setresuid                       sys_setresuid
186     o32     getresuid                       sys_getresuid
187     o32     query_module                    sys_ni_syscall
188     o32     poll                            sys_poll
189     o32     nfsservctl                      sys_ni_syscall
190     o32     setresgid                       sys_setresgid
191     o32     getresgid                       sys_getresgid
192     o32     prctl                           sys_prctl
193     o32     rt_sigreturn                    sys_rt_sigreturn                sys32_rt_sigreturn
194     o32     rt_sigaction                    sys_rt_sigaction                compat_sys_rt_sigaction
195     o32     rt_sigprocmask                  sys_rt_sigprocmask              compat_sys_rt_sigprocmask
196     o32     rt_sigpending                   sys_rt_sigpending               compat_sys_rt_sigpending
197     o32     rt_sigtimedwait                 sys_rt_sigtimedwait_time32      compat_sys_rt_sigtimedwait_time32
198     o32     rt_sigqueueinfo                 sys_rt_sigqueueinfo             compat_sys_rt_sigqueueinfo
199     o32     rt_sigsuspend                   sys_rt_sigsuspend               compat_sys_rt_sigsuspend
200     o32     pread64                         sys_pread64                     sys_32_pread
201     o32     pwrite64                        sys_pwrite64                    sys_32_pwrite
202     o32     chown                           sys_chown
203     o32     getcwd                          sys_getcwd
204     o32     capget                          sys_capget
205     o32     capset                          sys_capset
206     o32     sigaltstack                     sys_sigaltstack                 compat_sys_sigaltstack
207     o32     sendfile                        sys_sendfile                    compat_sys_sendfile
208     o32     getpmsg                         sys_ni_syscall
209     o32     putpmsg                         sys_ni_syscall
210     o32     mmap2                           sys_mips_mmap2
211     o32     truncate64                      sys_truncate64                  sys_32_truncate64
212     o32     ftruncate64                     sys_ftruncate64                 sys_32_ftruncate64
213     o32     stat64                          sys_stat64                      sys_newstat
214     o32     lstat64                         sys_lstat64                     sys_newlstat
215     o32     fstat64                         sys_fstat64                     sys_newfstat
216     o32     pivot_root                      sys_pivot_root
217     o32     mincore                         sys_mincore
218     o32     madvise                         sys_madvise
219     o32     getdents64                      sys_getdents64
220     o32     fcntl64                         sys_fcntl64                     compat_sys_fcntl64
221     o32     reserved221                     sys_ni_syscall
222     o32     gettid                          sys_gettid
223     o32     readahead                       sys_readahead                   sys32_readahead
224     o32     setxattr                        sys_setxattr
225     o32     lsetxattr                       sys_lsetxattr
226     o32     fsetxattr                       sys_fsetxattr
227     o32     getxattr                        sys_getxattr
228     o32     lgetxattr                       sys_lgetxattr
229     o32     fgetxattr                       sys_fgetxattr
230     o32     listxattr                       sys_listxattr
231     o32     llistxattr                      sys_llistxattr
232     o32     flistxattr                      sys_flistxattr
233     o32     removexattr                     sys_removexattr
234     o32     lremovexattr                    sys_lremovexattr
235     o32     fremovexattr                    sys_fremovexattr
236     o32     tkill                           sys_tkill
237     o32     sendfile64                      sys_sendfile64
238     o32     futex                           sys_futex_time32
239     o32     sched_setaffinity               sys_sched_setaffinity           compat_sys_sched_setaffinity
240     o32     sched_getaffinity               sys_sched_getaffinity           compat_sys_sched_getaffinity
241     o32     io_setup                        sys_io_setup                    compat_sys_io_setup
242     o32     io_destroy                      sys_io_destroy
243     o32     io_getevents                    sys_io_getevents_time32
244     o32     io_submit                       sys_io_submit                   compat_sys_io_submit
245     o32     io_cancel                       sys_io_cancel
246     o32     exit_group                      sys_exit_group
247     o32     lookup_dcookie                  sys_lookup_dcookie              compat_sys_lookup_dcookie
248     o32     epoll_create                    sys_epoll_create
249     o32     epoll_ctl                       sys_epoll_ctl
250     o32     epoll_wait                      sys_epoll_wait
251     o32     remap_file_pages                sys_remap_file_pages
252     o32     set_tid_address                 sys_set_tid_address
253     o32     restart_syscall                 sys_restart_syscall
254     o32     fadvise64                       sys_fadvise64_64                sys32_fadvise64_64
255     o32     statfs64                        sys_statfs64                    compat_sys_statfs64
256     o32     fstatfs64                       sys_fstatfs64                   compat_sys_fstatfs64
257     o32     timer_create                    sys_timer_create                compat_sys_timer_create
258     o32     timer_settime                   sys_timer_settime32
259     o32     timer_gettime                   sys_timer_gettime32
260     o32     timer_getoverrun                sys_timer_getoverrun
261     o32     timer_delete                    sys_timer_delete
262     o32     clock_settime                   sys_clock_settime32
263     o32     clock_gettime                   sys_clock_gettime32
264     o32     clock_getres                    sys_clock_getres_time32
265     o32     clock_nanosleep                 sys_clock_nanosleep_time32
266     o32     tgkill                          sys_tgkill
267     o32     utimes                          sys_utimes_time32
268     o32     mbind                           sys_mbind
269     o32     get_mempolicy                   sys_get_mempolicy
270     o32     set_mempolicy                   sys_set_mempolicy
271     o32     mq_open                         sys_mq_open                     compat_sys_mq_open
272     o32     mq_unlink                       sys_mq_unlink
273     o32     mq_timedsend                    sys_mq_timedsend_time32
274     o32     mq_timedreceive                 sys_mq_timedreceive_time32
275     o32     mq_notify                       sys_mq_notify                   compat_sys_mq_notify
276     o32     mq_getsetattr                   sys_mq_getsetattr               compat_sys_mq_getsetattr
277     o32     vserver                         sys_ni_syscall
278     o32     waitid                          sys_waitid                      compat_sys_waitid
# 279 was sys_setaltroot
280     o32     add_key                         sys_add_key
281     o32     request_key                     sys_request_key
282     o32     keyctl                          sys_keyctl                      compat_sys_keyctl
283     o32     set_thread_area                 sys_set_thread_area
284     o32     inotify_init                    sys_inotify_init
285     o32     inotify_add_watch               sys_inotify_add_watch
286     o32     inotify_rm_watch                sys_inotify_rm_watch
287     o32     migrate_pages                   sys_migrate_pages
288     o32     openat                          sys_openat                      compat_sys_openat
289     o32     mkdirat                         sys_mkdirat
290     o32     mknodat                         sys_mknodat
291     o32     fchownat                        sys_fchownat
292     o32     futimesat                       sys_futimesat_time32
293     o32     fstatat64                       sys_fstatat64                   sys_newfstatat
294     o32     unlinkat                        sys_unlinkat
295     o32     renameat                        sys_renameat
296     o32     linkat                          sys_linkat
297     o32     symlinkat                       sys_symlinkat
298     o32     readlinkat                      sys_readlinkat
299     o32     fchmodat                        sys_fchmodat
300     o32     faccessat                       sys_faccessat
301     o32     pselect6                        sys_pselect6_time32             compat_sys_pselect6_time32
302     o32     ppoll                           sys_ppoll_time32                compat_sys_ppoll_time32
303     o32     unshare                         sys_unshare
304     o32     splice                          sys_splice
305     o32     sync_file_range                 sys_sync_file_range             sys32_sync_file_range
306     o32     tee                             sys_tee
307     o32     vmsplice                        sys_vmsplice
308     o32     move_pages                      sys_move_pages
309     o32     set_robust_list                 sys_set_robust_list             compat_sys_set_robust_list
310     o32     get_robust_list                 sys_get_robust_list             compat_sys_get_robust_list
311     o32     kexec_load                      sys_kexec_load                  compat_sys_kexec_load
312     o32     getcpu                          sys_getcpu
313     o32     epoll_pwait                     sys_epoll_pwait                 compat_sys_epoll_pwait
314     o32     ioprio_set                      sys_ioprio_set
315     o32     ioprio_get                      sys_ioprio_get
316     o32     utimensat                       sys_utimensat_time32
317     o32     signalfd                        sys_signalfd                    compat_sys_signalfd
318     o32     timerfd                         sys_ni_syscall
319     o32     eventfd                         sys_eventfd
320     o32     fallocate                       sys_fallocate                   sys32_fallocate
321     o32     timerfd_create                  sys_timerfd_create
322     o32     timerfd_gettime                 sys_timerfd_gettime32
323     o32     timerfd_settime                 sys_timerfd_settime32
324     o32     signalfd4                       sys_signalfd4                   compat_sys_signalfd4
325     o32     eventfd2                        sys_eventfd2
326     o32     epoll_create1                   sys_epoll_create1
327     o32     dup3                            sys_dup3
328     o32     pipe2                           sys_pipe2
329     o32     inotify_init1                   sys_inotify_init1
330     o32     preadv                          sys_preadv                      compat_sys_preadv
331     o32     pwritev                         sys_pwritev                     compat_sys_pwritev
332     o32     rt_tgsigqueueinfo               sys_rt_tgsigqueueinfo           compat_sys_rt_tgsigqueueinfo
333     o32     perf_event_open                 sys_perf_event_open
334     o32     accept4                         sys_accept4
335     o32     recvmmsg                        sys_recvmmsg_time32             compat_sys_recvmmsg_time32
336     o32     fanotify_init                   sys_fanotify_init
337     o32     fanotify_mark                   sys_fanotify_mark               compat_sys_fanotify_mark
338     o32     prlimit64                       sys_prlimit64
339     o32     name_to_handle_at               sys_name_to_handle_at
340     o32     open_by_handle_at               sys_open_by_handle_at           compat_sys_open_by_handle_at
341     o32     clock_adjtime                   sys_clock_adjtime32
342     o32     syncfs                          sys_syncfs
343     o32     sendmmsg                        sys_sendmmsg                    compat_sys_sendmmsg
344     o32     setns                           sys_setns
345     o32     process_vm_readv                sys_process_vm_readv
346     o32     process_vm_writev               sys_process_vm_writev
347     o32     kcmp                            sys_kcmp
348     o32     finit_module                    sys_finit_module
349     o32     sched_setattr                   sys_sched_setattr
350     o32     sched_getattr                   sys_sched_getattr
351     o32     renameat2                       sys_renameat2
352     o32     seccomp                         sys_seccomp
353     o32     getrandom                       sys_getrandom
354     o32     memfd_create                    sys_memfd_create
355     o32     bpf                             sys_bpf
356     o32     execveat                        sys_execveat                    compat_sys_execveat
357     o32     userfaultfd                     sys_userfaultfd
358     o32     membarrier                      sys_membarrier
359     o32     mlock2                          sys_mlock2
360     o32     copy_file_range                 sys_copy_file_range
361     o32     preadv2                         sys_preadv2                     compat_sys_preadv2
362     o32     pwritev2                        sys_pwritev2                    compat_sys_pwritev2
363     o32     pkey_mprotect                   sys_pkey_mprotect
364     o32     pkey_alloc                      sys_pkey_alloc
365     o32     pkey_free                       sys_pkey_free
366     o32     statx                           sys_statx
367     o32     rseq                            sys_rseq
368     o32     io_pgetevents                   sys_io_pgetevents_time32        compat_sys_io_pgetevents
# room for arch specific calls
393     o32     semget                          sys_semget
394     o32     semctl                          sys_semctl                      compat_sys_semctl
395     o32     shmget                          sys_shmget
396     o32     shmctl                          sys_shmctl                      compat_sys_shmctl
397     o32     shmat                           sys_shmat                       compat_sys_shmat
398     o32     shmdt                           sys_shmdt
399     o32     msgget                          sys_msgget
400     o32     msgsnd                          sys_msgsnd                      compat_sys_msgsnd
401     o32     msgrcv                          sys_msgrcv                      compat_sys_msgrcv
402     o32     msgctl                          sys_msgctl                      compat_sys_msgctl
403     o32     clock_gettime64                 sys_clock_gettime               sys_clock_gettime
404     o32     clock_settime64                 sys_clock_settime               sys_clock_settime
405     o32     clock_adjtime64                 sys_clock_adjtime               sys_clock_adjtime
406     o32     clock_getres_time64             sys_clock_getres                sys_clock_getres
407     o32     clock_nanosleep_time64          sys_clock_nanosleep             sys_clock_nanosleep
408     o32     timer_gettime64                 sys_timer_gettime               sys_timer_gettime
409     o32     timer_settime64                 sys_timer_settime               sys_timer_settime
410     o32     timerfd_gettime64               sys_timerfd_gettime             sys_timerfd_gettime
411     o32     timerfd_settime64               sys_timerfd_settime             sys_timerfd_settime
412     o32     utimensat_time64                sys_utimensat                   sys_utimensat
413     o32     pselect6_time64                 sys_pselect6                    compat_sys_pselect6_time64
414     o32     ppoll_time64                    sys_ppoll                       compat_sys_ppoll_time64
416     o32     io_pgetevents_time64            sys_io_pgetevents               sys_io_pgetevents
417     o32     recvmmsg_time64                 sys_recvmmsg                    compat_sys_recvmmsg_time64
418     o32     mq_timedsend_time64             sys_mq_timedsend                sys_mq_timedsend
419     o32     mq_timedreceive_time64          sys_mq_timedreceive             sys_mq_timedreceive
420     o32     semtimedop_time64               sys_semtimedop                  sys_semtimedop
421     o32     rt_sigtimedwait_time64          sys_rt_sigtimedwait             compat_sys_rt_sigtimedwait_time64
422     o32     futex_time64                    sys_futex                       sys_futex
423     o32     sched_rr_get_interval_time64    sys_sched_rr_get_interval       sys_sched_rr_get_interval
424     o32     pidfd_send_signal               sys_pidfd_send_signal
425     o32     io_uring_setup                  sys_io_uring_setup
426     o32     io_uring_enter                  sys_io_uring_enter
427     o32     io_uring_register               sys_io_uring_register
428     o32     open_tree                       sys_open_tree
429     o32     move_mount                      sys_move_mount
430     o32     fsopen                          sys_fsopen
431     o32     fsconfig                        sys_fsconfig
432     o32     fsmount                         sys_fsmount
433     o32     fspick                          sys_fspick
434     o32     pidfd_open                      sys_pidfd_open
435     o32     clone3                          __sys_clone3
436     o32     close_range                     sys_close_range
437     o32     openat2                         sys_openat2
438     o32     pidfd_getfd                     sys_pidfd_getfd
439     o32     faccessat2                      sys_faccessat2
440     o32     process_madvise                 sys_process_madvise
441     o32     epoll_pwait2                    sys_epoll_pwait2                compat_sys_epoll_pwait2
442     o32     mount_setattr                   sys_mount_setattr
443     o32     quotactl_fd                     sys_quotactl_fd
444     o32     landlock_create_ruleset         sys_landlock_create_ruleset
445     o32     landlock_add_rule               sys_landlock_add_rule
446     o32     landlock_restrict_self          sys_landlock_restrict_self
# 447 reserved for memfd_secret
448     o32     process_mrelease                sys_process_mrelease
449     o32     futex_waitv                     sys_futex_waitv
450     o32     set_mempolicy_home_node         sys_set_mempolicy_home_node
"""


# MIPS n32 (default ABI, present in /lib32)
# - arch/mips/kernel/syscalls/syscall_n32.tbl
mips_n32_syscall_tbl = """
# system call numbers and entry vectors for mips
#
# The format is:
# <number> <abi> <name> <entry point> <compat entry point>
#
# The <abi> is always "n32" for this file.
#
0       n32     read                            sys_read
1       n32     write                           sys_write
2       n32     open                            sys_open
3       n32     close                           sys_close
4       n32     stat                            sys_newstat
5       n32     fstat                           sys_newfstat
6       n32     lstat                           sys_newlstat
7       n32     poll                            sys_poll
8       n32     lseek                           sys_lseek
9       n32     mmap                            sys_mips_mmap
10      n32     mprotect                        sys_mprotect
11      n32     munmap                          sys_munmap
12      n32     brk                             sys_brk
13      n32     rt_sigaction                    compat_sys_rt_sigaction
14      n32     rt_sigprocmask                  compat_sys_rt_sigprocmask
15      n32     ioctl                           compat_sys_ioctl
16      n32     pread64                         sys_pread64
17      n32     pwrite64                        sys_pwrite64
18      n32     readv                           sys_readv
19      n32     writev                          sys_writev
20      n32     access                          sys_access
21      n32     pipe                            sysm_pipe
22      n32     _newselect                      compat_sys_select
23      n32     sched_yield                     sys_sched_yield
24      n32     mremap                          sys_mremap
25      n32     msync                           sys_msync
26      n32     mincore                         sys_mincore
27      n32     madvise                         sys_madvise
28      n32     shmget                          sys_shmget
29      n32     shmat                           sys_shmat
30      n32     shmctl                          compat_sys_old_shmctl
31      n32     dup                             sys_dup
32      n32     dup2                            sys_dup2
33      n32     pause                           sys_pause
34      n32     nanosleep                       sys_nanosleep_time32
35      n32     getitimer                       compat_sys_getitimer
36      n32     setitimer                       compat_sys_setitimer
37      n32     alarm                           sys_alarm
38      n32     getpid                          sys_getpid
39      n32     sendfile                        compat_sys_sendfile
40      n32     socket                          sys_socket
41      n32     connect                         sys_connect
42      n32     accept                          sys_accept
43      n32     sendto                          sys_sendto
44      n32     recvfrom                        compat_sys_recvfrom
45      n32     sendmsg                         compat_sys_sendmsg
46      n32     recvmsg                         compat_sys_recvmsg
47      n32     shutdown                        sys_shutdown
48      n32     bind                            sys_bind
49      n32     listen                          sys_listen
50      n32     getsockname                     sys_getsockname
51      n32     getpeername                     sys_getpeername
52      n32     socketpair                      sys_socketpair
53      n32     setsockopt                      sys_setsockopt
54      n32     getsockopt                      sys_getsockopt
55      n32     clone                           __sys_clone
56      n32     fork                            __sys_fork
57      n32     execve                          compat_sys_execve
58      n32     exit                            sys_exit
59      n32     wait4                           compat_sys_wait4
60      n32     kill                            sys_kill
61      n32     uname                           sys_newuname
62      n32     semget                          sys_semget
63      n32     semop                           sys_semop
64      n32     semctl                          compat_sys_old_semctl
65      n32     shmdt                           sys_shmdt
66      n32     msgget                          sys_msgget
67      n32     msgsnd                          compat_sys_msgsnd
68      n32     msgrcv                          compat_sys_msgrcv
69      n32     msgctl                          compat_sys_old_msgctl
70      n32     fcntl                           compat_sys_fcntl
71      n32     flock                           sys_flock
72      n32     fsync                           sys_fsync
73      n32     fdatasync                       sys_fdatasync
74      n32     truncate                        sys_truncate
75      n32     ftruncate                       sys_ftruncate
76      n32     getdents                        compat_sys_getdents
77      n32     getcwd                          sys_getcwd
78      n32     chdir                           sys_chdir
79      n32     fchdir                          sys_fchdir
80      n32     rename                          sys_rename
81      n32     mkdir                           sys_mkdir
82      n32     rmdir                           sys_rmdir
83      n32     creat                           sys_creat
84      n32     link                            sys_link
85      n32     unlink                          sys_unlink
86      n32     symlink                         sys_symlink
87      n32     readlink                        sys_readlink
88      n32     chmod                           sys_chmod
89      n32     fchmod                          sys_fchmod
90      n32     chown                           sys_chown
91      n32     fchown                          sys_fchown
92      n32     lchown                          sys_lchown
93      n32     umask                           sys_umask
94      n32     gettimeofday                    compat_sys_gettimeofday
95      n32     getrlimit                       compat_sys_getrlimit
96      n32     getrusage                       compat_sys_getrusage
97      n32     sysinfo                         compat_sys_sysinfo
98      n32     times                           compat_sys_times
99      n32     ptrace                          compat_sys_ptrace
100     n32     getuid                          sys_getuid
101     n32     syslog                          sys_syslog
102     n32     getgid                          sys_getgid
103     n32     setuid                          sys_setuid
104     n32     setgid                          sys_setgid
105     n32     geteuid                         sys_geteuid
106     n32     getegid                         sys_getegid
107     n32     setpgid                         sys_setpgid
108     n32     getppid                         sys_getppid
109     n32     getpgrp                         sys_getpgrp
110     n32     setsid                          sys_setsid
111     n32     setreuid                        sys_setreuid
112     n32     setregid                        sys_setregid
113     n32     getgroups                       sys_getgroups
114     n32     setgroups                       sys_setgroups
115     n32     setresuid                       sys_setresuid
116     n32     getresuid                       sys_getresuid
117     n32     setresgid                       sys_setresgid
118     n32     getresgid                       sys_getresgid
119     n32     getpgid                         sys_getpgid
120     n32     setfsuid                        sys_setfsuid
121     n32     setfsgid                        sys_setfsgid
122     n32     getsid                          sys_getsid
123     n32     capget                          sys_capget
124     n32     capset                          sys_capset
125     n32     rt_sigpending                   compat_sys_rt_sigpending
126     n32     rt_sigtimedwait                 compat_sys_rt_sigtimedwait_time32
127     n32     rt_sigqueueinfo                 compat_sys_rt_sigqueueinfo
128     n32     rt_sigsuspend                   compat_sys_rt_sigsuspend
129     n32     sigaltstack                     compat_sys_sigaltstack
130     n32     utime                           sys_utime32
131     n32     mknod                           sys_mknod
132     n32     personality                     sys_32_personality
133     n32     ustat                           compat_sys_ustat
134     n32     statfs                          compat_sys_statfs
135     n32     fstatfs                         compat_sys_fstatfs
136     n32     sysfs                           sys_sysfs
137     n32     getpriority                     sys_getpriority
138     n32     setpriority                     sys_setpriority
139     n32     sched_setparam                  sys_sched_setparam
140     n32     sched_getparam                  sys_sched_getparam
141     n32     sched_setscheduler              sys_sched_setscheduler
142     n32     sched_getscheduler              sys_sched_getscheduler
143     n32     sched_get_priority_max          sys_sched_get_priority_max
144     n32     sched_get_priority_min          sys_sched_get_priority_min
145     n32     sched_rr_get_interval           sys_sched_rr_get_interval_time32
146     n32     mlock                           sys_mlock
147     n32     munlock                         sys_munlock
148     n32     mlockall                        sys_mlockall
149     n32     munlockall                      sys_munlockall
150     n32     vhangup                         sys_vhangup
151     n32     pivot_root                      sys_pivot_root
152     n32     _sysctl                         sys_ni_syscall
153     n32     prctl                           sys_prctl
154     n32     adjtimex                        sys_adjtimex_time32
155     n32     setrlimit                       compat_sys_setrlimit
156     n32     chroot                          sys_chroot
157     n32     sync                            sys_sync
158     n32     acct                            sys_acct
159     n32     settimeofday                    compat_sys_settimeofday
160     n32     mount                           sys_mount
161     n32     umount2                         sys_umount
162     n32     swapon                          sys_swapon
163     n32     swapoff                         sys_swapoff
164     n32     reboot                          sys_reboot
165     n32     sethostname                     sys_sethostname
166     n32     setdomainname                   sys_setdomainname
167     n32     create_module                   sys_ni_syscall
168     n32     init_module                     sys_init_module
169     n32     delete_module                   sys_delete_module
170     n32     get_kernel_syms                 sys_ni_syscall
171     n32     query_module                    sys_ni_syscall
172     n32     quotactl                        sys_quotactl
173     n32     nfsservctl                      sys_ni_syscall
174     n32     getpmsg                         sys_ni_syscall
175     n32     putpmsg                         sys_ni_syscall
176     n32     afs_syscall                     sys_ni_syscall
# 177 reserved for security
177     n32     reserved177                     sys_ni_syscall
178     n32     gettid                          sys_gettid
179     n32     readahead                       sys_readahead
180     n32     setxattr                        sys_setxattr
181     n32     lsetxattr                       sys_lsetxattr
182     n32     fsetxattr                       sys_fsetxattr
183     n32     getxattr                        sys_getxattr
184     n32     lgetxattr                       sys_lgetxattr
185     n32     fgetxattr                       sys_fgetxattr
186     n32     listxattr                       sys_listxattr
187     n32     llistxattr                      sys_llistxattr
188     n32     flistxattr                      sys_flistxattr
189     n32     removexattr                     sys_removexattr
190     n32     lremovexattr                    sys_lremovexattr
191     n32     fremovexattr                    sys_fremovexattr
192     n32     tkill                           sys_tkill
193     n32     reserved193                     sys_ni_syscall
194     n32     futex                           sys_futex_time32
195     n32     sched_setaffinity               compat_sys_sched_setaffinity
196     n32     sched_getaffinity               compat_sys_sched_getaffinity
197     n32     cacheflush                      sys_cacheflush
198     n32     cachectl                        sys_cachectl
199     n32     sysmips                         __sys_sysmips
200     n32     io_setup                        compat_sys_io_setup
201     n32     io_destroy                      sys_io_destroy
202     n32     io_getevents                    sys_io_getevents_time32
203     n32     io_submit                       compat_sys_io_submit
204     n32     io_cancel                       sys_io_cancel
205     n32     exit_group                      sys_exit_group
206     n32     lookup_dcookie                  sys_lookup_dcookie
207     n32     epoll_create                    sys_epoll_create
208     n32     epoll_ctl                       sys_epoll_ctl
209     n32     epoll_wait                      sys_epoll_wait
210     n32     remap_file_pages                sys_remap_file_pages
211     n32     rt_sigreturn                    sysn32_rt_sigreturn
212     n32     fcntl64                         compat_sys_fcntl64
213     n32     set_tid_address                 sys_set_tid_address
214     n32     restart_syscall                 sys_restart_syscall
215     n32     semtimedop                      sys_semtimedop_time32
216     n32     fadvise64                       sys_fadvise64_64
217     n32     statfs64                        compat_sys_statfs64
218     n32     fstatfs64                       compat_sys_fstatfs64
219     n32     sendfile64                      sys_sendfile64
220     n32     timer_create                    compat_sys_timer_create
221     n32     timer_settime                   sys_timer_settime32
222     n32     timer_gettime                   sys_timer_gettime32
223     n32     timer_getoverrun                sys_timer_getoverrun
224     n32     timer_delete                    sys_timer_delete
225     n32     clock_settime                   sys_clock_settime32
226     n32     clock_gettime                   sys_clock_gettime32
227     n32     clock_getres                    sys_clock_getres_time32
228     n32     clock_nanosleep                 sys_clock_nanosleep_time32
229     n32     tgkill                          sys_tgkill
230     n32     utimes                          sys_utimes_time32
231     n32     mbind                           sys_mbind
232     n32     get_mempolicy                   sys_get_mempolicy
233     n32     set_mempolicy                   sys_set_mempolicy
234     n32     mq_open                         compat_sys_mq_open
235     n32     mq_unlink                       sys_mq_unlink
236     n32     mq_timedsend                    sys_mq_timedsend_time32
237     n32     mq_timedreceive                 sys_mq_timedreceive_time32
238     n32     mq_notify                       compat_sys_mq_notify
239     n32     mq_getsetattr                   compat_sys_mq_getsetattr
240     n32     vserver                         sys_ni_syscall
241     n32     waitid                          compat_sys_waitid
# 242 was sys_setaltroot
243     n32     add_key                         sys_add_key
244     n32     request_key                     sys_request_key
245     n32     keyctl                          compat_sys_keyctl
246     n32     set_thread_area                 sys_set_thread_area
247     n32     inotify_init                    sys_inotify_init
248     n32     inotify_add_watch               sys_inotify_add_watch
249     n32     inotify_rm_watch                sys_inotify_rm_watch
250     n32     migrate_pages                   sys_migrate_pages
251     n32     openat                          sys_openat
252     n32     mkdirat                         sys_mkdirat
253     n32     mknodat                         sys_mknodat
254     n32     fchownat                        sys_fchownat
255     n32     futimesat                       sys_futimesat_time32
256     n32     newfstatat                      sys_newfstatat
257     n32     unlinkat                        sys_unlinkat
258     n32     renameat                        sys_renameat
259     n32     linkat                          sys_linkat
260     n32     symlinkat                       sys_symlinkat
261     n32     readlinkat                      sys_readlinkat
262     n32     fchmodat                        sys_fchmodat
263     n32     faccessat                       sys_faccessat
264     n32     pselect6                        compat_sys_pselect6_time32
265     n32     ppoll                           compat_sys_ppoll_time32
266     n32     unshare                         sys_unshare
267     n32     splice                          sys_splice
268     n32     sync_file_range                 sys_sync_file_range
269     n32     tee                             sys_tee
270     n32     vmsplice                        sys_vmsplice
271     n32     move_pages                      sys_move_pages
272     n32     set_robust_list                 compat_sys_set_robust_list
273     n32     get_robust_list                 compat_sys_get_robust_list
274     n32     kexec_load                      compat_sys_kexec_load
275     n32     getcpu                          sys_getcpu
276     n32     epoll_pwait                     compat_sys_epoll_pwait
277     n32     ioprio_set                      sys_ioprio_set
278     n32     ioprio_get                      sys_ioprio_get
279     n32     utimensat                       sys_utimensat_time32
280     n32     signalfd                        compat_sys_signalfd
281     n32     timerfd                         sys_ni_syscall
282     n32     eventfd                         sys_eventfd
283     n32     fallocate                       sys_fallocate
284     n32     timerfd_create                  sys_timerfd_create
285     n32     timerfd_gettime                 sys_timerfd_gettime32
286     n32     timerfd_settime                 sys_timerfd_settime32
287     n32     signalfd4                       compat_sys_signalfd4
288     n32     eventfd2                        sys_eventfd2
289     n32     epoll_create1                   sys_epoll_create1
290     n32     dup3                            sys_dup3
291     n32     pipe2                           sys_pipe2
292     n32     inotify_init1                   sys_inotify_init1
293     n32     preadv                          compat_sys_preadv
294     n32     pwritev                         compat_sys_pwritev
295     n32     rt_tgsigqueueinfo               compat_sys_rt_tgsigqueueinfo
296     n32     perf_event_open                 sys_perf_event_open
297     n32     accept4                         sys_accept4
298     n32     recvmmsg                        compat_sys_recvmmsg_time32
299     n32     getdents64                      sys_getdents64
300     n32     fanotify_init                   sys_fanotify_init
301     n32     fanotify_mark                   sys_fanotify_mark
302     n32     prlimit64                       sys_prlimit64
303     n32     name_to_handle_at               sys_name_to_handle_at
304     n32     open_by_handle_at               sys_open_by_handle_at
305     n32     clock_adjtime                   sys_clock_adjtime32
306     n32     syncfs                          sys_syncfs
307     n32     sendmmsg                        compat_sys_sendmmsg
308     n32     setns                           sys_setns
309     n32     process_vm_readv                sys_process_vm_readv
310     n32     process_vm_writev               sys_process_vm_writev
311     n32     kcmp                            sys_kcmp
312     n32     finit_module                    sys_finit_module
313     n32     sched_setattr                   sys_sched_setattr
314     n32     sched_getattr                   sys_sched_getattr
315     n32     renameat2                       sys_renameat2
316     n32     seccomp                         sys_seccomp
317     n32     getrandom                       sys_getrandom
318     n32     memfd_create                    sys_memfd_create
319     n32     bpf                             sys_bpf
320     n32     execveat                        compat_sys_execveat
321     n32     userfaultfd                     sys_userfaultfd
322     n32     membarrier                      sys_membarrier
323     n32     mlock2                          sys_mlock2
324     n32     copy_file_range                 sys_copy_file_range
325     n32     preadv2                         compat_sys_preadv2
326     n32     pwritev2                        compat_sys_pwritev2
327     n32     pkey_mprotect                   sys_pkey_mprotect
328     n32     pkey_alloc                      sys_pkey_alloc
329     n32     pkey_free                       sys_pkey_free
330     n32     statx                           sys_statx
331     n32     rseq                            sys_rseq
332     n32     io_pgetevents                   compat_sys_io_pgetevents
# 333 through 402 are unassigned to sync up with generic numbers
403     n32     clock_gettime64                 sys_clock_gettime
404     n32     clock_settime64                 sys_clock_settime
405     n32     clock_adjtime64                 sys_clock_adjtime
406     n32     clock_getres_time64             sys_clock_getres
407     n32     clock_nanosleep_time64          sys_clock_nanosleep
408     n32     timer_gettime64                 sys_timer_gettime
409     n32     timer_settime64                 sys_timer_settime
410     n32     timerfd_gettime64               sys_timerfd_gettime
411     n32     timerfd_settime64               sys_timerfd_settime
412     n32     utimensat_time64                sys_utimensat
413     n32     pselect6_time64                 compat_sys_pselect6_time64
414     n32     ppoll_time64                    compat_sys_ppoll_time64
416     n32     io_pgetevents_time64            sys_io_pgetevents
417     n32     recvmmsg_time64                 compat_sys_recvmmsg_time64
418     n32     mq_timedsend_time64             sys_mq_timedsend
419     n32     mq_timedreceive_time64          sys_mq_timedreceive
420     n32     semtimedop_time64               sys_semtimedop
421     n32     rt_sigtimedwait_time64          compat_sys_rt_sigtimedwait_time64
422     n32     futex_time64                    sys_futex
423     n32     sched_rr_get_interval_time64    sys_sched_rr_get_interval
424     n32     pidfd_send_signal               sys_pidfd_send_signal
425     n32     io_uring_setup                  sys_io_uring_setup
426     n32     io_uring_enter                  sys_io_uring_enter
427     n32     io_uring_register               sys_io_uring_register
428     n32     open_tree                       sys_open_tree
429     n32     move_mount                      sys_move_mount
430     n32     fsopen                          sys_fsopen
431     n32     fsconfig                        sys_fsconfig
432     n32     fsmount                         sys_fsmount
433     n32     fspick                          sys_fspick
434     n32     pidfd_open                      sys_pidfd_open
435     n32     clone3                          __sys_clone3
436     n32     close_range                     sys_close_range
437     n32     openat2                         sys_openat2
438     n32     pidfd_getfd                     sys_pidfd_getfd
439     n32     faccessat2                      sys_faccessat2
440     n32     process_madvise                 sys_process_madvise
441     n32     epoll_pwait2                    compat_sys_epoll_pwait2
442     n32     mount_setattr                   sys_mount_setattr
443     n32     quotactl_fd                     sys_quotactl_fd
444     n32     landlock_create_ruleset         sys_landlock_create_ruleset
445     n32     landlock_add_rule               sys_landlock_add_rule
446     n32     landlock_restrict_self          sys_landlock_restrict_self
# 447 reserved for memfd_secret
448     n32     process_mrelease                sys_process_mrelease
449     n32     futex_waitv                     sys_futex_waitv
450     n32     set_mempolicy_home_node         sys_set_mempolicy_home_node
"""


# MIPS n64 (for 64-bit ABI, present in /lib64)
# - arch/mips/kernel/syscalls/syscall_n64.tbl
mips_n64_syscall_tbl = """
# system call numbers and entry vectors for mips
#
# The format is:
# <number> <abi> <name> <entry point>
#
# The <abi> is always "n64" for this file.
#
0       n64     read                            sys_read
1       n64     write                           sys_write
2       n64     open                            sys_open
3       n64     close                           sys_close
4       n64     stat                            sys_newstat
5       n64     fstat                           sys_newfstat
6       n64     lstat                           sys_newlstat
7       n64     poll                            sys_poll
8       n64     lseek                           sys_lseek
9       n64     mmap                            sys_mips_mmap
10      n64     mprotect                        sys_mprotect
11      n64     munmap                          sys_munmap
12      n64     brk                             sys_brk
13      n64     rt_sigaction                    sys_rt_sigaction
14      n64     rt_sigprocmask                  sys_rt_sigprocmask
15      n64     ioctl                           sys_ioctl
16      n64     pread64                         sys_pread64
17      n64     pwrite64                        sys_pwrite64
18      n64     readv                           sys_readv
19      n64     writev                          sys_writev
20      n64     access                          sys_access
21      n64     pipe                            sysm_pipe
22      n64     _newselect                      sys_select
23      n64     sched_yield                     sys_sched_yield
24      n64     mremap                          sys_mremap
25      n64     msync                           sys_msync
26      n64     mincore                         sys_mincore
27      n64     madvise                         sys_madvise
28      n64     shmget                          sys_shmget
29      n64     shmat                           sys_shmat
30      n64     shmctl                          sys_old_shmctl
31      n64     dup                             sys_dup
32      n64     dup2                            sys_dup2
33      n64     pause                           sys_pause
34      n64     nanosleep                       sys_nanosleep
35      n64     getitimer                       sys_getitimer
36      n64     setitimer                       sys_setitimer
37      n64     alarm                           sys_alarm
38      n64     getpid                          sys_getpid
39      n64     sendfile                        sys_sendfile64
40      n64     socket                          sys_socket
41      n64     connect                         sys_connect
42      n64     accept                          sys_accept
43      n64     sendto                          sys_sendto
44      n64     recvfrom                        sys_recvfrom
45      n64     sendmsg                         sys_sendmsg
46      n64     recvmsg                         sys_recvmsg
47      n64     shutdown                        sys_shutdown
48      n64     bind                            sys_bind
49      n64     listen                          sys_listen
50      n64     getsockname                     sys_getsockname
51      n64     getpeername                     sys_getpeername
52      n64     socketpair                      sys_socketpair
53      n64     setsockopt                      sys_setsockopt
54      n64     getsockopt                      sys_getsockopt
55      n64     clone                           __sys_clone
56      n64     fork                            __sys_fork
57      n64     execve                          sys_execve
58      n64     exit                            sys_exit
59      n64     wait4                           sys_wait4
60      n64     kill                            sys_kill
61      n64     uname                           sys_newuname
62      n64     semget                          sys_semget
63      n64     semop                           sys_semop
64      n64     semctl                          sys_old_semctl
65      n64     shmdt                           sys_shmdt
66      n64     msgget                          sys_msgget
67      n64     msgsnd                          sys_msgsnd
68      n64     msgrcv                          sys_msgrcv
69      n64     msgctl                          sys_old_msgctl
70      n64     fcntl                           sys_fcntl
71      n64     flock                           sys_flock
72      n64     fsync                           sys_fsync
73      n64     fdatasync                       sys_fdatasync
74      n64     truncate                        sys_truncate
75      n64     ftruncate                       sys_ftruncate
76      n64     getdents                        sys_getdents
77      n64     getcwd                          sys_getcwd
78      n64     chdir                           sys_chdir
79      n64     fchdir                          sys_fchdir
80      n64     rename                          sys_rename
81      n64     mkdir                           sys_mkdir
82      n64     rmdir                           sys_rmdir
83      n64     creat                           sys_creat
84      n64     link                            sys_link
85      n64     unlink                          sys_unlink
86      n64     symlink                         sys_symlink
87      n64     readlink                        sys_readlink
88      n64     chmod                           sys_chmod
89      n64     fchmod                          sys_fchmod
90      n64     chown                           sys_chown
91      n64     fchown                          sys_fchown
92      n64     lchown                          sys_lchown
93      n64     umask                           sys_umask
94      n64     gettimeofday                    sys_gettimeofday
95      n64     getrlimit                       sys_getrlimit
96      n64     getrusage                       sys_getrusage
97      n64     sysinfo                         sys_sysinfo
98      n64     times                           sys_times
99      n64     ptrace                          sys_ptrace
100     n64     getuid                          sys_getuid
101     n64     syslog                          sys_syslog
102     n64     getgid                          sys_getgid
103     n64     setuid                          sys_setuid
104     n64     setgid                          sys_setgid
105     n64     geteuid                         sys_geteuid
106     n64     getegid                         sys_getegid
107     n64     setpgid                         sys_setpgid
108     n64     getppid                         sys_getppid
109     n64     getpgrp                         sys_getpgrp
110     n64     setsid                          sys_setsid
111     n64     setreuid                        sys_setreuid
112     n64     setregid                        sys_setregid
113     n64     getgroups                       sys_getgroups
114     n64     setgroups                       sys_setgroups
115     n64     setresuid                       sys_setresuid
116     n64     getresuid                       sys_getresuid
117     n64     setresgid                       sys_setresgid
118     n64     getresgid                       sys_getresgid
119     n64     getpgid                         sys_getpgid
120     n64     setfsuid                        sys_setfsuid
121     n64     setfsgid                        sys_setfsgid
122     n64     getsid                          sys_getsid
123     n64     capget                          sys_capget
124     n64     capset                          sys_capset
125     n64     rt_sigpending                   sys_rt_sigpending
126     n64     rt_sigtimedwait                 sys_rt_sigtimedwait
127     n64     rt_sigqueueinfo                 sys_rt_sigqueueinfo
128     n64     rt_sigsuspend                   sys_rt_sigsuspend
129     n64     sigaltstack                     sys_sigaltstack
130     n64     utime                           sys_utime
131     n64     mknod                           sys_mknod
132     n64     personality                     sys_personality
133     n64     ustat                           sys_ustat
134     n64     statfs                          sys_statfs
135     n64     fstatfs                         sys_fstatfs
136     n64     sysfs                           sys_sysfs
137     n64     getpriority                     sys_getpriority
138     n64     setpriority                     sys_setpriority
139     n64     sched_setparam                  sys_sched_setparam
140     n64     sched_getparam                  sys_sched_getparam
141     n64     sched_setscheduler              sys_sched_setscheduler
142     n64     sched_getscheduler              sys_sched_getscheduler
143     n64     sched_get_priority_max          sys_sched_get_priority_max
144     n64     sched_get_priority_min          sys_sched_get_priority_min
145     n64     sched_rr_get_interval           sys_sched_rr_get_interval
146     n64     mlock                           sys_mlock
147     n64     munlock                         sys_munlock
148     n64     mlockall                        sys_mlockall
149     n64     munlockall                      sys_munlockall
150     n64     vhangup                         sys_vhangup
151     n64     pivot_root                      sys_pivot_root
152     n64     _sysctl                         sys_ni_syscall
153     n64     prctl                           sys_prctl
154     n64     adjtimex                        sys_adjtimex
155     n64     setrlimit                       sys_setrlimit
156     n64     chroot                          sys_chroot
157     n64     sync                            sys_sync
158     n64     acct                            sys_acct
159     n64     settimeofday                    sys_settimeofday
160     n64     mount                           sys_mount
161     n64     umount2                         sys_umount
162     n64     swapon                          sys_swapon
163     n64     swapoff                         sys_swapoff
164     n64     reboot                          sys_reboot
165     n64     sethostname                     sys_sethostname
166     n64     setdomainname                   sys_setdomainname
167     n64     create_module                   sys_ni_syscall
168     n64     init_module                     sys_init_module
169     n64     delete_module                   sys_delete_module
170     n64     get_kernel_syms                 sys_ni_syscall
171     n64     query_module                    sys_ni_syscall
172     n64     quotactl                        sys_quotactl
173     n64     nfsservctl                      sys_ni_syscall
174     n64     getpmsg                         sys_ni_syscall
175     n64     putpmsg                         sys_ni_syscall
176     n64     afs_syscall                     sys_ni_syscall
# 177 reserved for security
177     n64     reserved177                     sys_ni_syscall
178     n64     gettid                          sys_gettid
179     n64     readahead                       sys_readahead
180     n64     setxattr                        sys_setxattr
181     n64     lsetxattr                       sys_lsetxattr
182     n64     fsetxattr                       sys_fsetxattr
183     n64     getxattr                        sys_getxattr
184     n64     lgetxattr                       sys_lgetxattr
185     n64     fgetxattr                       sys_fgetxattr
186     n64     listxattr                       sys_listxattr
187     n64     llistxattr                      sys_llistxattr
188     n64     flistxattr                      sys_flistxattr
189     n64     removexattr                     sys_removexattr
190     n64     lremovexattr                    sys_lremovexattr
191     n64     fremovexattr                    sys_fremovexattr
192     n64     tkill                           sys_tkill
193     n64     reserved193                     sys_ni_syscall
194     n64     futex                           sys_futex
195     n64     sched_setaffinity               sys_sched_setaffinity
196     n64     sched_getaffinity               sys_sched_getaffinity
197     n64     cacheflush                      sys_cacheflush
198     n64     cachectl                        sys_cachectl
199     n64     sysmips                         __sys_sysmips
200     n64     io_setup                        sys_io_setup
201     n64     io_destroy                      sys_io_destroy
202     n64     io_getevents                    sys_io_getevents
203     n64     io_submit                       sys_io_submit
204     n64     io_cancel                       sys_io_cancel
205     n64     exit_group                      sys_exit_group
206     n64     lookup_dcookie                  sys_lookup_dcookie
207     n64     epoll_create                    sys_epoll_create
208     n64     epoll_ctl                       sys_epoll_ctl
209     n64     epoll_wait                      sys_epoll_wait
210     n64     remap_file_pages                sys_remap_file_pages
211     n64     rt_sigreturn                    sys_rt_sigreturn
212     n64     set_tid_address                 sys_set_tid_address
213     n64     restart_syscall                 sys_restart_syscall
214     n64     semtimedop                      sys_semtimedop
215     n64     fadvise64                       sys_fadvise64_64
216     n64     timer_create                    sys_timer_create
217     n64     timer_settime                   sys_timer_settime
218     n64     timer_gettime                   sys_timer_gettime
219     n64     timer_getoverrun                sys_timer_getoverrun
220     n64     timer_delete                    sys_timer_delete
221     n64     clock_settime                   sys_clock_settime
222     n64     clock_gettime                   sys_clock_gettime
223     n64     clock_getres                    sys_clock_getres
224     n64     clock_nanosleep                 sys_clock_nanosleep
225     n64     tgkill                          sys_tgkill
226     n64     utimes                          sys_utimes
227     n64     mbind                           sys_mbind
228     n64     get_mempolicy                   sys_get_mempolicy
229     n64     set_mempolicy                   sys_set_mempolicy
230     n64     mq_open                         sys_mq_open
231     n64     mq_unlink                       sys_mq_unlink
232     n64     mq_timedsend                    sys_mq_timedsend
233     n64     mq_timedreceive                 sys_mq_timedreceive
234     n64     mq_notify                       sys_mq_notify
235     n64     mq_getsetattr                   sys_mq_getsetattr
236     n64     vserver                         sys_ni_syscall
237     n64     waitid                          sys_waitid
# 238 was sys_setaltroot
239     n64     add_key                         sys_add_key
240     n64     request_key                     sys_request_key
241     n64     keyctl                          sys_keyctl
242     n64     set_thread_area                 sys_set_thread_area
243     n64     inotify_init                    sys_inotify_init
244     n64     inotify_add_watch               sys_inotify_add_watch
245     n64     inotify_rm_watch                sys_inotify_rm_watch
246     n64     migrate_pages                   sys_migrate_pages
247     n64     openat                          sys_openat
248     n64     mkdirat                         sys_mkdirat
249     n64     mknodat                         sys_mknodat
250     n64     fchownat                        sys_fchownat
251     n64     futimesat                       sys_futimesat
252     n64     newfstatat                      sys_newfstatat
253     n64     unlinkat                        sys_unlinkat
254     n64     renameat                        sys_renameat
255     n64     linkat                          sys_linkat
256     n64     symlinkat                       sys_symlinkat
257     n64     readlinkat                      sys_readlinkat
258     n64     fchmodat                        sys_fchmodat
259     n64     faccessat                       sys_faccessat
260     n64     pselect6                        sys_pselect6
261     n64     ppoll                           sys_ppoll
262     n64     unshare                         sys_unshare
263     n64     splice                          sys_splice
264     n64     sync_file_range                 sys_sync_file_range
265     n64     tee                             sys_tee
266     n64     vmsplice                        sys_vmsplice
267     n64     move_pages                      sys_move_pages
268     n64     set_robust_list                 sys_set_robust_list
269     n64     get_robust_list                 sys_get_robust_list
270     n64     kexec_load                      sys_kexec_load
271     n64     getcpu                          sys_getcpu
272     n64     epoll_pwait                     sys_epoll_pwait
273     n64     ioprio_set                      sys_ioprio_set
274     n64     ioprio_get                      sys_ioprio_get
275     n64     utimensat                       sys_utimensat
276     n64     signalfd                        sys_signalfd
277     n64     timerfd                         sys_ni_syscall
278     n64     eventfd                         sys_eventfd
279     n64     fallocate                       sys_fallocate
280     n64     timerfd_create                  sys_timerfd_create
281     n64     timerfd_gettime                 sys_timerfd_gettime
282     n64     timerfd_settime                 sys_timerfd_settime
283     n64     signalfd4                       sys_signalfd4
284     n64     eventfd2                        sys_eventfd2
285     n64     epoll_create1                   sys_epoll_create1
286     n64     dup3                            sys_dup3
287     n64     pipe2                           sys_pipe2
288     n64     inotify_init1                   sys_inotify_init1
289     n64     preadv                          sys_preadv
290     n64     pwritev                         sys_pwritev
291     n64     rt_tgsigqueueinfo               sys_rt_tgsigqueueinfo
292     n64     perf_event_open                 sys_perf_event_open
293     n64     accept4                         sys_accept4
294     n64     recvmmsg                        sys_recvmmsg
295     n64     fanotify_init                   sys_fanotify_init
296     n64     fanotify_mark                   sys_fanotify_mark
297     n64     prlimit64                       sys_prlimit64
298     n64     name_to_handle_at               sys_name_to_handle_at
299     n64     open_by_handle_at               sys_open_by_handle_at
300     n64     clock_adjtime                   sys_clock_adjtime
301     n64     syncfs                          sys_syncfs
302     n64     sendmmsg                        sys_sendmmsg
303     n64     setns                           sys_setns
304     n64     process_vm_readv                sys_process_vm_readv
305     n64     process_vm_writev               sys_process_vm_writev
306     n64     kcmp                            sys_kcmp
307     n64     finit_module                    sys_finit_module
308     n64     getdents64                      sys_getdents64
309     n64     sched_setattr                   sys_sched_setattr
310     n64     sched_getattr                   sys_sched_getattr
311     n64     renameat2                       sys_renameat2
312     n64     seccomp                         sys_seccomp
313     n64     getrandom                       sys_getrandom
314     n64     memfd_create                    sys_memfd_create
315     n64     bpf                             sys_bpf
316     n64     execveat                        sys_execveat
317     n64     userfaultfd                     sys_userfaultfd
318     n64     membarrier                      sys_membarrier
319     n64     mlock2                          sys_mlock2
320     n64     copy_file_range                 sys_copy_file_range
321     n64     preadv2                         sys_preadv2
322     n64     pwritev2                        sys_pwritev2
323     n64     pkey_mprotect                   sys_pkey_mprotect
324     n64     pkey_alloc                      sys_pkey_alloc
325     n64     pkey_free                       sys_pkey_free
326     n64     statx                           sys_statx
327     n64     rseq                            sys_rseq
328     n64     io_pgetevents                   sys_io_pgetevents
# 329 through 423 are reserved to sync up with other architectures
424     n64     pidfd_send_signal               sys_pidfd_send_signal
425     n64     io_uring_setup                  sys_io_uring_setup
426     n64     io_uring_enter                  sys_io_uring_enter
427     n64     io_uring_register               sys_io_uring_register
428     n64     open_tree                       sys_open_tree
429     n64     move_mount                      sys_move_mount
430     n64     fsopen                          sys_fsopen
431     n64     fsconfig                        sys_fsconfig
432     n64     fsmount                         sys_fsmount
433     n64     fspick                          sys_fspick
434     n64     pidfd_open                      sys_pidfd_open
435     n64     clone3                          __sys_clone3
436     n64     close_range                     sys_close_range
437     n64     openat2                         sys_openat2
438     n64     pidfd_getfd                     sys_pidfd_getfd
439     n64     faccessat2                      sys_faccessat2
440     n64     process_madvise                 sys_process_madvise
441     n64     epoll_pwait2                    sys_epoll_pwait2
442     n64     mount_setattr                   sys_mount_setattr
443     n64     quotactl_fd                     sys_quotactl_fd
444     n64     landlock_create_ruleset         sys_landlock_create_ruleset
445     n64     landlock_add_rule               sys_landlock_add_rule
446     n64     landlock_restrict_self          sys_landlock_restrict_self
# 447 reserved for memfd_secret
448     n64     process_mrelease                sys_process_mrelease
449     n64     futex_waitv                     sys_futex_waitv
450     common  set_mempolicy_home_node         sys_set_mempolicy_home_node
"""


# PowerPC
# - arch/powerpc/kernel/syscalls/syscall.tbl
ppc_syscall_tbl = """
# system call numbers and entry vectors for powerpc
#
# The format is:
# <number> <abi> <name> <entry point> <compat entry point>
#
# The <abi> can be common, spu, nospu, 64, or 32 for this file.
#
0       nospu   restart_syscall                 sys_restart_syscall
1       nospu   exit                            sys_exit
2       nospu   fork                            sys_fork
3       common  read                            sys_read
4       common  write                           sys_write
5       common  open                            sys_open                        compat_sys_open
6       common  close                           sys_close
7       common  waitpid                         sys_waitpid
8       common  creat                           sys_creat
9       common  link                            sys_link
10      common  unlink                          sys_unlink
11      nospu   execve                          sys_execve                      compat_sys_execve
12      common  chdir                           sys_chdir
13      32      time                            sys_time32
13      64      time                            sys_time
13      spu     time                            sys_time
14      common  mknod                           sys_mknod
15      common  chmod                           sys_chmod
16      common  lchown                          sys_lchown
17      common  break                           sys_ni_syscall
18      32      oldstat                         sys_stat                        sys_ni_syscall
18      64      oldstat                         sys_ni_syscall
18      spu     oldstat                         sys_ni_syscall
19      common  lseek                           sys_lseek                       compat_sys_lseek
20      common  getpid                          sys_getpid
21      nospu   mount                           sys_mount
22      32      umount                          sys_oldumount
22      64      umount                          sys_ni_syscall
22      spu     umount                          sys_ni_syscall
23      common  setuid                          sys_setuid
24      common  getuid                          sys_getuid
25      32      stime                           sys_stime32
25      64      stime                           sys_stime
25      spu     stime                           sys_stime
26      nospu   ptrace                          sys_ptrace                      compat_sys_ptrace
27      common  alarm                           sys_alarm
28      32      oldfstat                        sys_fstat                       sys_ni_syscall
28      64      oldfstat                        sys_ni_syscall
28      spu     oldfstat                        sys_ni_syscall
29      nospu   pause                           sys_pause
30      32      utime                           sys_utime32
30      64      utime                           sys_utime
31      common  stty                            sys_ni_syscall
32      common  gtty                            sys_ni_syscall
33      common  access                          sys_access
34      common  nice                            sys_nice
35      common  ftime                           sys_ni_syscall
36      common  sync                            sys_sync
37      common  kill                            sys_kill
38      common  rename                          sys_rename
39      common  mkdir                           sys_mkdir
40      common  rmdir                           sys_rmdir
41      common  dup                             sys_dup
42      common  pipe                            sys_pipe
43      common  times                           sys_times                       compat_sys_times
44      common  prof                            sys_ni_syscall
45      common  brk                             sys_brk
46      common  setgid                          sys_setgid
47      common  getgid                          sys_getgid
48      nospu   signal                          sys_signal
49      common  geteuid                         sys_geteuid
50      common  getegid                         sys_getegid
51      nospu   acct                            sys_acct
52      nospu   umount2                         sys_umount
53      common  lock                            sys_ni_syscall
54      common  ioctl                           sys_ioctl                       compat_sys_ioctl
55      common  fcntl                           sys_fcntl                       compat_sys_fcntl
56      common  mpx                             sys_ni_syscall
57      common  setpgid                         sys_setpgid
58      common  ulimit                          sys_ni_syscall
59      32      oldolduname                     sys_olduname
59      64      oldolduname                     sys_ni_syscall
59      spu     oldolduname                     sys_ni_syscall
60      common  umask                           sys_umask
61      common  chroot                          sys_chroot
62      nospu   ustat                           sys_ustat                       compat_sys_ustat
63      common  dup2                            sys_dup2
64      common  getppid                         sys_getppid
65      common  getpgrp                         sys_getpgrp
66      common  setsid                          sys_setsid
67      32      sigaction                       sys_sigaction                   compat_sys_sigaction
67      64      sigaction                       sys_ni_syscall
67      spu     sigaction                       sys_ni_syscall
68      common  sgetmask                        sys_sgetmask
69      common  ssetmask                        sys_ssetmask
70      common  setreuid                        sys_setreuid
71      common  setregid                        sys_setregid
72      32      sigsuspend                      sys_sigsuspend
72      64      sigsuspend                      sys_ni_syscall
72      spu     sigsuspend                      sys_ni_syscall
73      32      sigpending                      sys_sigpending                  compat_sys_sigpending
73      64      sigpending                      sys_ni_syscall
73      spu     sigpending                      sys_ni_syscall
74      common  sethostname                     sys_sethostname
75      common  setrlimit                       sys_setrlimit                   compat_sys_setrlimit
76      32      getrlimit                       sys_old_getrlimit               compat_sys_old_getrlimit
76      64      getrlimit                       sys_ni_syscall
76      spu     getrlimit                       sys_ni_syscall
77      common  getrusage                       sys_getrusage                   compat_sys_getrusage
78      common  gettimeofday                    sys_gettimeofday                compat_sys_gettimeofday
79      common  settimeofday                    sys_settimeofday                compat_sys_settimeofday
80      common  getgroups                       sys_getgroups
81      common  setgroups                       sys_setgroups
82      32      select                          ppc_select                      sys_ni_syscall
82      64      select                          sys_ni_syscall
82      spu     select                          sys_ni_syscall
83      common  symlink                         sys_symlink
84      32      oldlstat                        sys_lstat                       sys_ni_syscall
84      64      oldlstat                        sys_ni_syscall
84      spu     oldlstat                        sys_ni_syscall
85      common  readlink                        sys_readlink
86      nospu   uselib                          sys_uselib
87      nospu   swapon                          sys_swapon
88      nospu   reboot                          sys_reboot
89      32      readdir                         sys_old_readdir                 compat_sys_old_readdir
89      64      readdir                         sys_ni_syscall
89      spu     readdir                         sys_ni_syscall
90      common  mmap                            sys_mmap
91      common  munmap                          sys_munmap
92      common  truncate                        sys_truncate                    compat_sys_truncate
93      common  ftruncate                       sys_ftruncate                   compat_sys_ftruncate
94      common  fchmod                          sys_fchmod
95      common  fchown                          sys_fchown
96      common  getpriority                     sys_getpriority
97      common  setpriority                     sys_setpriority
98      common  profil                          sys_ni_syscall
99      nospu   statfs                          sys_statfs                      compat_sys_statfs
100     nospu   fstatfs                         sys_fstatfs                     compat_sys_fstatfs
101     common  ioperm                          sys_ni_syscall
102     common  socketcall                      sys_socketcall                  compat_sys_socketcall
103     common  syslog                          sys_syslog
104     common  setitimer                       sys_setitimer                   compat_sys_setitimer
105     common  getitimer                       sys_getitimer                   compat_sys_getitimer
106     common  stat                            sys_newstat                     compat_sys_newstat
107     common  lstat                           sys_newlstat                    compat_sys_newlstat
108     common  fstat                           sys_newfstat                    compat_sys_newfstat
109     32      olduname                        sys_uname
109     64      olduname                        sys_ni_syscall
109     spu     olduname                        sys_ni_syscall
110     common  iopl                            sys_ni_syscall
111     common  vhangup                         sys_vhangup
112     common  idle                            sys_ni_syscall
113     common  vm86                            sys_ni_syscall
114     common  wait4                           sys_wait4                       compat_sys_wait4
115     nospu   swapoff                         sys_swapoff
116     common  sysinfo                         sys_sysinfo                     compat_sys_sysinfo
117     nospu   ipc                             sys_ipc                         compat_sys_ipc
118     common  fsync                           sys_fsync
119     32      sigreturn                       sys_sigreturn                   compat_sys_sigreturn
119     64      sigreturn                       sys_ni_syscall
119     spu     sigreturn                       sys_ni_syscall
120     nospu   clone                           sys_clone
121     common  setdomainname                   sys_setdomainname
122     common  uname                           sys_newuname
123     common  modify_ldt                      sys_ni_syscall
124     32      adjtimex                        sys_adjtimex_time32
124     64      adjtimex                        sys_adjtimex
124     spu     adjtimex                        sys_adjtimex
125     common  mprotect                        sys_mprotect
126     32      sigprocmask                     sys_sigprocmask                 compat_sys_sigprocmask
126     64      sigprocmask                     sys_ni_syscall
126     spu     sigprocmask                     sys_ni_syscall
127     common  create_module                   sys_ni_syscall
128     nospu   init_module                     sys_init_module
129     nospu   delete_module                   sys_delete_module
130     common  get_kernel_syms                 sys_ni_syscall
131     nospu   quotactl                        sys_quotactl
132     common  getpgid                         sys_getpgid
133     common  fchdir                          sys_fchdir
134     common  bdflush                         sys_ni_syscall
135     common  sysfs                           sys_sysfs
136     32      personality                     sys_personality                 ppc64_personality
136     64      personality                     ppc64_personality
136     spu     personality                     ppc64_personality
137     common  afs_syscall                     sys_ni_syscall
138     common  setfsuid                        sys_setfsuid
139     common  setfsgid                        sys_setfsgid
140     common  _llseek                         sys_llseek
141     common  getdents                        sys_getdents                    compat_sys_getdents
142     common  _newselect                      sys_select                      compat_sys_select
143     common  flock                           sys_flock
144     common  msync                           sys_msync
145     common  readv                           sys_readv
146     common  writev                          sys_writev
147     common  getsid                          sys_getsid
148     common  fdatasync                       sys_fdatasync
149     nospu   _sysctl                         sys_ni_syscall
150     common  mlock                           sys_mlock
151     common  munlock                         sys_munlock
152     common  mlockall                        sys_mlockall
153     common  munlockall                      sys_munlockall
154     common  sched_setparam                  sys_sched_setparam
155     common  sched_getparam                  sys_sched_getparam
156     common  sched_setscheduler              sys_sched_setscheduler
157     common  sched_getscheduler              sys_sched_getscheduler
158     common  sched_yield                     sys_sched_yield
159     common  sched_get_priority_max          sys_sched_get_priority_max
160     common  sched_get_priority_min          sys_sched_get_priority_min
161     32      sched_rr_get_interval           sys_sched_rr_get_interval_time32
161     64      sched_rr_get_interval           sys_sched_rr_get_interval
161     spu     sched_rr_get_interval           sys_sched_rr_get_interval
162     32      nanosleep                       sys_nanosleep_time32
162     64      nanosleep                       sys_nanosleep
162     spu     nanosleep                       sys_nanosleep
163     common  mremap                          sys_mremap
164     common  setresuid                       sys_setresuid
165     common  getresuid                       sys_getresuid
166     common  query_module                    sys_ni_syscall
167     common  poll                            sys_poll
168     common  nfsservctl                      sys_ni_syscall
169     common  setresgid                       sys_setresgid
170     common  getresgid                       sys_getresgid
171     common  prctl                           sys_prctl
172     nospu   rt_sigreturn                    sys_rt_sigreturn                compat_sys_rt_sigreturn
173     nospu   rt_sigaction                    sys_rt_sigaction                compat_sys_rt_sigaction
174     nospu   rt_sigprocmask                  sys_rt_sigprocmask              compat_sys_rt_sigprocmask
175     nospu   rt_sigpending                   sys_rt_sigpending               compat_sys_rt_sigpending
176     32      rt_sigtimedwait                 sys_rt_sigtimedwait_time32      compat_sys_rt_sigtimedwait_time32
176     64      rt_sigtimedwait                 sys_rt_sigtimedwait
177     nospu   rt_sigqueueinfo                 sys_rt_sigqueueinfo             compat_sys_rt_sigqueueinfo
178     nospu   rt_sigsuspend                   sys_rt_sigsuspend               compat_sys_rt_sigsuspend
179     common  pread64                         sys_pread64                     compat_sys_pread64
180     common  pwrite64                        sys_pwrite64                    compat_sys_pwrite64
181     common  chown                           sys_chown
182     common  getcwd                          sys_getcwd
183     common  capget                          sys_capget
184     common  capset                          sys_capset
185     nospu   sigaltstack                     sys_sigaltstack                 compat_sys_sigaltstack
186     32      sendfile                        sys_sendfile                    compat_sys_sendfile
186     64      sendfile                        sys_sendfile64
186     spu     sendfile                        sys_sendfile64
187     common  getpmsg                         sys_ni_syscall
188     common  putpmsg                         sys_ni_syscall
189     nospu   vfork                           sys_vfork
190     common  ugetrlimit                      sys_getrlimit                   compat_sys_getrlimit
191     common  readahead                       sys_readahead                   compat_sys_readahead
192     32      mmap2                           sys_mmap2                       compat_sys_mmap2
193     32      truncate64                      sys_truncate64                  compat_sys_truncate64
194     32      ftruncate64                     sys_ftruncate64                 compat_sys_ftruncate64
195     32      stat64                          sys_stat64
196     32      lstat64                         sys_lstat64
197     32      fstat64                         sys_fstat64
198     nospu   pciconfig_read                  sys_pciconfig_read
199     nospu   pciconfig_write                 sys_pciconfig_write
200     nospu   pciconfig_iobase                sys_pciconfig_iobase
201     common  multiplexer                     sys_ni_syscall
202     common  getdents64                      sys_getdents64
203     common  pivot_root                      sys_pivot_root
204     32      fcntl64                         sys_fcntl64                     compat_sys_fcntl64
205     common  madvise                         sys_madvise
206     common  mincore                         sys_mincore
207     common  gettid                          sys_gettid
208     common  tkill                           sys_tkill
209     common  setxattr                        sys_setxattr
210     common  lsetxattr                       sys_lsetxattr
211     common  fsetxattr                       sys_fsetxattr
212     common  getxattr                        sys_getxattr
213     common  lgetxattr                       sys_lgetxattr
214     common  fgetxattr                       sys_fgetxattr
215     common  listxattr                       sys_listxattr
216     common  llistxattr                      sys_llistxattr
217     common  flistxattr                      sys_flistxattr
218     common  removexattr                     sys_removexattr
219     common  lremovexattr                    sys_lremovexattr
220     common  fremovexattr                    sys_fremovexattr
221     32      futex                           sys_futex_time32
221     64      futex                           sys_futex
221     spu     futex                           sys_futex
222     common  sched_setaffinity               sys_sched_setaffinity           compat_sys_sched_setaffinity
223     common  sched_getaffinity               sys_sched_getaffinity           compat_sys_sched_getaffinity
# 224 unused
225     common  tuxcall                         sys_ni_syscall
226     32      sendfile64                      sys_sendfile64                  compat_sys_sendfile64
227     common  io_setup                        sys_io_setup                    compat_sys_io_setup
228     common  io_destroy                      sys_io_destroy
229     32      io_getevents                    sys_io_getevents_time32
229     64      io_getevents                    sys_io_getevents
229     spu     io_getevents                    sys_io_getevents
230     common  io_submit                       sys_io_submit                   compat_sys_io_submit
231     common  io_cancel                       sys_io_cancel
232     nospu   set_tid_address                 sys_set_tid_address
233     common  fadvise64                       sys_fadvise64                   ppc32_fadvise64
234     nospu   exit_group                      sys_exit_group
235     nospu   lookup_dcookie                  sys_lookup_dcookie              compat_sys_lookup_dcookie
236     common  epoll_create                    sys_epoll_create
237     common  epoll_ctl                       sys_epoll_ctl
238     common  epoll_wait                      sys_epoll_wait
239     common  remap_file_pages                sys_remap_file_pages
240     common  timer_create                    sys_timer_create                compat_sys_timer_create
241     32      timer_settime                   sys_timer_settime32
241     64      timer_settime                   sys_timer_settime
241     spu     timer_settime                   sys_timer_settime
242     32      timer_gettime                   sys_timer_gettime32
242     64      timer_gettime                   sys_timer_gettime
242     spu     timer_gettime                   sys_timer_gettime
243     common  timer_getoverrun                sys_timer_getoverrun
244     common  timer_delete                    sys_timer_delete
245     32      clock_settime                   sys_clock_settime32
245     64      clock_settime                   sys_clock_settime
245     spu     clock_settime                   sys_clock_settime
246     32      clock_gettime                   sys_clock_gettime32
246     64      clock_gettime                   sys_clock_gettime
246     spu     clock_gettime                   sys_clock_gettime
247     32      clock_getres                    sys_clock_getres_time32
247     64      clock_getres                    sys_clock_getres
247     spu     clock_getres                    sys_clock_getres
248     32      clock_nanosleep                 sys_clock_nanosleep_time32
248     64      clock_nanosleep                 sys_clock_nanosleep
248     spu     clock_nanosleep                 sys_clock_nanosleep
249     nospu   swapcontext                     sys_swapcontext                 compat_sys_swapcontext
250     common  tgkill                          sys_tgkill
251     32      utimes                          sys_utimes_time32
251     64      utimes                          sys_utimes
251     spu     utimes                          sys_utimes
252     common  statfs64                        sys_statfs64                    compat_sys_statfs64
253     common  fstatfs64                       sys_fstatfs64                   compat_sys_fstatfs64
254     32      fadvise64_64                    ppc_fadvise64_64
254     spu     fadvise64_64                    sys_ni_syscall
255     common  rtas                            sys_rtas
256     32      sys_debug_setcontext            sys_debug_setcontext            sys_ni_syscall
256     64      sys_debug_setcontext            sys_ni_syscall
256     spu     sys_debug_setcontext            sys_ni_syscall
# 257 reserved for vserver
258     nospu   migrate_pages                   sys_migrate_pages
259     nospu   mbind                           sys_mbind
260     nospu   get_mempolicy                   sys_get_mempolicy
261     nospu   set_mempolicy                   sys_set_mempolicy
262     nospu   mq_open                         sys_mq_open                     compat_sys_mq_open
263     nospu   mq_unlink                       sys_mq_unlink
264     32      mq_timedsend                    sys_mq_timedsend_time32
264     64      mq_timedsend                    sys_mq_timedsend
265     32      mq_timedreceive                 sys_mq_timedreceive_time32
265     64      mq_timedreceive                 sys_mq_timedreceive
266     nospu   mq_notify                       sys_mq_notify                   compat_sys_mq_notify
267     nospu   mq_getsetattr                   sys_mq_getsetattr               compat_sys_mq_getsetattr
268     nospu   kexec_load                      sys_kexec_load                  compat_sys_kexec_load
269     nospu   add_key                         sys_add_key
270     nospu   request_key                     sys_request_key
271     nospu   keyctl                          sys_keyctl                      compat_sys_keyctl
272     nospu   waitid                          sys_waitid                      compat_sys_waitid
273     nospu   ioprio_set                      sys_ioprio_set
274     nospu   ioprio_get                      sys_ioprio_get
275     nospu   inotify_init                    sys_inotify_init
276     nospu   inotify_add_watch               sys_inotify_add_watch
277     nospu   inotify_rm_watch                sys_inotify_rm_watch
278     nospu   spu_run                         sys_spu_run
279     nospu   spu_create                      sys_spu_create
280     32      pselect6                        sys_pselect6_time32             compat_sys_pselect6_time32
280     64      pselect6                        sys_pselect6
281     32      ppoll                           sys_ppoll_time32                compat_sys_ppoll_time32
281     64      ppoll                           sys_ppoll
282     common  unshare                         sys_unshare
283     common  splice                          sys_splice
284     common  tee                             sys_tee
285     common  vmsplice                        sys_vmsplice
286     common  openat                          sys_openat                      compat_sys_openat
287     common  mkdirat                         sys_mkdirat
288     common  mknodat                         sys_mknodat
289     common  fchownat                        sys_fchownat
290     32      futimesat                       sys_futimesat_time32
290     64      futimesat                       sys_futimesat
290     spu     utimesat                        sys_futimesat
291     32      fstatat64                       sys_fstatat64
291     64      newfstatat                      sys_newfstatat
291     spu     newfstatat                      sys_newfstatat
292     common  unlinkat                        sys_unlinkat
293     common  renameat                        sys_renameat
294     common  linkat                          sys_linkat
295     common  symlinkat                       sys_symlinkat
296     common  readlinkat                      sys_readlinkat
297     common  fchmodat                        sys_fchmodat
298     common  faccessat                       sys_faccessat
299     common  get_robust_list                 sys_get_robust_list             compat_sys_get_robust_list
300     common  set_robust_list                 sys_set_robust_list             compat_sys_set_robust_list
301     common  move_pages                      sys_move_pages
302     common  getcpu                          sys_getcpu
303     nospu   epoll_pwait                     sys_epoll_pwait                 compat_sys_epoll_pwait
304     32      utimensat                       sys_utimensat_time32
304     64      utimensat                       sys_utimensat
304     spu     utimensat                       sys_utimensat
305     common  signalfd                        sys_signalfd                    compat_sys_signalfd
306     common  timerfd_create                  sys_timerfd_create
307     common  eventfd                         sys_eventfd
308     common  sync_file_range2                sys_sync_file_range2            compat_sys_sync_file_range2
309     nospu   fallocate                       sys_fallocate                   compat_sys_fallocate
310     nospu   subpage_prot                    sys_subpage_prot
311     32      timerfd_settime                 sys_timerfd_settime32
311     64      timerfd_settime                 sys_timerfd_settime
311     spu     timerfd_settime                 sys_timerfd_settime
312     32      timerfd_gettime                 sys_timerfd_gettime32
312     64      timerfd_gettime                 sys_timerfd_gettime
312     spu     timerfd_gettime                 sys_timerfd_gettime
313     common  signalfd4                       sys_signalfd4                   compat_sys_signalfd4
314     common  eventfd2                        sys_eventfd2
315     common  epoll_create1                   sys_epoll_create1
316     common  dup3                            sys_dup3
317     common  pipe2                           sys_pipe2
318     nospu   inotify_init1                   sys_inotify_init1
319     common  perf_event_open                 sys_perf_event_open
320     common  preadv                          sys_preadv                      compat_sys_preadv
321     common  pwritev                         sys_pwritev                     compat_sys_pwritev
322     nospu   rt_tgsigqueueinfo               sys_rt_tgsigqueueinfo           compat_sys_rt_tgsigqueueinfo
323     nospu   fanotify_init                   sys_fanotify_init
324     nospu   fanotify_mark                   sys_fanotify_mark               compat_sys_fanotify_mark
325     common  prlimit64                       sys_prlimit64
326     common  socket                          sys_socket
327     common  bind                            sys_bind
328     common  connect                         sys_connect
329     common  listen                          sys_listen
330     common  accept                          sys_accept
331     common  getsockname                     sys_getsockname
332     common  getpeername                     sys_getpeername
333     common  socketpair                      sys_socketpair
334     common  send                            sys_send
335     common  sendto                          sys_sendto
336     common  recv                            sys_recv                        compat_sys_recv
337     common  recvfrom                        sys_recvfrom                    compat_sys_recvfrom
338     common  shutdown                        sys_shutdown
339     common  setsockopt                      sys_setsockopt                  sys_setsockopt
340     common  getsockopt                      sys_getsockopt                  sys_getsockopt
341     common  sendmsg                         sys_sendmsg                     compat_sys_sendmsg
342     common  recvmsg                         sys_recvmsg                     compat_sys_recvmsg
343     32      recvmmsg                        sys_recvmmsg_time32             compat_sys_recvmmsg_time32
343     64      recvmmsg                        sys_recvmmsg
343     spu     recvmmsg                        sys_recvmmsg
344     common  accept4                         sys_accept4
345     common  name_to_handle_at               sys_name_to_handle_at
346     common  open_by_handle_at               sys_open_by_handle_at           compat_sys_open_by_handle_at
347     32      clock_adjtime                   sys_clock_adjtime32
347     64      clock_adjtime                   sys_clock_adjtime
347     spu     clock_adjtime                   sys_clock_adjtime
348     common  syncfs                          sys_syncfs
349     common  sendmmsg                        sys_sendmmsg                    compat_sys_sendmmsg
350     common  setns                           sys_setns
351     nospu   process_vm_readv                sys_process_vm_readv
352     nospu   process_vm_writev               sys_process_vm_writev
353     nospu   finit_module                    sys_finit_module
354     nospu   kcmp                            sys_kcmp
355     common  sched_setattr                   sys_sched_setattr
356     common  sched_getattr                   sys_sched_getattr
357     common  renameat2                       sys_renameat2
358     common  seccomp                         sys_seccomp
359     common  getrandom                       sys_getrandom
360     common  memfd_create                    sys_memfd_create
361     common  bpf                             sys_bpf
362     nospu   execveat                        sys_execveat                    compat_sys_execveat
363     32      switch_endian                   sys_ni_syscall
363     64      switch_endian                   sys_switch_endian
363     spu     switch_endian                   sys_ni_syscall
364     common  userfaultfd                     sys_userfaultfd
365     common  membarrier                      sys_membarrier
# 366-377 originally left for IPC, now unused
378     nospu   mlock2                          sys_mlock2
379     nospu   copy_file_range                 sys_copy_file_range
380     common  preadv2                         sys_preadv2                     compat_sys_preadv2
381     common  pwritev2                        sys_pwritev2                    compat_sys_pwritev2
382     nospu   kexec_file_load                 sys_kexec_file_load
383     nospu   statx                           sys_statx
384     nospu   pkey_alloc                      sys_pkey_alloc
385     nospu   pkey_free                       sys_pkey_free
386     nospu   pkey_mprotect                   sys_pkey_mprotect
387     nospu   rseq                            sys_rseq
388     32      io_pgetevents                   sys_io_pgetevents_time32        compat_sys_io_pgetevents
388     64      io_pgetevents                   sys_io_pgetevents
# room for arch specific syscalls
392     64      semtimedop                      sys_semtimedop
393     common  semget                          sys_semget
394     common  semctl                          sys_semctl                      compat_sys_semctl
395     common  shmget                          sys_shmget
396     common  shmctl                          sys_shmctl                      compat_sys_shmctl
397     common  shmat                           sys_shmat                       compat_sys_shmat
398     common  shmdt                           sys_shmdt
399     common  msgget                          sys_msgget
400     common  msgsnd                          sys_msgsnd                      compat_sys_msgsnd
401     common  msgrcv                          sys_msgrcv                      compat_sys_msgrcv
402     common  msgctl                          sys_msgctl                      compat_sys_msgctl
403     32      clock_gettime64                 sys_clock_gettime               sys_clock_gettime
404     32      clock_settime64                 sys_clock_settime               sys_clock_settime
405     32      clock_adjtime64                 sys_clock_adjtime               sys_clock_adjtime
406     32      clock_getres_time64             sys_clock_getres                sys_clock_getres
407     32      clock_nanosleep_time64          sys_clock_nanosleep             sys_clock_nanosleep
408     32      timer_gettime64                 sys_timer_gettime               sys_timer_gettime
409     32      timer_settime64                 sys_timer_settime               sys_timer_settime
410     32      timerfd_gettime64               sys_timerfd_gettime             sys_timerfd_gettime
411     32      timerfd_settime64               sys_timerfd_settime             sys_timerfd_settime
412     32      utimensat_time64                sys_utimensat                   sys_utimensat
413     32      pselect6_time64                 sys_pselect6                    compat_sys_pselect6_time64
414     32      ppoll_time64                    sys_ppoll                       compat_sys_ppoll_time64
416     32      io_pgetevents_time64            sys_io_pgetevents               sys_io_pgetevents
417     32      recvmmsg_time64                 sys_recvmmsg                    compat_sys_recvmmsg_time64
418     32      mq_timedsend_time64             sys_mq_timedsend                sys_mq_timedsend
419     32      mq_timedreceive_time64          sys_mq_timedreceive             sys_mq_timedreceive
420     32      semtimedop_time64               sys_semtimedop                  sys_semtimedop
421     32      rt_sigtimedwait_time64          sys_rt_sigtimedwait             compat_sys_rt_sigtimedwait_time64
422     32      futex_time64                    sys_futex                       sys_futex
423     32      sched_rr_get_interval_time64    sys_sched_rr_get_interval       sys_sched_rr_get_interval
424     common  pidfd_send_signal               sys_pidfd_send_signal
425     common  io_uring_setup                  sys_io_uring_setup
426     common  io_uring_enter                  sys_io_uring_enter
427     common  io_uring_register               sys_io_uring_register
428     common  open_tree                       sys_open_tree
429     common  move_mount                      sys_move_mount
430     common  fsopen                          sys_fsopen
431     common  fsconfig                        sys_fsconfig
432     common  fsmount                         sys_fsmount
433     common  fspick                          sys_fspick
434     common  pidfd_open                      sys_pidfd_open
435     nospu   clone3                          sys_clone3
436     common  close_range                     sys_close_range
437     common  openat2                         sys_openat2
438     common  pidfd_getfd                     sys_pidfd_getfd
439     common  faccessat2                      sys_faccessat2
440     common  process_madvise                 sys_process_madvise
441     common  epoll_pwait2                    sys_epoll_pwait2                compat_sys_epoll_pwait2
442     common  mount_setattr                   sys_mount_setattr
443     common  quotactl_fd                     sys_quotactl_fd
444     common  landlock_create_ruleset         sys_landlock_create_ruleset
445     common  landlock_add_rule               sys_landlock_add_rule
446     common  landlock_restrict_self          sys_landlock_restrict_self
# 447 reserved for memfd_secret
448     common  process_mrelease                sys_process_mrelease
449     common  futex_waitv                     sys_futex_waitv
450     nospu   set_mempolicy_home_node         sys_set_mempolicy_home_node
"""


# SPARC
# - arch/sparc/kernel/syscalls/syscall.tbl
sparc_syscall_tbl = """
# system call numbers and entry vectors for sparc
#
# The format is:
# <number> <abi> <name> <entry point> <compat entry point>
#
# The <abi> can be common, 64, or 32 for this file.
#
0       common  restart_syscall         sys_restart_syscall
1       32      exit                    sys_exit                        sparc_exit
1       64      exit                    sparc_exit
2       common  fork                    sys_fork
3       common  read                    sys_read
4       common  write                   sys_write
5       common  open                    sys_open                        compat_sys_open
6       common  close                   sys_close
7       common  wait4                   sys_wait4                       compat_sys_wait4
8       common  creat                   sys_creat
9       common  link                    sys_link
10      common  unlink                  sys_unlink
11      32      execv                   sunos_execv
11      64      execv                   sys_nis_syscall
12      common  chdir                   sys_chdir
13      32      chown                   sys_chown16
13      64      chown                   sys_chown
14      common  mknod                   sys_mknod
15      common  chmod                   sys_chmod
16      32      lchown                  sys_lchown16
16      64      lchown                  sys_lchown
17      common  brk                     sys_brk
18      common  perfctr                 sys_nis_syscall
19      common  lseek                   sys_lseek                       compat_sys_lseek
20      common  getpid                  sys_getpid
21      common  capget                  sys_capget
22      common  capset                  sys_capset
23      32      setuid                  sys_setuid16
23      64      setuid                  sys_setuid
24      32      getuid                  sys_getuid16
24      64      getuid                  sys_getuid
25      common  vmsplice                sys_vmsplice
26      common  ptrace                  sys_ptrace                      compat_sys_ptrace
27      common  alarm                   sys_alarm
28      common  sigaltstack             sys_sigaltstack                 compat_sys_sigaltstack
29      32      pause                   sys_pause
29      64      pause                   sys_nis_syscall
30      32      utime                   sys_utime32
30      64      utime                   sys_utime
31      32      lchown32                sys_lchown
32      32      fchown32                sys_fchown
33      common  access                  sys_access
34      common  nice                    sys_nice
35      32      chown32                 sys_chown
36      common  sync                    sys_sync
37      common  kill                    sys_kill
38      common  stat                    sys_newstat                     compat_sys_newstat
39      32      sendfile                sys_sendfile                    compat_sys_sendfile
39      64      sendfile                sys_sendfile64
40      common  lstat                   sys_newlstat                    compat_sys_newlstat
41      common  dup                     sys_dup
42      common  pipe                    sys_sparc_pipe
43      common  times                   sys_times                       compat_sys_times
44      32      getuid32                sys_getuid
45      common  umount2                 sys_umount
46      32      setgid                  sys_setgid16
46      64      setgid                  sys_setgid
47      32      getgid                  sys_getgid16
47      64      getgid                  sys_getgid
48      common  signal                  sys_signal
49      32      geteuid                 sys_geteuid16
49      64      geteuid                 sys_geteuid
50      32      getegid                 sys_getegid16
50      64      getegid                 sys_getegid
51      common  acct                    sys_acct
52      64      memory_ordering         sys_memory_ordering
53      32      getgid32                sys_getgid
54      common  ioctl                   sys_ioctl                       compat_sys_ioctl
55      common  reboot                  sys_reboot
56      32      mmap2                   sys_mmap2                       sys32_mmap2
57      common  symlink                 sys_symlink
58      common  readlink                sys_readlink
59      32      execve                  sys_execve                      sys32_execve
59      64      execve                  sys64_execve
60      common  umask                   sys_umask
61      common  chroot                  sys_chroot
62      common  fstat                   sys_newfstat                    compat_sys_newfstat
63      common  fstat64                 sys_fstat64                     compat_sys_fstat64
64      common  getpagesize             sys_getpagesize
65      common  msync                   sys_msync
66      common  vfork                   sys_vfork
67      common  pread64                 sys_pread64                     compat_sys_pread64
68      common  pwrite64                sys_pwrite64                    compat_sys_pwrite64
69      32      geteuid32               sys_geteuid
70      32      getegid32               sys_getegid
71      common  mmap                    sys_mmap
72      32      setreuid32              sys_setreuid
73      32      munmap                  sys_munmap
73      64      munmap                  sys_64_munmap
74      common  mprotect                sys_mprotect
75      common  madvise                 sys_madvise
76      common  vhangup                 sys_vhangup
77      32      truncate64              sys_truncate64                  compat_sys_truncate64
78      common  mincore                 sys_mincore
79      32      getgroups               sys_getgroups16
79      64      getgroups               sys_getgroups
80      32      setgroups               sys_setgroups16
80      64      setgroups               sys_setgroups
81      common  getpgrp                 sys_getpgrp
82      32      setgroups32             sys_setgroups
83      common  setitimer               sys_setitimer                   compat_sys_setitimer
84      32      ftruncate64             sys_ftruncate64                 compat_sys_ftruncate64
85      common  swapon                  sys_swapon
86      common  getitimer               sys_getitimer                   compat_sys_getitimer
87      32      setuid32                sys_setuid
88      common  sethostname             sys_sethostname
89      32      setgid32                sys_setgid
90      common  dup2                    sys_dup2
91      32      setfsuid32              sys_setfsuid
92      common  fcntl                   sys_fcntl                       compat_sys_fcntl
93      common  select                  sys_select
94      32      setfsgid32              sys_setfsgid
95      common  fsync                   sys_fsync
96      common  setpriority             sys_setpriority
97      common  socket                  sys_socket
98      common  connect                 sys_connect
99      common  accept                  sys_accept
100     common  getpriority             sys_getpriority
101     common  rt_sigreturn            sys_rt_sigreturn                sys32_rt_sigreturn
102     common  rt_sigaction            sys_rt_sigaction                compat_sys_rt_sigaction
103     common  rt_sigprocmask          sys_rt_sigprocmask              compat_sys_rt_sigprocmask
104     common  rt_sigpending           sys_rt_sigpending               compat_sys_rt_sigpending
105     32      rt_sigtimedwait         sys_rt_sigtimedwait_time32      compat_sys_rt_sigtimedwait_time32
105     64      rt_sigtimedwait         sys_rt_sigtimedwait
106     common  rt_sigqueueinfo         sys_rt_sigqueueinfo             compat_sys_rt_sigqueueinfo
107     common  rt_sigsuspend           sys_rt_sigsuspend               compat_sys_rt_sigsuspend
108     32      setresuid32             sys_setresuid
108     64      setresuid               sys_setresuid
109     32      getresuid32             sys_getresuid
109     64      getresuid               sys_getresuid
110     32      setresgid32             sys_setresgid
110     64      setresgid               sys_setresgid
111     32      getresgid32             sys_getresgid
111     64      getresgid               sys_getresgid
112     32      setregid32              sys_setregid
113     common  recvmsg                 sys_recvmsg                     compat_sys_recvmsg
114     common  sendmsg                 sys_sendmsg                     compat_sys_sendmsg
115     32      getgroups32             sys_getgroups
116     common  gettimeofday            sys_gettimeofday                compat_sys_gettimeofday
117     common  getrusage               sys_getrusage                   compat_sys_getrusage
118     common  getsockopt              sys_getsockopt                  sys_getsockopt
119     common  getcwd                  sys_getcwd
120     common  readv                   sys_readv
121     common  writev                  sys_writev
122     common  settimeofday            sys_settimeofday                compat_sys_settimeofday
123     32      fchown                  sys_fchown16
123     64      fchown                  sys_fchown
124     common  fchmod                  sys_fchmod
125     common  recvfrom                sys_recvfrom
126     32      setreuid                sys_setreuid16
126     64      setreuid                sys_setreuid
127     32      setregid                sys_setregid16
127     64      setregid                sys_setregid
128     common  rename                  sys_rename
129     common  truncate                sys_truncate                    compat_sys_truncate
130     common  ftruncate               sys_ftruncate                   compat_sys_ftruncate
131     common  flock                   sys_flock
132     common  lstat64                 sys_lstat64                     compat_sys_lstat64
133     common  sendto                  sys_sendto
134     common  shutdown                sys_shutdown
135     common  socketpair              sys_socketpair
136     common  mkdir                   sys_mkdir
137     common  rmdir                   sys_rmdir
138     32      utimes                  sys_utimes_time32
138     64      utimes                  sys_utimes
139     common  stat64                  sys_stat64                      compat_sys_stat64
140     common  sendfile64              sys_sendfile64
141     common  getpeername             sys_getpeername
142     32      futex                   sys_futex_time32
142     64      futex                   sys_futex
143     common  gettid                  sys_gettid
144     common  getrlimit               sys_getrlimit                   compat_sys_getrlimit
145     common  setrlimit               sys_setrlimit                   compat_sys_setrlimit
146     common  pivot_root              sys_pivot_root
147     common  prctl                   sys_prctl
148     common  pciconfig_read          sys_pciconfig_read
149     common  pciconfig_write         sys_pciconfig_write
150     common  getsockname             sys_getsockname
151     common  inotify_init            sys_inotify_init
152     common  inotify_add_watch       sys_inotify_add_watch
153     common  poll                    sys_poll
154     common  getdents64              sys_getdents64
155     32      fcntl64                 sys_fcntl64                     compat_sys_fcntl64
156     common  inotify_rm_watch        sys_inotify_rm_watch
157     common  statfs                  sys_statfs                      compat_sys_statfs
158     common  fstatfs                 sys_fstatfs                     compat_sys_fstatfs
159     common  umount                  sys_oldumount
160     common  sched_set_affinity      sys_sched_setaffinity           compat_sys_sched_setaffinity
161     common  sched_get_affinity      sys_sched_getaffinity           compat_sys_sched_getaffinity
162     common  getdomainname           sys_getdomainname
163     common  setdomainname           sys_setdomainname
164     64      utrap_install           sys_utrap_install
165     common  quotactl                sys_quotactl
166     common  set_tid_address         sys_set_tid_address
167     common  mount                   sys_mount
168     common  ustat                   sys_ustat                       compat_sys_ustat
169     common  setxattr                sys_setxattr
170     common  lsetxattr               sys_lsetxattr
171     common  fsetxattr               sys_fsetxattr
172     common  getxattr                sys_getxattr
173     common  lgetxattr               sys_lgetxattr
174     common  getdents                sys_getdents                    compat_sys_getdents
175     common  setsid                  sys_setsid
176     common  fchdir                  sys_fchdir
177     common  fgetxattr               sys_fgetxattr
178     common  listxattr               sys_listxattr
179     common  llistxattr              sys_llistxattr
180     common  flistxattr              sys_flistxattr
181     common  removexattr             sys_removexattr
182     common  lremovexattr            sys_lremovexattr
183     32      sigpending              sys_sigpending                  compat_sys_sigpending
183     64      sigpending              sys_nis_syscall
184     common  query_module            sys_ni_syscall
185     common  setpgid                 sys_setpgid
186     common  fremovexattr            sys_fremovexattr
187     common  tkill                   sys_tkill
188     32      exit_group              sys_exit_group                  sparc_exit_group
188     64      exit_group              sparc_exit_group
189     common  uname                   sys_newuname
190     common  init_module             sys_init_module
191     32      personality             sys_personality                 sys_sparc64_personality
191     64      personality             sys_sparc64_personality
192     32      remap_file_pages        sys_sparc_remap_file_pages      sys_remap_file_pages
192     64      remap_file_pages        sys_remap_file_pages
193     common  epoll_create            sys_epoll_create
194     common  epoll_ctl               sys_epoll_ctl
195     common  epoll_wait              sys_epoll_wait
196     common  ioprio_set              sys_ioprio_set
197     common  getppid                 sys_getppid
198     32      sigaction               sys_sparc_sigaction             compat_sys_sparc_sigaction
198     64      sigaction               sys_nis_syscall
199     common  sgetmask                sys_sgetmask
200     common  ssetmask                sys_ssetmask
201     32      sigsuspend              sys_sigsuspend
201     64      sigsuspend              sys_nis_syscall
202     common  oldlstat                sys_newlstat                    compat_sys_newlstat
203     common  uselib                  sys_uselib
204     32      readdir                 sys_old_readdir                 compat_sys_old_readdir
204     64      readdir                 sys_nis_syscall
205     common  readahead               sys_readahead                   compat_sys_readahead
206     common  socketcall              sys_socketcall                  sys32_socketcall
207     common  syslog                  sys_syslog
208     common  lookup_dcookie          sys_lookup_dcookie              compat_sys_lookup_dcookie
209     common  fadvise64               sys_fadvise64                   compat_sys_fadvise64
210     common  fadvise64_64            sys_fadvise64_64                compat_sys_fadvise64_64
211     common  tgkill                  sys_tgkill
212     common  waitpid                 sys_waitpid
213     common  swapoff                 sys_swapoff
214     common  sysinfo                 sys_sysinfo                     compat_sys_sysinfo
215     32      ipc                     sys_ipc                         compat_sys_ipc
215     64      ipc                     sys_sparc_ipc
216     32      sigreturn               sys_sigreturn                   sys32_sigreturn
216     64      sigreturn               sys_nis_syscall
217     common  clone                   sys_clone
218     common  ioprio_get              sys_ioprio_get
219     32      adjtimex                sys_adjtimex_time32
219     64      adjtimex                sys_sparc_adjtimex
220     32      sigprocmask             sys_sigprocmask                 compat_sys_sigprocmask
220     64      sigprocmask             sys_nis_syscall
221     common  create_module           sys_ni_syscall
222     common  delete_module           sys_delete_module
223     common  get_kernel_syms         sys_ni_syscall
224     common  getpgid                 sys_getpgid
225     common  bdflush                 sys_ni_syscall
226     common  sysfs                   sys_sysfs
227     common  afs_syscall             sys_nis_syscall
228     common  setfsuid                sys_setfsuid16
229     common  setfsgid                sys_setfsgid16
230     common  _newselect              sys_select                      compat_sys_select
231     32      time                    sys_time32
232     common  splice                  sys_splice
233     32      stime                   sys_stime32
233     64      stime                   sys_stime
234     common  statfs64                sys_statfs64                    compat_sys_statfs64
235     common  fstatfs64               sys_fstatfs64                   compat_sys_fstatfs64
236     common  _llseek                 sys_llseek
237     common  mlock                   sys_mlock
238     common  munlock                 sys_munlock
239     common  mlockall                sys_mlockall
240     common  munlockall              sys_munlockall
241     common  sched_setparam          sys_sched_setparam
242     common  sched_getparam          sys_sched_getparam
243     common  sched_setscheduler      sys_sched_setscheduler
244     common  sched_getscheduler      sys_sched_getscheduler
245     common  sched_yield             sys_sched_yield
246     common  sched_get_priority_max  sys_sched_get_priority_max
247     common  sched_get_priority_min  sys_sched_get_priority_min
248     32      sched_rr_get_interval   sys_sched_rr_get_interval_time32
248     64      sched_rr_get_interval   sys_sched_rr_get_interval
249     32      nanosleep               sys_nanosleep_time32
249     64      nanosleep               sys_nanosleep
250     32      mremap                  sys_mremap
250     64      mremap                  sys_64_mremap
251     common  _sysctl                 sys_ni_syscall
252     common  getsid                  sys_getsid
253     common  fdatasync               sys_fdatasync
254     32      nfsservctl              sys_ni_syscall                  sys_nis_syscall
254     64      nfsservctl              sys_nis_syscall
255     common  sync_file_range         sys_sync_file_range             compat_sys_sync_file_range
256     32      clock_settime           sys_clock_settime32
256     64      clock_settime           sys_clock_settime
257     32      clock_gettime           sys_clock_gettime32
257     64      clock_gettime           sys_clock_gettime
258     32      clock_getres            sys_clock_getres_time32
258     64      clock_getres            sys_clock_getres
259     32      clock_nanosleep         sys_clock_nanosleep_time32
259     64      clock_nanosleep         sys_clock_nanosleep
260     common  sched_getaffinity       sys_sched_getaffinity           compat_sys_sched_getaffinity
261     common  sched_setaffinity       sys_sched_setaffinity           compat_sys_sched_setaffinity
262     32      timer_settime           sys_timer_settime32
262     64      timer_settime           sys_timer_settime
263     32      timer_gettime           sys_timer_gettime32
263     64      timer_gettime           sys_timer_gettime
264     common  timer_getoverrun        sys_timer_getoverrun
265     common  timer_delete            sys_timer_delete
266     common  timer_create            sys_timer_create                compat_sys_timer_create
# 267 was vserver
267     common  vserver                 sys_nis_syscall
268     common  io_setup                sys_io_setup                    compat_sys_io_setup
269     common  io_destroy              sys_io_destroy
270     common  io_submit               sys_io_submit                   compat_sys_io_submit
271     common  io_cancel               sys_io_cancel
272     32      io_getevents            sys_io_getevents_time32
272     64      io_getevents            sys_io_getevents
273     common  mq_open                 sys_mq_open                     compat_sys_mq_open
274     common  mq_unlink               sys_mq_unlink
275     32      mq_timedsend            sys_mq_timedsend_time32
275     64      mq_timedsend            sys_mq_timedsend
276     32      mq_timedreceive         sys_mq_timedreceive_time32
276     64      mq_timedreceive         sys_mq_timedreceive
277     common  mq_notify               sys_mq_notify                   compat_sys_mq_notify
278     common  mq_getsetattr           sys_mq_getsetattr               compat_sys_mq_getsetattr
279     common  waitid                  sys_waitid                      compat_sys_waitid
280     common  tee                     sys_tee
281     common  add_key                 sys_add_key
282     common  request_key             sys_request_key
283     common  keyctl                  sys_keyctl                      compat_sys_keyctl
284     common  openat                  sys_openat                      compat_sys_openat
285     common  mkdirat                 sys_mkdirat
286     common  mknodat                 sys_mknodat
287     common  fchownat                sys_fchownat
288     32      futimesat               sys_futimesat_time32
288     64      futimesat               sys_futimesat
289     common  fstatat64               sys_fstatat64                   compat_sys_fstatat64
290     common  unlinkat                sys_unlinkat
291     common  renameat                sys_renameat
292     common  linkat                  sys_linkat
293     common  symlinkat               sys_symlinkat
294     common  readlinkat              sys_readlinkat
295     common  fchmodat                sys_fchmodat
296     common  faccessat               sys_faccessat
297     32      pselect6                sys_pselect6_time32             compat_sys_pselect6_time32
297     64      pselect6                sys_pselect6
298     32      ppoll                   sys_ppoll_time32                compat_sys_ppoll_time32
298     64      ppoll                   sys_ppoll
299     common  unshare                 sys_unshare
300     common  set_robust_list         sys_set_robust_list             compat_sys_set_robust_list
301     common  get_robust_list         sys_get_robust_list             compat_sys_get_robust_list
302     common  migrate_pages           sys_migrate_pages
303     common  mbind                   sys_mbind
304     common  get_mempolicy           sys_get_mempolicy
305     common  set_mempolicy           sys_set_mempolicy
306     common  kexec_load              sys_kexec_load                  compat_sys_kexec_load
307     common  move_pages              sys_move_pages
308     common  getcpu                  sys_getcpu
309     common  epoll_pwait             sys_epoll_pwait                 compat_sys_epoll_pwait
310     32      utimensat               sys_utimensat_time32
310     64      utimensat               sys_utimensat
311     common  signalfd                sys_signalfd                    compat_sys_signalfd
312     common  timerfd_create          sys_timerfd_create
313     common  eventfd                 sys_eventfd
314     common  fallocate               sys_fallocate                   compat_sys_fallocate
315     32      timerfd_settime         sys_timerfd_settime32
315     64      timerfd_settime         sys_timerfd_settime
316     32      timerfd_gettime         sys_timerfd_gettime32
316     64      timerfd_gettime         sys_timerfd_gettime
317     common  signalfd4               sys_signalfd4                   compat_sys_signalfd4
318     common  eventfd2                sys_eventfd2
319     common  epoll_create1           sys_epoll_create1
320     common  dup3                    sys_dup3
321     common  pipe2                   sys_pipe2
322     common  inotify_init1           sys_inotify_init1
323     common  accept4                 sys_accept4
324     common  preadv                  sys_preadv                      compat_sys_preadv
325     common  pwritev                 sys_pwritev                     compat_sys_pwritev
326     common  rt_tgsigqueueinfo       sys_rt_tgsigqueueinfo           compat_sys_rt_tgsigqueueinfo
327     common  perf_event_open         sys_perf_event_open
328     32      recvmmsg                sys_recvmmsg_time32             compat_sys_recvmmsg_time32
328     64      recvmmsg                sys_recvmmsg
329     common  fanotify_init           sys_fanotify_init
330     common  fanotify_mark           sys_fanotify_mark               compat_sys_fanotify_mark
331     common  prlimit64               sys_prlimit64
332     common  name_to_handle_at       sys_name_to_handle_at
333     common  open_by_handle_at       sys_open_by_handle_at           compat_sys_open_by_handle_at
334     32      clock_adjtime           sys_clock_adjtime32
334     64      clock_adjtime           sys_sparc_clock_adjtime
335     common  syncfs                  sys_syncfs
336     common  sendmmsg                sys_sendmmsg                    compat_sys_sendmmsg
337     common  setns                   sys_setns
338     common  process_vm_readv        sys_process_vm_readv
339     common  process_vm_writev       sys_process_vm_writev
340     32      kern_features           sys_ni_syscall                  sys_kern_features
340     64      kern_features           sys_kern_features
341     common  kcmp                    sys_kcmp
342     common  finit_module            sys_finit_module
343     common  sched_setattr           sys_sched_setattr
344     common  sched_getattr           sys_sched_getattr
345     common  renameat2               sys_renameat2
346     common  seccomp                 sys_seccomp
347     common  getrandom               sys_getrandom
348     common  memfd_create            sys_memfd_create
349     common  bpf                     sys_bpf
350     32      execveat                sys_execveat                    sys32_execveat
350     64      execveat                sys64_execveat
351     common  membarrier              sys_membarrier
352     common  userfaultfd             sys_userfaultfd
353     common  bind                    sys_bind
354     common  listen                  sys_listen
355     common  setsockopt              sys_setsockopt                  sys_setsockopt
356     common  mlock2                  sys_mlock2
357     common  copy_file_range         sys_copy_file_range
358     common  preadv2                 sys_preadv2                     compat_sys_preadv2
359     common  pwritev2                sys_pwritev2                    compat_sys_pwritev2
360     common  statx                   sys_statx
361     32      io_pgetevents           sys_io_pgetevents_time32        compat_sys_io_pgetevents
361     64      io_pgetevents           sys_io_pgetevents
362     common  pkey_mprotect           sys_pkey_mprotect
363     common  pkey_alloc              sys_pkey_alloc
364     common  pkey_free               sys_pkey_free
365     common  rseq                    sys_rseq
# room for arch specific syscalls
392     64      semtimedop                      sys_semtimedop
393     common  semget                  sys_semget
394     common  semctl                  sys_semctl                      compat_sys_semctl
395     common  shmget                  sys_shmget
396     common  shmctl                  sys_shmctl                      compat_sys_shmctl
397     common  shmat                   sys_shmat                       compat_sys_shmat
398     common  shmdt                   sys_shmdt
399     common  msgget                  sys_msgget
400     common  msgsnd                  sys_msgsnd                      compat_sys_msgsnd
401     common  msgrcv                  sys_msgrcv                      compat_sys_msgrcv
402     common  msgctl                  sys_msgctl                      compat_sys_msgctl
403     32      clock_gettime64                 sys_clock_gettime               sys_clock_gettime
404     32      clock_settime64                 sys_clock_settime               sys_clock_settime
405     32      clock_adjtime64                 sys_clock_adjtime               sys_clock_adjtime
406     32      clock_getres_time64             sys_clock_getres                sys_clock_getres
407     32      clock_nanosleep_time64          sys_clock_nanosleep             sys_clock_nanosleep
408     32      timer_gettime64                 sys_timer_gettime               sys_timer_gettime
409     32      timer_settime64                 sys_timer_settime               sys_timer_settime
410     32      timerfd_gettime64               sys_timerfd_gettime             sys_timerfd_gettime
411     32      timerfd_settime64               sys_timerfd_settime             sys_timerfd_settime
412     32      utimensat_time64                sys_utimensat                   sys_utimensat
413     32      pselect6_time64                 sys_pselect6                    compat_sys_pselect6_time64
414     32      ppoll_time64                    sys_ppoll                       compat_sys_ppoll_time64
416     32      io_pgetevents_time64            sys_io_pgetevents               sys_io_pgetevents
417     32      recvmmsg_time64                 sys_recvmmsg                    compat_sys_recvmmsg_time64
418     32      mq_timedsend_time64             sys_mq_timedsend                sys_mq_timedsend
419     32      mq_timedreceive_time64          sys_mq_timedreceive             sys_mq_timedreceive
420     32      semtimedop_time64               sys_semtimedop                  sys_semtimedop
421     32      rt_sigtimedwait_time64          sys_rt_sigtimedwait             compat_sys_rt_sigtimedwait_time64
422     32      futex_time64                    sys_futex                       sys_futex
423     32      sched_rr_get_interval_time64    sys_sched_rr_get_interval       sys_sched_rr_get_interval
424     common  pidfd_send_signal               sys_pidfd_send_signal
425     common  io_uring_setup                  sys_io_uring_setup
426     common  io_uring_enter                  sys_io_uring_enter
427     common  io_uring_register               sys_io_uring_register
428     common  open_tree                       sys_open_tree
429     common  move_mount                      sys_move_mount
430     common  fsopen                          sys_fsopen
431     common  fsconfig                        sys_fsconfig
432     common  fsmount                         sys_fsmount
433     common  fspick                          sys_fspick
434     common  pidfd_open                      sys_pidfd_open
# 435 reserved for clone3
436     common  close_range                     sys_close_range
437     common  openat2                 sys_openat2
438     common  pidfd_getfd                     sys_pidfd_getfd
439     common  faccessat2                      sys_faccessat2
440     common  process_madvise                 sys_process_madvise
441     common  epoll_pwait2                    sys_epoll_pwait2                compat_sys_epoll_pwait2
442     common  mount_setattr                   sys_mount_setattr
443     common  quotactl_fd                     sys_quotactl_fd
444     common  landlock_create_ruleset         sys_landlock_create_ruleset
445     common  landlock_add_rule               sys_landlock_add_rule
446     common  landlock_restrict_self          sys_landlock_restrict_self
# 447 reserved for memfd_secret
448     common  process_mrelease                sys_process_mrelease
449     common  futex_waitv                     sys_futex_waitv
450     common  set_mempolicy_home_node         sys_set_mempolicy_home_node
"""


# RISCV64
#
# [How to make]
# gcc -I `pwd`/include/uapi/ -E -D__SYSCALL=SYSCALL arch/riscv/include/uapi/asm/unistd.h \
# | grep ^SYSCALL | sed -e 's/SYSCALL(//;s/[,)]//g;/+/d' > /tmp/a
# grep -oP "__NR\S+\s+\d+$" include/uapi/asm-generic/unistd.h | grep -v __NR_sync_file_range2 > /tmp/b
# join -2 2 -o 1.1,1.10,2.1,1.2 -e riscv64 /tmp/a /tmp/b | sed -e 's/\(__NR_\|__NR3264_\)//g' | column -t
#
riscv64_syscall_tbl = """
0    riscv64  io_setup                 sys_io_setup
1    riscv64  io_destroy               sys_io_destroy
2    riscv64  io_submit                sys_io_submit
3    riscv64  io_cancel                sys_io_cancel
4    riscv64  io_getevents             sys_io_getevents
5    riscv64  setxattr                 sys_setxattr
6    riscv64  lsetxattr                sys_lsetxattr
7    riscv64  fsetxattr                sys_fsetxattr
8    riscv64  getxattr                 sys_getxattr
9    riscv64  lgetxattr                sys_lgetxattr
10   riscv64  fgetxattr                sys_fgetxattr
11   riscv64  listxattr                sys_listxattr
12   riscv64  llistxattr               sys_llistxattr
13   riscv64  flistxattr               sys_flistxattr
14   riscv64  removexattr              sys_removexattr
15   riscv64  lremovexattr             sys_lremovexattr
16   riscv64  fremovexattr             sys_fremovexattr
17   riscv64  getcwd                   sys_getcwd
18   riscv64  lookup_dcookie           sys_lookup_dcookie
19   riscv64  eventfd2                 sys_eventfd2
20   riscv64  epoll_create1            sys_epoll_create1
21   riscv64  epoll_ctl                sys_epoll_ctl
22   riscv64  epoll_pwait              sys_epoll_pwait
23   riscv64  dup                      sys_dup
24   riscv64  dup3                     sys_dup3
25   riscv64  fcntl                    sys_fcntl
26   riscv64  inotify_init1            sys_inotify_init1
27   riscv64  inotify_add_watch        sys_inotify_add_watch
28   riscv64  inotify_rm_watch         sys_inotify_rm_watch
29   riscv64  ioctl                    sys_ioctl
30   riscv64  ioprio_set               sys_ioprio_set
31   riscv64  ioprio_get               sys_ioprio_get
32   riscv64  flock                    sys_flock
33   riscv64  mknodat                  sys_mknodat
34   riscv64  mkdirat                  sys_mkdirat
35   riscv64  unlinkat                 sys_unlinkat
36   riscv64  symlinkat                sys_symlinkat
37   riscv64  linkat                   sys_linkat
39   riscv64  umount2                  sys_umount
40   riscv64  mount                    sys_mount
41   riscv64  pivot_root               sys_pivot_root
42   riscv64  nfsservctl               sys_ni_syscall
43   riscv64  statfs                   sys_statfs
44   riscv64  fstatfs                  sys_fstatfs
45   riscv64  truncate                 sys_truncate
46   riscv64  ftruncate                sys_ftruncate
47   riscv64  fallocate                sys_fallocate
48   riscv64  faccessat                sys_faccessat
49   riscv64  chdir                    sys_chdir
50   riscv64  fchdir                   sys_fchdir
51   riscv64  chroot                   sys_chroot
52   riscv64  fchmod                   sys_fchmod
53   riscv64  fchmodat                 sys_fchmodat
54   riscv64  fchownat                 sys_fchownat
55   riscv64  fchown                   sys_fchown
56   riscv64  openat                   sys_openat
57   riscv64  close                    sys_close
58   riscv64  vhangup                  sys_vhangup
59   riscv64  pipe2                    sys_pipe2
60   riscv64  quotactl                 sys_quotactl
61   riscv64  getdents64               sys_getdents64
62   riscv64  lseek                    sys_lseek
63   riscv64  read                     sys_read
64   riscv64  write                    sys_write
65   riscv64  readv                    sys_readv
66   riscv64  writev                   sys_writev
67   riscv64  pread64                  sys_pread64
68   riscv64  pwrite64                 sys_pwrite64
69   riscv64  preadv                   sys_preadv
70   riscv64  pwritev                  sys_pwritev
71   riscv64  sendfile                 sys_sendfile64
72   riscv64  pselect6                 sys_pselect6
73   riscv64  ppoll                    sys_ppoll
74   riscv64  signalfd4                sys_signalfd4
75   riscv64  vmsplice                 sys_vmsplice
76   riscv64  splice                   sys_splice
77   riscv64  tee                      sys_tee
78   riscv64  readlinkat               sys_readlinkat
79   riscv64  fstatat                  sys_newfstatat
80   riscv64  fstat                    sys_newfstat
81   riscv64  sync                     sys_sync
82   riscv64  fsync                    sys_fsync
83   riscv64  fdatasync                sys_fdatasync
84   riscv64  sync_file_range          sys_sync_file_range
85   riscv64  timerfd_create           sys_timerfd_create
86   riscv64  timerfd_settime          sys_timerfd_settime
87   riscv64  timerfd_gettime          sys_timerfd_gettime
88   riscv64  utimensat                sys_utimensat
89   riscv64  acct                     sys_acct
90   riscv64  capget                   sys_capget
91   riscv64  capset                   sys_capset
92   riscv64  personality              sys_personality
93   riscv64  exit                     sys_exit
94   riscv64  exit_group               sys_exit_group
95   riscv64  waitid                   sys_waitid
96   riscv64  set_tid_address          sys_set_tid_address
97   riscv64  unshare                  sys_unshare
98   riscv64  futex                    sys_futex
99   riscv64  set_robust_list          sys_set_robust_list
100  riscv64  get_robust_list          sys_get_robust_list
101  riscv64  nanosleep                sys_nanosleep
102  riscv64  getitimer                sys_getitimer
103  riscv64  setitimer                sys_setitimer
104  riscv64  kexec_load               sys_kexec_load
105  riscv64  init_module              sys_init_module
106  riscv64  delete_module            sys_delete_module
107  riscv64  timer_create             sys_timer_create
108  riscv64  timer_gettime            sys_timer_gettime
109  riscv64  timer_getoverrun         sys_timer_getoverrun
110  riscv64  timer_settime            sys_timer_settime
111  riscv64  timer_delete             sys_timer_delete
112  riscv64  clock_settime            sys_clock_settime
113  riscv64  clock_gettime            sys_clock_gettime
114  riscv64  clock_getres             sys_clock_getres
115  riscv64  clock_nanosleep          sys_clock_nanosleep
116  riscv64  syslog                   sys_syslog
117  riscv64  ptrace                   sys_ptrace
118  riscv64  sched_setparam           sys_sched_setparam
119  riscv64  sched_setscheduler       sys_sched_setscheduler
120  riscv64  sched_getscheduler       sys_sched_getscheduler
121  riscv64  sched_getparam           sys_sched_getparam
122  riscv64  sched_setaffinity        sys_sched_setaffinity
123  riscv64  sched_getaffinity        sys_sched_getaffinity
124  riscv64  sched_yield              sys_sched_yield
125  riscv64  sched_get_priority_max   sys_sched_get_priority_max
126  riscv64  sched_get_priority_min   sys_sched_get_priority_min
127  riscv64  sched_rr_get_interval    sys_sched_rr_get_interval
128  riscv64  restart_syscall          sys_restart_syscall
129  riscv64  kill                     sys_kill
130  riscv64  tkill                    sys_tkill
131  riscv64  tgkill                   sys_tgkill
132  riscv64  sigaltstack              sys_sigaltstack
133  riscv64  rt_sigsuspend            sys_rt_sigsuspend
134  riscv64  rt_sigaction             sys_rt_sigaction
135  riscv64  rt_sigprocmask           sys_rt_sigprocmask
136  riscv64  rt_sigpending            sys_rt_sigpending
137  riscv64  rt_sigtimedwait          sys_rt_sigtimedwait
138  riscv64  rt_sigqueueinfo          sys_rt_sigqueueinfo
139  riscv64  rt_sigreturn             sys_rt_sigreturn
140  riscv64  setpriority              sys_setpriority
141  riscv64  getpriority              sys_getpriority
142  riscv64  reboot                   sys_reboot
143  riscv64  setregid                 sys_setregid
144  riscv64  setgid                   sys_setgid
145  riscv64  setreuid                 sys_setreuid
146  riscv64  setuid                   sys_setuid
147  riscv64  setresuid                sys_setresuid
148  riscv64  getresuid                sys_getresuid
149  riscv64  setresgid                sys_setresgid
150  riscv64  getresgid                sys_getresgid
151  riscv64  setfsuid                 sys_setfsuid
152  riscv64  setfsgid                 sys_setfsgid
153  riscv64  times                    sys_times
154  riscv64  setpgid                  sys_setpgid
155  riscv64  getpgid                  sys_getpgid
156  riscv64  getsid                   sys_getsid
157  riscv64  setsid                   sys_setsid
158  riscv64  getgroups                sys_getgroups
159  riscv64  setgroups                sys_setgroups
160  riscv64  uname                    sys_newuname
161  riscv64  sethostname              sys_sethostname
162  riscv64  setdomainname            sys_setdomainname
163  riscv64  getrlimit                sys_getrlimit
164  riscv64  setrlimit                sys_setrlimit
165  riscv64  getrusage                sys_getrusage
166  riscv64  umask                    sys_umask
167  riscv64  prctl                    sys_prctl
168  riscv64  getcpu                   sys_getcpu
169  riscv64  gettimeofday             sys_gettimeofday
170  riscv64  settimeofday             sys_settimeofday
171  riscv64  adjtimex                 sys_adjtimex
172  riscv64  getpid                   sys_getpid
173  riscv64  getppid                  sys_getppid
174  riscv64  getuid                   sys_getuid
175  riscv64  geteuid                  sys_geteuid
176  riscv64  getgid                   sys_getgid
177  riscv64  getegid                  sys_getegid
178  riscv64  gettid                   sys_gettid
179  riscv64  sysinfo                  sys_sysinfo
180  riscv64  mq_open                  sys_mq_open
181  riscv64  mq_unlink                sys_mq_unlink
182  riscv64  mq_timedsend             sys_mq_timedsend
183  riscv64  mq_timedreceive          sys_mq_timedreceive
184  riscv64  mq_notify                sys_mq_notify
185  riscv64  mq_getsetattr            sys_mq_getsetattr
186  riscv64  msgget                   sys_msgget
187  riscv64  msgctl                   sys_msgctl
188  riscv64  msgrcv                   sys_msgrcv
189  riscv64  msgsnd                   sys_msgsnd
190  riscv64  semget                   sys_semget
191  riscv64  semctl                   sys_semctl
192  riscv64  semtimedop               sys_semtimedop
193  riscv64  semop                    sys_semop
194  riscv64  shmget                   sys_shmget
195  riscv64  shmctl                   sys_shmctl
196  riscv64  shmat                    sys_shmat
197  riscv64  shmdt                    sys_shmdt
198  riscv64  socket                   sys_socket
199  riscv64  socketpair               sys_socketpair
200  riscv64  bind                     sys_bind
201  riscv64  listen                   sys_listen
202  riscv64  accept                   sys_accept
203  riscv64  connect                  sys_connect
204  riscv64  getsockname              sys_getsockname
205  riscv64  getpeername              sys_getpeername
206  riscv64  sendto                   sys_sendto
207  riscv64  recvfrom                 sys_recvfrom
208  riscv64  setsockopt               sys_setsockopt
209  riscv64  getsockopt               sys_getsockopt
210  riscv64  shutdown                 sys_shutdown
211  riscv64  sendmsg                  sys_sendmsg
212  riscv64  recvmsg                  sys_recvmsg
213  riscv64  readahead                sys_readahead
214  riscv64  brk                      sys_brk
215  riscv64  munmap                   sys_munmap
216  riscv64  mremap                   sys_mremap
217  riscv64  add_key                  sys_add_key
218  riscv64  request_key              sys_request_key
219  riscv64  keyctl                   sys_keyctl
220  riscv64  clone                    sys_clone
221  riscv64  execve                   sys_execve
222  riscv64  mmap                     sys_mmap
223  riscv64  fadvise64                sys_fadvise64_64
224  riscv64  swapon                   sys_swapon
225  riscv64  swapoff                  sys_swapoff
226  riscv64  mprotect                 sys_mprotect
227  riscv64  msync                    sys_msync
228  riscv64  mlock                    sys_mlock
229  riscv64  munlock                  sys_munlock
230  riscv64  mlockall                 sys_mlockall
231  riscv64  munlockall               sys_munlockall
232  riscv64  mincore                  sys_mincore
233  riscv64  madvise                  sys_madvise
234  riscv64  remap_file_pages         sys_remap_file_pages
235  riscv64  mbind                    sys_mbind
236  riscv64  get_mempolicy            sys_get_mempolicy
237  riscv64  set_mempolicy            sys_set_mempolicy
238  riscv64  migrate_pages            sys_migrate_pages
239  riscv64  move_pages               sys_move_pages
240  riscv64  rt_tgsigqueueinfo        sys_rt_tgsigqueueinfo
241  riscv64  perf_event_open          sys_perf_event_open
242  riscv64  accept4                  sys_accept4
243  riscv64  recvmmsg                 sys_recvmmsg
260  riscv64  wait4                    sys_wait4
261  riscv64  prlimit64                sys_prlimit64
262  riscv64  fanotify_init            sys_fanotify_init
263  riscv64  fanotify_mark            sys_fanotify_mark
264  riscv64  name_to_handle_at        sys_name_to_handle_at
265  riscv64  open_by_handle_at        sys_open_by_handle_at
266  riscv64  clock_adjtime            sys_clock_adjtime
267  riscv64  syncfs                   sys_syncfs
268  riscv64  setns                    sys_setns
269  riscv64  sendmmsg                 sys_sendmmsg
270  riscv64  process_vm_readv         sys_process_vm_readv
271  riscv64  process_vm_writev        sys_process_vm_writev
272  riscv64  kcmp                     sys_kcmp
273  riscv64  finit_module             sys_finit_module
274  riscv64  sched_setattr            sys_sched_setattr
275  riscv64  sched_getattr            sys_sched_getattr
276  riscv64  renameat2                sys_renameat2
277  riscv64  seccomp                  sys_seccomp
278  riscv64  getrandom                sys_getrandom
279  riscv64  memfd_create             sys_memfd_create
280  riscv64  bpf                      sys_bpf
281  riscv64  execveat                 sys_execveat
282  riscv64  userfaultfd              sys_userfaultfd
283  riscv64  membarrier               sys_membarrier
284  riscv64  mlock2                   sys_mlock2
285  riscv64  copy_file_range          sys_copy_file_range
286  riscv64  preadv2                  sys_preadv2
287  riscv64  pwritev2                 sys_pwritev2
288  riscv64  pkey_mprotect            sys_pkey_mprotect
289  riscv64  pkey_alloc               sys_pkey_alloc
290  riscv64  pkey_free                sys_pkey_free
291  riscv64  statx                    sys_statx
292  riscv64  io_pgetevents            sys_io_pgetevents
293  riscv64  rseq                     sys_rseq
294  riscv64  kexec_file_load          sys_kexec_file_load
424  riscv64  pidfd_send_signal        sys_pidfd_send_signal
425  riscv64  io_uring_setup           sys_io_uring_setup
426  riscv64  io_uring_enter           sys_io_uring_enter
427  riscv64  io_uring_register        sys_io_uring_register
428  riscv64  open_tree                sys_open_tree
429  riscv64  move_mount               sys_move_mount
430  riscv64  fsopen                   sys_fsopen
431  riscv64  fsconfig                 sys_fsconfig
432  riscv64  fsmount                  sys_fsmount
433  riscv64  fspick                   sys_fspick
434  riscv64  pidfd_open               sys_pidfd_open
435  riscv64  clone3                   sys_clone3
436  riscv64  close_range              sys_close_range
437  riscv64  openat2                  sys_openat2
438  riscv64  pidfd_getfd              sys_pidfd_getfd
439  riscv64  faccessat2               sys_faccessat2
440  riscv64  process_madvise          sys_process_madvise
441  riscv64  epoll_pwait2             sys_epoll_pwait2
442  riscv64  mount_setattr            sys_mount_setattr
443  riscv64  quotactl_fd              sys_quotactl_fd
444  riscv64  landlock_create_ruleset  sys_landlock_create_ruleset
445  riscv64  landlock_add_rule        sys_landlock_add_rule
446  riscv64  landlock_restrict_self   sys_landlock_restrict_self
447  riscv64  memfd_secret             sys_memfd_secret
448  riscv64  process_mrelease         sys_process_mrelease
449  riscv64  futex_waitv              sys_futex_waitv
450  riscv64  set_mempolicy_home_node  sys_set_mempolicy_home_node
"""


# RISCV32
#
# [How to make]
# gcc -I `pwd`/include/uapi/ -E -D__SYSCALL=SYSCALL -D__BITS_PER_LONG=32 -D__ILP32__=1 arch/riscv/include/uapi/asm/unistd.h \
# | grep ^SYSCALL | sed -e 's/SYSCALL(//;s/[,)]//g;/+/d' > /tmp/a
# grep -oP "__NR\S+\s+\d+$" include/uapi/asm-generic/unistd.h | grep -v __NR_sync_file_range2 > /tmp/b
# join -2 2 -o 1.1,1.10,2.1,1.2 -e riscv32 /tmp/a /tmp/b | sed -e 's/\(__NR_\|__NR3264_\)//g' | column -t
#
riscv32_syscall_tbl = """
0    riscv32  io_setup                      sys_io_setup
1    riscv32  io_destroy                    sys_io_destroy
2    riscv32  io_submit                     sys_io_submit
3    riscv32  io_cancel                     sys_io_cancel
5    riscv32  setxattr                      sys_setxattr
6    riscv32  lsetxattr                     sys_lsetxattr
7    riscv32  fsetxattr                     sys_fsetxattr
8    riscv32  getxattr                      sys_getxattr
9    riscv32  lgetxattr                     sys_lgetxattr
10   riscv32  fgetxattr                     sys_fgetxattr
11   riscv32  listxattr                     sys_listxattr
12   riscv32  llistxattr                    sys_llistxattr
13   riscv32  flistxattr                    sys_flistxattr
14   riscv32  removexattr                   sys_removexattr
15   riscv32  lremovexattr                  sys_lremovexattr
16   riscv32  fremovexattr                  sys_fremovexattr
17   riscv32  getcwd                        sys_getcwd
18   riscv32  lookup_dcookie                sys_lookup_dcookie
19   riscv32  eventfd2                      sys_eventfd2
20   riscv32  epoll_create1                 sys_epoll_create1
21   riscv32  epoll_ctl                     sys_epoll_ctl
22   riscv32  epoll_pwait                   sys_epoll_pwait
23   riscv32  dup                           sys_dup
24   riscv32  dup3                          sys_dup3
25   riscv32  fcntl                         sys_fcntl64
26   riscv32  inotify_init1                 sys_inotify_init1
27   riscv32  inotify_add_watch             sys_inotify_add_watch
28   riscv32  inotify_rm_watch              sys_inotify_rm_watch
29   riscv32  ioctl                         sys_ioctl
30   riscv32  ioprio_set                    sys_ioprio_set
31   riscv32  ioprio_get                    sys_ioprio_get
32   riscv32  flock                         sys_flock
33   riscv32  mknodat                       sys_mknodat
34   riscv32  mkdirat                       sys_mkdirat
35   riscv32  unlinkat                      sys_unlinkat
36   riscv32  symlinkat                     sys_symlinkat
37   riscv32  linkat                        sys_linkat
39   riscv32  umount2                       sys_umount
40   riscv32  mount                         sys_mount
41   riscv32  pivot_root                    sys_pivot_root
42   riscv32  nfsservctl                    sys_ni_syscall
43   riscv32  statfs                        sys_statfs64
44   riscv32  fstatfs                       sys_fstatfs64
45   riscv32  truncate                      sys_truncate64
46   riscv32  ftruncate                     sys_ftruncate64
47   riscv32  fallocate                     sys_fallocate
48   riscv32  faccessat                     sys_faccessat
49   riscv32  chdir                         sys_chdir
50   riscv32  fchdir                        sys_fchdir
51   riscv32  chroot                        sys_chroot
52   riscv32  fchmod                        sys_fchmod
53   riscv32  fchmodat                      sys_fchmodat
54   riscv32  fchownat                      sys_fchownat
55   riscv32  fchown                        sys_fchown
56   riscv32  openat                        sys_openat
57   riscv32  close                         sys_close
58   riscv32  vhangup                       sys_vhangup
59   riscv32  pipe2                         sys_pipe2
60   riscv32  quotactl                      sys_quotactl
61   riscv32  getdents64                    sys_getdents64
62   riscv32  lseek                         sys_llseek
63   riscv32  read                          sys_read
64   riscv32  write                         sys_write
65   riscv32  readv                         sys_readv
66   riscv32  writev                        sys_writev
67   riscv32  pread64                       sys_pread64
68   riscv32  pwrite64                      sys_pwrite64
69   riscv32  preadv                        sys_preadv
70   riscv32  pwritev                       sys_pwritev
71   riscv32  sendfile                      sys_sendfile64
74   riscv32  signalfd4                     sys_signalfd4
75   riscv32  vmsplice                      sys_vmsplice
76   riscv32  splice                        sys_splice
77   riscv32  tee                           sys_tee
78   riscv32  readlinkat                    sys_readlinkat
79   riscv32  fstatat                       sys_fstatat64
80   riscv32  fstat                         sys_fstat64
81   riscv32  sync                          sys_sync
82   riscv32  fsync                         sys_fsync
83   riscv32  fdatasync                     sys_fdatasync
84   riscv32  sync_file_range               sys_sync_file_range
85   riscv32  timerfd_create                sys_timerfd_create
89   riscv32  acct                          sys_acct
90   riscv32  capget                        sys_capget
91   riscv32  capset                        sys_capset
92   riscv32  personality                   sys_personality
93   riscv32  exit                          sys_exit
94   riscv32  exit_group                    sys_exit_group
95   riscv32  waitid                        sys_waitid
96   riscv32  set_tid_address               sys_set_tid_address
97   riscv32  unshare                       sys_unshare
99   riscv32  set_robust_list               sys_set_robust_list
100  riscv32  get_robust_list               sys_get_robust_list
102  riscv32  getitimer                     sys_getitimer
103  riscv32  setitimer                     sys_setitimer
104  riscv32  kexec_load                    sys_kexec_load
105  riscv32  init_module                   sys_init_module
106  riscv32  delete_module                 sys_delete_module
107  riscv32  timer_create                  sys_timer_create
109  riscv32  timer_getoverrun              sys_timer_getoverrun
111  riscv32  timer_delete                  sys_timer_delete
116  riscv32  syslog                        sys_syslog
117  riscv32  ptrace                        sys_ptrace
118  riscv32  sched_setparam                sys_sched_setparam
119  riscv32  sched_setscheduler            sys_sched_setscheduler
120  riscv32  sched_getscheduler            sys_sched_getscheduler
121  riscv32  sched_getparam                sys_sched_getparam
122  riscv32  sched_setaffinity             sys_sched_setaffinity
123  riscv32  sched_getaffinity             sys_sched_getaffinity
124  riscv32  sched_yield                   sys_sched_yield
125  riscv32  sched_get_priority_max        sys_sched_get_priority_max
126  riscv32  sched_get_priority_min        sys_sched_get_priority_min
128  riscv32  restart_syscall               sys_restart_syscall
129  riscv32  kill                          sys_kill
130  riscv32  tkill                         sys_tkill
131  riscv32  tgkill                        sys_tgkill
132  riscv32  sigaltstack                   sys_sigaltstack
133  riscv32  rt_sigsuspend                 sys_rt_sigsuspend
134  riscv32  rt_sigaction                  sys_rt_sigaction
135  riscv32  rt_sigprocmask                sys_rt_sigprocmask
136  riscv32  rt_sigpending                 sys_rt_sigpending
138  riscv32  rt_sigqueueinfo               sys_rt_sigqueueinfo
139  riscv32  rt_sigreturn                  sys_rt_sigreturn
140  riscv32  setpriority                   sys_setpriority
141  riscv32  getpriority                   sys_getpriority
142  riscv32  reboot                        sys_reboot
143  riscv32  setregid                      sys_setregid
144  riscv32  setgid                        sys_setgid
145  riscv32  setreuid                      sys_setreuid
146  riscv32  setuid                        sys_setuid
147  riscv32  setresuid                     sys_setresuid
148  riscv32  getresuid                     sys_getresuid
149  riscv32  setresgid                     sys_setresgid
150  riscv32  getresgid                     sys_getresgid
151  riscv32  setfsuid                      sys_setfsuid
152  riscv32  setfsgid                      sys_setfsgid
153  riscv32  times                         sys_times
154  riscv32  setpgid                       sys_setpgid
155  riscv32  getpgid                       sys_getpgid
156  riscv32  getsid                        sys_getsid
157  riscv32  setsid                        sys_setsid
158  riscv32  getgroups                     sys_getgroups
159  riscv32  setgroups                     sys_setgroups
160  riscv32  uname                         sys_newuname
161  riscv32  sethostname                   sys_sethostname
162  riscv32  setdomainname                 sys_setdomainname
163  riscv32  getrlimit                     sys_getrlimit
164  riscv32  setrlimit                     sys_setrlimit
165  riscv32  getrusage                     sys_getrusage
166  riscv32  umask                         sys_umask
167  riscv32  prctl                         sys_prctl
168  riscv32  getcpu                        sys_getcpu
172  riscv32  getpid                        sys_getpid
173  riscv32  getppid                       sys_getppid
174  riscv32  getuid                        sys_getuid
175  riscv32  geteuid                       sys_geteuid
176  riscv32  getgid                        sys_getgid
177  riscv32  getegid                       sys_getegid
178  riscv32  gettid                        sys_gettid
179  riscv32  sysinfo                       sys_sysinfo
180  riscv32  mq_open                       sys_mq_open
181  riscv32  mq_unlink                     sys_mq_unlink
184  riscv32  mq_notify                     sys_mq_notify
185  riscv32  mq_getsetattr                 sys_mq_getsetattr
186  riscv32  msgget                        sys_msgget
187  riscv32  msgctl                        sys_msgctl
188  riscv32  msgrcv                        sys_msgrcv
189  riscv32  msgsnd                        sys_msgsnd
190  riscv32  semget                        sys_semget
191  riscv32  semctl                        sys_semctl
193  riscv32  semop                         sys_semop
194  riscv32  shmget                        sys_shmget
195  riscv32  shmctl                        sys_shmctl
196  riscv32  shmat                         sys_shmat
197  riscv32  shmdt                         sys_shmdt
198  riscv32  socket                        sys_socket
199  riscv32  socketpair                    sys_socketpair
200  riscv32  bind                          sys_bind
201  riscv32  listen                        sys_listen
202  riscv32  accept                        sys_accept
203  riscv32  connect                       sys_connect
204  riscv32  getsockname                   sys_getsockname
205  riscv32  getpeername                   sys_getpeername
206  riscv32  sendto                        sys_sendto
207  riscv32  recvfrom                      sys_recvfrom
208  riscv32  setsockopt                    sys_setsockopt
209  riscv32  getsockopt                    sys_getsockopt
210  riscv32  shutdown                      sys_shutdown
211  riscv32  sendmsg                       sys_sendmsg
212  riscv32  recvmsg                       sys_recvmsg
213  riscv32  readahead                     sys_readahead
214  riscv32  brk                           sys_brk
215  riscv32  munmap                        sys_munmap
216  riscv32  mremap                        sys_mremap
217  riscv32  add_key                       sys_add_key
218  riscv32  request_key                   sys_request_key
219  riscv32  keyctl                        sys_keyctl
220  riscv32  clone                         sys_clone
221  riscv32  execve                        sys_execve
222  riscv32  mmap                          sys_mmap2
223  riscv32  fadvise64                     sys_fadvise64_64
224  riscv32  swapon                        sys_swapon
225  riscv32  swapoff                       sys_swapoff
226  riscv32  mprotect                      sys_mprotect
227  riscv32  msync                         sys_msync
228  riscv32  mlock                         sys_mlock
229  riscv32  munlock                       sys_munlock
230  riscv32  mlockall                      sys_mlockall
231  riscv32  munlockall                    sys_munlockall
232  riscv32  mincore                       sys_mincore
233  riscv32  madvise                       sys_madvise
234  riscv32  remap_file_pages              sys_remap_file_pages
235  riscv32  mbind                         sys_mbind
236  riscv32  get_mempolicy                 sys_get_mempolicy
237  riscv32  set_mempolicy                 sys_set_mempolicy
238  riscv32  migrate_pages                 sys_migrate_pages
239  riscv32  move_pages                    sys_move_pages
240  riscv32  rt_tgsigqueueinfo             sys_rt_tgsigqueueinfo
241  riscv32  perf_event_open               sys_perf_event_open
242  riscv32  accept4                       sys_accept4
261  riscv32  prlimit64                     sys_prlimit64
262  riscv32  fanotify_init                 sys_fanotify_init
263  riscv32  fanotify_mark                 sys_fanotify_mark
264  riscv32  name_to_handle_at             sys_name_to_handle_at
265  riscv32  open_by_handle_at             sys_open_by_handle_at
267  riscv32  syncfs                        sys_syncfs
268  riscv32  setns                         sys_setns
269  riscv32  sendmmsg                      sys_sendmmsg
270  riscv32  process_vm_readv              sys_process_vm_readv
271  riscv32  process_vm_writev             sys_process_vm_writev
272  riscv32  kcmp                          sys_kcmp
273  riscv32  finit_module                  sys_finit_module
274  riscv32  sched_setattr                 sys_sched_setattr
275  riscv32  sched_getattr                 sys_sched_getattr
276  riscv32  renameat2                     sys_renameat2
277  riscv32  seccomp                       sys_seccomp
278  riscv32  getrandom                     sys_getrandom
279  riscv32  memfd_create                  sys_memfd_create
280  riscv32  bpf                           sys_bpf
281  riscv32  execveat                      sys_execveat
282  riscv32  userfaultfd                   sys_userfaultfd
283  riscv32  membarrier                    sys_membarrier
284  riscv32  mlock2                        sys_mlock2
285  riscv32  copy_file_range               sys_copy_file_range
286  riscv32  preadv2                       sys_preadv2
287  riscv32  pwritev2                      sys_pwritev2
288  riscv32  pkey_mprotect                 sys_pkey_mprotect
289  riscv32  pkey_alloc                    sys_pkey_alloc
290  riscv32  pkey_free                     sys_pkey_free
291  riscv32  statx                         sys_statx
293  riscv32  rseq                          sys_rseq
294  riscv32  kexec_file_load               sys_kexec_file_load
403  riscv32  clock_gettime64               sys_clock_gettime
404  riscv32  clock_settime64               sys_clock_settime
405  riscv32  clock_adjtime64               sys_clock_adjtime
406  riscv32  clock_getres_time64           sys_clock_getres
407  riscv32  clock_nanosleep_time64        sys_clock_nanosleep
408  riscv32  timer_gettime64               sys_timer_gettime
409  riscv32  timer_settime64               sys_timer_settime
410  riscv32  timerfd_gettime64             sys_timerfd_gettime
411  riscv32  timerfd_settime64             sys_timerfd_settime
412  riscv32  utimensat_time64              sys_utimensat
413  riscv32  pselect6_time64               sys_pselect6
414  riscv32  ppoll_time64                  sys_ppoll
416  riscv32  io_pgetevents_time64          sys_io_pgetevents
417  riscv32  recvmmsg_time64               sys_recvmmsg
418  riscv32  mq_timedsend_time64           sys_mq_timedsend
419  riscv32  mq_timedreceive_time64        sys_mq_timedreceive
420  riscv32  semtimedop_time64             sys_semtimedop
421  riscv32  rt_sigtimedwait_time64        sys_rt_sigtimedwait
422  riscv32  futex_time64                  sys_futex
423  riscv32  sched_rr_get_interval_time64  sys_sched_rr_get_interval
424  riscv32  pidfd_send_signal             sys_pidfd_send_signal
425  riscv32  io_uring_setup                sys_io_uring_setup
426  riscv32  io_uring_enter                sys_io_uring_enter
427  riscv32  io_uring_register             sys_io_uring_register
428  riscv32  open_tree                     sys_open_tree
429  riscv32  move_mount                    sys_move_mount
430  riscv32  fsopen                        sys_fsopen
431  riscv32  fsconfig                      sys_fsconfig
432  riscv32  fsmount                       sys_fsmount
433  riscv32  fspick                        sys_fspick
434  riscv32  pidfd_open                    sys_pidfd_open
435  riscv32  clone3                        sys_clone3
436  riscv32  close_range                   sys_close_range
437  riscv32  openat2                       sys_openat2
438  riscv32  pidfd_getfd                   sys_pidfd_getfd
439  riscv32  faccessat2                    sys_faccessat2
440  riscv32  process_madvise               sys_process_madvise
441  riscv32  epoll_pwait2                  sys_epoll_pwait2
442  riscv32  mount_setattr                 sys_mount_setattr
443  riscv32  quotactl_fd                   sys_quotactl_fd
444  riscv32  landlock_create_ruleset       sys_landlock_create_ruleset
445  riscv32  landlock_add_rule             sys_landlock_add_rule
446  riscv32  landlock_restrict_self        sys_landlock_restrict_self
447  riscv32  memfd_secret                  sys_memfd_secret
448  riscv32  process_mrelease              sys_process_mrelease
449  riscv32  futex_waitv                   sys_futex_waitv
450  riscv32  set_mempolicy_home_node       sys_set_mempolicy_home_node
"""


# S390X
# - arch/s390/kernel/syscalls/syscall.tbl
s390x_syscall_tbl = """
# System call table for s390
#
# Format:
#
# <nr> <abi> <syscall> <entry-64bit> <compat-entry>
#
# where <abi> can be common, 64, or 32

1    common     exit                    sys_exit                        sys_exit
2    common     fork                    sys_fork                        sys_fork
3    common     read                    sys_read                        compat_sys_s390_read
4    common     write                   sys_write                       compat_sys_s390_write
5    common     open                    sys_open                        compat_sys_open
6    common     close                   sys_close                       sys_close
7    common     restart_syscall         sys_restart_syscall             sys_restart_syscall
8    common     creat                   sys_creat                       sys_creat
9    common     link                    sys_link                        sys_link
10   common     unlink                  sys_unlink                      sys_unlink
11   common     execve                  sys_execve                      compat_sys_execve
12   common     chdir                   sys_chdir                       sys_chdir
13   32         time                    -                               sys_time32
14   common     mknod                   sys_mknod                       sys_mknod
15   common     chmod                   sys_chmod                       sys_chmod
16   32         lchown                  -                               sys_lchown16
19   common     lseek                   sys_lseek                       compat_sys_lseek
20   common     getpid                  sys_getpid                      sys_getpid
21   common     mount                   sys_mount                       sys_mount
22   common     umount                  sys_oldumount                   sys_oldumount
23   32         setuid                  -                               sys_setuid16
24   32         getuid                  -                               sys_getuid16
25   32         stime                   -                               sys_stime32
26   common     ptrace                  sys_ptrace                      compat_sys_ptrace
27   common     alarm                   sys_alarm                       sys_alarm
29   common     pause                   sys_pause                       sys_pause
30   common     utime                   sys_utime                       sys_utime32
33   common     access                  sys_access                      sys_access
34   common     nice                    sys_nice                        sys_nice
36   common     sync                    sys_sync                        sys_sync
37   common     kill                    sys_kill                        sys_kill
38   common     rename                  sys_rename                      sys_rename
39   common     mkdir                   sys_mkdir                       sys_mkdir
40   common     rmdir                   sys_rmdir                       sys_rmdir
41   common     dup                     sys_dup                         sys_dup
42   common     pipe                    sys_pipe                        sys_pipe
43   common     times                   sys_times                       compat_sys_times
45   common     brk                     sys_brk                         sys_brk
46   32         setgid                  -                               sys_setgid16
47   32         getgid                  -                               sys_getgid16
48   common     signal                  sys_signal                      sys_signal
49   32         geteuid                 -                               sys_geteuid16
50   32         getegid                 -                               sys_getegid16
51   common     acct                    sys_acct                        sys_acct
52   common     umount2                 sys_umount                      sys_umount
54   common     ioctl                   sys_ioctl                       compat_sys_ioctl
55   common     fcntl                   sys_fcntl                       compat_sys_fcntl
57   common     setpgid                 sys_setpgid                     sys_setpgid
60   common     umask                   sys_umask                       sys_umask
61   common     chroot                  sys_chroot                      sys_chroot
62   common     ustat                   sys_ustat                       compat_sys_ustat
63   common     dup2                    sys_dup2                        sys_dup2
64   common     getppid                 sys_getppid                     sys_getppid
65   common     getpgrp                 sys_getpgrp                     sys_getpgrp
66   common     setsid                  sys_setsid                      sys_setsid
67   common     sigaction               sys_sigaction                   compat_sys_sigaction
70   32         setreuid                -                               sys_setreuid16
71   32         setregid                -                               sys_setregid16
72   common     sigsuspend              sys_sigsuspend                  sys_sigsuspend
73   common     sigpending              sys_sigpending                  compat_sys_sigpending
74   common     sethostname             sys_sethostname                 sys_sethostname
75   common     setrlimit               sys_setrlimit                   compat_sys_setrlimit
76   32         getrlimit               -                               compat_sys_old_getrlimit
77   common     getrusage               sys_getrusage                   compat_sys_getrusage
78   common     gettimeofday            sys_gettimeofday                compat_sys_gettimeofday
79   common     settimeofday            sys_settimeofday                compat_sys_settimeofday
80   32         getgroups               -                               sys_getgroups16
81   32         setgroups               -                               sys_setgroups16
83   common     symlink                 sys_symlink                     sys_symlink
85   common     readlink                sys_readlink                    sys_readlink
86   common     uselib                  sys_uselib                      sys_uselib
87   common     swapon                  sys_swapon                      sys_swapon
88   common     reboot                  sys_reboot                      sys_reboot
89   common     readdir                 -                               compat_sys_old_readdir
90   common     mmap                    sys_old_mmap                    compat_sys_s390_old_mmap
91   common     munmap                  sys_munmap                      sys_munmap
92   common     truncate                sys_truncate                    compat_sys_truncate
93   common     ftruncate               sys_ftruncate                   compat_sys_ftruncate
94   common     fchmod                  sys_fchmod                      sys_fchmod
95   32         fchown                  -                               sys_fchown16
96   common     getpriority             sys_getpriority                 sys_getpriority
97   common     setpriority             sys_setpriority                 sys_setpriority
99   common     statfs                  sys_statfs                      compat_sys_statfs
100  common     fstatfs                 sys_fstatfs                     compat_sys_fstatfs
101  32         ioperm                  -                               -
102  common     socketcall              sys_socketcall                  compat_sys_socketcall
103  common     syslog                  sys_syslog                      sys_syslog
104  common     setitimer               sys_setitimer                   compat_sys_setitimer
105  common     getitimer               sys_getitimer                   compat_sys_getitimer
106  common     stat                    sys_newstat                     compat_sys_newstat
107  common     lstat                   sys_newlstat                    compat_sys_newlstat
108  common     fstat                   sys_newfstat                    compat_sys_newfstat
110  common     lookup_dcookie          sys_lookup_dcookie              compat_sys_lookup_dcookie
111  common     vhangup                 sys_vhangup                     sys_vhangup
112  common     idle                    -                               -
114  common     wait4                   sys_wait4                       compat_sys_wait4
115  common     swapoff                 sys_swapoff                     sys_swapoff
116  common     sysinfo                 sys_sysinfo                     compat_sys_sysinfo
117  common     ipc                     sys_s390_ipc                    compat_sys_s390_ipc
118  common     fsync                   sys_fsync                       sys_fsync
119  common     sigreturn               sys_sigreturn                   compat_sys_sigreturn
120  common     clone                   sys_clone                       sys_clone
121  common     setdomainname           sys_setdomainname               sys_setdomainname
122  common     uname                   sys_newuname                    sys_newuname
124  common     adjtimex                sys_adjtimex                    sys_adjtimex_time32
125  common     mprotect                sys_mprotect                    sys_mprotect
126  common     sigprocmask             sys_sigprocmask                 compat_sys_sigprocmask
127  common     create_module           -                               -
128  common     init_module             sys_init_module                 sys_init_module
129  common     delete_module           sys_delete_module               sys_delete_module
130  common     get_kernel_syms         -                               -
131  common     quotactl                sys_quotactl                    sys_quotactl
132  common     getpgid                 sys_getpgid                     sys_getpgid
133  common     fchdir                  sys_fchdir                      sys_fchdir
134  common     bdflush                 sys_ni_syscall                  sys_ni_syscall
135  common     sysfs                   sys_sysfs                       sys_sysfs
136  common     personality             sys_s390_personality            sys_s390_personality
137  common     afs_syscall             -                               -
138  32         setfsuid                -                               sys_setfsuid16
139  32         setfsgid                -                               sys_setfsgid16
140  32         _llseek                 -                               sys_llseek
141  common     getdents                sys_getdents                    compat_sys_getdents
142  32         _newselect              -                               compat_sys_select
142  64         select                  sys_select                      -
143  common     flock                   sys_flock                       sys_flock
144  common     msync                   sys_msync                       sys_msync
145  common     readv                   sys_readv                       sys_readv
146  common     writev                  sys_writev                      sys_writev
147  common     getsid                  sys_getsid                      sys_getsid
148  common     fdatasync               sys_fdatasync                   sys_fdatasync
149  common     _sysctl                 -                               -
150  common     mlock                   sys_mlock                       sys_mlock
151  common     munlock                 sys_munlock                     sys_munlock
152  common     mlockall                sys_mlockall                    sys_mlockall
153  common     munlockall              sys_munlockall                  sys_munlockall
154  common     sched_setparam          sys_sched_setparam              sys_sched_setparam
155  common     sched_getparam          sys_sched_getparam              sys_sched_getparam
156  common     sched_setscheduler      sys_sched_setscheduler          sys_sched_setscheduler
157  common     sched_getscheduler      sys_sched_getscheduler          sys_sched_getscheduler
158  common     sched_yield             sys_sched_yield                 sys_sched_yield
159  common     sched_get_priority_max  sys_sched_get_priority_max      sys_sched_get_priority_max
160  common     sched_get_priority_min  sys_sched_get_priority_min      sys_sched_get_priority_min
161  common     sched_rr_get_interval   sys_sched_rr_get_interval       sys_sched_rr_get_interval_time32
162  common     nanosleep               sys_nanosleep                   sys_nanosleep_time32
163  common     mremap                  sys_mremap                      sys_mremap
164  32         setresuid               -                               sys_setresuid16
165  32         getresuid               -                               sys_getresuid16
167  common     query_module            -                               -
168  common     poll                    sys_poll                        sys_poll
169  common     nfsservctl              -                               -
170  32         setresgid               -                               sys_setresgid16
171  32         getresgid               -                               sys_getresgid16
172  common     prctl                   sys_prctl                       sys_prctl
173  common     rt_sigreturn            sys_rt_sigreturn                compat_sys_rt_sigreturn
174  common     rt_sigaction            sys_rt_sigaction                compat_sys_rt_sigaction
175  common     rt_sigprocmask          sys_rt_sigprocmask              compat_sys_rt_sigprocmask
176  common     rt_sigpending           sys_rt_sigpending               compat_sys_rt_sigpending
177  common     rt_sigtimedwait         sys_rt_sigtimedwait             compat_sys_rt_sigtimedwait_time32
178  common     rt_sigqueueinfo         sys_rt_sigqueueinfo             compat_sys_rt_sigqueueinfo
179  common     rt_sigsuspend           sys_rt_sigsuspend               compat_sys_rt_sigsuspend
180  common     pread64                 sys_pread64                     compat_sys_s390_pread64
181  common     pwrite64                sys_pwrite64                    compat_sys_s390_pwrite64
182  32         chown                   -                               sys_chown16
183  common     getcwd                  sys_getcwd                      sys_getcwd
184  common     capget                  sys_capget                      sys_capget
185  common     capset                  sys_capset                      sys_capset
186  common     sigaltstack             sys_sigaltstack                 compat_sys_sigaltstack
187  common     sendfile                sys_sendfile64                  compat_sys_sendfile
188  common     getpmsg                 -                               -
189  common     putpmsg                 -                               -
190  common     vfork                   sys_vfork                       sys_vfork
191  32         ugetrlimit              -                               compat_sys_getrlimit
191  64         getrlimit               sys_getrlimit                   -
192  32         mmap2                   -                               compat_sys_s390_mmap2
193  32         truncate64              -                               compat_sys_s390_truncate64
194  32         ftruncate64             -                               compat_sys_s390_ftruncate64
195  32         stat64                  -                               compat_sys_s390_stat64
196  32         lstat64                 -                               compat_sys_s390_lstat64
197  32         fstat64                 -                               compat_sys_s390_fstat64
198  32         lchown32                -                               sys_lchown
198  64         lchown                  sys_lchown                      -
199  32         getuid32                -                               sys_getuid
199  64         getuid                  sys_getuid                      -
200  32         getgid32                -                               sys_getgid
200  64         getgid                  sys_getgid                      -
201  32         geteuid32               -                               sys_geteuid
201  64         geteuid                 sys_geteuid                     -
202  32         getegid32               -                               sys_getegid
202  64         getegid                 sys_getegid                     -
203  32         setreuid32              -                               sys_setreuid
203  64         setreuid                sys_setreuid                    -
204  32         setregid32              -                               sys_setregid
204  64         setregid                sys_setregid                    -
205  32         getgroups32             -                               sys_getgroups
205  64         getgroups               sys_getgroups                   -
206  32         setgroups32             -                               sys_setgroups
206  64         setgroups               sys_setgroups                   -
207  32         fchown32                -                               sys_fchown
207  64         fchown                  sys_fchown                      -
208  32         setresuid32             -                               sys_setresuid
208  64         setresuid               sys_setresuid                   -
209  32         getresuid32             -                               sys_getresuid
209  64         getresuid               sys_getresuid                   -
210  32         setresgid32             -                               sys_setresgid
210  64         setresgid               sys_setresgid                   -
211  32         getresgid32             -                               sys_getresgid
211  64         getresgid               sys_getresgid                   -
212  32         chown32                 -                               sys_chown
212  64         chown                   sys_chown                       -
213  32         setuid32                -                               sys_setuid
213  64         setuid                  sys_setuid                      -
214  32         setgid32                -                               sys_setgid
214  64         setgid                  sys_setgid                      -
215  32         setfsuid32              -                               sys_setfsuid
215  64         setfsuid                sys_setfsuid                    -
216  32         setfsgid32              -                               sys_setfsgid
216  64         setfsgid                sys_setfsgid                    -
217  common     pivot_root              sys_pivot_root                  sys_pivot_root
218  common     mincore                 sys_mincore                     sys_mincore
219  common     madvise                 sys_madvise                     sys_madvise
220  common     getdents64              sys_getdents64                  sys_getdents64
221  32         fcntl64                 -                               compat_sys_fcntl64
222  common     readahead               sys_readahead                   compat_sys_s390_readahead
223  32         sendfile64              -                               compat_sys_sendfile64
224  common     setxattr                sys_setxattr                    sys_setxattr
225  common     lsetxattr               sys_lsetxattr                   sys_lsetxattr
226  common     fsetxattr               sys_fsetxattr                   sys_fsetxattr
227  common     getxattr                sys_getxattr                    sys_getxattr
228  common     lgetxattr               sys_lgetxattr                   sys_lgetxattr
229  common     fgetxattr               sys_fgetxattr                   sys_fgetxattr
230  common     listxattr               sys_listxattr                   sys_listxattr
231  common     llistxattr              sys_llistxattr                  sys_llistxattr
232  common     flistxattr              sys_flistxattr                  sys_flistxattr
233  common     removexattr             sys_removexattr                 sys_removexattr
234  common     lremovexattr            sys_lremovexattr                sys_lremovexattr
235  common     fremovexattr            sys_fremovexattr                sys_fremovexattr
236  common     gettid                  sys_gettid                      sys_gettid
237  common     tkill                   sys_tkill                       sys_tkill
238  common     futex                   sys_futex                       sys_futex_time32
239  common     sched_setaffinity       sys_sched_setaffinity           compat_sys_sched_setaffinity
240  common     sched_getaffinity       sys_sched_getaffinity           compat_sys_sched_getaffinity
241  common     tgkill                  sys_tgkill                      sys_tgkill
243  common     io_setup                sys_io_setup                    compat_sys_io_setup
244  common     io_destroy              sys_io_destroy                  sys_io_destroy
245  common     io_getevents            sys_io_getevents                sys_io_getevents_time32
246  common     io_submit               sys_io_submit                   compat_sys_io_submit
247  common     io_cancel               sys_io_cancel                   sys_io_cancel
248  common     exit_group              sys_exit_group                  sys_exit_group
249  common     epoll_create            sys_epoll_create                sys_epoll_create
250  common     epoll_ctl               sys_epoll_ctl                   sys_epoll_ctl
251  common     epoll_wait              sys_epoll_wait                  sys_epoll_wait
252  common     set_tid_address         sys_set_tid_address             sys_set_tid_address
253  common     fadvise64               sys_fadvise64_64                compat_sys_s390_fadvise64
254  common     timer_create            sys_timer_create                compat_sys_timer_create
255  common     timer_settime           sys_timer_settime               sys_timer_settime32
256  common     timer_gettime           sys_timer_gettime               sys_timer_gettime32
257  common     timer_getoverrun        sys_timer_getoverrun            sys_timer_getoverrun
258  common     timer_delete            sys_timer_delete                sys_timer_delete
259  common     clock_settime           sys_clock_settime               sys_clock_settime32
260  common     clock_gettime           sys_clock_gettime               sys_clock_gettime32
261  common     clock_getres            sys_clock_getres                sys_clock_getres_time32
262  common     clock_nanosleep         sys_clock_nanosleep             sys_clock_nanosleep_time32
264  32         fadvise64_64            -                               compat_sys_s390_fadvise64_64
265  common     statfs64                sys_statfs64                    compat_sys_statfs64
266  common     fstatfs64               sys_fstatfs64                   compat_sys_fstatfs64
267  common     remap_file_pages        sys_remap_file_pages            sys_remap_file_pages
268  common     mbind                   sys_mbind                       sys_mbind
269  common     get_mempolicy           sys_get_mempolicy               sys_get_mempolicy
270  common     set_mempolicy           sys_set_mempolicy               sys_set_mempolicy
271  common     mq_open                 sys_mq_open                     compat_sys_mq_open
272  common     mq_unlink               sys_mq_unlink                   sys_mq_unlink
273  common     mq_timedsend            sys_mq_timedsend                sys_mq_timedsend_time32
274  common     mq_timedreceive         sys_mq_timedreceive             sys_mq_timedreceive_time32
275  common     mq_notify               sys_mq_notify                   compat_sys_mq_notify
276  common     mq_getsetattr           sys_mq_getsetattr               compat_sys_mq_getsetattr
277  common     kexec_load              sys_kexec_load                  compat_sys_kexec_load
278  common     add_key                 sys_add_key                     sys_add_key
279  common     request_key             sys_request_key                 sys_request_key
280  common     keyctl                  sys_keyctl                      compat_sys_keyctl
281  common     waitid                  sys_waitid                      compat_sys_waitid
282  common     ioprio_set              sys_ioprio_set                  sys_ioprio_set
283  common     ioprio_get              sys_ioprio_get                  sys_ioprio_get
284  common     inotify_init            sys_inotify_init                sys_inotify_init
285  common     inotify_add_watch       sys_inotify_add_watch           sys_inotify_add_watch
286  common     inotify_rm_watch        sys_inotify_rm_watch            sys_inotify_rm_watch
287  common     migrate_pages           sys_migrate_pages               sys_migrate_pages
288  common     openat                  sys_openat                      compat_sys_openat
289  common     mkdirat                 sys_mkdirat                     sys_mkdirat
290  common     mknodat                 sys_mknodat                     sys_mknodat
291  common     fchownat                sys_fchownat                    sys_fchownat
292  common     futimesat               sys_futimesat                   sys_futimesat_time32
293  32         fstatat64               -                               compat_sys_s390_fstatat64
293  64         newfstatat              sys_newfstatat                  -
294  common     unlinkat                sys_unlinkat                    sys_unlinkat
295  common     renameat                sys_renameat                    sys_renameat
296  common     linkat                  sys_linkat                      sys_linkat
297  common     symlinkat               sys_symlinkat                   sys_symlinkat
298  common     readlinkat              sys_readlinkat                  sys_readlinkat
299  common     fchmodat                sys_fchmodat                    sys_fchmodat
300  common     faccessat               sys_faccessat                   sys_faccessat
301  common     pselect6                sys_pselect6                    compat_sys_pselect6_time32
302  common     ppoll                   sys_ppoll                       compat_sys_ppoll_time32
303  common     unshare                 sys_unshare                     sys_unshare
304  common     set_robust_list         sys_set_robust_list             compat_sys_set_robust_list
305  common     get_robust_list         sys_get_robust_list             compat_sys_get_robust_list
306  common     splice                  sys_splice                      sys_splice
307  common     sync_file_range         sys_sync_file_range             compat_sys_s390_sync_file_range
308  common     tee                     sys_tee                         sys_tee
309  common     vmsplice                sys_vmsplice                    sys_vmsplice
310  common     move_pages              sys_move_pages                  sys_move_pages
311  common     getcpu                  sys_getcpu                      sys_getcpu
312  common     epoll_pwait             sys_epoll_pwait                 compat_sys_epoll_pwait
313  common     utimes                  sys_utimes                      sys_utimes_time32
314  common     fallocate               sys_fallocate                   compat_sys_s390_fallocate
315  common     utimensat               sys_utimensat                   sys_utimensat_time32
316  common     signalfd                sys_signalfd                    compat_sys_signalfd
317  common     timerfd                 -                               -
318  common     eventfd                 sys_eventfd                     sys_eventfd
319  common     timerfd_create          sys_timerfd_create              sys_timerfd_create
320  common     timerfd_settime         sys_timerfd_settime             sys_timerfd_settime32
321  common     timerfd_gettime         sys_timerfd_gettime             sys_timerfd_gettime32
322  common     signalfd4               sys_signalfd4                   compat_sys_signalfd4
323  common     eventfd2                sys_eventfd2                    sys_eventfd2
324  common     inotify_init1           sys_inotify_init1               sys_inotify_init1
325  common     pipe2                   sys_pipe2                       sys_pipe2
326  common     dup3                    sys_dup3                        sys_dup3
327  common     epoll_create1           sys_epoll_create1               sys_epoll_create1
328  common     preadv                  sys_preadv                      compat_sys_preadv
329  common     pwritev                 sys_pwritev                     compat_sys_pwritev
330  common     rt_tgsigqueueinfo       sys_rt_tgsigqueueinfo           compat_sys_rt_tgsigqueueinfo
331  common     perf_event_open         sys_perf_event_open             sys_perf_event_open
332  common     fanotify_init           sys_fanotify_init               sys_fanotify_init
333  common     fanotify_mark           sys_fanotify_mark               compat_sys_fanotify_mark
334  common     prlimit64               sys_prlimit64                   sys_prlimit64
335  common     name_to_handle_at       sys_name_to_handle_at           sys_name_to_handle_at
336  common     open_by_handle_at       sys_open_by_handle_at           compat_sys_open_by_handle_at
337  common     clock_adjtime           sys_clock_adjtime               sys_clock_adjtime32
338  common     syncfs                  sys_syncfs                      sys_syncfs
339  common     setns                   sys_setns                       sys_setns
340  common     process_vm_readv        sys_process_vm_readv            sys_process_vm_readv
341  common     process_vm_writev       sys_process_vm_writev           sys_process_vm_writev
342  common     s390_runtime_instr      sys_s390_runtime_instr          sys_s390_runtime_instr
343  common     kcmp                    sys_kcmp                        sys_kcmp
344  common     finit_module            sys_finit_module                sys_finit_module
345  common     sched_setattr           sys_sched_setattr               sys_sched_setattr
346  common     sched_getattr           sys_sched_getattr               sys_sched_getattr
347  common     renameat2               sys_renameat2                   sys_renameat2
348  common     seccomp                 sys_seccomp                     sys_seccomp
349  common     getrandom               sys_getrandom                   sys_getrandom
350  common     memfd_create            sys_memfd_create                sys_memfd_create
351  common     bpf                     sys_bpf                         sys_bpf
352  common     s390_pci_mmio_write     sys_s390_pci_mmio_write         sys_s390_pci_mmio_write
353  common     s390_pci_mmio_read      sys_s390_pci_mmio_read          sys_s390_pci_mmio_read
354  common     execveat                sys_execveat                    compat_sys_execveat
355  common     userfaultfd             sys_userfaultfd                 sys_userfaultfd
356  common     membarrier              sys_membarrier                  sys_membarrier
357  common     recvmmsg                sys_recvmmsg                    compat_sys_recvmmsg_time32
358  common     sendmmsg                sys_sendmmsg                    compat_sys_sendmmsg
359  common     socket                  sys_socket                      sys_socket
360  common     socketpair              sys_socketpair                  sys_socketpair
361  common     bind                    sys_bind                        sys_bind
362  common     connect                 sys_connect                     sys_connect
363  common     listen                  sys_listen                      sys_listen
364  common     accept4                 sys_accept4                     sys_accept4
365  common     getsockopt              sys_getsockopt                  sys_getsockopt
366  common     setsockopt              sys_setsockopt                  sys_setsockopt
367  common     getsockname             sys_getsockname                 sys_getsockname
368  common     getpeername             sys_getpeername                 sys_getpeername
369  common     sendto                  sys_sendto                      sys_sendto
370  common     sendmsg                 sys_sendmsg                     compat_sys_sendmsg
371  common     recvfrom                sys_recvfrom                    compat_sys_recvfrom
372  common     recvmsg                 sys_recvmsg                     compat_sys_recvmsg
373  common     shutdown                sys_shutdown                    sys_shutdown
374  common     mlock2                  sys_mlock2                      sys_mlock2
375  common     copy_file_range         sys_copy_file_range             sys_copy_file_range
376  common     preadv2                 sys_preadv2                     compat_sys_preadv2
377  common     pwritev2                sys_pwritev2                    compat_sys_pwritev2
378  common     s390_guarded_storage    sys_s390_guarded_storage        sys_s390_guarded_storage
379  common     statx                   sys_statx                       sys_statx
380  common     s390_sthyi              sys_s390_sthyi                  sys_s390_sthyi
381  common     kexec_file_load         sys_kexec_file_load             sys_kexec_file_load
382  common     io_pgetevents           sys_io_pgetevents               compat_sys_io_pgetevents
383  common     rseq                    sys_rseq                        sys_rseq
384  common     pkey_mprotect           sys_pkey_mprotect               sys_pkey_mprotect
385  common     pkey_alloc              sys_pkey_alloc                  sys_pkey_alloc
386  common     pkey_free               sys_pkey_free                   sys_pkey_free
# room for arch specific syscalls
392     64      semtimedop              sys_semtimedop                  -
393  common     semget                  sys_semget                      sys_semget
394  common     semctl                  sys_semctl                      compat_sys_semctl
395  common     shmget                  sys_shmget                      sys_shmget
396  common     shmctl                  sys_shmctl                      compat_sys_shmctl
397  common     shmat                   sys_shmat                       compat_sys_shmat
398  common     shmdt                   sys_shmdt                       sys_shmdt
399  common     msgget                  sys_msgget                      sys_msgget
400  common     msgsnd                  sys_msgsnd                      compat_sys_msgsnd
401  common     msgrcv                  sys_msgrcv                      compat_sys_msgrcv
402  common     msgctl                  sys_msgctl                      compat_sys_msgctl
403     32      clock_gettime64         -                               sys_clock_gettime
404     32      clock_settime64         -                               sys_clock_settime
405     32      clock_adjtime64         -                               sys_clock_adjtime
406     32      clock_getres_time64     -                               sys_clock_getres
407     32      clock_nanosleep_time64  -                               sys_clock_nanosleep
408     32      timer_gettime64         -                               sys_timer_gettime
409     32      timer_settime64         -                               sys_timer_settime
410     32      timerfd_gettime64       -                               sys_timerfd_gettime
411     32      timerfd_settime64       -                               sys_timerfd_settime
412     32      utimensat_time64        -                               sys_utimensat
413     32      pselect6_time64         -                               compat_sys_pselect6_time64
414     32      ppoll_time64            -                               compat_sys_ppoll_time64
416     32      io_pgetevents_time64    -                               sys_io_pgetevents
417     32      recvmmsg_time64         -                               compat_sys_recvmmsg_time64
418     32      mq_timedsend_time64     -                               sys_mq_timedsend
419     32      mq_timedreceive_time64  -                               sys_mq_timedreceive
420     32      semtimedop_time64       -                               sys_semtimedop
421     32      rt_sigtimedwait_time64  -                               compat_sys_rt_sigtimedwait_time64
422     32      futex_time64            -                               sys_futex
423     32      sched_rr_get_interval_time64    -                       sys_sched_rr_get_interval
424  common     pidfd_send_signal       sys_pidfd_send_signal           sys_pidfd_send_signal
425  common     io_uring_setup          sys_io_uring_setup              sys_io_uring_setup
426  common     io_uring_enter          sys_io_uring_enter              sys_io_uring_enter
427  common     io_uring_register       sys_io_uring_register           sys_io_uring_register
428  common     open_tree               sys_open_tree                   sys_open_tree
429  common     move_mount              sys_move_mount                  sys_move_mount
430  common     fsopen                  sys_fsopen                      sys_fsopen
431  common     fsconfig                sys_fsconfig                    sys_fsconfig
432  common     fsmount                 sys_fsmount                     sys_fsmount
433  common     fspick                  sys_fspick                      sys_fspick
434  common     pidfd_open              sys_pidfd_open                  sys_pidfd_open
435  common     clone3                  sys_clone3                      sys_clone3
436  common     close_range             sys_close_range                 sys_close_range
437  common     openat2                 sys_openat2                     sys_openat2
438  common     pidfd_getfd             sys_pidfd_getfd                 sys_pidfd_getfd
439  common     faccessat2              sys_faccessat2                  sys_faccessat2
440  common     process_madvise         sys_process_madvise             sys_process_madvise
441  common     epoll_pwait2            sys_epoll_pwait2                compat_sys_epoll_pwait2
442  common     mount_setattr           sys_mount_setattr               sys_mount_setattr
443  common     quotactl_fd             sys_quotactl_fd                 sys_quotactl_fd
444  common     landlock_create_ruleset sys_landlock_create_ruleset     sys_landlock_create_ruleset
445  common     landlock_add_rule       sys_landlock_add_rule           sys_landlock_add_rule
446  common     landlock_restrict_self  sys_landlock_restrict_self      sys_landlock_restrict_self
# 447 reserved for memfd_secret
448  common     process_mrelease        sys_process_mrelease            sys_process_mrelease
449  common     futex_waitv             sys_futex_waitv                 sys_futex_waitv
450  common     set_mempolicy_home_node sys_set_mempolicy_home_node     sys_set_mempolicy_home_node
"""


# SH4
# - arch/sh/kernel/syscalls/syscall.tbl
sh4_syscall_tbl = """
# system call numbers and entry vectors for sh
#
# The format is:
# <number> <abi> <name> <entry point>
#
# The <abi> is always "common" for this file
#
0       common  restart_syscall                 sys_restart_syscall
1       common  exit                            sys_exit
2       common  fork                            sys_fork
3       common  read                            sys_read
4       common  write                           sys_write
5       common  open                            sys_open
6       common  close                           sys_close
7       common  waitpid                         sys_waitpid
8       common  creat                           sys_creat
9       common  link                            sys_link
10      common  unlink                          sys_unlink
11      common  execve                          sys_execve
12      common  chdir                           sys_chdir
13      common  time                            sys_time32
14      common  mknod                           sys_mknod
15      common  chmod                           sys_chmod
16      common  lchown                          sys_lchown16
# 17 was break
18      common  oldstat                         sys_stat
19      common  lseek                           sys_lseek
20      common  getpid                          sys_getpid
21      common  mount                           sys_mount
22      common  umount                          sys_oldumount
23      common  setuid                          sys_setuid16
24      common  getuid                          sys_getuid16
25      common  stime                           sys_stime32
26      common  ptrace                          sys_ptrace
27      common  alarm                           sys_alarm
28      common  oldfstat                        sys_fstat
29      common  pause                           sys_pause
30      common  utime                           sys_utime32
# 31 was stty
# 32 was gtty
33      common  access                          sys_access
34      common  nice                            sys_nice
# 35 was ftime
36      common  sync                            sys_sync
37      common  kill                            sys_kill
38      common  rename                          sys_rename
39      common  mkdir                           sys_mkdir
40      common  rmdir                           sys_rmdir
41      common  dup                             sys_dup
42      common  pipe                            sys_sh_pipe
43      common  times                           sys_times
# 44 was prof
45      common  brk                             sys_brk
46      common  setgid                          sys_setgid16
47      common  getgid                          sys_getgid16
48      common  signal                          sys_signal
49      common  geteuid                         sys_geteuid16
50      common  getegid                         sys_getegid16
51      common  acct                            sys_acct
52      common  umount2                         sys_umount
# 53 was lock
54      common  ioctl                           sys_ioctl
55      common  fcntl                           sys_fcntl
# 56 was mpx
57      common  setpgid                         sys_setpgid
# 58 was ulimit
# 59 was olduname
60      common  umask                           sys_umask
61      common  chroot                          sys_chroot
62      common  ustat                           sys_ustat
63      common  dup2                            sys_dup2
64      common  getppid                         sys_getppid
65      common  getpgrp                         sys_getpgrp
66      common  setsid                          sys_setsid
67      common  sigaction                       sys_sigaction
68      common  sgetmask                        sys_sgetmask
69      common  ssetmask                        sys_ssetmask
70      common  setreuid                        sys_setreuid16
71      common  setregid                        sys_setregid16
72      common  sigsuspend                      sys_sigsuspend
73      common  sigpending                      sys_sigpending
74      common  sethostname                     sys_sethostname
75      common  setrlimit                       sys_setrlimit
76      common  getrlimit                       sys_old_getrlimit
77      common  getrusage                       sys_getrusage
78      common  gettimeofday                    sys_gettimeofday
79      common  settimeofday                    sys_settimeofday
80      common  getgroups                       sys_getgroups16
81      common  setgroups                       sys_setgroups16
# 82 was select
83      common  symlink                         sys_symlink
84      common  oldlstat                        sys_lstat
85      common  readlink                        sys_readlink
86      common  uselib                          sys_uselib
87      common  swapon                          sys_swapon
88      common  reboot                          sys_reboot
89      common  readdir                         sys_old_readdir
90      common  mmap                            old_mmap
91      common  munmap                          sys_munmap
92      common  truncate                        sys_truncate
93      common  ftruncate                       sys_ftruncate
94      common  fchmod                          sys_fchmod
95      common  fchown                          sys_fchown16
96      common  getpriority                     sys_getpriority
97      common  setpriority                     sys_setpriority
# 98 was profil
99      common  statfs                          sys_statfs
100     common  fstatfs                         sys_fstatfs
# 101 was ioperm
102     common  socketcall                      sys_socketcall
103     common  syslog                          sys_syslog
104     common  setitimer                       sys_setitimer
105     common  getitimer                       sys_getitimer
106     common  stat                            sys_newstat
107     common  lstat                           sys_newlstat
108     common  fstat                           sys_newfstat
109     common  olduname                        sys_uname
# 110 was iopl
111     common  vhangup                         sys_vhangup
# 112 was idle
# 113 was vm86old
114     common  wait4                           sys_wait4
115     common  swapoff                         sys_swapoff
116     common  sysinfo                         sys_sysinfo
117     common  ipc                             sys_ipc
118     common  fsync                           sys_fsync
119     common  sigreturn                       sys_sigreturn
120     common  clone                           sys_clone
121     common  setdomainname                   sys_setdomainname
122     common  uname                           sys_newuname
123     common  cacheflush                      sys_cacheflush
124     common  adjtimex                        sys_adjtimex_time32
125     common  mprotect                        sys_mprotect
126     common  sigprocmask                     sys_sigprocmask
# 127 was create_module
128     common  init_module                     sys_init_module
129     common  delete_module                   sys_delete_module
# 130 was get_kernel_syms
131     common  quotactl                        sys_quotactl
132     common  getpgid                         sys_getpgid
133     common  fchdir                          sys_fchdir
134     common  bdflush                         sys_ni_syscall
135     common  sysfs                           sys_sysfs
136     common  personality                     sys_personality
# 137 was afs_syscall
138     common  setfsuid                        sys_setfsuid16
139     common  setfsgid                        sys_setfsgid16
140     common  _llseek                         sys_llseek
141     common  getdents                        sys_getdents
142     common  _newselect                      sys_select
143     common  flock                           sys_flock
144     common  msync                           sys_msync
145     common  readv                           sys_readv
146     common  writev                          sys_writev
147     common  getsid                          sys_getsid
148     common  fdatasync                       sys_fdatasync
149     common  _sysctl                         sys_ni_syscall
150     common  mlock                           sys_mlock
151     common  munlock                         sys_munlock
152     common  mlockall                        sys_mlockall
153     common  munlockall                      sys_munlockall
154     common  sched_setparam                  sys_sched_setparam
155     common  sched_getparam                  sys_sched_getparam
156     common  sched_setscheduler              sys_sched_setscheduler
157     common  sched_getscheduler              sys_sched_getscheduler
158     common  sched_yield                     sys_sched_yield
159     common  sched_get_priority_max          sys_sched_get_priority_max
160     common  sched_get_priority_min          sys_sched_get_priority_min
161     common  sched_rr_get_interval           sys_sched_rr_get_interval_time32
162     common  nanosleep                       sys_nanosleep_time32
163     common  mremap                          sys_mremap
164     common  setresuid                       sys_setresuid16
165     common  getresuid                       sys_getresuid16
# 166 was vm86
# 167 was query_module
168     common  poll                            sys_poll
169     common  nfsservctl                      sys_ni_syscall
170     common  setresgid                       sys_setresgid16
171     common  getresgid                       sys_getresgid16
172     common  prctl                           sys_prctl
173     common  rt_sigreturn                    sys_rt_sigreturn
174     common  rt_sigaction                    sys_rt_sigaction
175     common  rt_sigprocmask                  sys_rt_sigprocmask
176     common  rt_sigpending                   sys_rt_sigpending
177     common  rt_sigtimedwait                 sys_rt_sigtimedwait_time32
178     common  rt_sigqueueinfo                 sys_rt_sigqueueinfo
179     common  rt_sigsuspend                   sys_rt_sigsuspend
180     common  pread64                         sys_pread_wrapper
181     common  pwrite64                        sys_pwrite_wrapper
182     common  chown                           sys_chown16
183     common  getcwd                          sys_getcwd
184     common  capget                          sys_capget
185     common  capset                          sys_capset
186     common  sigaltstack                     sys_sigaltstack
187     common  sendfile                        sys_sendfile
# 188 is reserved for getpmsg
# 189 is reserved for putpmsg
190     common  vfork                           sys_vfork
191     common  ugetrlimit                      sys_getrlimit
192     common  mmap2                           sys_mmap2
193     common  truncate64                      sys_truncate64
194     common  ftruncate64                     sys_ftruncate64
195     common  stat64                          sys_stat64
196     common  lstat64                         sys_lstat64
197     common  fstat64                         sys_fstat64
198     common  lchown32                        sys_lchown
199     common  getuid32                        sys_getuid
200     common  getgid32                        sys_getgid
201     common  geteuid32                       sys_geteuid
202     common  getegid32                       sys_getegid
203     common  setreuid32                      sys_setreuid
204     common  setregid32                      sys_setregid
205     common  getgroups32                     sys_getgroups
206     common  setgroups32                     sys_setgroups
207     common  fchown32                        sys_fchown
208     common  setresuid32                     sys_setresuid
209     common  getresuid32                     sys_getresuid
210     common  setresgid32                     sys_setresgid
211     common  getresgid32                     sys_getresgid
212     common  chown32                         sys_chown
213     common  setuid32                        sys_setuid
214     common  setgid32                        sys_setgid
215     common  setfsuid32                      sys_setfsuid
216     common  setfsgid32                      sys_setfsgid
217     common  pivot_root                      sys_pivot_root
218     common  mincore                         sys_mincore
219     common  madvise                         sys_madvise
220     common  getdents64                      sys_getdents64
221     common  fcntl64                         sys_fcntl64
# 222 is reserved for tux
# 223 is unused
224     common  gettid                          sys_gettid
225     common  readahead                       sys_readahead
226     common  setxattr                        sys_setxattr
227     common  lsetxattr                       sys_lsetxattr
228     common  fsetxattr                       sys_fsetxattr
229     common  getxattr                        sys_getxattr
230     common  lgetxattr                       sys_lgetxattr
231     common  fgetxattr                       sys_fgetxattr
232     common  listxattr                       sys_listxattr
233     common  llistxattr                      sys_llistxattr
234     common  flistxattr                      sys_flistxattr
235     common  removexattr                     sys_removexattr
236     common  lremovexattr                    sys_lremovexattr
237     common  fremovexattr                    sys_fremovexattr
238     common  tkill                           sys_tkill
239     common  sendfile64                      sys_sendfile64
240     common  futex                           sys_futex_time32
241     common  sched_setaffinity               sys_sched_setaffinity
242     common  sched_getaffinity               sys_sched_getaffinity
# 243 is reserved for set_thread_area
# 244 is reserved for get_thread_area
245     common  io_setup                        sys_io_setup
246     common  io_destroy                      sys_io_destroy
247     common  io_getevents                    sys_io_getevents_time32
248     common  io_submit                       sys_io_submit
249     common  io_cancel                       sys_io_cancel
250     common  fadvise64                       sys_fadvise64
# 251 is unused
252     common  exit_group                      sys_exit_group
253     common  lookup_dcookie                  sys_lookup_dcookie
254     common  epoll_create                    sys_epoll_create
255     common  epoll_ctl                       sys_epoll_ctl
256     common  epoll_wait                      sys_epoll_wait
257     common  remap_file_pages                sys_remap_file_pages
258     common  set_tid_address                 sys_set_tid_address
259     common  timer_create                    sys_timer_create
260     common  timer_settime                   sys_timer_settime32
261     common  timer_gettime                   sys_timer_gettime32
262     common  timer_getoverrun                sys_timer_getoverrun
263     common  timer_delete                    sys_timer_delete
264     common  clock_settime                   sys_clock_settime32
265     common  clock_gettime                   sys_clock_gettime32
266     common  clock_getres                    sys_clock_getres_time32
267     common  clock_nanosleep                 sys_clock_nanosleep_time32
268     common  statfs64                        sys_statfs64
269     common  fstatfs64                       sys_fstatfs64
270     common  tgkill                          sys_tgkill
271     common  utimes                          sys_utimes_time32
272     common  fadvise64_64                    sys_fadvise64_64_wrapper
# 273 is reserved for vserver
274     common  mbind                           sys_mbind
275     common  get_mempolicy                   sys_get_mempolicy
276     common  set_mempolicy                   sys_set_mempolicy
277     common  mq_open                         sys_mq_open
278     common  mq_unlink                       sys_mq_unlink
279     common  mq_timedsend                    sys_mq_timedsend_time32
280     common  mq_timedreceive                 sys_mq_timedreceive_time32
281     common  mq_notify                       sys_mq_notify
282     common  mq_getsetattr                   sys_mq_getsetattr
283     common  kexec_load                      sys_kexec_load
284     common  waitid                          sys_waitid
285     common  add_key                         sys_add_key
286     common  request_key                     sys_request_key
287     common  keyctl                          sys_keyctl
288     common  ioprio_set                      sys_ioprio_set
289     common  ioprio_get                      sys_ioprio_get
290     common  inotify_init                    sys_inotify_init
291     common  inotify_add_watch               sys_inotify_add_watch
292     common  inotify_rm_watch                sys_inotify_rm_watch
# 293 is unused
294     common  migrate_pages                   sys_migrate_pages
295     common  openat                          sys_openat
296     common  mkdirat                         sys_mkdirat
297     common  mknodat                         sys_mknodat
298     common  fchownat                        sys_fchownat
299     common  futimesat                       sys_futimesat_time32
300     common  fstatat64                       sys_fstatat64
301     common  unlinkat                        sys_unlinkat
302     common  renameat                        sys_renameat
303     common  linkat                          sys_linkat
304     common  symlinkat                       sys_symlinkat
305     common  readlinkat                      sys_readlinkat
306     common  fchmodat                        sys_fchmodat
307     common  faccessat                       sys_faccessat
308     common  pselect6                        sys_pselect6_time32
309     common  ppoll                           sys_ppoll_time32
310     common  unshare                         sys_unshare
311     common  set_robust_list                 sys_set_robust_list
312     common  get_robust_list                 sys_get_robust_list
313     common  splice                          sys_splice
314     common  sync_file_range                 sys_sync_file_range
315     common  tee                             sys_tee
316     common  vmsplice                        sys_vmsplice
317     common  move_pages                      sys_move_pages
318     common  getcpu                          sys_getcpu
319     common  epoll_pwait                     sys_epoll_pwait
320     common  utimensat                       sys_utimensat_time32
321     common  signalfd                        sys_signalfd
322     common  timerfd_create                  sys_timerfd_create
323     common  eventfd                         sys_eventfd
324     common  fallocate                       sys_fallocate
325     common  timerfd_settime                 sys_timerfd_settime32
326     common  timerfd_gettime                 sys_timerfd_gettime32
327     common  signalfd4                       sys_signalfd4
328     common  eventfd2                        sys_eventfd2
329     common  epoll_create1                   sys_epoll_create1
330     common  dup3                            sys_dup3
331     common  pipe2                           sys_pipe2
332     common  inotify_init1                   sys_inotify_init1
333     common  preadv                          sys_preadv
334     common  pwritev                         sys_pwritev
335     common  rt_tgsigqueueinfo               sys_rt_tgsigqueueinfo
336     common  perf_event_open                 sys_perf_event_open
337     common  fanotify_init                   sys_fanotify_init
338     common  fanotify_mark                   sys_fanotify_mark
339     common  prlimit64                       sys_prlimit64
340     common  socket                          sys_socket
341     common  bind                            sys_bind
342     common  connect                         sys_connect
343     common  listen                          sys_listen
344     common  accept                          sys_accept
345     common  getsockname                     sys_getsockname
346     common  getpeername                     sys_getpeername
347     common  socketpair                      sys_socketpair
348     common  send                            sys_send
349     common  sendto                          sys_sendto
350     common  recv                            sys_recv
351     common  recvfrom                        sys_recvfrom
352     common  shutdown                        sys_shutdown
353     common  setsockopt                      sys_setsockopt
354     common  getsockopt                      sys_getsockopt
355     common  sendmsg                         sys_sendmsg
356     common  recvmsg                         sys_recvmsg
357     common  recvmmsg                        sys_recvmmsg_time32
358     common  accept4                         sys_accept4
359     common  name_to_handle_at               sys_name_to_handle_at
360     common  open_by_handle_at               sys_open_by_handle_at
361     common  clock_adjtime                   sys_clock_adjtime32
362     common  syncfs                          sys_syncfs
363     common  sendmmsg                        sys_sendmmsg
364     common  setns                           sys_setns
365     common  process_vm_readv                sys_process_vm_readv
366     common  process_vm_writev               sys_process_vm_writev
367     common  kcmp                            sys_kcmp
368     common  finit_module                    sys_finit_module
369     common  sched_getattr                   sys_sched_getattr
370     common  sched_setattr                   sys_sched_setattr
371     common  renameat2                       sys_renameat2
372     common  seccomp                         sys_seccomp
373     common  getrandom                       sys_getrandom
374     common  memfd_create                    sys_memfd_create
375     common  bpf                             sys_bpf
376     common  execveat                        sys_execveat
377     common  userfaultfd                     sys_userfaultfd
378     common  membarrier                      sys_membarrier
379     common  mlock2                          sys_mlock2
380     common  copy_file_range                 sys_copy_file_range
381     common  preadv2                         sys_preadv2
382     common  pwritev2                        sys_pwritev2
383     common  statx                           sys_statx
384     common  pkey_mprotect                   sys_pkey_mprotect
385     common  pkey_alloc                      sys_pkey_alloc
386     common  pkey_free                       sys_pkey_free
387     common  rseq                            sys_rseq
# room for arch specific syscalls
393     common  semget                          sys_semget
394     common  semctl                          sys_semctl
395     common  shmget                          sys_shmget
396     common  shmctl                          sys_shmctl
397     common  shmat                           sys_shmat
398     common  shmdt                           sys_shmdt
399     common  msgget                          sys_msgget
400     common  msgsnd                          sys_msgsnd
401     common  msgrcv                          sys_msgrcv
402     common  msgctl                          sys_msgctl
403     common  clock_gettime64                 sys_clock_gettime
404     common  clock_settime64                 sys_clock_settime
405     common  clock_adjtime64                 sys_clock_adjtime
406     common  clock_getres_time64             sys_clock_getres
407     common  clock_nanosleep_time64          sys_clock_nanosleep
408     common  timer_gettime64                 sys_timer_gettime
409     common  timer_settime64                 sys_timer_settime
410     common  timerfd_gettime64               sys_timerfd_gettime
411     common  timerfd_settime64               sys_timerfd_settime
412     common  utimensat_time64                sys_utimensat
413     common  pselect6_time64                 sys_pselect6
414     common  ppoll_time64                    sys_ppoll
416     common  io_pgetevents_time64            sys_io_pgetevents
417     common  recvmmsg_time64                 sys_recvmmsg
418     common  mq_timedsend_time64             sys_mq_timedsend
419     common  mq_timedreceive_time64          sys_mq_timedreceive
420     common  semtimedop_time64               sys_semtimedop
421     common  rt_sigtimedwait_time64          sys_rt_sigtimedwait
422     common  futex_time64                    sys_futex
423     common  sched_rr_get_interval_time64    sys_sched_rr_get_interval
424     common  pidfd_send_signal               sys_pidfd_send_signal
425     common  io_uring_setup                  sys_io_uring_setup
426     common  io_uring_enter                  sys_io_uring_enter
427     common  io_uring_register               sys_io_uring_register
428     common  open_tree                       sys_open_tree
429     common  move_mount                      sys_move_mount
430     common  fsopen                          sys_fsopen
431     common  fsconfig                        sys_fsconfig
432     common  fsmount                         sys_fsmount
433     common  fspick                          sys_fspick
434     common  pidfd_open                      sys_pidfd_open
# 435 reserved for clone3
436     common  close_range                     sys_close_range
437     common  openat2                         sys_openat2
438     common  pidfd_getfd                     sys_pidfd_getfd
439     common  faccessat2                      sys_faccessat2
440     common  process_madvise                 sys_process_madvise
441     common  epoll_pwait2                    sys_epoll_pwait2
442     common  mount_setattr                   sys_mount_setattr
443     common  quotactl_fd                     sys_quotactl_fd
444     common  landlock_create_ruleset         sys_landlock_create_ruleset
445     common  landlock_add_rule               sys_landlock_add_rule
446     common  landlock_restrict_self          sys_landlock_restrict_self
# 447 reserved for memfd_secret
448     common  process_mrelease                sys_process_mrelease
449     common  futex_waitv                     sys_futex_waitv
450     common  set_mempolicy_home_node         sys_set_mempolicy_home_node
"""


# m68k
# - arch/m68k/kernel/syscall/syscall.tbl
m68k_syscall_tbl = """
# system call numbers and entry vectors for m68k
#
# The format is:
# <number> <abi> <name> <entry point>
#
# The <abi> is always "common" for this file
#
0       common  restart_syscall                 sys_restart_syscall
1       common  exit                            sys_exit
2       common  fork                            __sys_fork
3       common  read                            sys_read
4       common  write                           sys_write
5       common  open                            sys_open
6       common  close                           sys_close
7       common  waitpid                         sys_waitpid
8       common  creat                           sys_creat
9       common  link                            sys_link
10      common  unlink                          sys_unlink
11      common  execve                          sys_execve
12      common  chdir                           sys_chdir
13      common  time                            sys_time32
14      common  mknod                           sys_mknod
15      common  chmod                           sys_chmod
16      common  chown                           sys_chown16
# 17 was break
18      common  oldstat                         sys_stat
19      common  lseek                           sys_lseek
20      common  getpid                          sys_getpid
21      common  mount                           sys_mount
22      common  umount                          sys_oldumount
23      common  setuid                          sys_setuid16
24      common  getuid                          sys_getuid16
25      common  stime                           sys_stime32
26      common  ptrace                          sys_ptrace
27      common  alarm                           sys_alarm
28      common  oldfstat                        sys_fstat
29      common  pause                           sys_pause
30      common  utime                           sys_utime32
# 31 was stty
# 32 was gtty
33      common  access                          sys_access
34      common  nice                            sys_nice
# 35 was ftime
36      common  sync                            sys_sync
37      common  kill                            sys_kill
38      common  rename                          sys_rename
39      common  mkdir                           sys_mkdir
40      common  rmdir                           sys_rmdir
41      common  dup                             sys_dup
42      common  pipe                            sys_pipe
43      common  times                           sys_times
# 44 was prof
45      common  brk                             sys_brk
46      common  setgid                          sys_setgid16
47      common  getgid                          sys_getgid16
48      common  signal                          sys_signal
49      common  geteuid                         sys_geteuid16
50      common  getegid                         sys_getegid16
51      common  acct                            sys_acct
52      common  umount2                         sys_umount
# 53 was lock
54      common  ioctl                           sys_ioctl
55      common  fcntl                           sys_fcntl
# 56 was mpx
57      common  setpgid                         sys_setpgid
# 58 was ulimit
# 59 was oldolduname
60      common  umask                           sys_umask
61      common  chroot                          sys_chroot
62      common  ustat                           sys_ustat
63      common  dup2                            sys_dup2
64      common  getppid                         sys_getppid
65      common  getpgrp                         sys_getpgrp
66      common  setsid                          sys_setsid
67      common  sigaction                       sys_sigaction
68      common  sgetmask                        sys_sgetmask
69      common  ssetmask                        sys_ssetmask
70      common  setreuid                        sys_setreuid16
71      common  setregid                        sys_setregid16
72      common  sigsuspend                      sys_sigsuspend
73      common  sigpending                      sys_sigpending
74      common  sethostname                     sys_sethostname
75      common  setrlimit                       sys_setrlimit
76      common  getrlimit                       sys_old_getrlimit
77      common  getrusage                       sys_getrusage
78      common  gettimeofday                    sys_gettimeofday
79      common  settimeofday                    sys_settimeofday
80      common  getgroups                       sys_getgroups16
81      common  setgroups                       sys_setgroups16
82      common  select                          sys_old_select
83      common  symlink                         sys_symlink
84      common  oldlstat                        sys_lstat
85      common  readlink                        sys_readlink
86      common  uselib                          sys_uselib
87      common  swapon                          sys_swapon
88      common  reboot                          sys_reboot
89      common  readdir                         sys_old_readdir
90      common  mmap                            sys_old_mmap
91      common  munmap                          sys_munmap
92      common  truncate                        sys_truncate
93      common  ftruncate                       sys_ftruncate
94      common  fchmod                          sys_fchmod
95      common  fchown                          sys_fchown16
96      common  getpriority                     sys_getpriority
97      common  setpriority                     sys_setpriority
# 98 was profil
99      common  statfs                          sys_statfs
100     common  fstatfs                         sys_fstatfs
# 101 was ioperm
102     common  socketcall                      sys_socketcall
103     common  syslog                          sys_syslog
104     common  setitimer                       sys_setitimer
105     common  getitimer                       sys_getitimer
106     common  stat                            sys_newstat
107     common  lstat                           sys_newlstat
108     common  fstat                           sys_newfstat
# 109 was olduname
# 110 was iopl
111     common  vhangup                         sys_vhangup
# 112 was idle
# 113 was vm86
114     common  wait4                           sys_wait4
115     common  swapoff                         sys_swapoff
116     common  sysinfo                         sys_sysinfo
117     common  ipc                             sys_ipc
118     common  fsync                           sys_fsync
119     common  sigreturn                       sys_sigreturn
120     common  clone                           __sys_clone
121     common  setdomainname                   sys_setdomainname
122     common  uname                           sys_newuname
123     common  cacheflush                      sys_cacheflush
124     common  adjtimex                        sys_adjtimex_time32
125     common  mprotect                        sys_mprotect
126     common  sigprocmask                     sys_sigprocmask
127     common  create_module                   sys_ni_syscall
128     common  init_module                     sys_init_module
129     common  delete_module                   sys_delete_module
130     common  get_kernel_syms                 sys_ni_syscall
131     common  quotactl                        sys_quotactl
132     common  getpgid                         sys_getpgid
133     common  fchdir                          sys_fchdir
134     common  bdflush                         sys_ni_syscall
135     common  sysfs                           sys_sysfs
136     common  personality                     sys_personality
# 137 was afs_syscall
138     common  setfsuid                        sys_setfsuid16
139     common  setfsgid                        sys_setfsgid16
140     common  _llseek                         sys_llseek
141     common  getdents                        sys_getdents
142     common  _newselect                      sys_select
143     common  flock                           sys_flock
144     common  msync                           sys_msync
145     common  readv                           sys_readv
146     common  writev                          sys_writev
147     common  getsid                          sys_getsid
148     common  fdatasync                       sys_fdatasync
149     common  _sysctl                         sys_ni_syscall
150     common  mlock                           sys_mlock
151     common  munlock                         sys_munlock
152     common  mlockall                        sys_mlockall
153     common  munlockall                      sys_munlockall
154     common  sched_setparam                  sys_sched_setparam
155     common  sched_getparam                  sys_sched_getparam
156     common  sched_setscheduler              sys_sched_setscheduler
157     common  sched_getscheduler              sys_sched_getscheduler
158     common  sched_yield                     sys_sched_yield
159     common  sched_get_priority_max          sys_sched_get_priority_max
160     common  sched_get_priority_min          sys_sched_get_priority_min
161     common  sched_rr_get_interval           sys_sched_rr_get_interval_time32
162     common  nanosleep                       sys_nanosleep_time32
163     common  mremap                          sys_mremap
164     common  setresuid                       sys_setresuid16
165     common  getresuid                       sys_getresuid16
166     common  getpagesize                     sys_getpagesize
167     common  query_module                    sys_ni_syscall
168     common  poll                            sys_poll
169     common  nfsservctl                      sys_ni_syscall
170     common  setresgid                       sys_setresgid16
171     common  getresgid                       sys_getresgid16
172     common  prctl                           sys_prctl
173     common  rt_sigreturn                    sys_rt_sigreturn
174     common  rt_sigaction                    sys_rt_sigaction
175     common  rt_sigprocmask                  sys_rt_sigprocmask
176     common  rt_sigpending                   sys_rt_sigpending
177     common  rt_sigtimedwait                 sys_rt_sigtimedwait_time32
178     common  rt_sigqueueinfo                 sys_rt_sigqueueinfo
179     common  rt_sigsuspend                   sys_rt_sigsuspend
180     common  pread64                         sys_pread64
181     common  pwrite64                        sys_pwrite64
182     common  lchown                          sys_lchown16
183     common  getcwd                          sys_getcwd
184     common  capget                          sys_capget
185     common  capset                          sys_capset
186     common  sigaltstack                     sys_sigaltstack
187     common  sendfile                        sys_sendfile
188     common  getpmsg                         sys_ni_syscall
189     common  putpmsg                         sys_ni_syscall
190     common  vfork                           __sys_vfork
191     common  ugetrlimit                      sys_getrlimit
192     common  mmap2                           sys_mmap2
193     common  truncate64                      sys_truncate64
194     common  ftruncate64                     sys_ftruncate64
195     common  stat64                          sys_stat64
196     common  lstat64                         sys_lstat64
197     common  fstat64                         sys_fstat64
198     common  chown32                         sys_chown
199     common  getuid32                        sys_getuid
200     common  getgid32                        sys_getgid
201     common  geteuid32                       sys_geteuid
202     common  getegid32                       sys_getegid
203     common  setreuid32                      sys_setreuid
204     common  setregid32                      sys_setregid
205     common  getgroups32                     sys_getgroups
206     common  setgroups32                     sys_setgroups
207     common  fchown32                        sys_fchown
208     common  setresuid32                     sys_setresuid
209     common  getresuid32                     sys_getresuid
210     common  setresgid32                     sys_setresgid
211     common  getresgid32                     sys_getresgid
212     common  lchown32                        sys_lchown
213     common  setuid32                        sys_setuid
214     common  setgid32                        sys_setgid
215     common  setfsuid32                      sys_setfsuid
216     common  setfsgid32                      sys_setfsgid
217     common  pivot_root                      sys_pivot_root
# 218 is reserved
# 219 is reserved
220     common  getdents64                      sys_getdents64
221     common  gettid                          sys_gettid
222     common  tkill                           sys_tkill
223     common  setxattr                        sys_setxattr
224     common  lsetxattr                       sys_lsetxattr
225     common  fsetxattr                       sys_fsetxattr
226     common  getxattr                        sys_getxattr
227     common  lgetxattr                       sys_lgetxattr
228     common  fgetxattr                       sys_fgetxattr
229     common  listxattr                       sys_listxattr
230     common  llistxattr                      sys_llistxattr
231     common  flistxattr                      sys_flistxattr
232     common  removexattr                     sys_removexattr
233     common  lremovexattr                    sys_lremovexattr
234     common  fremovexattr                    sys_fremovexattr
235     common  futex                           sys_futex_time32
236     common  sendfile64                      sys_sendfile64
237     common  mincore                         sys_mincore
238     common  madvise                         sys_madvise
239     common  fcntl64                         sys_fcntl64
240     common  readahead                       sys_readahead
241     common  io_setup                        sys_io_setup
242     common  io_destroy                      sys_io_destroy
243     common  io_getevents                    sys_io_getevents_time32
244     common  io_submit                       sys_io_submit
245     common  io_cancel                       sys_io_cancel
246     common  fadvise64                       sys_fadvise64
247     common  exit_group                      sys_exit_group
248     common  lookup_dcookie                  sys_lookup_dcookie
249     common  epoll_create                    sys_epoll_create
250     common  epoll_ctl                       sys_epoll_ctl
251     common  epoll_wait                      sys_epoll_wait
252     common  remap_file_pages                sys_remap_file_pages
253     common  set_tid_address                 sys_set_tid_address
254     common  timer_create                    sys_timer_create
255     common  timer_settime                   sys_timer_settime32
256     common  timer_gettime                   sys_timer_gettime32
257     common  timer_getoverrun                sys_timer_getoverrun
258     common  timer_delete                    sys_timer_delete
259     common  clock_settime                   sys_clock_settime32
260     common  clock_gettime                   sys_clock_gettime32
261     common  clock_getres                    sys_clock_getres_time32
262     common  clock_nanosleep                 sys_clock_nanosleep_time32
263     common  statfs64                        sys_statfs64
264     common  fstatfs64                       sys_fstatfs64
265     common  tgkill                          sys_tgkill
266     common  utimes                          sys_utimes_time32
267     common  fadvise64_64                    sys_fadvise64_64
268     common  mbind                           sys_mbind
269     common  get_mempolicy                   sys_get_mempolicy
270     common  set_mempolicy                   sys_set_mempolicy
271     common  mq_open                         sys_mq_open
272     common  mq_unlink                       sys_mq_unlink
273     common  mq_timedsend                    sys_mq_timedsend_time32
274     common  mq_timedreceive                 sys_mq_timedreceive_time32
275     common  mq_notify                       sys_mq_notify
276     common  mq_getsetattr                   sys_mq_getsetattr
277     common  waitid                          sys_waitid
# 278 was vserver
279     common  add_key                         sys_add_key
280     common  request_key                     sys_request_key
281     common  keyctl                          sys_keyctl
282     common  ioprio_set                      sys_ioprio_set
283     common  ioprio_get                      sys_ioprio_get
284     common  inotify_init                    sys_inotify_init
285     common  inotify_add_watch               sys_inotify_add_watch
286     common  inotify_rm_watch                sys_inotify_rm_watch
287     common  migrate_pages                   sys_migrate_pages
288     common  openat                          sys_openat
289     common  mkdirat                         sys_mkdirat
290     common  mknodat                         sys_mknodat
291     common  fchownat                        sys_fchownat
292     common  futimesat                       sys_futimesat_time32
293     common  fstatat64                       sys_fstatat64
294     common  unlinkat                        sys_unlinkat
295     common  renameat                        sys_renameat
296     common  linkat                          sys_linkat
297     common  symlinkat                       sys_symlinkat
298     common  readlinkat                      sys_readlinkat
299     common  fchmodat                        sys_fchmodat
300     common  faccessat                       sys_faccessat
301     common  pselect6                        sys_pselect6_time32
302     common  ppoll                           sys_ppoll_time32
303     common  unshare                         sys_unshare
304     common  set_robust_list                 sys_set_robust_list
305     common  get_robust_list                 sys_get_robust_list
306     common  splice                          sys_splice
307     common  sync_file_range                 sys_sync_file_range
308     common  tee                             sys_tee
309     common  vmsplice                        sys_vmsplice
310     common  move_pages                      sys_move_pages
311     common  sched_setaffinity               sys_sched_setaffinity
312     common  sched_getaffinity               sys_sched_getaffinity
313     common  kexec_load                      sys_kexec_load
314     common  getcpu                          sys_getcpu
315     common  epoll_pwait                     sys_epoll_pwait
316     common  utimensat                       sys_utimensat_time32
317     common  signalfd                        sys_signalfd
318     common  timerfd_create                  sys_timerfd_create
319     common  eventfd                         sys_eventfd
320     common  fallocate                       sys_fallocate
321     common  timerfd_settime                 sys_timerfd_settime32
322     common  timerfd_gettime                 sys_timerfd_gettime32
323     common  signalfd4                       sys_signalfd4
324     common  eventfd2                        sys_eventfd2
325     common  epoll_create1                   sys_epoll_create1
326     common  dup3                            sys_dup3
327     common  pipe2                           sys_pipe2
328     common  inotify_init1                   sys_inotify_init1
329     common  preadv                          sys_preadv
330     common  pwritev                         sys_pwritev
331     common  rt_tgsigqueueinfo               sys_rt_tgsigqueueinfo
332     common  perf_event_open                 sys_perf_event_open
333     common  get_thread_area                 sys_get_thread_area
334     common  set_thread_area                 sys_set_thread_area
335     common  atomic_cmpxchg_32               sys_atomic_cmpxchg_32
336     common  atomic_barrier                  sys_atomic_barrier
337     common  fanotify_init                   sys_fanotify_init
338     common  fanotify_mark                   sys_fanotify_mark
339     common  prlimit64                       sys_prlimit64
340     common  name_to_handle_at               sys_name_to_handle_at
341     common  open_by_handle_at               sys_open_by_handle_at
342     common  clock_adjtime                   sys_clock_adjtime32
343     common  syncfs                          sys_syncfs
344     common  setns                           sys_setns
345     common  process_vm_readv                sys_process_vm_readv
346     common  process_vm_writev               sys_process_vm_writev
347     common  kcmp                            sys_kcmp
348     common  finit_module                    sys_finit_module
349     common  sched_setattr                   sys_sched_setattr
350     common  sched_getattr                   sys_sched_getattr
351     common  renameat2                       sys_renameat2
352     common  getrandom                       sys_getrandom
353     common  memfd_create                    sys_memfd_create
354     common  bpf                             sys_bpf
355     common  execveat                        sys_execveat
356     common  socket                          sys_socket
357     common  socketpair                      sys_socketpair
358     common  bind                            sys_bind
359     common  connect                         sys_connect
360     common  listen                          sys_listen
361     common  accept4                         sys_accept4
362     common  getsockopt                      sys_getsockopt
363     common  setsockopt                      sys_setsockopt
364     common  getsockname                     sys_getsockname
365     common  getpeername                     sys_getpeername
366     common  sendto                          sys_sendto
367     common  sendmsg                         sys_sendmsg
368     common  recvfrom                        sys_recvfrom
369     common  recvmsg                         sys_recvmsg
370     common  shutdown                        sys_shutdown
371     common  recvmmsg                        sys_recvmmsg_time32
372     common  sendmmsg                        sys_sendmmsg
373     common  userfaultfd                     sys_userfaultfd
374     common  membarrier                      sys_membarrier
375     common  mlock2                          sys_mlock2
376     common  copy_file_range                 sys_copy_file_range
377     common  preadv2                         sys_preadv2
378     common  pwritev2                        sys_pwritev2
379     common  statx                           sys_statx
380     common  seccomp                         sys_seccomp
381     common  pkey_mprotect                   sys_pkey_mprotect
382     common  pkey_alloc                      sys_pkey_alloc
383     common  pkey_free                       sys_pkey_free
384     common  rseq                            sys_rseq
# room for arch specific calls
393     common  semget                          sys_semget
394     common  semctl                          sys_semctl
395     common  shmget                          sys_shmget
396     common  shmctl                          sys_shmctl
397     common  shmat                           sys_shmat
398     common  shmdt                           sys_shmdt
399     common  msgget                          sys_msgget
400     common  msgsnd                          sys_msgsnd
401     common  msgrcv                          sys_msgrcv
402     common  msgctl                          sys_msgctl
403     common  clock_gettime64                 sys_clock_gettime
404     common  clock_settime64                 sys_clock_settime
405     common  clock_adjtime64                 sys_clock_adjtime
406     common  clock_getres_time64             sys_clock_getres
407     common  clock_nanosleep_time64          sys_clock_nanosleep
408     common  timer_gettime64                 sys_timer_gettime
409     common  timer_settime64                 sys_timer_settime
410     common  timerfd_gettime64               sys_timerfd_gettime
411     common  timerfd_settime64               sys_timerfd_settime
412     common  utimensat_time64                sys_utimensat
413     common  pselect6_time64                 sys_pselect6
414     common  ppoll_time64                    sys_ppoll
416     common  io_pgetevents_time64            sys_io_pgetevents
417     common  recvmmsg_time64                 sys_recvmmsg
418     common  mq_timedsend_time64             sys_mq_timedsend
419     common  mq_timedreceive_time64          sys_mq_timedreceive
420     common  semtimedop_time64               sys_semtimedop
421     common  rt_sigtimedwait_time64          sys_rt_sigtimedwait
422     common  futex_time64                    sys_futex
423     common  sched_rr_get_interval_time64    sys_sched_rr_get_interval
424     common  pidfd_send_signal               sys_pidfd_send_signal
425     common  io_uring_setup                  sys_io_uring_setup
426     common  io_uring_enter                  sys_io_uring_enter
427     common  io_uring_register               sys_io_uring_register
428     common  open_tree                       sys_open_tree
429     common  move_mount                      sys_move_mount
430     common  fsopen                          sys_fsopen
431     common  fsconfig                        sys_fsconfig
432     common  fsmount                         sys_fsmount
433     common  fspick                          sys_fspick
434     common  pidfd_open                      sys_pidfd_open
435     common  clone3                          __sys_clone3
436     common  close_range                     sys_close_range
437     common  openat2                         sys_openat2
438     common  pidfd_getfd                     sys_pidfd_getfd
439     common  faccessat2                      sys_faccessat2
440     common  process_madvise                 sys_process_madvise
441     common  epoll_pwait2                    sys_epoll_pwait2
442     common  mount_setattr                   sys_mount_setattr
443     common  quotactl_fd                     sys_quotactl_fd
444     common  landlock_create_ruleset         sys_landlock_create_ruleset
445     common  landlock_add_rule               sys_landlock_add_rule
446     common  landlock_restrict_self          sys_landlock_restrict_self
# 447 reserved for memfd_secret
448     common  process_mrelease                sys_process_mrelease
449     common  futex_waitv                     sys_futex_waitv
450     common  set_mempolicy_home_node         sys_set_mempolicy_home_node
"""


# alpha
# - arch/alpha/kernel/syscalls/syscall.tbl
alpha_syscall_tbl = """
# system call numbers and entry vectors for alpha
#
# The format is:
# <number> <abi> <name> <entry point>
#
# The <abi> is always "common" for this file
#
0       common  osf_syscall                     alpha_syscall_zero
1       common  exit                            sys_exit
2       common  fork                            alpha_fork
3       common  read                            sys_read
4       common  write                           sys_write
5       common  osf_old_open                    sys_ni_syscall
6       common  close                           sys_close
7       common  osf_wait4                       sys_osf_wait4
8       common  osf_old_creat                   sys_ni_syscall
9       common  link                            sys_link
10      common  unlink                          sys_unlink
11      common  osf_execve                      sys_ni_syscall
12      common  chdir                           sys_chdir
13      common  fchdir                          sys_fchdir
14      common  mknod                           sys_mknod
15      common  chmod                           sys_chmod
16      common  chown                           sys_chown
17      common  brk                             sys_osf_brk
18      common  osf_getfsstat                   sys_ni_syscall
19      common  lseek                           sys_lseek
20      common  getxpid                         sys_getxpid
21      common  osf_mount                       sys_osf_mount
22      common  umount2                         sys_umount
23      common  setuid                          sys_setuid
24      common  getxuid                         sys_getxuid
25      common  exec_with_loader                sys_ni_syscall
26      common  ptrace                          sys_ptrace
27      common  osf_nrecvmsg                    sys_ni_syscall
28      common  osf_nsendmsg                    sys_ni_syscall
29      common  osf_nrecvfrom                   sys_ni_syscall
30      common  osf_naccept                     sys_ni_syscall
31      common  osf_ngetpeername                sys_ni_syscall
32      common  osf_ngetsockname                sys_ni_syscall
33      common  access                          sys_access
34      common  osf_chflags                     sys_ni_syscall
35      common  osf_fchflags                    sys_ni_syscall
36      common  sync                            sys_sync
37      common  kill                            sys_kill
38      common  osf_old_stat                    sys_ni_syscall
39      common  setpgid                         sys_setpgid
40      common  osf_old_lstat                   sys_ni_syscall
41      common  dup                             sys_dup
42      common  pipe                            sys_alpha_pipe
43      common  osf_set_program_attributes      sys_osf_set_program_attributes
44      common  osf_profil                      sys_ni_syscall
45      common  open                            sys_open
46      common  osf_old_sigaction               sys_ni_syscall
47      common  getxgid                         sys_getxgid
48      common  osf_sigprocmask                 sys_osf_sigprocmask
49      common  osf_getlogin                    sys_ni_syscall
50      common  osf_setlogin                    sys_ni_syscall
51      common  acct                            sys_acct
52      common  sigpending                      sys_sigpending
54      common  ioctl                           sys_ioctl
55      common  osf_reboot                      sys_ni_syscall
56      common  osf_revoke                      sys_ni_syscall
57      common  symlink                         sys_symlink
58      common  readlink                        sys_readlink
59      common  execve                          sys_execve
60      common  umask                           sys_umask
61      common  chroot                          sys_chroot
62      common  osf_old_fstat                   sys_ni_syscall
63      common  getpgrp                         sys_getpgrp
64      common  getpagesize                     sys_getpagesize
65      common  osf_mremap                      sys_ni_syscall
66      common  vfork                           alpha_vfork
67      common  stat                            sys_newstat
68      common  lstat                           sys_newlstat
69      common  osf_sbrk                        sys_ni_syscall
70      common  osf_sstk                        sys_ni_syscall
71      common  mmap                            sys_osf_mmap
72      common  osf_old_vadvise                 sys_ni_syscall
73      common  munmap                          sys_munmap
74      common  mprotect                        sys_mprotect
75      common  madvise                         sys_madvise
76      common  vhangup                         sys_vhangup
77      common  osf_kmodcall                    sys_ni_syscall
78      common  osf_mincore                     sys_ni_syscall
79      common  getgroups                       sys_getgroups
80      common  setgroups                       sys_setgroups
81      common  osf_old_getpgrp                 sys_ni_syscall
82      common  setpgrp                         sys_setpgid
83      common  osf_setitimer                   compat_sys_setitimer
84      common  osf_old_wait                    sys_ni_syscall
85      common  osf_table                       sys_ni_syscall
86      common  osf_getitimer                   compat_sys_getitimer
87      common  gethostname                     sys_gethostname
88      common  sethostname                     sys_sethostname
89      common  getdtablesize                   sys_getdtablesize
90      common  dup2                            sys_dup2
91      common  fstat                           sys_newfstat
92      common  fcntl                           sys_fcntl
93      common  osf_select                      sys_osf_select
94      common  poll                            sys_poll
95      common  fsync                           sys_fsync
96      common  setpriority                     sys_setpriority
97      common  socket                          sys_socket
98      common  connect                         sys_connect
99      common  accept                          sys_accept
100     common  getpriority                     sys_osf_getpriority
101     common  send                            sys_send
102     common  recv                            sys_recv
103     common  sigreturn                       sys_sigreturn
104     common  bind                            sys_bind
105     common  setsockopt                      sys_setsockopt
106     common  listen                          sys_listen
107     common  osf_plock                       sys_ni_syscall
108     common  osf_old_sigvec                  sys_ni_syscall
109     common  osf_old_sigblock                sys_ni_syscall
110     common  osf_old_sigsetmask              sys_ni_syscall
111     common  sigsuspend                      sys_sigsuspend
112     common  osf_sigstack                    sys_osf_sigstack
113     common  recvmsg                         sys_recvmsg
114     common  sendmsg                         sys_sendmsg
115     common  osf_old_vtrace                  sys_ni_syscall
116     common  osf_gettimeofday                sys_osf_gettimeofday
117     common  osf_getrusage                   sys_osf_getrusage
118     common  getsockopt                      sys_getsockopt
120     common  readv                           sys_osf_readv
121     common  writev                          sys_osf_writev
122     common  osf_settimeofday                sys_osf_settimeofday
123     common  fchown                          sys_fchown
124     common  fchmod                          sys_fchmod
125     common  recvfrom                        sys_recvfrom
126     common  setreuid                        sys_setreuid
127     common  setregid                        sys_setregid
128     common  rename                          sys_rename
129     common  truncate                        sys_truncate
130     common  ftruncate                       sys_ftruncate
131     common  flock                           sys_flock
132     common  setgid                          sys_setgid
133     common  sendto                          sys_sendto
134     common  shutdown                        sys_shutdown
135     common  socketpair                      sys_socketpair
136     common  mkdir                           sys_mkdir
137     common  rmdir                           sys_rmdir
138     common  osf_utimes                      sys_osf_utimes
139     common  osf_old_sigreturn               sys_ni_syscall
140     common  osf_adjtime                     sys_ni_syscall
141     common  getpeername                     sys_getpeername
142     common  osf_gethostid                   sys_ni_syscall
143     common  osf_sethostid                   sys_ni_syscall
144     common  getrlimit                       sys_getrlimit
145     common  setrlimit                       sys_setrlimit
146     common  osf_old_killpg                  sys_ni_syscall
147     common  setsid                          sys_setsid
148     common  quotactl                        sys_quotactl
149     common  osf_oldquota                    sys_ni_syscall
150     common  getsockname                     sys_getsockname
153     common  osf_pid_block                   sys_ni_syscall
154     common  osf_pid_unblock                 sys_ni_syscall
156     common  sigaction                       sys_osf_sigaction
157     common  osf_sigwaitprim                 sys_ni_syscall
158     common  osf_nfssvc                      sys_ni_syscall
159     common  osf_getdirentries               sys_osf_getdirentries
160     common  osf_statfs                      sys_osf_statfs
161     common  osf_fstatfs                     sys_osf_fstatfs
163     common  osf_asynch_daemon               sys_ni_syscall
164     common  osf_getfh                       sys_ni_syscall
165     common  osf_getdomainname               sys_osf_getdomainname
166     common  setdomainname                   sys_setdomainname
169     common  osf_exportfs                    sys_ni_syscall
181     common  osf_alt_plock                   sys_ni_syscall
184     common  osf_getmnt                      sys_ni_syscall
187     common  osf_alt_sigpending              sys_ni_syscall
188     common  osf_alt_setsid                  sys_ni_syscall
199     common  osf_swapon                      sys_swapon
200     common  msgctl                          sys_old_msgctl
201     common  msgget                          sys_msgget
202     common  msgrcv                          sys_msgrcv
203     common  msgsnd                          sys_msgsnd
204     common  semctl                          sys_old_semctl
205     common  semget                          sys_semget
206     common  semop                           sys_semop
207     common  osf_utsname                     sys_osf_utsname
208     common  lchown                          sys_lchown
209     common  shmat                           sys_shmat
210     common  shmctl                          sys_old_shmctl
211     common  shmdt                           sys_shmdt
212     common  shmget                          sys_shmget
213     common  osf_mvalid                      sys_ni_syscall
214     common  osf_getaddressconf              sys_ni_syscall
215     common  osf_msleep                      sys_ni_syscall
216     common  osf_mwakeup                     sys_ni_syscall
217     common  msync                           sys_msync
218     common  osf_signal                      sys_ni_syscall
219     common  osf_utc_gettime                 sys_ni_syscall
220     common  osf_utc_adjtime                 sys_ni_syscall
222     common  osf_security                    sys_ni_syscall
223     common  osf_kloadcall                   sys_ni_syscall
224     common  osf_stat                        sys_osf_stat
225     common  osf_lstat                       sys_osf_lstat
226     common  osf_fstat                       sys_osf_fstat
227     common  osf_statfs64                    sys_osf_statfs64
228     common  osf_fstatfs64                   sys_osf_fstatfs64
233     common  getpgid                         sys_getpgid
234     common  getsid                          sys_getsid
235     common  sigaltstack                     sys_sigaltstack
236     common  osf_waitid                      sys_ni_syscall
237     common  osf_priocntlset                 sys_ni_syscall
238     common  osf_sigsendset                  sys_ni_syscall
239     common  osf_set_speculative             sys_ni_syscall
240     common  osf_msfs_syscall                sys_ni_syscall
241     common  osf_sysinfo                     sys_osf_sysinfo
242     common  osf_uadmin                      sys_ni_syscall
243     common  osf_fuser                       sys_ni_syscall
244     common  osf_proplist_syscall            sys_osf_proplist_syscall
245     common  osf_ntp_adjtime                 sys_ni_syscall
246     common  osf_ntp_gettime                 sys_ni_syscall
247     common  osf_pathconf                    sys_ni_syscall
248     common  osf_fpathconf                   sys_ni_syscall
250     common  osf_uswitch                     sys_ni_syscall
251     common  osf_usleep_thread               sys_osf_usleep_thread
252     common  osf_audcntl                     sys_ni_syscall
253     common  osf_audgen                      sys_ni_syscall
254     common  sysfs                           sys_sysfs
255     common  osf_subsys_info                 sys_ni_syscall
256     common  osf_getsysinfo                  sys_osf_getsysinfo
257     common  osf_setsysinfo                  sys_osf_setsysinfo
258     common  osf_afs_syscall                 sys_ni_syscall
259     common  osf_swapctl                     sys_ni_syscall
260     common  osf_memcntl                     sys_ni_syscall
261     common  osf_fdatasync                   sys_ni_syscall
300     common  bdflush                         sys_ni_syscall
301     common  sethae                          sys_sethae
302     common  mount                           sys_mount
303     common  old_adjtimex                    sys_old_adjtimex
304     common  swapoff                         sys_swapoff
305     common  getdents                        sys_getdents
306     common  create_module                   sys_ni_syscall
307     common  init_module                     sys_init_module
308     common  delete_module                   sys_delete_module
309     common  get_kernel_syms                 sys_ni_syscall
310     common  syslog                          sys_syslog
311     common  reboot                          sys_reboot
312     common  clone                           alpha_clone
313     common  uselib                          sys_uselib
314     common  mlock                           sys_mlock
315     common  munlock                         sys_munlock
316     common  mlockall                        sys_mlockall
317     common  munlockall                      sys_munlockall
318     common  sysinfo                         sys_sysinfo
319     common  _sysctl                         sys_ni_syscall
# 320 was sys_idle
321     common  oldumount                       sys_oldumount
322     common  swapon                          sys_swapon
323     common  times                           sys_times
324     common  personality                     sys_personality
325     common  setfsuid                        sys_setfsuid
326     common  setfsgid                        sys_setfsgid
327     common  ustat                           sys_ustat
328     common  statfs                          sys_statfs
329     common  fstatfs                         sys_fstatfs
330     common  sched_setparam                  sys_sched_setparam
331     common  sched_getparam                  sys_sched_getparam
332     common  sched_setscheduler              sys_sched_setscheduler
333     common  sched_getscheduler              sys_sched_getscheduler
334     common  sched_yield                     sys_sched_yield
335     common  sched_get_priority_max          sys_sched_get_priority_max
336     common  sched_get_priority_min          sys_sched_get_priority_min
337     common  sched_rr_get_interval           sys_sched_rr_get_interval
338     common  afs_syscall                     sys_ni_syscall
339     common  uname                           sys_newuname
340     common  nanosleep                       sys_nanosleep
341     common  mremap                          sys_mremap
342     common  nfsservctl                      sys_ni_syscall
343     common  setresuid                       sys_setresuid
344     common  getresuid                       sys_getresuid
345     common  pciconfig_read                  sys_pciconfig_read
346     common  pciconfig_write                 sys_pciconfig_write
347     common  query_module                    sys_ni_syscall
348     common  prctl                           sys_prctl
349     common  pread64                         sys_pread64
350     common  pwrite64                        sys_pwrite64
351     common  rt_sigreturn                    sys_rt_sigreturn
352     common  rt_sigaction                    sys_rt_sigaction
353     common  rt_sigprocmask                  sys_rt_sigprocmask
354     common  rt_sigpending                   sys_rt_sigpending
355     common  rt_sigtimedwait                 sys_rt_sigtimedwait
356     common  rt_sigqueueinfo                 sys_rt_sigqueueinfo
357     common  rt_sigsuspend                   sys_rt_sigsuspend
358     common  select                          sys_select
359     common  gettimeofday                    sys_gettimeofday
360     common  settimeofday                    sys_settimeofday
361     common  getitimer                       sys_getitimer
362     common  setitimer                       sys_setitimer
363     common  utimes                          sys_utimes
364     common  getrusage                       sys_getrusage
365     common  wait4                           sys_wait4
366     common  adjtimex                        sys_adjtimex
367     common  getcwd                          sys_getcwd
368     common  capget                          sys_capget
369     common  capset                          sys_capset
370     common  sendfile                        sys_sendfile64
371     common  setresgid                       sys_setresgid
372     common  getresgid                       sys_getresgid
373     common  dipc                            sys_ni_syscall
374     common  pivot_root                      sys_pivot_root
375     common  mincore                         sys_mincore
376     common  pciconfig_iobase                sys_pciconfig_iobase
377     common  getdents64                      sys_getdents64
378     common  gettid                          sys_gettid
379     common  readahead                       sys_readahead
# 380 is unused
381     common  tkill                           sys_tkill
382     common  setxattr                        sys_setxattr
383     common  lsetxattr                       sys_lsetxattr
384     common  fsetxattr                       sys_fsetxattr
385     common  getxattr                        sys_getxattr
386     common  lgetxattr                       sys_lgetxattr
387     common  fgetxattr                       sys_fgetxattr
388     common  listxattr                       sys_listxattr
389     common  llistxattr                      sys_llistxattr
390     common  flistxattr                      sys_flistxattr
391     common  removexattr                     sys_removexattr
392     common  lremovexattr                    sys_lremovexattr
393     common  fremovexattr                    sys_fremovexattr
394     common  futex                           sys_futex
395     common  sched_setaffinity               sys_sched_setaffinity
396     common  sched_getaffinity               sys_sched_getaffinity
397     common  tuxcall                         sys_ni_syscall
398     common  io_setup                        sys_io_setup
399     common  io_destroy                      sys_io_destroy
400     common  io_getevents                    sys_io_getevents
401     common  io_submit                       sys_io_submit
402     common  io_cancel                       sys_io_cancel
405     common  exit_group                      sys_exit_group
406     common  lookup_dcookie                  sys_lookup_dcookie
407     common  epoll_create                    sys_epoll_create
408     common  epoll_ctl                       sys_epoll_ctl
409     common  epoll_wait                      sys_epoll_wait
410     common  remap_file_pages                sys_remap_file_pages
411     common  set_tid_address                 sys_set_tid_address
412     common  restart_syscall                 sys_restart_syscall
413     common  fadvise64                       sys_fadvise64
414     common  timer_create                    sys_timer_create
415     common  timer_settime                   sys_timer_settime
416     common  timer_gettime                   sys_timer_gettime
417     common  timer_getoverrun                sys_timer_getoverrun
418     common  timer_delete                    sys_timer_delete
419     common  clock_settime                   sys_clock_settime
420     common  clock_gettime                   sys_clock_gettime
421     common  clock_getres                    sys_clock_getres
422     common  clock_nanosleep                 sys_clock_nanosleep
423     common  semtimedop                      sys_semtimedop
424     common  tgkill                          sys_tgkill
425     common  stat64                          sys_stat64
426     common  lstat64                         sys_lstat64
427     common  fstat64                         sys_fstat64
428     common  vserver                         sys_ni_syscall
429     common  mbind                           sys_ni_syscall
430     common  get_mempolicy                   sys_ni_syscall
431     common  set_mempolicy                   sys_ni_syscall
432     common  mq_open                         sys_mq_open
433     common  mq_unlink                       sys_mq_unlink
434     common  mq_timedsend                    sys_mq_timedsend
435     common  mq_timedreceive                 sys_mq_timedreceive
436     common  mq_notify                       sys_mq_notify
437     common  mq_getsetattr                   sys_mq_getsetattr
438     common  waitid                          sys_waitid
439     common  add_key                         sys_add_key
440     common  request_key                     sys_request_key
441     common  keyctl                          sys_keyctl
442     common  ioprio_set                      sys_ioprio_set
443     common  ioprio_get                      sys_ioprio_get
444     common  inotify_init                    sys_inotify_init
445     common  inotify_add_watch               sys_inotify_add_watch
446     common  inotify_rm_watch                sys_inotify_rm_watch
447     common  fdatasync                       sys_fdatasync
448     common  kexec_load                      sys_kexec_load
449     common  migrate_pages                   sys_migrate_pages
450     common  openat                          sys_openat
451     common  mkdirat                         sys_mkdirat
452     common  mknodat                         sys_mknodat
453     common  fchownat                        sys_fchownat
454     common  futimesat                       sys_futimesat
455     common  fstatat64                       sys_fstatat64
456     common  unlinkat                        sys_unlinkat
457     common  renameat                        sys_renameat
458     common  linkat                          sys_linkat
459     common  symlinkat                       sys_symlinkat
460     common  readlinkat                      sys_readlinkat
461     common  fchmodat                        sys_fchmodat
462     common  faccessat                       sys_faccessat
463     common  pselect6                        sys_pselect6
464     common  ppoll                           sys_ppoll
465     common  unshare                         sys_unshare
466     common  set_robust_list                 sys_set_robust_list
467     common  get_robust_list                 sys_get_robust_list
468     common  splice                          sys_splice
469     common  sync_file_range                 sys_sync_file_range
470     common  tee                             sys_tee
471     common  vmsplice                        sys_vmsplice
472     common  move_pages                      sys_move_pages
473     common  getcpu                          sys_getcpu
474     common  epoll_pwait                     sys_epoll_pwait
475     common  utimensat                       sys_utimensat
476     common  signalfd                        sys_signalfd
477     common  timerfd                         sys_ni_syscall
478     common  eventfd                         sys_eventfd
479     common  recvmmsg                        sys_recvmmsg
480     common  fallocate                       sys_fallocate
481     common  timerfd_create                  sys_timerfd_create
482     common  timerfd_settime                 sys_timerfd_settime
483     common  timerfd_gettime                 sys_timerfd_gettime
484     common  signalfd4                       sys_signalfd4
485     common  eventfd2                        sys_eventfd2
486     common  epoll_create1                   sys_epoll_create1
487     common  dup3                            sys_dup3
488     common  pipe2                           sys_pipe2
489     common  inotify_init1                   sys_inotify_init1
490     common  preadv                          sys_preadv
491     common  pwritev                         sys_pwritev
492     common  rt_tgsigqueueinfo               sys_rt_tgsigqueueinfo
493     common  perf_event_open                 sys_perf_event_open
494     common  fanotify_init                   sys_fanotify_init
495     common  fanotify_mark                   sys_fanotify_mark
496     common  prlimit64                       sys_prlimit64
497     common  name_to_handle_at               sys_name_to_handle_at
498     common  open_by_handle_at               sys_open_by_handle_at
499     common  clock_adjtime                   sys_clock_adjtime
500     common  syncfs                          sys_syncfs
501     common  setns                           sys_setns
502     common  accept4                         sys_accept4
503     common  sendmmsg                        sys_sendmmsg
504     common  process_vm_readv                sys_process_vm_readv
505     common  process_vm_writev               sys_process_vm_writev
506     common  kcmp                            sys_kcmp
507     common  finit_module                    sys_finit_module
508     common  sched_setattr                   sys_sched_setattr
509     common  sched_getattr                   sys_sched_getattr
510     common  renameat2                       sys_renameat2
511     common  getrandom                       sys_getrandom
512     common  memfd_create                    sys_memfd_create
513     common  execveat                        sys_execveat
514     common  seccomp                         sys_seccomp
515     common  bpf                             sys_bpf
516     common  userfaultfd                     sys_userfaultfd
517     common  membarrier                      sys_membarrier
518     common  mlock2                          sys_mlock2
519     common  copy_file_range                 sys_copy_file_range
520     common  preadv2                         sys_preadv2
521     common  pwritev2                        sys_pwritev2
522     common  statx                           sys_statx
523     common  io_pgetevents                   sys_io_pgetevents
524     common  pkey_mprotect                   sys_pkey_mprotect
525     common  pkey_alloc                      sys_pkey_alloc
526     common  pkey_free                       sys_pkey_free
527     common  rseq                            sys_rseq
528     common  statfs64                        sys_statfs64
529     common  fstatfs64                       sys_fstatfs64
530     common  getegid                         sys_getegid
531     common  geteuid                         sys_geteuid
532     common  getppid                         sys_getppid
# all other architectures have common numbers for new syscall, alpha
# is the exception.
534     common  pidfd_send_signal               sys_pidfd_send_signal
535     common  io_uring_setup                  sys_io_uring_setup
536     common  io_uring_enter                  sys_io_uring_enter
537     common  io_uring_register               sys_io_uring_register
538     common  open_tree                       sys_open_tree
539     common  move_mount                      sys_move_mount
540     common  fsopen                          sys_fsopen
541     common  fsconfig                        sys_fsconfig
542     common  fsmount                         sys_fsmount
543     common  fspick                          sys_fspick
544     common  pidfd_open                      sys_pidfd_open
# 545 reserved for clone3
546     common  close_range                     sys_close_range
547     common  openat2                         sys_openat2
548     common  pidfd_getfd                     sys_pidfd_getfd
549     common  faccessat2                      sys_faccessat2
550     common  process_madvise                 sys_process_madvise
551     common  epoll_pwait2                    sys_epoll_pwait2
552     common  mount_setattr                   sys_mount_setattr
553     common  quotactl_fd                     sys_quotactl_fd
554     common  landlock_create_ruleset         sys_landlock_create_ruleset
555     common  landlock_add_rule               sys_landlock_add_rule
556     common  landlock_restrict_self          sys_landlock_restrict_self
# 557 reserved for memfd_secret
558     common  process_mrelease                sys_process_mrelease
559     common  futex_waitv                     sys_futex_waitv
560     common  set_mempolicy_home_node         sys_ni_syscall
"""


# HPPA
# - arch/parisc/kernel/syscalls/syscall.tbl
hppa_syscall_tbl = """
# system call numbers and entry vectors for parisc
#
# The format is:
# <number> <abi> <name> <entry point> <compat entry point>
#
# The <abi> can be common, 64, or 32 for this file.
#
0       common  restart_syscall         sys_restart_syscall
1       common  exit                    sys_exit
2       common  fork                    sys_fork_wrapper
3       common  read                    sys_read
4       common  write                   sys_write
5       common  open                    sys_open                        compat_sys_open
6       common  close                   sys_close
7       common  waitpid                 sys_waitpid
8       common  creat                   sys_creat
9       common  link                    sys_link
10      common  unlink                  sys_unlink
11      common  execve                  sys_execve                      compat_sys_execve
12      common  chdir                   sys_chdir
13      32      time                    sys_time32
13      64      time                    sys_time
14      common  mknod                   sys_mknod
15      common  chmod                   sys_chmod
16      common  lchown                  sys_lchown
17      common  socket                  sys_socket
18      common  stat                    sys_newstat                     compat_sys_newstat
19      common  lseek                   sys_lseek                       compat_sys_lseek
20      common  getpid                  sys_getpid
21      common  mount                   sys_mount
22      common  bind                    sys_bind
23      common  setuid                  sys_setuid
24      common  getuid                  sys_getuid
25      32      stime                   sys_stime32
25      64      stime                   sys_stime
26      common  ptrace                  sys_ptrace                      compat_sys_ptrace
27      common  alarm                   sys_alarm
28      common  fstat                   sys_newfstat                    compat_sys_newfstat
29      common  pause                   sys_pause
30      32      utime                   sys_utime32
30      64      utime                   sys_utime
31      common  connect                 sys_connect
32      common  listen                  sys_listen
33      common  access                  sys_access
34      common  nice                    sys_nice
35      common  accept                  sys_accept
36      common  sync                    sys_sync
37      common  kill                    sys_kill
38      common  rename                  sys_rename
39      common  mkdir                   sys_mkdir
40      common  rmdir                   sys_rmdir
41      common  dup                     sys_dup
42      common  pipe                    sys_pipe
43      common  times                   sys_times                       compat_sys_times
44      common  getsockname             sys_getsockname
45      common  brk                     sys_brk
46      common  setgid                  sys_setgid
47      common  getgid                  sys_getgid
48      common  signal                  sys_signal
49      common  geteuid                 sys_geteuid
50      common  getegid                 sys_getegid
51      common  acct                    sys_acct
52      common  umount2                 sys_umount
53      common  getpeername             sys_getpeername
54      common  ioctl                   sys_ioctl                       compat_sys_ioctl
55      common  fcntl                   sys_fcntl                       compat_sys_fcntl
56      common  socketpair              sys_socketpair
57      common  setpgid                 sys_setpgid
58      common  send                    sys_send
59      common  uname                   sys_newuname
60      common  umask                   sys_umask
61      common  chroot                  sys_chroot
62      common  ustat                   sys_ustat                       compat_sys_ustat
63      common  dup2                    sys_dup2
64      common  getppid                 sys_getppid
65      common  getpgrp                 sys_getpgrp
66      common  setsid                  sys_setsid
67      common  pivot_root              sys_pivot_root
68      common  sgetmask                sys_sgetmask                    sys32_unimplemented
69      common  ssetmask                sys_ssetmask                    sys32_unimplemented
70      common  setreuid                sys_setreuid
71      common  setregid                sys_setregid
72      common  mincore                 sys_mincore
73      common  sigpending              sys_sigpending                  compat_sys_sigpending
74      common  sethostname             sys_sethostname
75      common  setrlimit               sys_setrlimit                   compat_sys_setrlimit
76      common  getrlimit               sys_getrlimit                   compat_sys_getrlimit
77      common  getrusage               sys_getrusage                   compat_sys_getrusage
78      common  gettimeofday            sys_gettimeofday                compat_sys_gettimeofday
79      common  settimeofday            sys_settimeofday                compat_sys_settimeofday
80      common  getgroups               sys_getgroups
81      common  setgroups               sys_setgroups
82      common  sendto                  sys_sendto
83      common  symlink                 sys_symlink
84      common  lstat                   sys_newlstat                    compat_sys_newlstat
85      common  readlink                sys_readlink
86      common  uselib                  sys_ni_syscall
87      common  swapon                  sys_swapon
88      common  reboot                  sys_reboot
89      common  mmap2                   sys_mmap2
90      common  mmap                    sys_mmap
91      common  munmap                  sys_munmap
92      common  truncate                sys_truncate                    compat_sys_truncate
93      common  ftruncate               sys_ftruncate                   compat_sys_ftruncate
94      common  fchmod                  sys_fchmod
95      common  fchown                  sys_fchown
96      common  getpriority             sys_getpriority
97      common  setpriority             sys_setpriority
98      common  recv                    sys_recv
99      common  statfs                  sys_statfs                      compat_sys_statfs
100     common  fstatfs                 sys_fstatfs                     compat_sys_fstatfs
101     common  stat64                  sys_stat64
# 102 was socketcall
103     common  syslog                  sys_syslog
104     common  setitimer               sys_setitimer                   compat_sys_setitimer
105     common  getitimer               sys_getitimer                   compat_sys_getitimer
106     common  capget                  sys_capget
107     common  capset                  sys_capset
108     32      pread64                 parisc_pread64
108     64      pread64                 sys_pread64
109     32      pwrite64                parisc_pwrite64
109     64      pwrite64                sys_pwrite64
110     common  getcwd                  sys_getcwd
111     common  vhangup                 sys_vhangup
112     common  fstat64                 sys_fstat64
113     common  vfork                   sys_vfork_wrapper
114     common  wait4                   sys_wait4                       compat_sys_wait4
115     common  swapoff                 sys_swapoff
116     common  sysinfo                 sys_sysinfo                     compat_sys_sysinfo
117     common  shutdown                sys_shutdown
118     common  fsync                   sys_fsync
119     common  madvise                 sys_madvise
120     common  clone                   sys_clone_wrapper
121     common  setdomainname           sys_setdomainname
122     common  sendfile                sys_sendfile                    compat_sys_sendfile
123     common  recvfrom                sys_recvfrom
124     32      adjtimex                sys_adjtimex_time32
124     64      adjtimex                sys_adjtimex
125     common  mprotect                sys_mprotect
126     common  sigprocmask             sys_sigprocmask                 compat_sys_sigprocmask
# 127 was create_module
128     common  init_module             sys_init_module
129     common  delete_module           sys_delete_module
# 130 was get_kernel_syms
131     common  quotactl                sys_quotactl
132     common  getpgid                 sys_getpgid
133     common  fchdir                  sys_fchdir
134     common  bdflush                 sys_ni_syscall
135     common  sysfs                   sys_sysfs
136     32      personality             parisc_personality
136     64      personality             sys_personality
# 137 was afs_syscall
138     common  setfsuid                sys_setfsuid
139     common  setfsgid                sys_setfsgid
140     common  _llseek                 sys_llseek
141     common  getdents                sys_getdents                    compat_sys_getdents
142     common  _newselect              sys_select                      compat_sys_select
143     common  flock                   sys_flock
144     common  msync                   sys_msync
145     common  readv                   sys_readv
146     common  writev                  sys_writev
147     common  getsid                  sys_getsid
148     common  fdatasync               sys_fdatasync
149     common  _sysctl                 sys_ni_syscall
150     common  mlock                   sys_mlock
151     common  munlock                 sys_munlock
152     common  mlockall                sys_mlockall
153     common  munlockall              sys_munlockall
154     common  sched_setparam          sys_sched_setparam
155     common  sched_getparam          sys_sched_getparam
156     common  sched_setscheduler      sys_sched_setscheduler
157     common  sched_getscheduler      sys_sched_getscheduler
158     common  sched_yield             sys_sched_yield
159     common  sched_get_priority_max  sys_sched_get_priority_max
160     common  sched_get_priority_min  sys_sched_get_priority_min
161     32      sched_rr_get_interval   sys_sched_rr_get_interval_time32
161     64      sched_rr_get_interval   sys_sched_rr_get_interval
162     32      nanosleep               sys_nanosleep_time32
162     64      nanosleep               sys_nanosleep
163     common  mremap                  sys_mremap
164     common  setresuid               sys_setresuid
165     common  getresuid               sys_getresuid
166     common  sigaltstack             sys_sigaltstack                 compat_sys_sigaltstack
# 167 was query_module
168     common  poll                    sys_poll
# 169 was nfsservctl
170     common  setresgid               sys_setresgid
171     common  getresgid               sys_getresgid
172     common  prctl                   sys_prctl
173     common  rt_sigreturn            sys_rt_sigreturn_wrapper
174     common  rt_sigaction            sys_rt_sigaction                compat_sys_rt_sigaction
175     common  rt_sigprocmask          sys_rt_sigprocmask              compat_sys_rt_sigprocmask
176     common  rt_sigpending           sys_rt_sigpending               compat_sys_rt_sigpending
177     32      rt_sigtimedwait         sys_rt_sigtimedwait_time32      compat_sys_rt_sigtimedwait_time32
177     64      rt_sigtimedwait         sys_rt_sigtimedwait
178     common  rt_sigqueueinfo         sys_rt_sigqueueinfo             compat_sys_rt_sigqueueinfo
179     common  rt_sigsuspend           sys_rt_sigsuspend               compat_sys_rt_sigsuspend
180     common  chown                   sys_chown
181     common  setsockopt              sys_setsockopt                  sys_setsockopt
182     common  getsockopt              sys_getsockopt                  sys_getsockopt
183     common  sendmsg                 sys_sendmsg                     compat_sys_sendmsg
184     common  recvmsg                 sys_recvmsg                     compat_sys_recvmsg
185     common  semop                   sys_semop
186     common  semget                  sys_semget
187     common  semctl                  sys_semctl                      compat_sys_semctl
188     common  msgsnd                  sys_msgsnd                      compat_sys_msgsnd
189     common  msgrcv                  sys_msgrcv                      compat_sys_msgrcv
190     common  msgget                  sys_msgget
191     common  msgctl                  sys_msgctl                      compat_sys_msgctl
192     common  shmat                   sys_shmat                       compat_sys_shmat
193     common  shmdt                   sys_shmdt
194     common  shmget                  sys_shmget
195     common  shmctl                  sys_shmctl                      compat_sys_shmctl
# 196 was getpmsg
# 197 was putpmsg
198     common  lstat64                 sys_lstat64
199     32      truncate64              parisc_truncate64
199     64      truncate64              sys_truncate64
200     32      ftruncate64             parisc_ftruncate64
200     64      ftruncate64             sys_ftruncate64
201     common  getdents64              sys_getdents64
202     common  fcntl64                 sys_fcntl64                     compat_sys_fcntl64
# 203 was attrctl
# 204 was acl_get
# 205 was acl_set
206     common  gettid                  sys_gettid
207     32      readahead               parisc_readahead
207     64      readahead               sys_readahead
208     common  tkill                   sys_tkill
209     common  sendfile64              sys_sendfile64                  compat_sys_sendfile64
210     32      futex                   sys_futex_time32
210     64      futex                   sys_futex
211     common  sched_setaffinity       sys_sched_setaffinity           compat_sys_sched_setaffinity
212     common  sched_getaffinity       sys_sched_getaffinity           compat_sys_sched_getaffinity
# 213 was set_thread_area
# 214 was get_thread_area
215     common  io_setup                sys_io_setup                    compat_sys_io_setup
216     common  io_destroy              sys_io_destroy
217     32      io_getevents            sys_io_getevents_time32
217     64      io_getevents            sys_io_getevents
218     common  io_submit               sys_io_submit                   compat_sys_io_submit
219     common  io_cancel               sys_io_cancel
# 220 was alloc_hugepages
# 221 was free_hugepages
222     common  exit_group              sys_exit_group
223     common  lookup_dcookie          sys_lookup_dcookie              compat_sys_lookup_dcookie
224     common  epoll_create            sys_epoll_create
225     common  epoll_ctl               sys_epoll_ctl
226     common  epoll_wait              sys_epoll_wait
227     common  remap_file_pages        sys_remap_file_pages
228     32      semtimedop              sys_semtimedop_time32
228     64      semtimedop              sys_semtimedop
229     common  mq_open                 sys_mq_open                     compat_sys_mq_open
230     common  mq_unlink               sys_mq_unlink
231     32      mq_timedsend            sys_mq_timedsend_time32
231     64      mq_timedsend            sys_mq_timedsend
232     32      mq_timedreceive         sys_mq_timedreceive_time32
232     64      mq_timedreceive         sys_mq_timedreceive
233     common  mq_notify               sys_mq_notify                   compat_sys_mq_notify
234     common  mq_getsetattr           sys_mq_getsetattr               compat_sys_mq_getsetattr
235     common  waitid                  sys_waitid                      compat_sys_waitid
236     32      fadvise64_64            parisc_fadvise64_64
236     64      fadvise64_64            sys_fadvise64_64
237     common  set_tid_address         sys_set_tid_address
238     common  setxattr                sys_setxattr
239     common  lsetxattr               sys_lsetxattr
240     common  fsetxattr               sys_fsetxattr
241     common  getxattr                sys_getxattr
242     common  lgetxattr               sys_lgetxattr
243     common  fgetxattr               sys_fgetxattr
244     common  listxattr               sys_listxattr
245     common  llistxattr              sys_llistxattr
246     common  flistxattr              sys_flistxattr
247     common  removexattr             sys_removexattr
248     common  lremovexattr            sys_lremovexattr
249     common  fremovexattr            sys_fremovexattr
250     common  timer_create            sys_timer_create                compat_sys_timer_create
251     32      timer_settime           sys_timer_settime32
251     64      timer_settime           sys_timer_settime
252     32      timer_gettime           sys_timer_gettime32
252     64      timer_gettime           sys_timer_gettime
253     common  timer_getoverrun        sys_timer_getoverrun
254     common  timer_delete            sys_timer_delete
255     32      clock_settime           sys_clock_settime32
255     64      clock_settime           sys_clock_settime
256     32      clock_gettime           sys_clock_gettime32
256     64      clock_gettime           sys_clock_gettime
257     32      clock_getres            sys_clock_getres_time32
257     64      clock_getres            sys_clock_getres
258     32      clock_nanosleep         sys_clock_nanosleep_time32
258     64      clock_nanosleep         sys_clock_nanosleep
259     common  tgkill                  sys_tgkill
260     common  mbind                   sys_mbind
261     common  get_mempolicy           sys_get_mempolicy
262     common  set_mempolicy           sys_set_mempolicy
# 263 was vserver
264     common  add_key                 sys_add_key
265     common  request_key             sys_request_key
266     common  keyctl                  sys_keyctl                      compat_sys_keyctl
267     common  ioprio_set              sys_ioprio_set
268     common  ioprio_get              sys_ioprio_get
269     common  inotify_init            sys_inotify_init
270     common  inotify_add_watch       sys_inotify_add_watch
271     common  inotify_rm_watch        sys_inotify_rm_watch
272     common  migrate_pages           sys_migrate_pages
273     32      pselect6                sys_pselect6_time32             compat_sys_pselect6_time32
273     64      pselect6                sys_pselect6
274     32      ppoll                   sys_ppoll_time32                compat_sys_ppoll_time32
274     64      ppoll                   sys_ppoll
275     common  openat                  sys_openat                      compat_sys_openat
276     common  mkdirat                 sys_mkdirat
277     common  mknodat                 sys_mknodat
278     common  fchownat                sys_fchownat
279     32      futimesat               sys_futimesat_time32
279     64      futimesat               sys_futimesat
280     common  fstatat64               sys_fstatat64
281     common  unlinkat                sys_unlinkat
282     common  renameat                sys_renameat
283     common  linkat                  sys_linkat
284     common  symlinkat               sys_symlinkat
285     common  readlinkat              sys_readlinkat
286     common  fchmodat                sys_fchmodat
287     common  faccessat               sys_faccessat
288     common  unshare                 sys_unshare
289     common  set_robust_list         sys_set_robust_list             compat_sys_set_robust_list
290     common  get_robust_list         sys_get_robust_list             compat_sys_get_robust_list
291     common  splice                  sys_splice
292     32      sync_file_range         parisc_sync_file_range
292     64      sync_file_range         sys_sync_file_range
293     common  tee                     sys_tee
294     common  vmsplice                sys_vmsplice
295     common  move_pages              sys_move_pages
296     common  getcpu                  sys_getcpu
297     common  epoll_pwait             sys_epoll_pwait                 compat_sys_epoll_pwait
298     common  statfs64                sys_statfs64                    compat_sys_statfs64
299     common  fstatfs64               sys_fstatfs64                   compat_sys_fstatfs64
300     common  kexec_load              sys_kexec_load                  compat_sys_kexec_load
301     32      utimensat               sys_utimensat_time32
301     64      utimensat               sys_utimensat
302     common  signalfd                sys_signalfd                    compat_sys_signalfd
# 303 was timerfd
304     common  eventfd                 sys_eventfd
305     32      fallocate               parisc_fallocate
305     64      fallocate               sys_fallocate
306     common  timerfd_create          parisc_timerfd_create
307     32      timerfd_settime         sys_timerfd_settime32
307     64      timerfd_settime         sys_timerfd_settime
308     32      timerfd_gettime         sys_timerfd_gettime32
308     64      timerfd_gettime         sys_timerfd_gettime
309     common  signalfd4               parisc_signalfd4                parisc_compat_signalfd4
310     common  eventfd2                parisc_eventfd2
311     common  epoll_create1           sys_epoll_create1
312     common  dup3                    sys_dup3
313     common  pipe2                   parisc_pipe2
314     common  inotify_init1           parisc_inotify_init1
315     common  preadv  sys_preadv      compat_sys_preadv
316     common  pwritev sys_pwritev     compat_sys_pwritev
317     common  rt_tgsigqueueinfo       sys_rt_tgsigqueueinfo           compat_sys_rt_tgsigqueueinfo
318     common  perf_event_open         sys_perf_event_open
319     32      recvmmsg                sys_recvmmsg_time32             compat_sys_recvmmsg_time32
319     64      recvmmsg                sys_recvmmsg
320     common  accept4                 sys_accept4
321     common  prlimit64               sys_prlimit64
322     common  fanotify_init           sys_fanotify_init
323     common  fanotify_mark           sys_fanotify_mark               sys32_fanotify_mark
324     32      clock_adjtime           sys_clock_adjtime32
324     64      clock_adjtime           sys_clock_adjtime
325     common  name_to_handle_at       sys_name_to_handle_at
326     common  open_by_handle_at       sys_open_by_handle_at           compat_sys_open_by_handle_at
327     common  syncfs                  sys_syncfs
328     common  setns                   sys_setns
329     common  sendmmsg                sys_sendmmsg                    compat_sys_sendmmsg
330     common  process_vm_readv        sys_process_vm_readv
331     common  process_vm_writev       sys_process_vm_writev
332     common  kcmp                    sys_kcmp
333     common  finit_module            sys_finit_module
334     common  sched_setattr           sys_sched_setattr
335     common  sched_getattr           sys_sched_getattr
336     32      utimes                  sys_utimes_time32
336     64      utimes                  sys_utimes
337     common  renameat2               sys_renameat2
338     common  seccomp                 sys_seccomp
339     common  getrandom               sys_getrandom
340     common  memfd_create            sys_memfd_create
341     common  bpf                     sys_bpf
342     common  execveat                sys_execveat                    compat_sys_execveat
343     common  membarrier              sys_membarrier
344     common  userfaultfd             parisc_userfaultfd
345     common  mlock2                  sys_mlock2
346     common  copy_file_range         sys_copy_file_range
347     common  preadv2                 sys_preadv2                     compat_sys_preadv2
348     common  pwritev2                sys_pwritev2                    compat_sys_pwritev2
349     common  statx                   sys_statx
350     32      io_pgetevents           sys_io_pgetevents_time32        compat_sys_io_pgetevents
350     64      io_pgetevents           sys_io_pgetevents
351     common  pkey_mprotect           sys_pkey_mprotect
352     common  pkey_alloc              sys_pkey_alloc
353     common  pkey_free               sys_pkey_free
354     common  rseq                    sys_rseq
355     common  kexec_file_load         sys_kexec_file_load             sys_kexec_file_load
# up to 402 is unassigned and reserved for arch specific syscalls
403     32      clock_gettime64                 sys_clock_gettime               sys_clock_gettime
404     32      clock_settime64                 sys_clock_settime               sys_clock_settime
405     32      clock_adjtime64                 sys_clock_adjtime               sys_clock_adjtime
406     32      clock_getres_time64             sys_clock_getres                sys_clock_getres
407     32      clock_nanosleep_time64          sys_clock_nanosleep             sys_clock_nanosleep
408     32      timer_gettime64                 sys_timer_gettime               sys_timer_gettime
409     32      timer_settime64                 sys_timer_settime               sys_timer_settime
410     32      timerfd_gettime64               sys_timerfd_gettime             sys_timerfd_gettime
411     32      timerfd_settime64               sys_timerfd_settime             sys_timerfd_settime
412     32      utimensat_time64                sys_utimensat                   sys_utimensat
413     32      pselect6_time64                 sys_pselect6                    compat_sys_pselect6_time64
414     32      ppoll_time64                    sys_ppoll                       compat_sys_ppoll_time64
416     32      io_pgetevents_time64            sys_io_pgetevents               compat_sys_io_pgetevents_time64
417     32      recvmmsg_time64                 sys_recvmmsg                    compat_sys_recvmmsg_time64
418     32      mq_timedsend_time64             sys_mq_timedsend                sys_mq_timedsend
419     32      mq_timedreceive_time64          sys_mq_timedreceive             sys_mq_timedreceive
420     32      semtimedop_time64               sys_semtimedop                  sys_semtimedop
421     32      rt_sigtimedwait_time64          sys_rt_sigtimedwait             compat_sys_rt_sigtimedwait_time64
422     32      futex_time64                    sys_futex                       sys_futex
423     32      sched_rr_get_interval_time64    sys_sched_rr_get_interval       sys_sched_rr_get_interval
424     common  pidfd_send_signal               sys_pidfd_send_signal
425     common  io_uring_setup                  sys_io_uring_setup
426     common  io_uring_enter                  sys_io_uring_enter
427     common  io_uring_register               sys_io_uring_register
428     common  open_tree                       sys_open_tree
429     common  move_mount                      sys_move_mount
430     common  fsopen                          sys_fsopen
431     common  fsconfig                        sys_fsconfig
432     common  fsmount                         sys_fsmount
433     common  fspick                          sys_fspick
434     common  pidfd_open                      sys_pidfd_open
435     common  clone3                          sys_clone3_wrapper
436     common  close_range                     sys_close_range
437     common  openat2                         sys_openat2
438     common  pidfd_getfd                     sys_pidfd_getfd
439     common  faccessat2                      sys_faccessat2
440     common  process_madvise                 sys_process_madvise
441     common  epoll_pwait2                    sys_epoll_pwait2                compat_sys_epoll_pwait2
442     common  mount_setattr                   sys_mount_setattr
443     common  quotactl_fd                     sys_quotactl_fd
444     common  landlock_create_ruleset         sys_landlock_create_ruleset
445     common  landlock_add_rule               sys_landlock_add_rule
446     common  landlock_restrict_self          sys_landlock_restrict_self
# 447 reserved for memfd_secret
448     common  process_mrelease                sys_process_mrelease
449     common  futex_waitv                     sys_futex_waitv
450     common  set_mempolicy_home_node         sys_set_mempolicy_home_node
"""


# OpenRISC
#
# [How to make]
# cd /path/to/linux-6.*/
# gcc -I `pwd`/include/uapi/ -E -D__SYSCALL=SYSCALL arch/openrisc/include/uapi/asm/unistd.h \
# | grep ^SYSCALL | sed -e 's/SYSCALL(//;s/[,)]//g' > /tmp/a
# grep -oP "__NR\S+\s+\d+$" include/uapi/asm-generic/unistd.h | grep -v __NR_sync_file_range2 > /tmp/b
# join -2 2 -o 1.1,1.10,2.1,1.2 -e or1k /tmp/a /tmp/b | sed -e 's/\(__NR_\|__NR3264_\)//g' | column -t
#
or1k_syscall_tbl = """
0    or1k  io_setup                 sys_io_setup
1    or1k  io_destroy               sys_io_destroy
2    or1k  io_submit                sys_io_submit
3    or1k  io_cancel                sys_io_cancel
4    or1k  io_getevents             sys_io_getevents
5    or1k  setxattr                 sys_setxattr
6    or1k  lsetxattr                sys_lsetxattr
7    or1k  fsetxattr                sys_fsetxattr
8    or1k  getxattr                 sys_getxattr
9    or1k  lgetxattr                sys_lgetxattr
10   or1k  fgetxattr                sys_fgetxattr
11   or1k  listxattr                sys_listxattr
12   or1k  llistxattr               sys_llistxattr
13   or1k  flistxattr               sys_flistxattr
14   or1k  removexattr              sys_removexattr
15   or1k  lremovexattr             sys_lremovexattr
16   or1k  fremovexattr             sys_fremovexattr
17   or1k  getcwd                   sys_getcwd
18   or1k  lookup_dcookie           sys_lookup_dcookie
19   or1k  eventfd2                 sys_eventfd2
20   or1k  epoll_create1            sys_epoll_create1
21   or1k  epoll_ctl                sys_epoll_ctl
22   or1k  epoll_pwait              sys_epoll_pwait
23   or1k  dup                      sys_dup
24   or1k  dup3                     sys_dup3
25   or1k  fcntl                    sys_fcntl
26   or1k  inotify_init1            sys_inotify_init1
27   or1k  inotify_add_watch        sys_inotify_add_watch
28   or1k  inotify_rm_watch         sys_inotify_rm_watch
29   or1k  ioctl                    sys_ioctl
30   or1k  ioprio_set               sys_ioprio_set
31   or1k  ioprio_get               sys_ioprio_get
32   or1k  flock                    sys_flock
33   or1k  mknodat                  sys_mknodat
34   or1k  mkdirat                  sys_mkdirat
35   or1k  unlinkat                 sys_unlinkat
36   or1k  symlinkat                sys_symlinkat
37   or1k  linkat                   sys_linkat
38   or1k  renameat                 sys_renameat
39   or1k  umount2                  sys_umount
40   or1k  mount                    sys_mount
41   or1k  pivot_root               sys_pivot_root
42   or1k  nfsservctl               sys_ni_syscall
43   or1k  statfs                   sys_statfs
44   or1k  fstatfs                  sys_fstatfs
45   or1k  truncate                 sys_truncate
46   or1k  ftruncate                sys_ftruncate
47   or1k  fallocate                sys_fallocate
48   or1k  faccessat                sys_faccessat
49   or1k  chdir                    sys_chdir
50   or1k  fchdir                   sys_fchdir
51   or1k  chroot                   sys_chroot
52   or1k  fchmod                   sys_fchmod
53   or1k  fchmodat                 sys_fchmodat
54   or1k  fchownat                 sys_fchownat
55   or1k  fchown                   sys_fchown
56   or1k  openat                   sys_openat
57   or1k  close                    sys_close
58   or1k  vhangup                  sys_vhangup
59   or1k  pipe2                    sys_pipe2
60   or1k  quotactl                 sys_quotactl
61   or1k  getdents64               sys_getdents64
62   or1k  lseek                    sys_lseek
63   or1k  read                     sys_read
64   or1k  write                    sys_write
65   or1k  readv                    sys_readv
66   or1k  writev                   sys_writev
67   or1k  pread64                  sys_pread64
68   or1k  pwrite64                 sys_pwrite64
69   or1k  preadv                   sys_preadv
70   or1k  pwritev                  sys_pwritev
71   or1k  sendfile                 sys_sendfile64
72   or1k  pselect6                 sys_pselect6
73   or1k  ppoll                    sys_ppoll
74   or1k  signalfd4                sys_signalfd4
75   or1k  vmsplice                 sys_vmsplice
76   or1k  splice                   sys_splice
77   or1k  tee                      sys_tee
78   or1k  readlinkat               sys_readlinkat
79   or1k  fstatat                  sys_newfstatat
80   or1k  fstat                    sys_newfstat
81   or1k  sync                     sys_sync
82   or1k  fsync                    sys_fsync
83   or1k  fdatasync                sys_fdatasync
84   or1k  sync_file_range          sys_sync_file_range
85   or1k  timerfd_create           sys_timerfd_create
86   or1k  timerfd_settime          sys_timerfd_settime
87   or1k  timerfd_gettime          sys_timerfd_gettime
88   or1k  utimensat                sys_utimensat
89   or1k  acct                     sys_acct
90   or1k  capget                   sys_capget
91   or1k  capset                   sys_capset
92   or1k  personality              sys_personality
93   or1k  exit                     sys_exit
94   or1k  exit_group               sys_exit_group
95   or1k  waitid                   sys_waitid
96   or1k  set_tid_address          sys_set_tid_address
97   or1k  unshare                  sys_unshare
98   or1k  futex                    sys_futex
99   or1k  set_robust_list          sys_set_robust_list
100  or1k  get_robust_list          sys_get_robust_list
101  or1k  nanosleep                sys_nanosleep
102  or1k  getitimer                sys_getitimer
103  or1k  setitimer                sys_setitimer
104  or1k  kexec_load               sys_kexec_load
105  or1k  init_module              sys_init_module
106  or1k  delete_module            sys_delete_module
107  or1k  timer_create             sys_timer_create
108  or1k  timer_gettime            sys_timer_gettime
109  or1k  timer_getoverrun         sys_timer_getoverrun
110  or1k  timer_settime            sys_timer_settime
111  or1k  timer_delete             sys_timer_delete
112  or1k  clock_settime            sys_clock_settime
113  or1k  clock_gettime            sys_clock_gettime
114  or1k  clock_getres             sys_clock_getres
115  or1k  clock_nanosleep          sys_clock_nanosleep
116  or1k  syslog                   sys_syslog
117  or1k  ptrace                   sys_ptrace
118  or1k  sched_setparam           sys_sched_setparam
119  or1k  sched_setscheduler       sys_sched_setscheduler
120  or1k  sched_getscheduler       sys_sched_getscheduler
121  or1k  sched_getparam           sys_sched_getparam
122  or1k  sched_setaffinity        sys_sched_setaffinity
123  or1k  sched_getaffinity        sys_sched_getaffinity
124  or1k  sched_yield              sys_sched_yield
125  or1k  sched_get_priority_max   sys_sched_get_priority_max
126  or1k  sched_get_priority_min   sys_sched_get_priority_min
127  or1k  sched_rr_get_interval    sys_sched_rr_get_interval
128  or1k  restart_syscall          sys_restart_syscall
129  or1k  kill                     sys_kill
130  or1k  tkill                    sys_tkill
131  or1k  tgkill                   sys_tgkill
132  or1k  sigaltstack              sys_sigaltstack
133  or1k  rt_sigsuspend            sys_rt_sigsuspend
134  or1k  rt_sigaction             sys_rt_sigaction
135  or1k  rt_sigprocmask           sys_rt_sigprocmask
136  or1k  rt_sigpending            sys_rt_sigpending
137  or1k  rt_sigtimedwait          sys_rt_sigtimedwait
138  or1k  rt_sigqueueinfo          sys_rt_sigqueueinfo
139  or1k  rt_sigreturn             sys_rt_sigreturn
140  or1k  setpriority              sys_setpriority
141  or1k  getpriority              sys_getpriority
142  or1k  reboot                   sys_reboot
143  or1k  setregid                 sys_setregid
144  or1k  setgid                   sys_setgid
145  or1k  setreuid                 sys_setreuid
146  or1k  setuid                   sys_setuid
147  or1k  setresuid                sys_setresuid
148  or1k  getresuid                sys_getresuid
149  or1k  setresgid                sys_setresgid
150  or1k  getresgid                sys_getresgid
151  or1k  setfsuid                 sys_setfsuid
152  or1k  setfsgid                 sys_setfsgid
153  or1k  times                    sys_times
154  or1k  setpgid                  sys_setpgid
155  or1k  getpgid                  sys_getpgid
156  or1k  getsid                   sys_getsid
157  or1k  setsid                   sys_setsid
158  or1k  getgroups                sys_getgroups
159  or1k  setgroups                sys_setgroups
160  or1k  uname                    sys_newuname
161  or1k  sethostname              sys_sethostname
162  or1k  setdomainname            sys_setdomainname
163  or1k  getrlimit                sys_getrlimit
164  or1k  setrlimit                sys_setrlimit
165  or1k  getrusage                sys_getrusage
166  or1k  umask                    sys_umask
167  or1k  prctl                    sys_prctl
168  or1k  getcpu                   sys_getcpu
169  or1k  gettimeofday             sys_gettimeofday
170  or1k  settimeofday             sys_settimeofday
171  or1k  adjtimex                 sys_adjtimex
172  or1k  getpid                   sys_getpid
173  or1k  getppid                  sys_getppid
174  or1k  getuid                   sys_getuid
175  or1k  geteuid                  sys_geteuid
176  or1k  getgid                   sys_getgid
177  or1k  getegid                  sys_getegid
178  or1k  gettid                   sys_gettid
179  or1k  sysinfo                  sys_sysinfo
180  or1k  mq_open                  sys_mq_open
181  or1k  mq_unlink                sys_mq_unlink
182  or1k  mq_timedsend             sys_mq_timedsend
183  or1k  mq_timedreceive          sys_mq_timedreceive
184  or1k  mq_notify                sys_mq_notify
185  or1k  mq_getsetattr            sys_mq_getsetattr
186  or1k  msgget                   sys_msgget
187  or1k  msgctl                   sys_msgctl
188  or1k  msgrcv                   sys_msgrcv
189  or1k  msgsnd                   sys_msgsnd
190  or1k  semget                   sys_semget
191  or1k  semctl                   sys_semctl
192  or1k  semtimedop               sys_semtimedop
193  or1k  semop                    sys_semop
194  or1k  shmget                   sys_shmget
195  or1k  shmctl                   sys_shmctl
196  or1k  shmat                    sys_shmat
197  or1k  shmdt                    sys_shmdt
198  or1k  socket                   sys_socket
199  or1k  socketpair               sys_socketpair
200  or1k  bind                     sys_bind
201  or1k  listen                   sys_listen
202  or1k  accept                   sys_accept
203  or1k  connect                  sys_connect
204  or1k  getsockname              sys_getsockname
205  or1k  getpeername              sys_getpeername
206  or1k  sendto                   sys_sendto
207  or1k  recvfrom                 sys_recvfrom
208  or1k  setsockopt               sys_setsockopt
209  or1k  getsockopt               sys_getsockopt
210  or1k  shutdown                 sys_shutdown
211  or1k  sendmsg                  sys_sendmsg
212  or1k  recvmsg                  sys_recvmsg
213  or1k  readahead                sys_readahead
214  or1k  brk                      sys_brk
215  or1k  munmap                   sys_munmap
216  or1k  mremap                   sys_mremap
217  or1k  add_key                  sys_add_key
218  or1k  request_key              sys_request_key
219  or1k  keyctl                   sys_keyctl
220  or1k  clone                    sys_clone
221  or1k  execve                   sys_execve
222  or1k  mmap                     sys_mmap
223  or1k  fadvise64                sys_fadvise64_64
224  or1k  swapon                   sys_swapon
225  or1k  swapoff                  sys_swapoff
226  or1k  mprotect                 sys_mprotect
227  or1k  msync                    sys_msync
228  or1k  mlock                    sys_mlock
229  or1k  munlock                  sys_munlock
230  or1k  mlockall                 sys_mlockall
231  or1k  munlockall               sys_munlockall
232  or1k  mincore                  sys_mincore
233  or1k  madvise                  sys_madvise
234  or1k  remap_file_pages         sys_remap_file_pages
235  or1k  mbind                    sys_mbind
236  or1k  get_mempolicy            sys_get_mempolicy
237  or1k  set_mempolicy            sys_set_mempolicy
238  or1k  migrate_pages            sys_migrate_pages
239  or1k  move_pages               sys_move_pages
240  or1k  rt_tgsigqueueinfo        sys_rt_tgsigqueueinfo
241  or1k  perf_event_open          sys_perf_event_open
242  or1k  accept4                  sys_accept4
243  or1k  recvmmsg                 sys_recvmmsg
260  or1k  wait4                    sys_wait4
261  or1k  prlimit64                sys_prlimit64
262  or1k  fanotify_init            sys_fanotify_init
263  or1k  fanotify_mark            sys_fanotify_mark
264  or1k  name_to_handle_at        sys_name_to_handle_at
265  or1k  open_by_handle_at        sys_open_by_handle_at
266  or1k  clock_adjtime            sys_clock_adjtime
267  or1k  syncfs                   sys_syncfs
268  or1k  setns                    sys_setns
269  or1k  sendmmsg                 sys_sendmmsg
270  or1k  process_vm_readv         sys_process_vm_readv
271  or1k  process_vm_writev        sys_process_vm_writev
272  or1k  kcmp                     sys_kcmp
273  or1k  finit_module             sys_finit_module
274  or1k  sched_setattr            sys_sched_setattr
275  or1k  sched_getattr            sys_sched_getattr
276  or1k  renameat2                sys_renameat2
277  or1k  seccomp                  sys_seccomp
278  or1k  getrandom                sys_getrandom
279  or1k  memfd_create             sys_memfd_create
280  or1k  bpf                      sys_bpf
281  or1k  execveat                 sys_execveat
282  or1k  userfaultfd              sys_userfaultfd
283  or1k  membarrier               sys_membarrier
284  or1k  mlock2                   sys_mlock2
285  or1k  copy_file_range          sys_copy_file_range
286  or1k  preadv2                  sys_preadv2
287  or1k  pwritev2                 sys_pwritev2
288  or1k  pkey_mprotect            sys_pkey_mprotect
289  or1k  pkey_alloc               sys_pkey_alloc
290  or1k  pkey_free                sys_pkey_free
291  or1k  statx                    sys_statx
292  or1k  io_pgetevents            sys_io_pgetevents
293  or1k  rseq                     sys_rseq
294  or1k  kexec_file_load          sys_kexec_file_load
424  or1k  pidfd_send_signal        sys_pidfd_send_signal
425  or1k  io_uring_setup           sys_io_uring_setup
426  or1k  io_uring_enter           sys_io_uring_enter
427  or1k  io_uring_register        sys_io_uring_register
428  or1k  open_tree                sys_open_tree
429  or1k  move_mount               sys_move_mount
430  or1k  fsopen                   sys_fsopen
431  or1k  fsconfig                 sys_fsconfig
432  or1k  fsmount                  sys_fsmount
433  or1k  fspick                   sys_fspick
434  or1k  pidfd_open               sys_pidfd_open
435  or1k  clone3                   sys_clone3
436  or1k  close_range              sys_close_range
437  or1k  openat2                  sys_openat2
438  or1k  pidfd_getfd              sys_pidfd_getfd
439  or1k  faccessat2               sys_faccessat2
440  or1k  process_madvise          sys_process_madvise
441  or1k  epoll_pwait2             sys_epoll_pwait2
442  or1k  mount_setattr            sys_mount_setattr
443  or1k  quotactl_fd              sys_quotactl_fd
444  or1k  landlock_create_ruleset  sys_landlock_create_ruleset
445  or1k  landlock_add_rule        sys_landlock_add_rule
446  or1k  landlock_restrict_self   sys_landlock_restrict_self
448  or1k  process_mrelease         sys_process_mrelease
449  or1k  futex_waitv              sys_futex_waitv
450  or1k  set_mempolicy_home_node  sys_set_mempolicy_home_node
"""


# Nios II
#
# [How to make]
# cd /path/to/linux-6.*/
# gcc -I `pwd`/include/uapi/ -E -D__SYSCALL=SYSCALL arch/nios2/include/uapi/asm/unistd.h \
# | grep ^SYSCALL | sed -e 's/SYSCALL(//;s/[,)]//g' > /tmp/a
# grep -oP "__NR\S+\s+\d+$" include/uapi/asm-generic/unistd.h | grep -v __NR_sync_file_range2 > /tmp/b
# join -2 2 -o 1.1,1.10,2.1,1.2 -e nios2 /tmp/a /tmp/b | sed -e 's/\(__NR_\|__NR3264_\)//g' | column -t
#
nios2_syscall_tbl = """
0    nios2  io_setup                 sys_io_setup
1    nios2  io_destroy               sys_io_destroy
2    nios2  io_submit                sys_io_submit
3    nios2  io_cancel                sys_io_cancel
4    nios2  io_getevents             sys_io_getevents
5    nios2  setxattr                 sys_setxattr
6    nios2  lsetxattr                sys_lsetxattr
7    nios2  fsetxattr                sys_fsetxattr
8    nios2  getxattr                 sys_getxattr
9    nios2  lgetxattr                sys_lgetxattr
10   nios2  fgetxattr                sys_fgetxattr
11   nios2  listxattr                sys_listxattr
12   nios2  llistxattr               sys_llistxattr
13   nios2  flistxattr               sys_flistxattr
14   nios2  removexattr              sys_removexattr
15   nios2  lremovexattr             sys_lremovexattr
16   nios2  fremovexattr             sys_fremovexattr
17   nios2  getcwd                   sys_getcwd
18   nios2  lookup_dcookie           sys_lookup_dcookie
19   nios2  eventfd2                 sys_eventfd2
20   nios2  epoll_create1            sys_epoll_create1
21   nios2  epoll_ctl                sys_epoll_ctl
22   nios2  epoll_pwait              sys_epoll_pwait
23   nios2  dup                      sys_dup
24   nios2  dup3                     sys_dup3
25   nios2  fcntl                    sys_fcntl
26   nios2  inotify_init1            sys_inotify_init1
27   nios2  inotify_add_watch        sys_inotify_add_watch
28   nios2  inotify_rm_watch         sys_inotify_rm_watch
29   nios2  ioctl                    sys_ioctl
30   nios2  ioprio_set               sys_ioprio_set
31   nios2  ioprio_get               sys_ioprio_get
32   nios2  flock                    sys_flock
33   nios2  mknodat                  sys_mknodat
34   nios2  mkdirat                  sys_mkdirat
35   nios2  unlinkat                 sys_unlinkat
36   nios2  symlinkat                sys_symlinkat
37   nios2  linkat                   sys_linkat
38   nios2  renameat                 sys_renameat
39   nios2  umount2                  sys_umount
40   nios2  mount                    sys_mount
41   nios2  pivot_root               sys_pivot_root
42   nios2  nfsservctl               sys_ni_syscall
43   nios2  statfs                   sys_statfs
44   nios2  fstatfs                  sys_fstatfs
45   nios2  truncate                 sys_truncate
46   nios2  ftruncate                sys_ftruncate
47   nios2  fallocate                sys_fallocate
48   nios2  faccessat                sys_faccessat
49   nios2  chdir                    sys_chdir
50   nios2  fchdir                   sys_fchdir
51   nios2  chroot                   sys_chroot
52   nios2  fchmod                   sys_fchmod
53   nios2  fchmodat                 sys_fchmodat
54   nios2  fchownat                 sys_fchownat
55   nios2  fchown                   sys_fchown
56   nios2  openat                   sys_openat
57   nios2  close                    sys_close
58   nios2  vhangup                  sys_vhangup
59   nios2  pipe2                    sys_pipe2
60   nios2  quotactl                 sys_quotactl
61   nios2  getdents64               sys_getdents64
62   nios2  lseek                    sys_lseek
63   nios2  read                     sys_read
64   nios2  write                    sys_write
65   nios2  readv                    sys_readv
66   nios2  writev                   sys_writev
67   nios2  pread64                  sys_pread64
68   nios2  pwrite64                 sys_pwrite64
69   nios2  preadv                   sys_preadv
70   nios2  pwritev                  sys_pwritev
71   nios2  sendfile                 sys_sendfile64
72   nios2  pselect6                 sys_pselect6
73   nios2  ppoll                    sys_ppoll
74   nios2  signalfd4                sys_signalfd4
75   nios2  vmsplice                 sys_vmsplice
76   nios2  splice                   sys_splice
77   nios2  tee                      sys_tee
78   nios2  readlinkat               sys_readlinkat
79   nios2  fstatat                  sys_newfstatat
80   nios2  fstat                    sys_newfstat
81   nios2  sync                     sys_sync
82   nios2  fsync                    sys_fsync
83   nios2  fdatasync                sys_fdatasync
84   nios2  sync_file_range          sys_sync_file_range
85   nios2  timerfd_create           sys_timerfd_create
86   nios2  timerfd_settime          sys_timerfd_settime
87   nios2  timerfd_gettime          sys_timerfd_gettime
88   nios2  utimensat                sys_utimensat
89   nios2  acct                     sys_acct
90   nios2  capget                   sys_capget
91   nios2  capset                   sys_capset
92   nios2  personality              sys_personality
93   nios2  exit                     sys_exit
94   nios2  exit_group               sys_exit_group
95   nios2  waitid                   sys_waitid
96   nios2  set_tid_address          sys_set_tid_address
97   nios2  unshare                  sys_unshare
98   nios2  futex                    sys_futex
99   nios2  set_robust_list          sys_set_robust_list
100  nios2  get_robust_list          sys_get_robust_list
101  nios2  nanosleep                sys_nanosleep
102  nios2  getitimer                sys_getitimer
103  nios2  setitimer                sys_setitimer
104  nios2  kexec_load               sys_kexec_load
105  nios2  init_module              sys_init_module
106  nios2  delete_module            sys_delete_module
107  nios2  timer_create             sys_timer_create
108  nios2  timer_gettime            sys_timer_gettime
109  nios2  timer_getoverrun         sys_timer_getoverrun
110  nios2  timer_settime            sys_timer_settime
111  nios2  timer_delete             sys_timer_delete
112  nios2  clock_settime            sys_clock_settime
113  nios2  clock_gettime            sys_clock_gettime
114  nios2  clock_getres             sys_clock_getres
115  nios2  clock_nanosleep          sys_clock_nanosleep
116  nios2  syslog                   sys_syslog
117  nios2  ptrace                   sys_ptrace
118  nios2  sched_setparam           sys_sched_setparam
119  nios2  sched_setscheduler       sys_sched_setscheduler
120  nios2  sched_getscheduler       sys_sched_getscheduler
121  nios2  sched_getparam           sys_sched_getparam
122  nios2  sched_setaffinity        sys_sched_setaffinity
123  nios2  sched_getaffinity        sys_sched_getaffinity
124  nios2  sched_yield              sys_sched_yield
125  nios2  sched_get_priority_max   sys_sched_get_priority_max
126  nios2  sched_get_priority_min   sys_sched_get_priority_min
127  nios2  sched_rr_get_interval    sys_sched_rr_get_interval
128  nios2  restart_syscall          sys_restart_syscall
129  nios2  kill                     sys_kill
130  nios2  tkill                    sys_tkill
131  nios2  tgkill                   sys_tgkill
132  nios2  sigaltstack              sys_sigaltstack
133  nios2  rt_sigsuspend            sys_rt_sigsuspend
134  nios2  rt_sigaction             sys_rt_sigaction
135  nios2  rt_sigprocmask           sys_rt_sigprocmask
136  nios2  rt_sigpending            sys_rt_sigpending
137  nios2  rt_sigtimedwait          sys_rt_sigtimedwait
138  nios2  rt_sigqueueinfo          sys_rt_sigqueueinfo
139  nios2  rt_sigreturn             sys_rt_sigreturn
140  nios2  setpriority              sys_setpriority
141  nios2  getpriority              sys_getpriority
142  nios2  reboot                   sys_reboot
143  nios2  setregid                 sys_setregid
144  nios2  setgid                   sys_setgid
145  nios2  setreuid                 sys_setreuid
146  nios2  setuid                   sys_setuid
147  nios2  setresuid                sys_setresuid
148  nios2  getresuid                sys_getresuid
149  nios2  setresgid                sys_setresgid
150  nios2  getresgid                sys_getresgid
151  nios2  setfsuid                 sys_setfsuid
152  nios2  setfsgid                 sys_setfsgid
153  nios2  times                    sys_times
154  nios2  setpgid                  sys_setpgid
155  nios2  getpgid                  sys_getpgid
156  nios2  getsid                   sys_getsid
157  nios2  setsid                   sys_setsid
158  nios2  getgroups                sys_getgroups
159  nios2  setgroups                sys_setgroups
160  nios2  uname                    sys_newuname
161  nios2  sethostname              sys_sethostname
162  nios2  setdomainname            sys_setdomainname
163  nios2  getrlimit                sys_getrlimit
164  nios2  setrlimit                sys_setrlimit
165  nios2  getrusage                sys_getrusage
166  nios2  umask                    sys_umask
167  nios2  prctl                    sys_prctl
168  nios2  getcpu                   sys_getcpu
169  nios2  gettimeofday             sys_gettimeofday
170  nios2  settimeofday             sys_settimeofday
171  nios2  adjtimex                 sys_adjtimex
172  nios2  getpid                   sys_getpid
173  nios2  getppid                  sys_getppid
174  nios2  getuid                   sys_getuid
175  nios2  geteuid                  sys_geteuid
176  nios2  getgid                   sys_getgid
177  nios2  getegid                  sys_getegid
178  nios2  gettid                   sys_gettid
179  nios2  sysinfo                  sys_sysinfo
180  nios2  mq_open                  sys_mq_open
181  nios2  mq_unlink                sys_mq_unlink
182  nios2  mq_timedsend             sys_mq_timedsend
183  nios2  mq_timedreceive          sys_mq_timedreceive
184  nios2  mq_notify                sys_mq_notify
185  nios2  mq_getsetattr            sys_mq_getsetattr
186  nios2  msgget                   sys_msgget
187  nios2  msgctl                   sys_msgctl
188  nios2  msgrcv                   sys_msgrcv
189  nios2  msgsnd                   sys_msgsnd
190  nios2  semget                   sys_semget
191  nios2  semctl                   sys_semctl
192  nios2  semtimedop               sys_semtimedop
193  nios2  semop                    sys_semop
194  nios2  shmget                   sys_shmget
195  nios2  shmctl                   sys_shmctl
196  nios2  shmat                    sys_shmat
197  nios2  shmdt                    sys_shmdt
198  nios2  socket                   sys_socket
199  nios2  socketpair               sys_socketpair
200  nios2  bind                     sys_bind
201  nios2  listen                   sys_listen
202  nios2  accept                   sys_accept
203  nios2  connect                  sys_connect
204  nios2  getsockname              sys_getsockname
205  nios2  getpeername              sys_getpeername
206  nios2  sendto                   sys_sendto
207  nios2  recvfrom                 sys_recvfrom
208  nios2  setsockopt               sys_setsockopt
209  nios2  getsockopt               sys_getsockopt
210  nios2  shutdown                 sys_shutdown
211  nios2  sendmsg                  sys_sendmsg
212  nios2  recvmsg                  sys_recvmsg
213  nios2  readahead                sys_readahead
214  nios2  brk                      sys_brk
215  nios2  munmap                   sys_munmap
216  nios2  mremap                   sys_mremap
217  nios2  add_key                  sys_add_key
218  nios2  request_key              sys_request_key
219  nios2  keyctl                   sys_keyctl
220  nios2  clone                    sys_clone
221  nios2  execve                   sys_execve
222  nios2  mmap                     sys_mmap
223  nios2  fadvise64                sys_fadvise64_64
224  nios2  swapon                   sys_swapon
225  nios2  swapoff                  sys_swapoff
226  nios2  mprotect                 sys_mprotect
227  nios2  msync                    sys_msync
228  nios2  mlock                    sys_mlock
229  nios2  munlock                  sys_munlock
230  nios2  mlockall                 sys_mlockall
231  nios2  munlockall               sys_munlockall
232  nios2  mincore                  sys_mincore
233  nios2  madvise                  sys_madvise
234  nios2  remap_file_pages         sys_remap_file_pages
235  nios2  mbind                    sys_mbind
236  nios2  get_mempolicy            sys_get_mempolicy
237  nios2  set_mempolicy            sys_set_mempolicy
238  nios2  migrate_pages            sys_migrate_pages
239  nios2  move_pages               sys_move_pages
240  nios2  rt_tgsigqueueinfo        sys_rt_tgsigqueueinfo
241  nios2  perf_event_open          sys_perf_event_open
242  nios2  accept4                  sys_accept4
243  nios2  recvmmsg                 sys_recvmmsg
260  nios2  wait4                    sys_wait4
261  nios2  prlimit64                sys_prlimit64
262  nios2  fanotify_init            sys_fanotify_init
263  nios2  fanotify_mark            sys_fanotify_mark
264  nios2  name_to_handle_at        sys_name_to_handle_at
265  nios2  open_by_handle_at        sys_open_by_handle_at
266  nios2  clock_adjtime            sys_clock_adjtime
267  nios2  syncfs                   sys_syncfs
268  nios2  setns                    sys_setns
269  nios2  sendmmsg                 sys_sendmmsg
270  nios2  process_vm_readv         sys_process_vm_readv
271  nios2  process_vm_writev        sys_process_vm_writev
272  nios2  kcmp                     sys_kcmp
273  nios2  finit_module             sys_finit_module
274  nios2  sched_setattr            sys_sched_setattr
275  nios2  sched_getattr            sys_sched_getattr
276  nios2  renameat2                sys_renameat2
277  nios2  seccomp                  sys_seccomp
278  nios2  getrandom                sys_getrandom
279  nios2  memfd_create             sys_memfd_create
280  nios2  bpf                      sys_bpf
281  nios2  execveat                 sys_execveat
282  nios2  userfaultfd              sys_userfaultfd
283  nios2  membarrier               sys_membarrier
284  nios2  mlock2                   sys_mlock2
285  nios2  copy_file_range          sys_copy_file_range
286  nios2  preadv2                  sys_preadv2
287  nios2  pwritev2                 sys_pwritev2
288  nios2  pkey_mprotect            sys_pkey_mprotect
289  nios2  pkey_alloc               sys_pkey_alloc
290  nios2  pkey_free                sys_pkey_free
291  nios2  statx                    sys_statx
292  nios2  io_pgetevents            sys_io_pgetevents
293  nios2  rseq                     sys_rseq
294  nios2  kexec_file_load          sys_kexec_file_load
424  nios2  pidfd_send_signal        sys_pidfd_send_signal
425  nios2  io_uring_setup           sys_io_uring_setup
426  nios2  io_uring_enter           sys_io_uring_enter
427  nios2  io_uring_register        sys_io_uring_register
428  nios2  open_tree                sys_open_tree
429  nios2  move_mount               sys_move_mount
430  nios2  fsopen                   sys_fsopen
431  nios2  fsconfig                 sys_fsconfig
432  nios2  fsmount                  sys_fsmount
433  nios2  fspick                   sys_fspick
434  nios2  pidfd_open               sys_pidfd_open
436  nios2  close_range              sys_close_range
437  nios2  openat2                  sys_openat2
438  nios2  pidfd_getfd              sys_pidfd_getfd
439  nios2  faccessat2               sys_faccessat2
440  nios2  process_madvise          sys_process_madvise
441  nios2  epoll_pwait2             sys_epoll_pwait2
442  nios2  mount_setattr            sys_mount_setattr
443  nios2  quotactl_fd              sys_quotactl_fd
444  nios2  landlock_create_ruleset  sys_landlock_create_ruleset
445  nios2  landlock_add_rule        sys_landlock_add_rule
446  nios2  landlock_restrict_self   sys_landlock_restrict_self
448  nios2  process_mrelease         sys_process_mrelease
449  nios2  futex_waitv              sys_futex_waitv
450  nios2  set_mempolicy_home_node  sys_set_mempolicy_home_node
"""


# MicroBlaze
# - arch/microblaze/kernel/syscalls/syscall.tbl
microblaze_syscall_tbl = """
# system call numbers and entry vectors for microblaze
#
# The format is:
# <number> <abi> <name> <entry point>
#
# The <abi> is always "common" for this file
#
0       common  restart_syscall                 sys_restart_syscall
1       common  exit                            sys_exit
2       common  fork                            sys_fork
3       common  read                            sys_read
4       common  write                           sys_write
5       common  open                            sys_open
6       common  close                           sys_close
7       common  waitpid                         sys_waitpid
8       common  creat                           sys_creat
9       common  link                            sys_link
10      common  unlink                          sys_unlink
11      common  execve                          sys_execve
12      common  chdir                           sys_chdir
13      common  time                            sys_time32
14      common  mknod                           sys_mknod
15      common  chmod                           sys_chmod
16      common  lchown                          sys_lchown
17      common  break                           sys_ni_syscall
18      common  oldstat                         sys_ni_syscall
19      common  lseek                           sys_lseek
20      common  getpid                          sys_getpid
21      common  mount                           sys_mount
22      common  umount                          sys_oldumount
23      common  setuid                          sys_setuid
24      common  getuid                          sys_getuid
25      common  stime                           sys_stime32
26      common  ptrace                          sys_ptrace
27      common  alarm                           sys_alarm
28      common  oldfstat                        sys_ni_syscall
29      common  pause                           sys_pause
30      common  utime                           sys_utime32
31      common  stty                            sys_ni_syscall
32      common  gtty                            sys_ni_syscall
33      common  access                          sys_access
34      common  nice                            sys_nice
35      common  ftime                           sys_ni_syscall
36      common  sync                            sys_sync
37      common  kill                            sys_kill
38      common  rename                          sys_rename
39      common  mkdir                           sys_mkdir
40      common  rmdir                           sys_rmdir
41      common  dup                             sys_dup
42      common  pipe                            sys_pipe
43      common  times                           sys_times
44      common  prof                            sys_ni_syscall
45      common  brk                             sys_brk
46      common  setgid                          sys_setgid
47      common  getgid                          sys_getgid
48      common  signal                          sys_signal
49      common  geteuid                         sys_geteuid
50      common  getegid                         sys_getegid
51      common  acct                            sys_acct
52      common  umount2                         sys_umount
53      common  lock                            sys_ni_syscall
54      common  ioctl                           sys_ioctl
55      common  fcntl                           sys_fcntl
56      common  mpx                             sys_ni_syscall
57      common  setpgid                         sys_setpgid
58      common  ulimit                          sys_ni_syscall
59      common  oldolduname                     sys_ni_syscall
60      common  umask                           sys_umask
61      common  chroot                          sys_chroot
62      common  ustat                           sys_ustat
63      common  dup2                            sys_dup2
64      common  getppid                         sys_getppid
65      common  getpgrp                         sys_getpgrp
66      common  setsid                          sys_setsid
67      common  sigaction                       sys_ni_syscall
68      common  sgetmask                        sys_sgetmask
69      common  ssetmask                        sys_ssetmask
70      common  setreuid                        sys_setreuid
71      common  setregid                        sys_setregid
72      common  sigsuspend                      sys_ni_syscall
73      common  sigpending                      sys_sigpending
74      common  sethostname                     sys_sethostname
75      common  setrlimit                       sys_setrlimit
76      common  getrlimit                       sys_ni_syscall
77      common  getrusage                       sys_getrusage
78      common  gettimeofday                    sys_gettimeofday
79      common  settimeofday                    sys_settimeofday
80      common  getgroups                       sys_getgroups
81      common  setgroups                       sys_setgroups
82      common  select                          sys_ni_syscall
83      common  symlink                         sys_symlink
84      common  oldlstat                        sys_ni_syscall
85      common  readlink                        sys_readlink
86      common  uselib                          sys_uselib
87      common  swapon                          sys_swapon
88      common  reboot                          sys_reboot
89      common  readdir                         sys_ni_syscall
90      common  mmap                            sys_mmap
91      common  munmap                          sys_munmap
92      common  truncate                        sys_truncate
93      common  ftruncate                       sys_ftruncate
94      common  fchmod                          sys_fchmod
95      common  fchown                          sys_fchown
96      common  getpriority                     sys_getpriority
97      common  setpriority                     sys_setpriority
98      common  profil                          sys_ni_syscall
99      common  statfs                          sys_statfs
100     common  fstatfs                         sys_fstatfs
101     common  ioperm                          sys_ni_syscall
102     common  socketcall                      sys_socketcall
103     common  syslog                          sys_syslog
104     common  setitimer                       sys_setitimer
105     common  getitimer                       sys_getitimer
106     common  stat                            sys_newstat
107     common  lstat                           sys_newlstat
108     common  fstat                           sys_newfstat
109     common  olduname                        sys_ni_syscall
110     common  iopl                            sys_ni_syscall
111     common  vhangup                         sys_vhangup
112     common  idle                            sys_ni_syscall
113     common  vm86old                         sys_ni_syscall
114     common  wait4                           sys_wait4
115     common  swapoff                         sys_swapoff
116     common  sysinfo                         sys_sysinfo
117     common  ipc                             sys_ni_syscall
118     common  fsync                           sys_fsync
119     common  sigreturn                       sys_ni_syscall
120     common  clone                           sys_clone
121     common  setdomainname                   sys_setdomainname
122     common  uname                           sys_newuname
123     common  modify_ldt                      sys_ni_syscall
124     common  adjtimex                        sys_adjtimex_time32
125     common  mprotect                        sys_mprotect
126     common  sigprocmask                     sys_sigprocmask
127     common  create_module                   sys_ni_syscall
128     common  init_module                     sys_init_module
129     common  delete_module                   sys_delete_module
130     common  get_kernel_syms                 sys_ni_syscall
131     common  quotactl                        sys_quotactl
132     common  getpgid                         sys_getpgid
133     common  fchdir                          sys_fchdir
134     common  bdflush                         sys_ni_syscall
135     common  sysfs                           sys_sysfs
136     common  personality                     sys_personality
137     common  afs_syscall                     sys_ni_syscall
138     common  setfsuid                        sys_setfsuid
139     common  setfsgid                        sys_setfsgid
140     common  _llseek                         sys_llseek
141     common  getdents                        sys_getdents
142     common  _newselect                      sys_select
143     common  flock                           sys_flock
144     common  msync                           sys_msync
145     common  readv                           sys_readv
146     common  writev                          sys_writev
147     common  getsid                          sys_getsid
148     common  fdatasync                       sys_fdatasync
149     common  _sysctl                         sys_ni_syscall
150     common  mlock                           sys_mlock
151     common  munlock                         sys_munlock
152     common  mlockall                        sys_mlockall
153     common  munlockall                      sys_munlockall
154     common  sched_setparam                  sys_sched_setparam
155     common  sched_getparam                  sys_sched_getparam
156     common  sched_setscheduler              sys_sched_setscheduler
157     common  sched_getscheduler              sys_sched_getscheduler
158     common  sched_yield                     sys_sched_yield
159     common  sched_get_priority_max          sys_sched_get_priority_max
160     common  sched_get_priority_min          sys_sched_get_priority_min
161     common  sched_rr_get_interval           sys_sched_rr_get_interval_time32
162     common  nanosleep                       sys_nanosleep_time32
163     common  mremap                          sys_mremap
164     common  setresuid                       sys_setresuid
165     common  getresuid                       sys_getresuid
166     common  vm86                            sys_ni_syscall
167     common  query_module                    sys_ni_syscall
168     common  poll                            sys_poll
169     common  nfsservctl                      sys_ni_syscall
170     common  setresgid                       sys_setresgid
171     common  getresgid                       sys_getresgid
172     common  prctl                           sys_prctl
173     common  rt_sigreturn                    sys_rt_sigreturn_wrapper
174     common  rt_sigaction                    sys_rt_sigaction
175     common  rt_sigprocmask                  sys_rt_sigprocmask
176     common  rt_sigpending                   sys_rt_sigpending
177     common  rt_sigtimedwait                 sys_rt_sigtimedwait_time32
178     common  rt_sigqueueinfo                 sys_rt_sigqueueinfo
179     common  rt_sigsuspend                   sys_rt_sigsuspend
180     common  pread64                         sys_pread64
181     common  pwrite64                        sys_pwrite64
182     common  chown                           sys_chown
183     common  getcwd                          sys_getcwd
184     common  capget                          sys_capget
185     common  capset                          sys_capset
186     common  sigaltstack                     sys_ni_syscall
187     common  sendfile                        sys_sendfile
188     common  getpmsg                         sys_ni_syscall
189     common  putpmsg                         sys_ni_syscall
190     common  vfork                           sys_vfork
191     common  ugetrlimit                      sys_getrlimit
192     common  mmap2                           sys_mmap2
193     common  truncate64                      sys_truncate64
194     common  ftruncate64                     sys_ftruncate64
195     common  stat64                          sys_stat64
196     common  lstat64                         sys_lstat64
197     common  fstat64                         sys_fstat64
198     common  lchown32                        sys_lchown
199     common  getuid32                        sys_getuid
200     common  getgid32                        sys_getgid
201     common  geteuid32                       sys_geteuid
202     common  getegid32                       sys_getegid
203     common  setreuid32                      sys_setreuid
204     common  setregid32                      sys_setregid
205     common  getgroups32                     sys_getgroups
206     common  setgroups32                     sys_setgroups
207     common  fchown32                        sys_fchown
208     common  setresuid32                     sys_setresuid
209     common  getresuid32                     sys_getresuid
210     common  setresgid32                     sys_setresgid
211     common  getresgid32                     sys_getresgid
212     common  chown32                         sys_chown
213     common  setuid32                        sys_setuid
214     common  setgid32                        sys_setgid
215     common  setfsuid32                      sys_setfsuid
216     common  setfsgid32                      sys_setfsgid
217     common  pivot_root                      sys_pivot_root
218     common  mincore                         sys_mincore
219     common  madvise                         sys_madvise
220     common  getdents64                      sys_getdents64
221     common  fcntl64                         sys_fcntl64
# 222 is reserved for TUX
# 223 is unused
224     common  gettid                          sys_gettid
225     common  readahead                       sys_readahead
226     common  setxattr                        sys_setxattr
227     common  lsetxattr                       sys_lsetxattr
228     common  fsetxattr                       sys_fsetxattr
229     common  getxattr                        sys_getxattr
230     common  lgetxattr                       sys_lgetxattr
231     common  fgetxattr                       sys_fgetxattr
232     common  listxattr                       sys_listxattr
233     common  llistxattr                      sys_llistxattr
234     common  flistxattr                      sys_flistxattr
235     common  removexattr                     sys_removexattr
236     common  lremovexattr                    sys_lremovexattr
237     common  fremovexattr                    sys_fremovexattr
238     common  tkill                           sys_tkill
239     common  sendfile64                      sys_sendfile64
240     common  futex                           sys_futex_time32
241     common  sched_setaffinity               sys_sched_setaffinity
242     common  sched_getaffinity               sys_sched_getaffinity
243     common  set_thread_area                 sys_ni_syscall
244     common  get_thread_area                 sys_ni_syscall
245     common  io_setup                        sys_io_setup
246     common  io_destroy                      sys_io_destroy
247     common  io_getevents                    sys_io_getevents_time32
248     common  io_submit                       sys_io_submit
249     common  io_cancel                       sys_io_cancel
250     common  fadvise64                       sys_fadvise64
# 251 is available for reuse (was briefly sys_set_zone_reclaim)
252     common  exit_group                      sys_exit_group
253     common  lookup_dcookie                  sys_lookup_dcookie
254     common  epoll_create                    sys_epoll_create
255     common  epoll_ctl                       sys_epoll_ctl
256     common  epoll_wait                      sys_epoll_wait
257     common  remap_file_pages                sys_remap_file_pages
258     common  set_tid_address                 sys_set_tid_address
259     common  timer_create                    sys_timer_create
260     common  timer_settime                   sys_timer_settime32
261     common  timer_gettime                   sys_timer_gettime32
262     common  timer_getoverrun                sys_timer_getoverrun
263     common  timer_delete                    sys_timer_delete
264     common  clock_settime                   sys_clock_settime32
265     common  clock_gettime                   sys_clock_gettime32
266     common  clock_getres                    sys_clock_getres_time32
267     common  clock_nanosleep                 sys_clock_nanosleep_time32
268     common  statfs64                        sys_statfs64
269     common  fstatfs64                       sys_fstatfs64
270     common  tgkill                          sys_tgkill
271     common  utimes                          sys_utimes_time32
272     common  fadvise64_64                    sys_fadvise64_64
273     common  vserver                         sys_ni_syscall
274     common  mbind                           sys_mbind
275     common  get_mempolicy                   sys_get_mempolicy
276     common  set_mempolicy                   sys_set_mempolicy
277     common  mq_open                         sys_mq_open
278     common  mq_unlink                       sys_mq_unlink
279     common  mq_timedsend                    sys_mq_timedsend_time32
280     common  mq_timedreceive                 sys_mq_timedreceive_time32
281     common  mq_notify                       sys_mq_notify
282     common  mq_getsetattr                   sys_mq_getsetattr
283     common  kexec_load                      sys_kexec_load
284     common  waitid                          sys_waitid
# 285 was setaltroot
286     common  add_key                         sys_add_key
287     common  request_key                     sys_request_key
288     common  keyctl                          sys_keyctl
289     common  ioprio_set                      sys_ioprio_set
290     common  ioprio_get                      sys_ioprio_get
291     common  inotify_init                    sys_inotify_init
292     common  inotify_add_watch               sys_inotify_add_watch
293     common  inotify_rm_watch                sys_inotify_rm_watch
294     common  migrate_pages                   sys_ni_syscall
295     common  openat                          sys_openat
296     common  mkdirat                         sys_mkdirat
297     common  mknodat                         sys_mknodat
298     common  fchownat                        sys_fchownat
299     common  futimesat                       sys_futimesat_time32
300     common  fstatat64                       sys_fstatat64
301     common  unlinkat                        sys_unlinkat
302     common  renameat                        sys_renameat
303     common  linkat                          sys_linkat
304     common  symlinkat                       sys_symlinkat
305     common  readlinkat                      sys_readlinkat
306     common  fchmodat                        sys_fchmodat
307     common  faccessat                       sys_faccessat
308     common  pselect6                        sys_pselect6_time32
309     common  ppoll                           sys_ppoll_time32
310     common  unshare                         sys_unshare
311     common  set_robust_list                 sys_set_robust_list
312     common  get_robust_list                 sys_get_robust_list
313     common  splice                          sys_splice
314     common  sync_file_range                 sys_sync_file_range
315     common  tee                             sys_tee
316     common  vmsplice                        sys_vmsplice
317     common  move_pages                      sys_move_pages
318     common  getcpu                          sys_getcpu
319     common  epoll_pwait                     sys_epoll_pwait
320     common  utimensat                       sys_utimensat_time32
321     common  signalfd                        sys_signalfd
322     common  timerfd_create                  sys_timerfd_create
323     common  eventfd                         sys_eventfd
324     common  fallocate                       sys_fallocate
325     common  semtimedop                      sys_semtimedop_time32
326     common  timerfd_settime                 sys_timerfd_settime32
327     common  timerfd_gettime                 sys_timerfd_gettime32
328     common  semctl                          sys_old_semctl
329     common  semget                          sys_semget
330     common  semop                           sys_semop
331     common  msgctl                          sys_old_msgctl
332     common  msgget                          sys_msgget
333     common  msgrcv                          sys_msgrcv
334     common  msgsnd                          sys_msgsnd
335     common  shmat                           sys_shmat
336     common  shmctl                          sys_old_shmctl
337     common  shmdt                           sys_shmdt
338     common  shmget                          sys_shmget
339     common  signalfd4                       sys_signalfd4
340     common  eventfd2                        sys_eventfd2
341     common  epoll_create1                   sys_epoll_create1
342     common  dup3                            sys_dup3
343     common  pipe2                           sys_pipe2
344     common  inotify_init1                   sys_inotify_init1
345     common  socket                          sys_socket
346     common  socketpair                      sys_socketpair
347     common  bind                            sys_bind
348     common  listen                          sys_listen
349     common  accept                          sys_accept
350     common  connect                         sys_connect
351     common  getsockname                     sys_getsockname
352     common  getpeername                     sys_getpeername
353     common  sendto                          sys_sendto
354     common  send                            sys_send
355     common  recvfrom                        sys_recvfrom
356     common  recv                            sys_recv
357     common  setsockopt                      sys_setsockopt
358     common  getsockopt                      sys_getsockopt
359     common  shutdown                        sys_shutdown
360     common  sendmsg                         sys_sendmsg
361     common  recvmsg                         sys_recvmsg
362     common  accept4                         sys_accept4
363     common  preadv                          sys_preadv
364     common  pwritev                         sys_pwritev
365     common  rt_tgsigqueueinfo               sys_rt_tgsigqueueinfo
366     common  perf_event_open                 sys_perf_event_open
367     common  recvmmsg                        sys_recvmmsg_time32
368     common  fanotify_init                   sys_fanotify_init
369     common  fanotify_mark                   sys_fanotify_mark
370     common  prlimit64                       sys_prlimit64
371     common  name_to_handle_at               sys_name_to_handle_at
372     common  open_by_handle_at               sys_open_by_handle_at
373     common  clock_adjtime                   sys_clock_adjtime32
374     common  syncfs                          sys_syncfs
375     common  setns                           sys_setns
376     common  sendmmsg                        sys_sendmmsg
377     common  process_vm_readv                sys_process_vm_readv
378     common  process_vm_writev               sys_process_vm_writev
379     common  kcmp                            sys_kcmp
380     common  finit_module                    sys_finit_module
381     common  sched_setattr                   sys_sched_setattr
382     common  sched_getattr                   sys_sched_getattr
383     common  renameat2                       sys_renameat2
384     common  seccomp                         sys_seccomp
385     common  getrandom                       sys_getrandom
386     common  memfd_create                    sys_memfd_create
387     common  bpf                             sys_bpf
388     common  execveat                        sys_execveat
389     common  userfaultfd                     sys_userfaultfd
390     common  membarrier                      sys_membarrier
391     common  mlock2                          sys_mlock2
392     common  copy_file_range                 sys_copy_file_range
393     common  preadv2                         sys_preadv2
394     common  pwritev2                        sys_pwritev2
395     common  pkey_mprotect                   sys_pkey_mprotect
396     common  pkey_alloc                      sys_pkey_alloc
397     common  pkey_free                       sys_pkey_free
398     common  statx                           sys_statx
399     common  io_pgetevents                   sys_io_pgetevents_time32
400     common  rseq                            sys_rseq
# 401 and 402 are unused
403     common  clock_gettime64                 sys_clock_gettime
404     common  clock_settime64                 sys_clock_settime
405     common  clock_adjtime64                 sys_clock_adjtime
406     common  clock_getres_time64             sys_clock_getres
407     common  clock_nanosleep_time64          sys_clock_nanosleep
408     common  timer_gettime64                 sys_timer_gettime
409     common  timer_settime64                 sys_timer_settime
410     common  timerfd_gettime64               sys_timerfd_gettime
411     common  timerfd_settime64               sys_timerfd_settime
412     common  utimensat_time64                sys_utimensat
413     common  pselect6_time64                 sys_pselect6
414     common  ppoll_time64                    sys_ppoll
416     common  io_pgetevents_time64            sys_io_pgetevents
417     common  recvmmsg_time64                 sys_recvmmsg
418     common  mq_timedsend_time64             sys_mq_timedsend
419     common  mq_timedreceive_time64          sys_mq_timedreceive
420     common  semtimedop_time64               sys_semtimedop
421     common  rt_sigtimedwait_time64          sys_rt_sigtimedwait
422     common  futex_time64                    sys_futex
423     common  sched_rr_get_interval_time64    sys_sched_rr_get_interval
424     common  pidfd_send_signal               sys_pidfd_send_signal
425     common  io_uring_setup                  sys_io_uring_setup
426     common  io_uring_enter                  sys_io_uring_enter
427     common  io_uring_register               sys_io_uring_register
428     common  open_tree                       sys_open_tree
429     common  move_mount                      sys_move_mount
430     common  fsopen                          sys_fsopen
431     common  fsconfig                        sys_fsconfig
432     common  fsmount                         sys_fsmount
433     common  fspick                          sys_fspick
434     common  pidfd_open                      sys_pidfd_open
435     common  clone3                          sys_clone3
436     common  close_range                     sys_close_range
437     common  openat2                         sys_openat2
438     common  pidfd_getfd                     sys_pidfd_getfd
439     common  faccessat2                      sys_faccessat2
440     common  process_madvise                 sys_process_madvise
441     common  epoll_pwait2                    sys_epoll_pwait2
442     common  mount_setattr                   sys_mount_setattr
443     common  quotactl_fd                     sys_quotactl_fd
444     common  landlock_create_ruleset         sys_landlock_create_ruleset
445     common  landlock_add_rule               sys_landlock_add_rule
446     common  landlock_restrict_self          sys_landlock_restrict_self
# 447 reserved for memfd_secret
448     common  process_mrelease                sys_process_mrelease
449     common  futex_waitv                     sys_futex_waitv
450     common  set_mempolicy_home_node         sys_set_mempolicy_home_node
"""


# Xtensa
# arch/xtensa/kernel/syscalls/syscall.tbl
xtensa_syscall_tbl = """
# system call numbers and entry vectors for xtensa
#
# The format is:
# <number> <abi> <name> <entry point>
#
# The <abi> is always "common" for this file
#
0       common  spill                           sys_ni_syscall
1       common  xtensa                          sys_ni_syscall
2       common  available4                      sys_ni_syscall
3       common  available5                      sys_ni_syscall
4       common  available6                      sys_ni_syscall
5       common  available7                      sys_ni_syscall
6       common  available8                      sys_ni_syscall
7       common  available9                      sys_ni_syscall
# File Operations
8       common  open                            sys_open
9       common  close                           sys_close
10      common  dup                             sys_dup
11      common  dup2                            sys_dup2
12      common  read                            sys_read
13      common  write                           sys_write
14      common  select                          sys_select
15      common  lseek                           sys_lseek
16      common  poll                            sys_poll
17      common  _llseek                         sys_llseek
18      common  epoll_wait                      sys_epoll_wait
19      common  epoll_ctl                       sys_epoll_ctl
20      common  epoll_create                    sys_epoll_create
21      common  creat                           sys_creat
22      common  truncate                        sys_truncate
23      common  ftruncate                       sys_ftruncate
24      common  readv                           sys_readv
25      common  writev                          sys_writev
26      common  fsync                           sys_fsync
27      common  fdatasync                       sys_fdatasync
28      common  truncate64                      sys_truncate64
29      common  ftruncate64                     sys_ftruncate64
30      common  pread64                         sys_pread64
31      common  pwrite64                        sys_pwrite64
32      common  link                            sys_link
33      common  rename                          sys_rename
34      common  symlink                         sys_symlink
35      common  readlink                        sys_readlink
36      common  mknod                           sys_mknod
37      common  pipe                            sys_pipe
38      common  unlink                          sys_unlink
39      common  rmdir                           sys_rmdir
40      common  mkdir                           sys_mkdir
41      common  chdir                           sys_chdir
42      common  fchdir                          sys_fchdir
43      common  getcwd                          sys_getcwd
44      common  chmod                           sys_chmod
45      common  chown                           sys_chown
46      common  stat                            sys_newstat
47      common  stat64                          sys_stat64
48      common  lchown                          sys_lchown
49      common  lstat                           sys_newlstat
50      common  lstat64                         sys_lstat64
51      common  available51                     sys_ni_syscall
52      common  fchmod                          sys_fchmod
53      common  fchown                          sys_fchown
54      common  fstat                           sys_newfstat
55      common  fstat64                         sys_fstat64
56      common  flock                           sys_flock
57      common  access                          sys_access
58      common  umask                           sys_umask
59      common  getdents                        sys_getdents
60      common  getdents64                      sys_getdents64
61      common  fcntl64                         sys_fcntl64
62      common  fallocate                       sys_fallocate
63      common  fadvise64_64                    xtensa_fadvise64_64
64      common  utime                           sys_utime32
65      common  utimes                          sys_utimes_time32
66      common  ioctl                           sys_ioctl
67      common  fcntl                           sys_fcntl
68      common  setxattr                        sys_setxattr
69      common  getxattr                        sys_getxattr
70      common  listxattr                       sys_listxattr
71      common  removexattr                     sys_removexattr
72      common  lsetxattr                       sys_lsetxattr
73      common  lgetxattr                       sys_lgetxattr
74      common  llistxattr                      sys_llistxattr
75      common  lremovexattr                    sys_lremovexattr
76      common  fsetxattr                       sys_fsetxattr
77      common  fgetxattr                       sys_fgetxattr
78      common  flistxattr                      sys_flistxattr
79      common  fremovexattr                    sys_fremovexattr
# File Map / Shared Memory Operations
80      common  mmap2                           sys_mmap_pgoff
81      common  munmap                          sys_munmap
82      common  mprotect                        sys_mprotect
83      common  brk                             sys_brk
84      common  mlock                           sys_mlock
85      common  munlock                         sys_munlock
86      common  mlockall                        sys_mlockall
87      common  munlockall                      sys_munlockall
88      common  mremap                          sys_mremap
89      common  msync                           sys_msync
90      common  mincore                         sys_mincore
91      common  madvise                         sys_madvise
92      common  shmget                          sys_shmget
93      common  shmat                           xtensa_shmat
94      common  shmctl                          sys_old_shmctl
95      common  shmdt                           sys_shmdt
# Socket Operations
96      common  socket                          sys_socket
97      common  setsockopt                      sys_setsockopt
98      common  getsockopt                      sys_getsockopt
99      common  shutdown                        sys_shutdown
100     common  bind                            sys_bind
101     common  connect                         sys_connect
102     common  listen                          sys_listen
103     common  accept                          sys_accept
104     common  getsockname                     sys_getsockname
105     common  getpeername                     sys_getpeername
106     common  sendmsg                         sys_sendmsg
107     common  recvmsg                         sys_recvmsg
108     common  send                            sys_send
109     common  recv                            sys_recv
110     common  sendto                          sys_sendto
111     common  recvfrom                        sys_recvfrom
112     common  socketpair                      sys_socketpair
113     common  sendfile                        sys_sendfile
114     common  sendfile64                      sys_sendfile64
115     common  sendmmsg                        sys_sendmmsg
# Process Operations
116     common  clone                           sys_clone
117     common  execve                          sys_execve
118     common  exit                            sys_exit
119     common  exit_group                      sys_exit_group
120     common  getpid                          sys_getpid
121     common  wait4                           sys_wait4
122     common  waitid                          sys_waitid
123     common  kill                            sys_kill
124     common  tkill                           sys_tkill
125     common  tgkill                          sys_tgkill
126     common  set_tid_address                 sys_set_tid_address
127     common  gettid                          sys_gettid
128     common  setsid                          sys_setsid
129     common  getsid                          sys_getsid
130     common  prctl                           sys_prctl
131     common  personality                     sys_personality
132     common  getpriority                     sys_getpriority
133     common  setpriority                     sys_setpriority
134     common  setitimer                       sys_setitimer
135     common  getitimer                       sys_getitimer
136     common  setuid                          sys_setuid
137     common  getuid                          sys_getuid
138     common  setgid                          sys_setgid
139     common  getgid                          sys_getgid
140     common  geteuid                         sys_geteuid
141     common  getegid                         sys_getegid
142     common  setreuid                        sys_setreuid
143     common  setregid                        sys_setregid
144     common  setresuid                       sys_setresuid
145     common  getresuid                       sys_getresuid
146     common  setresgid                       sys_setresgid
147     common  getresgid                       sys_getresgid
148     common  setpgid                         sys_setpgid
149     common  getpgid                         sys_getpgid
150     common  getppid                         sys_getppid
151     common  getpgrp                         sys_getpgrp
# 152 was set_thread_area
152     common  reserved152                     sys_ni_syscall
# 153 was get_thread_area
153     common  reserved153                     sys_ni_syscall
154     common  times                           sys_times
155     common  acct                            sys_acct
156     common  sched_setaffinity               sys_sched_setaffinity
157     common  sched_getaffinity               sys_sched_getaffinity
158     common  capget                          sys_capget
159     common  capset                          sys_capset
160     common  ptrace                          sys_ptrace
161     common  semtimedop                      sys_semtimedop_time32
162     common  semget                          sys_semget
163     common  semop                           sys_semop
164     common  semctl                          sys_old_semctl
165     common  available165                    sys_ni_syscall
166     common  msgget                          sys_msgget
167     common  msgsnd                          sys_msgsnd
168     common  msgrcv                          sys_msgrcv
169     common  msgctl                          sys_old_msgctl
170     common  available170                    sys_ni_syscall
# File System
171     common  umount2                         sys_umount
172     common  mount                           sys_mount
173     common  swapon                          sys_swapon
174     common  chroot                          sys_chroot
175     common  pivot_root                      sys_pivot_root
176     common  umount                          sys_oldumount
177     common  swapoff                         sys_swapoff
178     common  sync                            sys_sync
179     common  syncfs                          sys_syncfs
180     common  setfsuid                        sys_setfsuid
181     common  setfsgid                        sys_setfsgid
182     common  sysfs                           sys_sysfs
183     common  ustat                           sys_ustat
184     common  statfs                          sys_statfs
185     common  fstatfs                         sys_fstatfs
186     common  statfs64                        sys_statfs64
187     common  fstatfs64                       sys_fstatfs64
# System
188     common  setrlimit                       sys_setrlimit
189     common  getrlimit                       sys_getrlimit
190     common  getrusage                       sys_getrusage
191     common  futex                           sys_futex_time32
192     common  gettimeofday                    sys_gettimeofday
193     common  settimeofday                    sys_settimeofday
194     common  adjtimex                        sys_adjtimex_time32
195     common  nanosleep                       sys_nanosleep_time32
196     common  getgroups                       sys_getgroups
197     common  setgroups                       sys_setgroups
198     common  sethostname                     sys_sethostname
199     common  setdomainname                   sys_setdomainname
200     common  syslog                          sys_syslog
201     common  vhangup                         sys_vhangup
202     common  uselib                          sys_uselib
203     common  reboot                          sys_reboot
204     common  quotactl                        sys_quotactl
# 205 was old nfsservctl
205     common  nfsservctl                      sys_ni_syscall
206     common  _sysctl                         sys_ni_syscall
207     common  bdflush                         sys_ni_syscall
208     common  uname                           sys_newuname
209     common  sysinfo                         sys_sysinfo
210     common  init_module                     sys_init_module
211     common  delete_module                   sys_delete_module
212     common  sched_setparam                  sys_sched_setparam
213     common  sched_getparam                  sys_sched_getparam
214     common  sched_setscheduler              sys_sched_setscheduler
215     common  sched_getscheduler              sys_sched_getscheduler
216     common  sched_get_priority_max          sys_sched_get_priority_max
217     common  sched_get_priority_min          sys_sched_get_priority_min
218     common  sched_rr_get_interval           sys_sched_rr_get_interval_time32
219     common  sched_yield                     sys_sched_yield
222     common  available222                    sys_ni_syscall
# Signal Handling
223     common  restart_syscall                 sys_restart_syscall
224     common  sigaltstack                     sys_sigaltstack
225     common  rt_sigreturn                    xtensa_rt_sigreturn
226     common  rt_sigaction                    sys_rt_sigaction
227     common  rt_sigprocmask                  sys_rt_sigprocmask
228     common  rt_sigpending                   sys_rt_sigpending
229     common  rt_sigtimedwait                 sys_rt_sigtimedwait_time32
230     common  rt_sigqueueinfo                 sys_rt_sigqueueinfo
231     common  rt_sigsuspend                   sys_rt_sigsuspend
# Message
232     common  mq_open                         sys_mq_open
233     common  mq_unlink                       sys_mq_unlink
234     common  mq_timedsend                    sys_mq_timedsend_time32
235     common  mq_timedreceive                 sys_mq_timedreceive_time32
236     common  mq_notify                       sys_mq_notify
237     common  mq_getsetattr                   sys_mq_getsetattr
238     common  available238                    sys_ni_syscall
239     common  io_setup                        sys_io_setup
# IO
240     common  io_destroy                      sys_io_destroy
241     common  io_submit                       sys_io_submit
242     common  io_getevents                    sys_io_getevents_time32
243     common  io_cancel                       sys_io_cancel
244     common  clock_settime                   sys_clock_settime32
245     common  clock_gettime                   sys_clock_gettime32
246     common  clock_getres                    sys_clock_getres_time32
247     common  clock_nanosleep                 sys_clock_nanosleep_time32
# Timer
248     common  timer_create                    sys_timer_create
249     common  timer_delete                    sys_timer_delete
250     common  timer_settime                   sys_timer_settime32
251     common  timer_gettime                   sys_timer_gettime32
252     common  timer_getoverrun                sys_timer_getoverrun
# System
253     common  reserved253                     sys_ni_syscall
254     common  lookup_dcookie                  sys_lookup_dcookie
255     common  available255                    sys_ni_syscall
256     common  add_key                         sys_add_key
257     common  request_key                     sys_request_key
258     common  keyctl                          sys_keyctl
259     common  available259                    sys_ni_syscall
260     common  readahead                       sys_readahead
261     common  remap_file_pages                sys_remap_file_pages
262     common  migrate_pages                   sys_migrate_pages
263     common  mbind                           sys_mbind
264     common  get_mempolicy                   sys_get_mempolicy
265     common  set_mempolicy                   sys_set_mempolicy
266     common  unshare                         sys_unshare
267     common  move_pages                      sys_move_pages
268     common  splice                          sys_splice
269     common  tee                             sys_tee
270     common  vmsplice                        sys_vmsplice
271     common  available271                    sys_ni_syscall
272     common  pselect6                        sys_pselect6_time32
273     common  ppoll                           sys_ppoll_time32
274     common  epoll_pwait                     sys_epoll_pwait
275     common  epoll_create1                   sys_epoll_create1
276     common  inotify_init                    sys_inotify_init
277     common  inotify_add_watch               sys_inotify_add_watch
278     common  inotify_rm_watch                sys_inotify_rm_watch
279     common  inotify_init1                   sys_inotify_init1
280     common  getcpu                          sys_getcpu
281     common  kexec_load                      sys_ni_syscall
282     common  ioprio_set                      sys_ioprio_set
283     common  ioprio_get                      sys_ioprio_get
284     common  set_robust_list                 sys_set_robust_list
285     common  get_robust_list                 sys_get_robust_list
286     common  available286                    sys_ni_syscall
287     common  available287                    sys_ni_syscall
# Relative File Operations
288     common  openat                          sys_openat
289     common  mkdirat                         sys_mkdirat
290     common  mknodat                         sys_mknodat
291     common  unlinkat                        sys_unlinkat
292     common  renameat                        sys_renameat
293     common  linkat                          sys_linkat
294     common  symlinkat                       sys_symlinkat
295     common  readlinkat                      sys_readlinkat
296     common  utimensat                       sys_utimensat_time32
297     common  fchownat                        sys_fchownat
298     common  futimesat                       sys_futimesat_time32
299     common  fstatat64                       sys_fstatat64
300     common  fchmodat                        sys_fchmodat
301     common  faccessat                       sys_faccessat
302     common  available302                    sys_ni_syscall
303     common  available303                    sys_ni_syscall
304     common  signalfd                        sys_signalfd
# 305 was timerfd
306     common  eventfd                         sys_eventfd
307     common  recvmmsg                        sys_recvmmsg_time32
308     common  setns                           sys_setns
309     common  signalfd4                       sys_signalfd4
310     common  dup3                            sys_dup3
311     common  pipe2                           sys_pipe2
312     common  timerfd_create                  sys_timerfd_create
313     common  timerfd_settime                 sys_timerfd_settime32
314     common  timerfd_gettime                 sys_timerfd_gettime32
315     common  available315                    sys_ni_syscall
316     common  eventfd2                        sys_eventfd2
317     common  preadv                          sys_preadv
318     common  pwritev                         sys_pwritev
319     common  available319                    sys_ni_syscall
320     common  fanotify_init                   sys_fanotify_init
321     common  fanotify_mark                   sys_fanotify_mark
322     common  process_vm_readv                sys_process_vm_readv
323     common  process_vm_writev               sys_process_vm_writev
324     common  name_to_handle_at               sys_name_to_handle_at
325     common  open_by_handle_at               sys_open_by_handle_at
326     common  sync_file_range2                sys_sync_file_range2
327     common  perf_event_open                 sys_perf_event_open
328     common  rt_tgsigqueueinfo               sys_rt_tgsigqueueinfo
329     common  clock_adjtime                   sys_clock_adjtime32
330     common  prlimit64                       sys_prlimit64
331     common  kcmp                            sys_kcmp
332     common  finit_module                    sys_finit_module
333     common  accept4                         sys_accept4
334     common  sched_setattr                   sys_sched_setattr
335     common  sched_getattr                   sys_sched_getattr
336     common  renameat2                       sys_renameat2
337     common  seccomp                         sys_seccomp
338     common  getrandom                       sys_getrandom
339     common  memfd_create                    sys_memfd_create
340     common  bpf                             sys_bpf
341     common  execveat                        sys_execveat
342     common  userfaultfd                     sys_userfaultfd
343     common  membarrier                      sys_membarrier
344     common  mlock2                          sys_mlock2
345     common  copy_file_range                 sys_copy_file_range
346     common  preadv2                         sys_preadv2
347     common  pwritev2                        sys_pwritev2
348     common  pkey_mprotect                   sys_pkey_mprotect
349     common  pkey_alloc                      sys_pkey_alloc
350     common  pkey_free                       sys_pkey_free
351     common  statx                           sys_statx
352     common  rseq                            sys_rseq
# 353 through 402 are unassigned to sync up with generic numbers
403     common  clock_gettime64                 sys_clock_gettime
404     common  clock_settime64                 sys_clock_settime
405     common  clock_adjtime64                 sys_clock_adjtime
406     common  clock_getres_time64             sys_clock_getres
407     common  clock_nanosleep_time64          sys_clock_nanosleep
408     common  timer_gettime64                 sys_timer_gettime
409     common  timer_settime64                 sys_timer_settime
410     common  timerfd_gettime64               sys_timerfd_gettime
411     common  timerfd_settime64               sys_timerfd_settime
412     common  utimensat_time64                sys_utimensat
413     common  pselect6_time64                 sys_pselect6
414     common  ppoll_time64                    sys_ppoll
416     common  io_pgetevents_time64            sys_io_pgetevents
417     common  recvmmsg_time64                 sys_recvmmsg
418     common  mq_timedsend_time64             sys_mq_timedsend
419     common  mq_timedreceive_time64          sys_mq_timedreceive
420     common  semtimedop_time64               sys_semtimedop
421     common  rt_sigtimedwait_time64          sys_rt_sigtimedwait
422     common  futex_time64                    sys_futex
423     common  sched_rr_get_interval_time64    sys_sched_rr_get_interval
424     common  pidfd_send_signal               sys_pidfd_send_signal
425     common  io_uring_setup                  sys_io_uring_setup
426     common  io_uring_enter                  sys_io_uring_enter
427     common  io_uring_register               sys_io_uring_register
428     common  open_tree                       sys_open_tree
429     common  move_mount                      sys_move_mount
430     common  fsopen                          sys_fsopen
431     common  fsconfig                        sys_fsconfig
432     common  fsmount                         sys_fsmount
433     common  fspick                          sys_fspick
434     common  pidfd_open                      sys_pidfd_open
435     common  clone3                          sys_clone3
436     common  close_range                     sys_close_range
437     common  openat2                         sys_openat2
438     common  pidfd_getfd                     sys_pidfd_getfd
439     common  faccessat2                      sys_faccessat2
440     common  process_madvise                 sys_process_madvise
441     common  epoll_pwait2                    sys_epoll_pwait2
442     common  mount_setattr                   sys_mount_setattr
443     common  quotactl_fd                     sys_quotactl_fd
444     common  landlock_create_ruleset         sys_landlock_create_ruleset
445     common  landlock_add_rule               sys_landlock_add_rule
446     common  landlock_restrict_self          sys_landlock_restrict_self
# 447 reserved for memfd_secret
448     common  process_mrelease                sys_process_mrelease
449     common  futex_waitv                     sys_futex_waitv
450     common  set_mempolicy_home_node         sys_set_mempolicy_home_node
"""

# CRIS
# [How to make]
# cd /path/to/linux-4.16.18/
# awk '/sys_call_table:/,/^$/' arch/cris/arch-v10/kernel/entry.S \
# | grep -o "\.long \w*" | nl -v0 | awk '{print $1" cris "substr($3,5)" "$3}' |column -t
cris_syscall_tbl = """
0    cris  restart_syscall         sys_restart_syscall
1    cris  exit                    sys_exit
2    cris  fork                    sys_fork
3    cris  read                    sys_read
4    cris  write                   sys_write
5    cris  open                    sys_open
6    cris  close                   sys_close
7    cris  waitpid                 sys_waitpid
8    cris  creat                   sys_creat
9    cris  link                    sys_link
10   cris  unlink                  sys_unlink
11   cris  execve                  sys_execve
12   cris  chdir                   sys_chdir
13   cris  time                    sys_time
14   cris  mknod                   sys_mknod
15   cris  chmod                   sys_chmod
16   cris  lchown16                sys_lchown16
17   cris  ni_syscall              sys_ni_syscall
18   cris  stat                    sys_stat
19   cris  lseek                   sys_lseek
20   cris  getpid                  sys_getpid
21   cris  mount                   sys_mount
22   cris  oldumount               sys_oldumount
23   cris  setuid16                sys_setuid16
24   cris  getuid16                sys_getuid16
25   cris  stime                   sys_stime
26   cris  ptrace                  sys_ptrace
27   cris  alarm                   sys_alarm
28   cris  fstat                   sys_fstat
29   cris  pause                   sys_pause
30   cris  utime                   sys_utime
31   cris  ni_syscall              sys_ni_syscall
32   cris  ni_syscall              sys_ni_syscall
33   cris  access                  sys_access
34   cris  nice                    sys_nice
35   cris  ni_syscall              sys_ni_syscall
36   cris  sync                    sys_sync
37   cris  kill                    sys_kill
38   cris  rename                  sys_rename
39   cris  mkdir                   sys_mkdir
40   cris  rmdir                   sys_rmdir
41   cris  dup                     sys_dup
42   cris  pipe                    sys_pipe
43   cris  times                   sys_times
44   cris  ni_syscall              sys_ni_syscall
45   cris  brk                     sys_brk
46   cris  setgid16                sys_setgid16
47   cris  getgid16                sys_getgid16
48   cris  signal                  sys_signal
49   cris  geteuid16               sys_geteuid16
50   cris  getegid16               sys_getegid16
51   cris  acct                    sys_acct
52   cris  umount                  sys_umount
53   cris  ni_syscall              sys_ni_syscall
54   cris  ioctl                   sys_ioctl
55   cris  fcntl                   sys_fcntl
56   cris  ni_syscall              sys_ni_syscall
57   cris  setpgid                 sys_setpgid
58   cris  ni_syscall              sys_ni_syscall
59   cris  ni_syscall              sys_ni_syscall
60   cris  umask                   sys_umask
61   cris  chroot                  sys_chroot
62   cris  ustat                   sys_ustat
63   cris  dup2                    sys_dup2
64   cris  getppid                 sys_getppid
65   cris  getpgrp                 sys_getpgrp
66   cris  setsid                  sys_setsid
67   cris  sigaction               sys_sigaction
68   cris  sgetmask                sys_sgetmask
69   cris  ssetmask                sys_ssetmask
70   cris  setreuid16              sys_setreuid16
71   cris  setregid16              sys_setregid16
72   cris  sigsuspend              sys_sigsuspend
73   cris  sigpending              sys_sigpending
74   cris  sethostname             sys_sethostname
75   cris  setrlimit               sys_setrlimit
76   cris  old_getrlimit           sys_old_getrlimit
77   cris  getrusage               sys_getrusage
78   cris  gettimeofday            sys_gettimeofday
79   cris  settimeofday            sys_settimeofday
80   cris  getgroups16             sys_getgroups16
81   cris  setgroups16             sys_setgroups16
82   cris  select                  sys_select
83   cris  symlink                 sys_symlink
84   cris  lstat                   sys_lstat
85   cris  readlink                sys_readlink
86   cris  uselib                  sys_uselib
87   cris  swapon                  sys_swapon
88   cris  reboot                  sys_reboot
89   cris  old_readdir             sys_old_readdir
90   cris  old_mmap                sys_old_mmap
91   cris  munmap                  sys_munmap
92   cris  truncate                sys_truncate
93   cris  ftruncate               sys_ftruncate
94   cris  fchmod                  sys_fchmod
95   cris  fchown16                sys_fchown16
96   cris  getpriority             sys_getpriority
97   cris  setpriority             sys_setpriority
98   cris  ni_syscall              sys_ni_syscall
99   cris  statfs                  sys_statfs
100  cris  fstatfs                 sys_fstatfs
101  cris  ni_syscall              sys_ni_syscall
102  cris  socketcall              sys_socketcall
103  cris  syslog                  sys_syslog
104  cris  setitimer               sys_setitimer
105  cris  getitimer               sys_getitimer
106  cris  newstat                 sys_newstat
107  cris  newlstat                sys_newlstat
108  cris  newfstat                sys_newfstat
109  cris  ni_syscall              sys_ni_syscall
110  cris  ni_syscall              sys_ni_syscall
111  cris  vhangup                 sys_vhangup
112  cris  ni_syscall              sys_ni_syscall
113  cris  ni_syscall              sys_ni_syscall
114  cris  wait4                   sys_wait4
115  cris  swapoff                 sys_swapoff
116  cris  sysinfo                 sys_sysinfo
117  cris  ipc                     sys_ipc
118  cris  fsync                   sys_fsync
119  cris  sigreturn               sys_sigreturn
120  cris  clone                   sys_clone
121  cris  setdomainname           sys_setdomainname
122  cris  newuname                sys_newuname
123  cris  ni_syscall              sys_ni_syscall
124  cris  adjtimex                sys_adjtimex
125  cris  mprotect                sys_mprotect
126  cris  sigprocmask             sys_sigprocmask
127  cris  ni_syscall              sys_ni_syscall
128  cris  init_module             sys_init_module
129  cris  delete_module           sys_delete_module
130  cris  ni_syscall              sys_ni_syscall
131  cris  quotactl                sys_quotactl
132  cris  getpgid                 sys_getpgid
133  cris  fchdir                  sys_fchdir
134  cris  bdflush                 sys_bdflush
135  cris  sysfs                   sys_sysfs
136  cris  personality             sys_personality
137  cris  ni_syscall              sys_ni_syscall
138  cris  setfsuid16              sys_setfsuid16
139  cris  setfsgid16              sys_setfsgid16
140  cris  llseek                  sys_llseek
141  cris  getdents                sys_getdents
142  cris  select                  sys_select
143  cris  flock                   sys_flock
144  cris  msync                   sys_msync
145  cris  readv                   sys_readv
146  cris  writev                  sys_writev
147  cris  getsid                  sys_getsid
148  cris  fdatasync               sys_fdatasync
149  cris  sysctl                  sys_sysctl
150  cris  mlock                   sys_mlock
151  cris  munlock                 sys_munlock
152  cris  mlockall                sys_mlockall
153  cris  munlockall              sys_munlockall
154  cris  sched_setparam          sys_sched_setparam
155  cris  sched_getparam          sys_sched_getparam
156  cris  sched_setscheduler      sys_sched_setscheduler
157  cris  sched_getscheduler      sys_sched_getscheduler
158  cris  sched_yield             sys_sched_yield
159  cris  sched_get_priority_max  sys_sched_get_priority_max
160  cris  sched_get_priority_min  sys_sched_get_priority_min
161  cris  sched_rr_get_interval   sys_sched_rr_get_interval
162  cris  nanosleep               sys_nanosleep
163  cris  mremap                  sys_mremap
164  cris  setresuid16             sys_setresuid16
165  cris  getresuid16             sys_getresuid16
166  cris  ni_syscall              sys_ni_syscall
167  cris  ni_syscall              sys_ni_syscall
168  cris  poll                    sys_poll
169  cris  ni_syscall              sys_ni_syscall
170  cris  setresgid16             sys_setresgid16
171  cris  getresgid16             sys_getresgid16
172  cris  prctl                   sys_prctl
173  cris  rt_sigreturn            sys_rt_sigreturn
174  cris  rt_sigaction            sys_rt_sigaction
175  cris  rt_sigprocmask          sys_rt_sigprocmask
176  cris  rt_sigpending           sys_rt_sigpending
177  cris  rt_sigtimedwait         sys_rt_sigtimedwait
178  cris  rt_sigqueueinfo         sys_rt_sigqueueinfo
179  cris  rt_sigsuspend           sys_rt_sigsuspend
180  cris  pread64                 sys_pread64
181  cris  pwrite64                sys_pwrite64
182  cris  chown16                 sys_chown16
183  cris  getcwd                  sys_getcwd
184  cris  capget                  sys_capget
185  cris  capset                  sys_capset
186  cris  sigaltstack             sys_sigaltstack
187  cris  sendfile                sys_sendfile
188  cris  ni_syscall              sys_ni_syscall
189  cris  ni_syscall              sys_ni_syscall
190  cris  vfork                   sys_vfork
191  cris  getrlimit               sys_getrlimit
192  cris  mmap2                   sys_mmap2
193  cris  truncate64              sys_truncate64
194  cris  ftruncate64             sys_ftruncate64
195  cris  stat64                  sys_stat64
196  cris  lstat64                 sys_lstat64
197  cris  fstat64                 sys_fstat64
198  cris  lchown                  sys_lchown
199  cris  getuid                  sys_getuid
200  cris  getgid                  sys_getgid
201  cris  geteuid                 sys_geteuid
202  cris  getegid                 sys_getegid
203  cris  setreuid                sys_setreuid
204  cris  setregid                sys_setregid
205  cris  getgroups               sys_getgroups
206  cris  setgroups               sys_setgroups
207  cris  fchown                  sys_fchown
208  cris  setresuid               sys_setresuid
209  cris  getresuid               sys_getresuid
210  cris  setresgid               sys_setresgid
211  cris  getresgid               sys_getresgid
212  cris  chown                   sys_chown
213  cris  setuid                  sys_setuid
214  cris  setgid                  sys_setgid
215  cris  setfsuid                sys_setfsuid
216  cris  setfsgid                sys_setfsgid
217  cris  pivot_root              sys_pivot_root
218  cris  mincore                 sys_mincore
219  cris  madvise                 sys_madvise
220  cris  getdents64              sys_getdents64
221  cris  fcntl64                 sys_fcntl64
222  cris  ni_syscall              sys_ni_syscall
223  cris  ni_syscall              sys_ni_syscall
224  cris  gettid                  sys_gettid
225  cris  readahead               sys_readahead
226  cris  setxattr                sys_setxattr
227  cris  lsetxattr               sys_lsetxattr
228  cris  fsetxattr               sys_fsetxattr
229  cris  getxattr                sys_getxattr
230  cris  lgetxattr               sys_lgetxattr
231  cris  fgetxattr               sys_fgetxattr
232  cris  listxattr               sys_listxattr
233  cris  llistxattr              sys_llistxattr
234  cris  flistxattr              sys_flistxattr
235  cris  removexattr             sys_removexattr
236  cris  lremovexattr            sys_lremovexattr
237  cris  fremovexattr            sys_fremovexattr
238  cris  tkill                   sys_tkill
239  cris  sendfile64              sys_sendfile64
240  cris  futex                   sys_futex
241  cris  sched_setaffinity       sys_sched_setaffinity
242  cris  sched_getaffinity       sys_sched_getaffinity
243  cris  ni_syscall              sys_ni_syscall
244  cris  ni_syscall              sys_ni_syscall
245  cris  io_setup                sys_io_setup
246  cris  io_destroy              sys_io_destroy
247  cris  io_getevents            sys_io_getevents
248  cris  io_submit               sys_io_submit
249  cris  io_cancel               sys_io_cancel
250  cris  fadvise64               sys_fadvise64
251  cris  ni_syscall              sys_ni_syscall
252  cris  exit_group              sys_exit_group
253  cris  lookup_dcookie          sys_lookup_dcookie
254  cris  epoll_create            sys_epoll_create
255  cris  epoll_ctl               sys_epoll_ctl
256  cris  epoll_wait              sys_epoll_wait
257  cris  remap_file_pages        sys_remap_file_pages
258  cris  set_tid_address         sys_set_tid_address
259  cris  timer_create            sys_timer_create
260  cris  timer_settime           sys_timer_settime
261  cris  timer_gettime           sys_timer_gettime
262  cris  timer_getoverrun        sys_timer_getoverrun
263  cris  timer_delete            sys_timer_delete
264  cris  clock_settime           sys_clock_settime
265  cris  clock_gettime           sys_clock_gettime
266  cris  clock_getres            sys_clock_getres
267  cris  clock_nanosleep         sys_clock_nanosleep
268  cris  statfs64                sys_statfs64
269  cris  fstatfs64               sys_fstatfs64
270  cris  tgkill                  sys_tgkill
271  cris  utimes                  sys_utimes
272  cris  fadvise64_64            sys_fadvise64_64
273  cris  ni_syscall              sys_ni_syscall
274  cris  ni_syscall              sys_ni_syscall
275  cris  ni_syscall              sys_ni_syscall
276  cris  ni_syscall              sys_ni_syscall
277  cris  mq_open                 sys_mq_open
278  cris  mq_unlink               sys_mq_unlink
279  cris  mq_timedsend            sys_mq_timedsend
280  cris  mq_timedreceive         sys_mq_timedreceive
281  cris  mq_notify               sys_mq_notify
282  cris  mq_getsetattr           sys_mq_getsetattr
283  cris  ni_syscall              sys_ni_syscall
284  cris  waitid                  sys_waitid
285  cris  ni_syscall              sys_ni_syscall
286  cris  add_key                 sys_add_key
287  cris  request_key             sys_request_key
288  cris  keyctl                  sys_keyctl
289  cris  ioprio_set              sys_ioprio_set
290  cris  ioprio_get              sys_ioprio_get
291  cris  inotify_init            sys_inotify_init
292  cris  inotify_add_watch       sys_inotify_add_watch
293  cris  inotify_rm_watch        sys_inotify_rm_watch
294  cris  migrate_pages           sys_migrate_pages
295  cris  openat                  sys_openat
296  cris  mkdirat                 sys_mkdirat
297  cris  mknodat                 sys_mknodat
298  cris  fchownat                sys_fchownat
299  cris  futimesat               sys_futimesat
300  cris  fstatat64               sys_fstatat64
301  cris  unlinkat                sys_unlinkat
302  cris  renameat                sys_renameat
303  cris  linkat                  sys_linkat
304  cris  symlinkat               sys_symlinkat
305  cris  readlinkat              sys_readlinkat
306  cris  fchmodat                sys_fchmodat
307  cris  faccessat               sys_faccessat
308  cris  pselect6                sys_pselect6
309  cris  ppoll                   sys_ppoll
310  cris  unshare                 sys_unshare
311  cris  set_robust_list         sys_set_robust_list
312  cris  get_robust_list         sys_get_robust_list
313  cris  splice                  sys_splice
314  cris  sync_file_range         sys_sync_file_range
315  cris  tee                     sys_tee
316  cris  vmsplice                sys_vmsplice
317  cris  move_pages              sys_move_pages
318  cris  getcpu                  sys_getcpu
319  cris  epoll_pwait             sys_epoll_pwait
320  cris  utimensat               sys_utimensat
321  cris  signalfd                sys_signalfd
322  cris  timerfd_create          sys_timerfd_create
323  cris  eventfd                 sys_eventfd
324  cris  fallocate               sys_fallocate
325  cris  timerfd_settime         sys_timerfd_settime
326  cris  timerfd_gettime         sys_timerfd_gettime
327  cris  signalfd4               sys_signalfd4
328  cris  eventfd2                sys_eventfd2
329  cris  epoll_create1           sys_epoll_create1
330  cris  dup3                    sys_dup3
331  cris  pipe2                   sys_pipe2
332  cris  inotify_init1           sys_inotify_init1
333  cris  preadv                  sys_preadv
334  cris  pwritev                 sys_pwritev
335  cris  setns                   sys_setns
336  cris  name_to_handle_at       sys_name_to_handle_at
337  cris  open_by_handle_at       sys_open_by_handle_at
338  cris  rt_tgsigqueueinfo       sys_rt_tgsigqueueinfo
339  cris  perf_event_open         sys_perf_event_open
340  cris  recvmmsg                sys_recvmmsg
341  cris  accept4                 sys_accept4
342  cris  fanotify_init           sys_fanotify_init
343  cris  fanotify_mark           sys_fanotify_mark
344  cris  prlimit64               sys_prlimit64
345  cris  clock_adjtime           sys_clock_adjtime
346  cris  syncfs                  sys_syncfs
347  cris  sendmmsg                sys_sendmmsg
348  cris  process_vm_readv        sys_process_vm_readv
349  cris  process_vm_writev       sys_process_vm_writev
350  cris  kcmp                    sys_kcmp
351  cris  finit_module            sys_finit_module
352  cris  sched_setattr           sys_sched_setattr
353  cris  sched_getattr           sys_sched_getattr
354  cris  renameat2               sys_renameat2
355  cris  seccomp                 sys_seccomp
356  cris  getrandom               sys_getrandom
357  cris  memfd_create            sys_memfd_create
358  cris  bpf                     sys_bpf
359  cris  execveat                sys_execveat
"""


def parse_syscall_table_defs(table_defs):
    table = []
    for line in table_defs.splitlines():
        if line == "":
            continue
        if line.startswith("#"):
            continue
        entry = line.split()
        if len(entry) == 3: # it is unimplemented
            continue
        entry[0] = int(entry[0])
        table.append(entry)
    return table


# ARM/ARM64 OP-TEE (at secure world)
# - core/include/tee/tee_svc.h
# - core/include/tee/tee_svc_cryp.h
# - core/include/tee/tee_svc_storage.h
# - core/include/tee/svc_cache.h
arm_OPTEE_syscall_list = [
    [0x00, 'syscall_sys_return', ['unsigned long ret']],
    [0x01, 'syscall_log', ['const void *buf', 'size_t len']],
    [0x02, 'syscall_panic', ['unsigned long code']],
    [0x03, 'syscall_get_property', ['unsigned long prop_set', 'unsigned long index', 'void *name', 'uint32_t *name_len', 'void *buf', 'uint32_t *blen', 'uint32_t *prop_type']],
    [0x04, 'syscall_get_property_name_to_index', ['unsigned long prop_set', 'void *name', 'unsigned long name_len', 'uint32_t *index']],
    [0x05, 'syscall_open_ta_session', ['const TEE_UUID *dest', 'unsigned long cancel_req_to', 'struct utee_params *params', 'uint32_t *sess', 'uint32_t *ret_orig']],
    [0x06, 'syscall_close_ta_session', ['unsigned long sess']],
    [0x07, 'syscall_invoke_ta_command', ['unsigned long sess', 'unsigned long cancel_req_to', 'unsigned long cmd_id', 'struct utee_params *params', 'uint32_t *ret_orig']],
    [0x08, 'syscall_check_access_rights', ['unsigned long flags', 'const void *buf', 'size_t len']],
    [0x09, 'syscall_get_cancellation_flag', ['uint32_t *cancel', ]],
    [0x0a, 'syscall_unmask_cancellation', ['uint32_t *old_mask']],
    [0x0b, 'syscall_mask_cancellation', ['uint32_t *old_mask']],
    [0x0c, 'syscall_wait', ['unsigned long timeout']],
    [0x0d, 'syscall_get_time', ['unsigned long cat', 'TEE_Time *time']],
    [0x0e, 'syscall_set_ta_time', ['const TEE_Time *time']],
    [0x0f, 'syscall_cryp_state_alloc', ['unsigned long algo', 'unsigned long op_mode', 'unsigned long key1', 'unsigned long key2', 'uint32_t *state']],
    [0x10, 'syscall_cryp_state_copy', ['unsigned long dst', 'unsigned long src']],
    [0x11, 'syscall_cryp_state_free', ['unsigned long state']],
    [0x12, 'syscall_hash_init', ['unsigned long state', 'const void *iv', 'size_t iv_len']],
    [0x13, 'syscall_hash_update', ['unsigned long state', 'const void *chunk', 'size_t chunk_size']],
    [0x14, 'syscall_hash_final', ['unsigned long state', 'const void *chunk', 'size_t chunk_size', 'void *hash', 'uint64_t *hash_len']],
    [0x15, 'syscall_cipher_init', ['unsigned long state', 'const void *iv', 'size_t iv_len']],
    [0x16, 'syscall_cipher_update', ['unsigned long state', 'const void *src', 'size_t src_len', 'void *dest', 'uint64_t *dest_len']],
    [0x17, 'syscall_cipher_final', ['unsigned long state', 'const void *src', 'size_t src_len', 'void *dest', 'uint64_t *dest_len']],
    [0x18, 'syscall_cryp_obj_get_info', ['unsigned long obj', 'TEE_ObjectInfo *info']],
    [0x19, 'syscall_cryp_obj_restrict_usage', ['unsigned long obj', 'unsigned long usage']],
    [0x1a, 'syscall_cryp_obj_get_attr', ['unsigned long obj', 'unsigned long attr_id', 'void *buffer', 'uint64_t *size']],
    [0x1b, 'syscall_cryp_obj_alloc', ['unsigned long obj_type', 'unsigned long max_key_size', 'uint32_t *obj']],
    [0x1c, 'syscall_cryp_obj_close', ['unsigned long obj']],
    [0x1d, 'syscall_cryp_obj_reset', ['unsigned long obj']],
    [0x1e, 'syscall_cryp_obj_populate', ['unsigned long obj', 'struct utee_attribute *attrs', 'unsigned long attr_count']],
    [0x1f, 'syscall_cryp_obj_copy', ['unsigned long dst_obj', 'unsigned long src_obj']],
    [0x20, 'syscall_cryp_derive_key', ['unsigned long state', 'const struct utee_attribute *params', 'unsigned long param_count', 'unsigned long derived_key']],
    [0x21, 'syscall_cryp_random_number_generate', ['void *buf', 'size_t blen']],
    [0x22, 'syscall_authenc_init', ['unsigned long state', 'const void *nonce', 'size_t nonce_len', 'size_t tag_len', 'size_t aad_len', 'size_t payload_len']],
    [0x23, 'syscall_authenc_update_aad', ['unsigned long state', 'const void *aad_data', 'size_t aad_data_len']],
    [0x24, 'syscall_authenc_update_payload', ['unsigned long state', 'const void *src_data', 'size_t src_len', 'void *dest_data', 'uint64_t *dest_len']],
    [0x25, 'syscall_authenc_enc_final', ['unsigned long state', 'const void *src_data', 'size_t src_len', 'void *dest_data', 'uint64_t *dest_len', 'void *tag', 'uint64_t *tag_len']],
    [0x26, 'syscall_authenc_dec_final', ['unsigned long state', 'const void *src_data', 'size_t src_len', 'void *dest_data', 'uint64_t *dest_len', 'const void *tag', 'uint64_t *tag_len']],
    [0x27, 'syscall_asymm_operate', ['unsigned long state', 'const struct utee_attribute *usr_params', 'size_t num_params', 'const void *src_data', 'size_t src_len', 'void *dest_data', 'uint64_t *dest_len']],
    [0x28, 'syscall_asymm_verify', ['unsigned long state', 'const struct utee_attribute *usr_params', 'size_t num_params', 'const void *data', 'size_t data_len', 'const void *sig', 'size_t sig_len']],
    [0x29, 'syscall_storage_obj_open', ['unsigned long storage_id', 'void *object_id', 'size_t object_id_len', 'unsigned long flags', 'uint32_t *obj']],
    [0x2a, 'syscall_storage_obj_create', ['unsigned long storage_id', 'void *object_id', 'size_t object_id_len', 'unsigned long flags', 'unsigned long attr', 'void *data', 'size_t len', 'uint32_t *obj']],
    [0x2b, 'syscall_storage_obj_del', ['unsigned long obj']],
    [0x2c, 'syscall_storage_obj_rename', ['unsigned long obj', 'void *object_id', 'size_t object_id_len']],
    [0x2d, 'syscall_storage_alloc_enum', ['uint32_t *obj_enum']],
    [0x2e, 'syscall_storage_free_enum', ['nsigned long obj_enum']],
    [0x2f, 'syscall_storage_reset_enum', ['unsigned long obj_enum']],
    [0x30, 'syscall_storage_start_enum', ['unsigned long obj_enum', 'unsigned long storage_id']],
    [0x31, 'syscall_storage_next_enum', ['unsigned long obj_enum', 'TEE_ObjectInfo *info', 'void *obj_id', 'uint64_t *len']],
    [0x32, 'syscall_storage_obj_read', ['unsigned long obj', 'void *data', 'size_t len', 'uint64_t *count']],
    [0x33, 'syscall_storage_obj_write', ['unsigned long obj', 'void *data', 'size_t len']],
    [0x34, 'syscall_storage_obj_trunc', ['unsigned long obj, size_t len']],
    [0x35, 'syscall_storage_obj_seek', ['unsigned long obj', 'int32_t offset', 'unsigned long whence']],
    [0x36, 'syscall_obj_generate_key', ['unsigned long obj', 'unsigned long key_size', 'const struct utee_attribute *params', 'unsigned long param_count']],
    [0x37, 'syscall_not_supported', []],
    [0x38, 'syscall_not_supported', []],
    [0x39, 'syscall_not_supported', []],
    [0x3a, 'syscall_not_supported', []],
    [0x3b, 'syscall_not_supported', []],
    [0x3c, 'syscall_not_supported', []],
    [0x3d, 'syscall_not_supported', []],
    [0x3e, 'syscall_not_supported', []],
    [0x3f, 'syscall_not_supported', []],
    [0x40, 'syscall_not_supported', []],
    [0x41, 'syscall_not_supported', []],
    [0x42, 'syscall_not_supported', []],
    [0x43, 'syscall_not_supported', []],
    [0x44, 'syscall_not_supported', []],
    [0x45, 'syscall_not_supported', []],
    [0x46, 'syscall_cache_operation', ['void *va, size_t len', 'unsigned long op']],
]


# ARM/ARM64 OP-TEE ldelf (at secure world)
# - core/include/tee/tee_svc.h
# - core/include/kernel/ldelf_syscalls.h
arm_ldelf_syscall_list = [
    [0x00, 'syscall_sys_return', ['unsigned long ret']],
    [0x01, 'syscall_log', ['const void *buf', 'size_t len']],
    [0x02, 'syscall_panic', ['unsigned long code']],
    [0x03, 'ldelf_syscall_map_zi', ['vaddr_t *va', 'size_t num_bytes', 'size_t pad_begin', 'size_t pad_end', 'unsigned long flags']],
    [0x04, 'ldelf_syscall_unmap', ['vaddr_t va', 'size_t num_bytes']],
    [0x05, 'ldelf_syscall_open_bin', ['const TEE_UUID *uuid', 'size_t uuid_size', 'uint32_t *handle']],
    [0x06, 'ldelf_syscall_close_bin', ['unsigned long handle']],
    [0x07, 'ldelf_syscall_map_bin', ['vaddr_t *va', 'size_t num_bytes', 'unsigned long handle', 'size_t offs_bytes', 'size_t pad_begin', 'size_t pad_end', 'unsigned long flags']],
    [0x08, 'ldelf_syscall_copy_from_bin', ['void *dst', 'size_t offs', 'size_t num_bytes', 'unsigned long handle']],
    [0x09, 'ldelf_syscall_set_prot', ['unsigned long va', 'size_t num_bytes', 'unsigned long flags']],
    [0x0a, 'ldelf_syscall_remap', ['unsigned long old_va', 'addr_t *new_va', 'size_t num_bytes', 'size_t pad_begin', 'size_t pad_end']],
    [0x0b, 'ldelf_syscall_gen_rnd_num', ['void *buf', 'size_t num_bytes']],
]


# This cache is not cleared when reset_gef_cache() is run.
cached_syscall_table = {}


def get_syscall_table(arch=None, mode=None):

    def is_emulated32():
        if is_qemu_usermode():
            # This case cannot be determined
            return False

        if is_qemu_system():
            # corner case (ex: using qemu-system-x86_64, but process is executed as 32bit mode)
            # is not able to be detected
            return True

        for m in get_process_maps():
            # native x86:
            # 0xbffdf000 0xc0000000 0x021000 0x000000 rw- [stack]
            # emulated x86 on x86_64
            # 0xfffdd000 0xffffe000 0x021000 0x000000 rw- [stack]
            # native arm:
            # 0xbefdf000 0xbf000000 0x021000 0x000000 rw- [stack]
            # emulated arm on aarch64
            # 0xfffcf000 0xffff0000 0x021000 0x000000 rw- [stack]
            if m.path == "[stack]":
                return (m.page_start >> 28) == 0xf
        else:
            return False # by default it considers on native

    def is_secure():
        scr = get_register("$SCR" if is_arm32() else "$SCR_EL3")
        if scr is None:
            return False
        return (scr & 0b1) == 0

    if arch is None and mode is None :
        if is_x86_64():
            arch, mode = "X86", "64"
        elif is_x86_32():
            if is_emulated32():
                arch, mode = "X86", "Emulated-32"
            else:
                arch, mode = "X86", "Native-32"
        elif is_arm64():
            if is_secure():
                arch, mode = "ARM64", "Secure-World"
            else:
                arch, mode = "ARM64", "ARM"
        elif is_arm32():
            if is_secure():
                arch, mode = "ARM", "Secure-World"
            elif is_emulated32():
                arch, mode = "ARM", "Emulated-32"
            else:
                arch, mode = "ARM", "Native-32"
        else:
            arch = current_arch.arch
            mode = current_arch.mode

    if arch in ["ARM", "ARM64"] and mode == "S":
        mode = "Secure-World"
    if arch in ["X86", "ARM"] and mode == "32":
        mode = "Emulated-32"
    elif arch in ["X86", "ARM"] and mode == "N32":
        mode = "Native-32"

    global cached_syscall_table
    if (arch, mode) in cached_syscall_table:
        return cached_syscall_table[arch, mode]

    if arch == "X86" and mode == "64":
        register_list = X86_64().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(x64_syscall_tbl)
        arch_specific_dic = {
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'int __user *child_tidptr', 'unsigned long tls',
            ], # kernel/fork.c
            'sys_modify_ldt': [
                'int func', 'void __user *ptr', 'unsigned long bytecount',
            ], # arch/x86/kernel/ldt.c
            'sys_arch_prctl': [
                'int option', 'unsigned long arg2',
            ], # arch/x86/kernel/process_64.c
            'sys_iopl': [
                'unsigned int level',
            ], # arch/x86/kernel/ioport.c
            'compat_sys_x32_rt_sigreturn': [], # arch/x86/kernel/signal.c
            'sys_mmap': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long off',
            ], # arch/x86/kernel/sys_x86_64.c
            'sys_rt_sigreturn': [], # arch/x86/kernel/signal.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry
            if abi not in ["common", "64", "x32"]:
                continue
            # special case
            if func in arch_specific_dic:
                if abi in ["common", "64"]:
                    syscall_list.append([nr, name, arch_specific_dic[func]])
                if abi in ["common", "x32"]:
                    syscall_list.append([nr + 0x40000000, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            if abi in ["common", "64"]:
                syscall_list.append([nr, name, sc_def[func]])
            if abi in ["common", "x32"]:
                syscall_list.append([nr + 0x40000000, name, sc_def[func]])

    elif arch == "X86" and mode == "Emulated-32":
        register_list = X86().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(x86_syscall_tbl)
        arch_specific_dic = {
            'compat_sys_sigreturn': [], # arch/x86/ia32/ia32_signal.c
            'compat_sys_rt_sigreturn': [], # arch/x86/ia32/ia32_signal.c
            'compat_sys_old_getrlimit': [
                'unsigned int resource', 'struct compat_rlimit *rlim',
            ], # kernel/sys.c
            'compat_sys_ia32_mmap': [
                'struct mmap_arg_struct32 __user *arg',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_iopl': [
                'unsigned int level',
            ], # arch/x86/kernel/ioport.c
            'compat_sys_ia32_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls_val', 'int __user *child_tidptr',
            ], # arch/x86/kernel/sys_ia32.c (CONFIG_CLONE_BACKWARDS)
            'sys_modify_ldt': [
                'int func', 'void __user *ptr', 'unsigned long bytecount',
            ], # arch/x86/kernel/ldt.c
            'sys_ia32_pread64': [
                'unsigned int fd', 'char __user *ubuf', 'u32 count', 'u32 poslo', 'u32 poshi',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_pwrite64': [
                'unsigned int fd', 'const char __user *ubuf', 'u32 count', 'u32 poslo', 'u32 poshi',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_truncate64': [
                'const char __user *filename', 'unsigned long offset_low', 'unsigned long offset_high',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_ftruncate64': [
                'unsigned int fd', 'unsigned long offset_low', 'unsigned long offset_high',
            ], # arch/x86/kernel/sys_ia32.c
            'compat_sys_ia32_stat64': [
                'const char __user *filename', 'struct stat64 __user *statbuf',
            ], # arch/x86/kernel/sys_ia32.c
            'compat_sys_ia32_lstat64': [
                'const char __user *filename', 'struct stat64 __user *statbuf',
            ], # arch/x86/kernel/sys_ia32.c
            'compat_sys_ia32_fstat64': [
                'unsigned long fd', 'struct stat64 __user *statbuf',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_readahead': [
                'int fd', 'unsigned int off_lo', 'unsigned int off_high', 'size_t count',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_set_thread_area': [
                'struct user_desc __user * u_info',
            ], # arch/x86/kernel/tls.c
            'sys_get_thread_area': [
                'struct user_desc __user * u_info',
            ], # arch/x86/kernel/tls.c
            'sys_ia32_fadvise64': [
                'int fd', 'unsigned int offset_lo', 'unsigned int offset_hi', 'size_t len', 'int advice',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_fadvise64_64': [
                'int fd', '__u32 offset_low', '__u32 offset_high', '__u32 len_low', '__u32 len_high', 'int advice',
            ], # arch/x86/kernel/sys_ia32.c
            'compat_sys_ia32_fstatat64': [
                'unsigned int dfd', 'const char __user *filename', 'struct stat64 __user *statbuf', 'int flag',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_sync_file_range': [
                'int fd', 'unsigned int off_low', 'unsigned int off_hi', 'unsigned int n_low',
                'unsigned int n_hi', 'unsigned int flags',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_fallocate': [
                'int fd', 'int mode', 'unsigned int offset_lo', 'unsigned int offset_hi',
                'unsigned int len_lo', 'unsigned int len_hi',
            ], # arch/x86/kernel/sys_ia32.c
            'compat_sys_arch_prctl': [
                'int option', 'unsigned long arg2',
            ], # arch/x86/kernel/process_64.c
        }

        syscall_list = []
        for entry in tbl:
            if len(entry) == 5:
                nr, abi, name, _, func = entry # use compat
            else:
                nr, abi, name, func = entry
            if abi != "i386":
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "X86" and mode == "Native-32":
        register_list = X86().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(x86_syscall_tbl)
        arch_specific_dic = {
            'sys_iopl': [
                'unsigned int level',
            ], # arch/x86/kernel/ioport.c
            'sys_vm86old': [
                'struct vm86_struct __user *user_vm86',
            ], # arch/x86/kernel/vm86_32.c
            'sys_sigreturn': [], # arch/x86/kernel/signal.c
            'sys_rt_sigreturn': [], # arch/x86/kernel/signal.c
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls', 'int *child_tidptr',
            ], # kernel/fork.c (CONFIG_CLONE_BACKWARDS)
            'sys_modify_ldt': [
                'int func', 'void __user *ptr', 'unsigned long bytecount',
            ], # arch/x86/kernel/ldt.c
            'sys_vm86': [
                'unsigned long cmd', 'unsigned long arg',
            ], # arch/x86/kernel/vm86_32.c
            'sys_ia32_pread64': [
                'unsigned int fd', 'char __user *ubuf', 'u32 count', 'u32 poslo', 'u32 poshi',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_pwrite64': [
                'unsigned int fd', 'const char __user *ubuf', 'u32 count', 'u32 poslo', 'u32 poshi',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_truncate64': [
                'const char __user *filename', 'unsigned long offset_low', 'unsigned long offset_high',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_ftruncate64': [
                'unsigned int fd', 'unsigned long offset_low', 'unsigned long offset_high',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_readahead': [
                'int fd', 'unsigned int off_lo', 'unsigned int off_high', 'size_t count',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_set_thread_area': [
                'struct user_desc __user * u_info',
            ], # arch/x86/kernel/tls.c
            'sys_get_thread_area': [
                'struct user_desc __user * u_info',
            ], # arch/x86/kernel/tls.c
            'sys_ia32_fadvise64': [
                'int fd', 'unsigned int offset_lo', 'unsigned int offset_hi', 'size_t len', 'int advice',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_fadvise64_64': [
                'int fd', '__u32 offset_low', '__u32 offset_high', '__u32 len_low', '__u32 len_high', 'int advice',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_sync_file_range': [
                'int fd', 'unsigned int off_low', 'unsigned int off_hi', 'unsigned int n_low',
                'unsigned int n_hi', 'unsigned int flags',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_fallocate': [
                'int fd', 'int mode', 'unsigned int offset_lo', 'unsigned int offset_hi',
                'unsigned int len_lo', 'unsigned int len_hi',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_arch_prctl': [
                'int option', 'unsigned long arg2',
            ], # arch/x86/kernel/process_32.c
        }

        syscall_list = []
        for entry in tbl:
            if len(entry) == 5:
                nr, abi, name, func, _ = entry # dont use compat
            else:
                nr, abi, name, func = entry
            if abi != "i386":
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "ARM64" and mode == "ARM":
        register_list = AARCH64().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(arm64_syscall_tbl)
        arch_specific_dic = {
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls', 'int __user *child_tidptr',
            ], # kernel/fork.c (CONFIG_CLONE_BACKWARDS)
            'sys_rt_sigreturn': [], # arch/arm64/kernel/signal.c
            'sys_mmap': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long off',
            ], # arch/arm64/kernel/sys.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry
            if abi != "arm64":
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "ARM" and mode == "Emulated-32": # support EABI only
        register_list = ARM().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(arm_compat_syscall_tbl)
        arch_specific_dic = {
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls', 'int __user *child_tidptr',
            ], # kernel/fork.c (CONFIG_CLONE_BACKWARDS)
            'compat_sys_aarch32_pread64': [
                'unsigned int fd', 'char *buf', 'size_t count', 'u32 __pad', 'arg_u32p(pos)',
            ], # arch/arm64/kernel/sys32.c
            'compat_sys_aarch32_pwrite64': [
                'unsigned int fd', 'const char *buf', 'size_t count', 'u32 __pad', 'arg_u32p(pos)',
            ], # arch/arm64/kernel/sys32.c
            'compat_sys_aarch32_mmap2': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long off_4k',
            ], # arch/arm64/kernel/sys32.c
            'compat_sys_aarch32_truncate64': [
                'const char *path', 'u32 __pad', 'arg_u32p(length)',
            ], # arch/arm64/kernel/sys32.c
            'compat_sys_aarch32_ftruncate64': [
                'unsigned int fd', 'u32 __pad', 'arg_u32p(length)',
            ], # arch/arm64/kernel/sys32.c
            'compat_sys_aarch32_readahead': [
                'int fd', 'u32 __pad', 'arg_u32(offset)', 'size_t count',
            ], # arch/arm64/kernel/sys32.c
            'compat_sys_aarch32_statfs64': [
                'const char *pathname', 'compat_size_t sz', 'struct compat_statfs64 *buf',
            ], # arch/arm64/kernel/sys32.c
            'compat_sys_aarch32_fstatfs64': [
                'unsigned int fd', 'compat_size_t sz', 'struct compat_statfs64 *buf',
            ], # arch/arm64/kernel/sys32.c
            'compat_sys_aarch32_fadvise64_64': [
                'int fd', 'int advice', 'arg_u32p(offset)', 'arg_u32p(len)',
            ], # arch/arm64/kernel/sys32.c
            'compat_sys_aarch32_sync_file_range2': [
                'int fd', 'unsigned int flags', 'arg_u32p(offset)', 'arg_u32p(nbytes)',
            ], # arch/arm64/kernel/sys32.c
            'compat_sys_aarch32_fallocate': [
                'int fd', 'int mode', 'arg_u32p(offset)', 'arg_u32p(len)',
            ], # arch/arm64/kernel/sys32.c
            'compat_sys_old_semctl': [
                'int semid', 'int semnum', 'int cmd', 'int arg',
            ], # ipc/sem.c
            'compat_sys_old_msgctl': [
                'int msqid', 'int cmd', 'void *uptr',
            ], # ipc/msg.c
            'compat_sys_old_shmctl': [
                'int shmid', 'int cmd', 'void *uptr',
            ], # ipc/shm.c
            'compat_sys_sigreturn': [], # arch/arm64/kernel/signal32.c
            'compat_sys_rt_sigreturn': [], # arch/arm64/kernel/signal32.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry
            if abi != "arm":
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

        arch_specific_extra = [
            [0xf0002, 'cacheflush', [
                'unsigned long start', 'unsigned long end', 'int flags',
            ]], # arch/arm64/kernel/sys_compat.c
            [0xf0005, 'set_tls', [
                'unsigned long val',
            ]], # arch/arm64/kernel/sys_compat.c
        ]
        syscall_list += arch_specific_extra

    elif arch == "ARM" and mode == "Native-32": # support EABI only
        register_list = ARM().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(arm_native_syscall_tbl)
        arch_specific_dic = {
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls', 'int __user *child_tidptr',
            ], # kernel/fork.c (CONFIG_CLONE_BACKWARDS)
            'sys_mmap2': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long pgoff',
            ], # include/asm-generic/syscalls.h
            'sys_sigreturn_wrapper': [], # arch/arm/kernel/entry-common.S
            'sys_rt_sigreturn_wrapper': [], # arch/arm/kernel/entry-common.S
            'sys_statfs64_wrapper': [
                'const char __user *path', 'size_t sz', 'struct statfs64 __user *buf',
            ], # arch/arm/kernel/entry-common.S
            'sys_fstatfs64_wrapper': [
                'unsigned int fd', 'size_t sz', 'struct statfs64 __user *buf',
            ], # arch/arm/kernel/entry-common.S
            'sys_arm_fadvise64_64': [
                'int fd', 'int advice', 'loff_t offset', 'loff_t len',
            ] # arch/arm/kernel/sys_arm.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry[:4] # dont use OABI
            if abi not in ["common", "eabi"]:
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

        arch_specific_extra = [
            [0xf0001, 'breakpoint', []], # arch/arm/kernel/traps.c
            [0xf0002, 'cacheflush', [
                'unsigned long start', 'unsigned long end', 'int flags',
            ]], # arch/arm/kernel/traps.c
            [0xf0003, 'usr26', []], # arch/arm/kernel/traps.c
            [0xf0004, 'usr32', []], # arch/arm/kernel/traps.c
            [0xf0005, 'set_tls', [
                'unsigned long val',
            ]], # arch/arm/kernel/traps.c
            [0xf0006, 'get_tls', []], # arch/arm/kernel/traps.c
        ]
        syscall_list += arch_specific_extra

    elif arch in ["ARM64", "ARM"] and mode == "Secure-World":
        if arch == "ARM64":
            register_list = AARCH64().syscall_parameters + ["$x6"] # OPTEE uses 7 args
        else:
            register_list = ARM().syscall_parameters
        syscall_list = arm_OPTEE_syscall_list.copy()

    elif arch == "MIPS" and mode == "MIPS32":
        o32_register_list = MIPS().syscall_parameters_o32
        n32_register_list = MIPS().syscall_parameters_n32
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(mips_o32_syscall_tbl)
        tbl += parse_syscall_table_defs(mips_n32_syscall_tbl)
        arch_specific_dic = {
            # o32
            'sys_syscall': ['...', ], #
            '__sys_fork': [], #
            'sys_rt_sigreturn': [], # arch/mips/kernel/signal.c
            'sysm_pipe': [], # arch/mips/kernel/syscall.c
            'sys_mips_mmap': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'off_t offset',
            ], # arch/mips/kernel/syscall.c
            'sys_sigreturn': [], #
            '__sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls', 'int __user *child_tidptr',
            ], # kernel/fork.c (CONFIG_CLONE_BACKWARDS)
            'sys_cacheflush': [
                'unsigned long addr', 'unsigned long bytes', 'unsigned int cache',
            ], # arch/mips/mm/cache.c
            'sys_cachectl': [
                'char *addr', 'int nbytes', 'int op',
            ], # arch/mips/kernel/syscall.c
            '__sys_sysmips': [
                'long cmd', 'long arg1', 'long arg2',
            ], # arch/mips/kernel/syscall.c
            'sys_mips_mmap2': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long pgoff',
            ], # arch/mips/kernel/syscall.c
            'sys_set_thread_area': [
                'unsigned long addr',
            ], # arch/mips/kernel/syscall.c
            '__sys_clone3': [
                'struct clone_args __user *uargs', 'size_t size',
            ], #
            'sys_sigsuspend': [
                'sigset_t __user *uset',
            ], # arch/mips/kernel/signal.c
            'sys_sigaction': [
                'int sig2', 'const struct sigaction __user *act', 'struct sigaction __user *oact',
            ], # arch/mips/kernel/signal.c
            # n32
            'compat_sys_old_shmctl': [
                'int shmid', 'int cmd', 'void *uptr',
            ], # ipc/shm.c
            'compat_sys_old_semctl': [
                'int semid', 'int semnum', 'int cmd', 'int arg',
            ], # ipc/sem.c
            'compat_sys_old_msgctl': [
                'int msqid', 'int cmd', 'void *uptr',
            ], # ipc/msg.c
            'sys_32_personality': [
                'unsigned long personality',
            ], # arch/mips/kernel/linux32.c
            'sysn32_rt_sigreturn': [], # arch/mips/kernel/signal_n32.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry[:4] # dont use compat
            if abi not in ["o32", "n32"]:
                continue
            if abi == "o32":
                nr += 4000 # arch/mips/include/asm/unistd.h
            elif abi == "n32":
                nr += 6000 # arch/mips/include/asm/unistd.h
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "MIPS" and mode == "MIPS64":
        register_list = MIPS64().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(mips_n64_syscall_tbl)
        arch_specific_dic = {
            'sys_mips_mmap': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'off_t offset',
            ], # arch/mips/kernel/syscall.c
            'sysm_pipe': [], # arch/mips/kernel/syscall.c
            '__sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls', 'int __user *child_tidptr',
            ], # kernel/fork.c (CONFIG_CLONE_BACKWARDS)
            '__sys_fork': [], #
            'sys_rt_sigreturn': [], # arch/mips/kernel/signal.c
            'sys_cacheflush': [
                'unsigned long addr', 'unsigned long bytes', 'unsigned int cache',
            ], # arch/mips/mm/cache.c
            'sys_cachectl': [
                'char *addr', 'int nbytes', 'int op',
            ], # arch/mips/kernel/syscall.c
            '__sys_sysmips': [
                'long cmd', 'long arg1', 'long arg2',
            ], # arch/mips/kernel/syscall.c
            'sys_set_thread_area': [
                'unsigned long addr',
            ], # arch/mips/kernel/syscall.c
            '__sys_clone3': [
                'struct clone_args __user *uargs', 'size_t size',
            ], #
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry[:4] # dont use compat
            if abi != "n64":
                continue
            nr += 5000 # arch/mips/include/asm/unistd.h
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "PPC" and mode == "PPC32":
        register_list = PPC().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(ppc_syscall_tbl)
        arch_specific_dic = {
            'ppc_select': [
                'int n', 'fd_set __user *inp', 'fd_set __user *outp', 'fd_set __user *exp',
                'struct __kernel_old_timeval __user *tvp',
            ], # arch/poerpc/kernel/syscalls.c
            'sys_sigreturn': [], # arch/powerpc/kernel/signal_32.c
            'sys_rt_sigreturn': [], # arch/powerpc/kernel/signal_32.c
            'sys_mmap': [
                'unsigned long addr', 'size_t len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'off_t offset',
            ], # arch/powerpc/kernel/syscalls.c
            'sys_mmap2': [
                'unsigned long addr', 'size_t len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long pgoff',
            ], # arch/powerpc/kernel/syscalls.c
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls', 'int __user *child_tidptr',
            ], # kernel/fork.c (CONFIG_CLONE_BACKWARDS)
            'sys_swapcontext': [
                'struct ucontext __user *old_ctx', 'struct ucontext __user *new_ctx', 'long ctx_size',
            ], # arch/powerpc/kernel/signal_32.c
            'ppc_fadvise64_64': [
                'int fd', 'int advice', 'u32 offset_high', 'u32 offset_low', 'u32 len_high', 'u32 len_low',
            ], # arch/poerpc/kernel/syscalls.c
            'sys_rtas': [
                'struct rtas_args __user *uargs',
            ], # arch/powerpc/include/asm/syscalls.h
            'sys_debug_setcontext': [
                'struct ucontext __user *ctx', 'int ndbg', 'struct sig_dbg_op __user *dbg',
            ], # arch/powerpc/kernel/signal_32.c
            'sys_subpage_prot': [
                'unsigned long addr', 'unsigned long len', 'u32 __user *map',
            ], # arch/powerpc/mm/book3s64/subpage_prot.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry[:4] # dont use compat
            if abi not in ["common", "32", "nospu"]:
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "PPC" and mode == "PPC64":
        register_list = PPC64().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(ppc_syscall_tbl)
        arch_specific_dic = {
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls', 'int __user *child_tidptr',
            ], # kernel/fork.c (CONFIG_CLONE_BACKWARDS)
            'sys_rt_sigreturn': [], # arch/powerpc/kernel/signal_64.c
            'sys_mmap': [
                'unsigned long addr', 'size_t len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'off_t offset',
            ], # arch/powerpc/kernel/syscalls.c
            'sys_mmap2': [
                'unsigned long addr', 'size_t len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long pgoff',
            ], # arch/powerpc/kernel/syscalls.c
            'ppc64_personality': [
                'unsigned long personality',
            ], # arch/powerpc/kernel/syscalls.c
            'sys_swapcontext': [
                'struct ucontext __user *old_ctx', 'struct ucontext __user *new_ctx', 'long ctx_size',
            ], # arch/powerpc/kernel/signal_64.c
            'sys_rtas': [
                'struct rtas_args __user *uargs',
            ], # arch/powerpc/include/asm/syscalls.h
            'sys_subpage_prot': [
                'unsigned long addr', 'unsigned long len', 'u32 __user *map',
            ], # arch/powerpc/mm/book3s64/subpage_prot.c
            'sys_switch_endian': [], # arch/powerpc/kernel/syscalls.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry[:4] # dont use compat
            if abi not in ["common", "64", "nospu"]:
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "SPARC" and mode == "SPARC32":
        register_list = SPARC().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(sparc_syscall_tbl)
        arch_specific_dic = {
            'sys_mmap': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long off'
            ], # arch/sparc/kernel/sys_sparc_32.c
            'sys_mmap2': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long pgoff'
            ], # arch/sparc/kernel/sys_sparc_32.c
            'sunos_execv': [
                'const char __user *filename', 'const char __user *const __user *argv',
                'const char __user *const __user *envp',
            ], # arch/sparc/kernel/entry.S
            'sys_sparc_pipe': [], # arch/sparc/kernel/sys_sparc_32.c
            'sys_getpagesize': [], # arch/sparc/kernel/sys_sparc_32.c
            'sys_getdomainname': [
                'char __user *name', 'int len'
            ], # arch/sparc/kernel/sys_sparc_32.c
            'sys_sparc_remap_file_pages': [
                'unsigned long start', 'unsigned long size', 'unsigned long prot',
                'unsigned long pgoff', 'unsigned long flags',
            ], # kernel/sys_sparc_32.c
            'sys_sparc_sigaction': [
                'int, sig', 'struct old_sigaction __user *act', 'struct old_sigaction __user *oact',
            ], # arch/sparc/kernel/sys_sparc_32.c
            'sys_sigreturn': [], # arch/sparc/kernel/syscalls.S
            'sys_rt_sigreturn': [], # arch/sparc/kernel/syscalls.S
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'int __user *child_tidptr', 'unsigned long tls',
            ], # kernel/fork.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry[:4] # dont use compat
            if abi not in ["common", "32"]:
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func in ['sys_ni_syscall', 'sys_nis_syscall']:
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "SPARC" and mode == "SPARC64":
        register_list = SPARC64().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(sparc_syscall_tbl)
        arch_specific_dic = {
            'sparc_exit': [
                'int error_code',
            ], # arch/sparc/kernel/syscalls.S
            'sys_sparc_pipe': [], # arch/sparc/kernel/sys_sparc_64.c
            'sys_memory_ordering': [
                'unsigned long model',
            ], # arch/sparc/kernel/sys_sparc_64.c
            'sys64_execve': [
                'const char __user *filename', 'const char __user *const __user *argv',
                'const char __user *const __user *envp',
            ], # arch/sparc/kernel/syscalls.S
            'sys_getpagesize': [], # arch/sparc/kernel/sys_sparc_64.c
            'sys_64_munmap': [
                'unsigned long addr', 'size_t len',
            ], # arch/sparc/kernel/sys_sparc_64.c
            'sys_getdomainname': [
                'char __user *name', 'int len'
            ], # arch/sparc/kernel/sys_sparc_64.c
            'sys_utrap_install': [
                'utrap_entry_t type', 'utrap_handler_t new_p', 'utrap_handler_t new_d',
                'utrap_handler_t __user * old_p', 'utrap_handler_t __user *old_d',
            ], # arch/sparc/kernel/sys_sparc_64.c
            'sparc_exit_group': [
                'int error_code',
            ], # arch/sparc/kernel/syscalls.S
            'sys_sparc64_personality': [
                'unsigned long personality',
            ], # arch/sparc/kernel/sys_sparc_64.c
            'sys_sparc_ipc': [
                'unsigned int call', 'int first', 'unsigned long second',
                'unsigned long third', 'void __user *ptr', 'long fifth',
            ], # arch/sparc/kernel/sys_sparc_64.c
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'int __user *child_tidptr', 'unsigned long tls',
            ], # kernel/fork.c
            'sys_sparc_adjtimex': [
                'struct __kernel_timex __user *txc_p',
            ], # arch/sparc/kernel/sys_sparc_64.c
            'sys_mmap': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long off'
            ], # arch/sparc/kernel/sys_sparc_64.c
            'sys_64_mremap': [
                'unsigned long addr', 'unsigned long old_len', 'unsigned long new_len',
                'unsigned long flags', 'unsigned long new_addr',
            ], # arch/sparc/kernel/sys_sparc_64.c
            'sys_sparc_clock_adjtime': [
                'const clockid_t which_clock', 'struct __kernel_timex __user *txc_p',
            ], # arch/sparc/kernel/sys_sparc_64.c
            'sys_kern_features': [], # arch/sparc/kernel/sys_sparc_64.c
            'sys64_execveat': [
                'int dfd', 'const char __user *filename', 'const char __user *const __user *argv',
                'const char __user *const __user *envp', 'int flags',
            ] ,# arch/sparc/kernel/syscalls.S
            'sys_rt_sigreturn': [
                "struct pt_regs *regs",
            ], # arch/sparc/kernel/signal_64.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry[:4] # dont use compat
            if abi not in ["common", "64"]:
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func in ['sys_ni_syscall', 'sys_nis_syscall']:
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "RISCV" and mode == "RISCV32":
        register_list = RISCV().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(riscv32_syscall_tbl)
        arch_specific_dic = {
            'sys_rt_sigreturn': [], # arch/riscv/kernel/signal.c
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls', 'int *child_tidptr',
            ], # kernel/fork.c (CONFIG_CLONE_BACKWARDS)
            'sys_mmap2': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'off_t offset',
            ], # arch/riscv/kernel/sys_riscv.c"
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry
            if abi != "riscv32":
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

        arch_specific_extra = [
            [259, 'riscv_flush_icache', [
                'uintptr_t start', 'uintptr_t end', 'uintptr_t flags',
            ]], # arch/riscv/include/uapi/asm/unistd.h, arch/riscv/kernel/sys_riscv.c
        ]
        syscall_list += arch_specific_extra

    elif arch == "RISCV" and mode == "RISCV64":
        register_list = RISCV64().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(riscv64_syscall_tbl)
        arch_specific_dic = {
            'sys_rt_sigreturn': [], # arch/riscv/kernel/signal.c
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls', 'int *child_tidptr',
            ], # kernel/fork.c (CONFIG_CLONE_BACKWARDS)
            'sys_mmap': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'off_t offset',
            ], # arch/riscv/kernel/sys_riscv.c"
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry
            if abi != "riscv64":
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

        arch_specific_extra = [
            [259, 'riscv_flush_icache', [
                'uintptr_t start', 'uintptr_t end', 'uintptr_t flags',
            ]], # arch/riscv/include/uapi/asm/unistd.h, arch/riscv/kernel/sys_riscv.c
        ]
        syscall_list += arch_specific_extra

    elif arch == "S390X" and mode == "S390X":
        register_list = S390X().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(s390x_syscall_tbl)
        arch_specific_dic = {
            'sys_s390_ipc': [
                'uint, call', 'int first', 'unsigned long second',
                'unsigned long third', 'void __user *ptr',
            ], # arch/s390/kernel/syscall.c
            'sys_sigreturn': [], # arch/s390/kernel/signal.c
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int stack_size',
                'int __user *parent_tidptr', 'int __user *child_tidptr', 'unsigned long tls',
            ], # kernel/fork.c (CONFIG_CLONE_BACKWARDS2)
            'sys_s390_personality': [
                'unsigned int personality',
            ], # arch/s390/kernel/syscall.c
            'sys_rt_sigreturn': [], # arch/s390/kernel/signal.c
            'sys_s390_runtime_instr': [
                'int, command', 'int signum',
            ], # arch/s390/kernel/runtime_instr.c
            'sys_s390_pci_mmio_write': [
                'unsigned long mmio_addr', 'const void __user *user_buffer', 'size_t length',
            ], # arch/s390/pci/pci_mmio.c
            'sys_s390_pci_mmio_read': [
                'unsigned long mmio_addr', 'void __user *user_buffer', 'size_t length',
            ], # arch/s390/pci/pci_mmio.c
            'sys_s390_guarded_storage': [
                'int command', 'struct gs_cb __user *gs_cb',
            ], # arch/s390/kernel/guarded_storage.c
            'sys_s390_sthyi': [
                'unsigned long function_code', 'void __user *buffer', 'u64 __user *return_code',
                'unsigned long flags',
            ], # arch/s390/kernel/sthyi.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry[:4] # dont use compat
            if abi not in ["common", "64"]:
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func in ['sys_ni_syscall', "-"]:
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "SH4" and mode == "SH4":
        register_list = SH4().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(sh4_syscall_tbl)
        arch_specific_dic = {
            'sys_sh_pipe': [], # arch/sh/kernel/sys_sh32.c
            'old_mmap': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'int fd', 'unsigned long off',
            ], # arch/sh/kernel/sys_sh.c
            'sys_sigreturn': [], # arch/sh/kernel/signal_32.c
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'int __user *child_tidptr', 'unsigned long tls',
            ], # kernel/fork.c
            'sys_cacheflush': [
                'unsigned long addr', 'unsigned long len', 'int op',
            ], # arch/sh/kernel/sys_sh.c
            'sys_rt_sigreturn': [], # arch/sh/kernel/signal_32.c
            'sys_pread_wrapper': [
                'unsigned int fd', 'char __user *buf', 'size_t count', 'long dummy', 'loff_t pos',
            ], # arch/sh/kernel/sys_sh32.c
            'sys_pwrite_wrapper': [
                'unsigned int fd', 'const char __user *buf', 'size_t count', 'long dummy', 'loff_t pos',
            ], # arch/sh/kernel/sys_sh32.c
            'sys_mmap2': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long pgoff',
            ], # arch/sh/kernel/sys_sh.c
            'sys_fadvise64_64_wrapper': [
                'int fd', 'u32 offset0', 'u32 offset1', 'u32 len0', 'u32 len1', 'int advice',
            ], # arch/sh/kernel/sys_sh32.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry
            if abi != "common":
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "M68K" and mode == "M68K":
        register_list = M68K().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(m68k_syscall_tbl)
        arch_specific_dic = {
            '__sys_fork': [], # kernel/fork.c
            'sys_sigreturn': [], # arch/m68k/kernel/entry.S
            '__sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'int __user *child_tidptr', 'unsigned long tls',
            ], # kernel/fork.c
            'sys_cacheflush': [
                'unsigned long addr', 'int scope', 'int cache', 'unsigned long len',
            ], #
            'sys_getpagesize': [], # arch/m68k/kernel/sys_m68k.c
            'sys_rt_sigreturn': [], # arch/m68k/kernel/entry.S
            '__sys_vfork': [], # kernel/fork.c
            'sys_mmap2': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long pgoff',
            ], # arch/m68k/kernel/sys_m68k.c
            'sys_get_thread_area': [], # arch/m68k/kernel/sys_m68k.c
            'sys_set_thread_area': [
                'unsigned long tp',
            ], # arch/m68k/kernel/sys_m68k.c
            'sys_atomic_cmpxchg_32': [
                'unsigned long newval', 'int oldval', 'int d3', 'int d4', 'int d5',
                'unsigned long __user *mem',
            ], # arch/m68k/kernel/sys_m68k.c
            'sys_atomic_barrier': [], # arch/m68k/kernel/sys_m68k.c
            '__sys_clone3': [
                'struct clone_args __user *uargs', 'size_t size',
            ], #
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry
            if abi != "common":
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "ALPHA" and mode == "ALPHA":
        register_list = ALPHA().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(alpha_syscall_tbl)
        arch_specific_dic = {
            'alpha_syscall_zero': [], # arch/alpha/kernel/entry.S
            'alpha_fork': [], # arch/alpha/kernel/entry.S (fork_like macro)
            'sys_osf_wait4': [
                'pid_t pid', 'int __user *ustatus', 'int options', 'struct rusage32 __user *ur',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_brk': [
                'unsigned long brk',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_getxpid': [], # arch/alpha/kernel/osf_sys.c
            'sys_osf_mount': [
                'unsigned long typenr', 'const char __user *path', 'int flag', 'void __user *data'
            ], # arch/alpha/kernel/osf_sys.c
            'sys_getxuid': [], # arch/alpha/kernel/osf_sys.c
            'sys_alpha_pipe': [], # arch/alpha/kernel/osf_sys.c
            'sys_osf_set_program_attributes': [
                'unsigned long text_start', 'unsigned long text_len',
                'unsigned long bss_start', 'unsigned long bss_len',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_getxgid': [], # arch/alpha/kernel/osf_sys.c
            'sys_osf_sigprocmask': [
                'int how', 'unsigned long newmask',
            ], # arch/alpha/kernel/signal.c
            'sys_getpagesize': [], # arch/alpha/kernel/osf_sys.c
            'alpha_vfork': [], # arch/alpha/kernel/entry.S (fork_like macro)
            'sys_osf_mmap': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long off',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_getdtablesize': [], # arch/alpha/kernel/osf_sys.c
            'sys_osf_select': [
                'int, n, fd_set __user *inp', 'fd_set __user *outp',
                'fd_set __user *exp', 'struct timeval32 __user *tvp',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_getpriority': [
                'int which', 'int who',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_sigreturn': [], # arch/alpha/kernel/entry.S (sigreturn_like macro)
            'sys_osf_sigstack': [
                'struct sigstack __user *uss', 'struct sigstack __user *uoss',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_gettimeofday': [
                'struct timeval32 __user *tv', 'struct timezone __user *tz',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_getrusage': [
                'int who', 'struct rusage32 __user *ru',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_readv': [
                ' unsigned long fd', 'const struct iovec __user *vector', 'unsigned long count',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_writev': [
                ' unsigned long fd', 'const struct iovec __user *vector', 'unsigned long count',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_settimeofday': [
                'struct timeval32 __user *tv', 'struct timezone __user *tz',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_utimes': [
                'const char __user *filename', 'struct timeval32 __user *tvs',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_sigaction': [
                'int, sig', 'const struct osf_sigaction __user *act', 'struct osf_sigaction __user *oact',
            ], # arch/alpha/kernel/signal.c
            'sys_osf_getdirentries': [
                'unsigned int fd', 'struct osf_dirent __user *dirent',
                'unsigned int count', 'long __user *basep',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_statfs': [
                'const char __user *pathname', 'struct osf_statfs __user *buffer', 'unsigned long bufsiz',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_fstatfs': [
                'unsigned long fd', 'struct osf_statfs __user *buffer', 'unsigned long bufsiz',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_getdomainname': [
                'char __user *name', 'int namelen',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_utsname': [
                'char __user *name',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_stat': [
                'char __user *name', 'struct osf_stat __user *buf',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_lstat': [
                'char __user *name', 'struct osf_stat __user *buf',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_fstat': [
                'int fd', 'struct osf_stat __user *buf',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_statfs64': [
                'char __user *pathname', 'struct osf_statfs64 __user *buffer', 'unsigned long bufsiz',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_fstatfs64': [
                'unsigned long fd', 'struct osf_statfs64 __user *buffer', 'unsigned long bufsiz',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_sysinfo': [
                'int command', 'char __user *buf', 'long count',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_proplist_syscall': [
                'enum pl_code code', 'union pl_args __user *args',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_usleep_thread': [
                'struct timeval32 __user *sleep', 'struct timeval32 __user *remain',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_getsysinfo': [
                'unsigned long op', 'void __user *buffer', 'unsigned long nbytes',
                'int __user *start', 'void __user *arg',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_osf_setsysinfo': [
                'unsigned long op', 'void __user *buffer', 'unsigned long nbytes',
                'int __user *start', 'void __user *arg',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_sethae': [
                'unsigned long val',
            ], # arch/alpha/kernel/osf_sys.c
            'sys_old_adjtimex': [
                'struct timex32 __user *txc_p',
            ], # arch/alpha/kernel/osf_sys.c
            'alpha_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'int __user *child_tidptr', 'unsigned long tls',
            ], # kernel/fork.c
            'sys_rt_sigreturn': [], # arch/alpha/kernel/entry.S (sigreturn_like macro)
            'sys_rt_sigaction': [
                'int sig', 'const struct sigaction __user *act', 'struct sigaction __user *oact',
                'size_t sigsetsize', 'void __user *restorer',
            ] # arch/alpha/kernel/signal.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry
            if abi != "common":
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "HPPA" and mode == "HPPA32":
        register_list = HPPA().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(hppa_syscall_tbl)
        arch_specific_dic = {
            'sys_fork_wrapper': [], # arch/parisc/kernel/entry.S (fork_like macro)
            'sys_mmap2': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long pgoff',
            ], # arch/parisc/kernel/sys_parisc.c
            'sys_mmap': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long offset',
            ], # arch/parisc/kernel/sys_parisc.c
            'parisc_pread64': [
                'unsigned int fd', 'char __user *buf', 'size_t count',
                'unsigned int high', 'unsigned int low',
            ], # arch/parisc/kernel/sys_parisc.c
            'parisc_pwrite64': [
                'unsigned int fd', 'const char __user *buf', 'size_t count',
                'unsigned int high', 'unsigned int low',
            ], # arch/parisc/kernel/sys_parisc.c
            'sys_vfork_wrapper': [], # arch/parisc/kernel/entry.S (fork_like macro)
            'sys_clone_wrapper': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls', 'int *child_tidptr',
            ], # kernel/fork.c (fork_linke macro, CONFIG_CLONE_BACKWARDS)
            'parisc_personality': [
                'unsigned long personality',
            ], # arch/parisc/kernel/sys_parisc.c
            'sys_rt_sigreturn_wrapper': [], # arch/parisc/kernel/entry.S
            'parisc_truncate64': [
                'const char __user * path', 'unsigned int high', 'unsigned int low',
            ], # arch/parisc/kernel/sys_parisc.c
            'parisc_ftruncate64': [
                'unsigned int fd', 'unsigned int high', 'unsigned int low',
            ], # arch/parisc/kernel/sys_parisc.c
            'parisc_readahead': [
                'int fd', 'unsigned int high', 'unsigned int low', 'size_t count',
            ], # arch/parisc/kernel/sys_parisc.c
            'parisc_fadvise64_64': [
                'int fd', 'unsigned int high_off', 'unsigned int low_off',
                'unsigned int high_len', 'unsigned int low_len', 'int advice',
            ], # arch/parisc/kernel/sys_parisc.c
            'parisc_sync_file_range': [
                'int fd', 'u32 hi_off', 'u32 lo_off', 'u32 hi_nbytes', 'u32 lo_nbytes',
                'unsigned int flags',
            ], # arch/parisc/kernel/sys_parisc.c
            'parisc_fallocate': [
                'int fd', 'int mode', 'u32 offhi', 'u32 offlo', 'u32 lenhi', 'u32 lenlo',
            ], # arch/parisc/kernel/sys_parisc.c
            'parisc_timerfd_create': [
                'int clockid', 'int flags',
            ], # arch/parisc/kernel/sys_parisc.c
            'parisc_signalfd4': [
                'int ufd', 'sigset_t __user *user_mask', 'size_t sizemask', 'int flags',
            ], # arch/parisc/kernel/sys_parisc.c
            'parisc_eventfd2': [
                'unsigned int count', 'int flags',
            ], # arch/parisc/kernel/sys_parisc.c
            'parisc_pipe2': [
                'int __user *fildes', 'int flags',
            ], # arch/parisc/kernel/sys_parisc.c
            'parisc_inotify_init1': [
                'int flags',
            ], # arch/parisc/kernel/sys_parisc.c
            'parisc_userfaultfd': [
                'int flags',
            ], # arch/parisc/kernel/sys_parisc.c
            'sys_clone3_wrapper': [
                'struct clone_args __user *uargs', 'size_t size',
            ], # arch/parisc/kernel/entry.S (fork_like macro)
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry[:4] # dont use compat
            if abi not in ["common", "32"]:
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "HPPA" and mode == "HPPA64":
        register_list = HPPA64().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(hppa_syscall_tbl)
        arch_specific_dic = {
            'sys_fork_wrapper': [], # arch/parisc/kernel/entry.S (fork_like macro)
            'sys_mmap2': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long pgoff',
            ], # arch/parisc/kernel/sys_parisc.c
            'sys_mmap': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long offset',
            ], # arch/parisc/kernel/sys_parisc.c
            'sys_vfork_wrapper': [], # arch/parisc/kernel/entry.S (fork_like macro)
            'sys_clone_wrapper': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls', 'int *child_tidptr',
            ], # kernel/fork.c (fork_linke macro, CONFIG_CLONE_BACKWARDS)
            'sys_rt_sigreturn_wrapper': [], # arch/parisc/kernel/entry.S
            'parisc_timerfd_create': [
                'int clockid', 'int flags',
            ], # arch/parisc/kernel/sys_parisc.c
            'parisc_signalfd4': [
                'int ufd', 'sigset_t __user *user_mask', 'size_t sizemask', 'int flags',
            ], # arch/parisc/kernel/sys_parisc.c
            'parisc_eventfd2': [
                'unsigned int count', 'int flags',
            ], # arch/parisc/kernel/sys_parisc.c
            'parisc_pipe2': [
                'int __user *fildes', 'int flags',
            ], # arch/parisc/kernel/sys_parisc.c
            'parisc_inotify_init1': [
                'int flags',
            ], # arch/parisc/kernel/sys_parisc.c
            'parisc_userfaultfd': [
                'int flags',
            ], # arch/parisc/kernel/sys_parisc.c
            'sys_clone3_wrapper': [
                'struct clone_args __user *uargs', 'size_t size',
            ], # arch/parisc/kernel/entry.S (fork_like macro)
        }
        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry[:4] # dont use compat
            if abi not in ["common", "64"]:
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "OR1K" and mode == "OR1K":
        register_list = OR1K().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(or1k_syscall_tbl)
        arch_specific_dic = {
            'sys_rt_sigreturn': [], # arch/openrisc/kernel/entry.S
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp',
                'void __user *parent_tid', 'void __user *child_tid', 'int tls',
            ], # arch/openrisc/include/syscalls.h
            'sys_mmap': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'off_t pgoff',
            ], # include/asm-generic/syscalls.h
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry
            if abi != "or1k":
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "NIOS2" and mode == "NIOS2":
        register_list = NIOS2().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(nios2_syscall_tbl)
        arch_specific_dic = {
            'sys_rt_sigreturn': [], # arch/nios2/kernel/entry.S
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp',
                'int __user *parent_tidptr', 'int __user *child_tidptr', 'int tls_val',
            ], # arch/nios2/kernel/entry.S
            'sys_mmap': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'off_t pgoff',
            ], # include/asm-generic/syscalls.h
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry
            if abi != "nios2":
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "MICROBLAZE" and mode == "MICROBLAZE":
        register_list = MICROBLAZE().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(microblaze_syscall_tbl)
        arch_specific_dic = {
            'sys_mmap': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'off_t pgoff',
            ], # arch/microblaze/kernel/sys_microblaze.c
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int stack_size',
                'int __user *parent_tidptr', 'int __user *child_tidptr', 'unsigned long tls',
            ], # kernel/fork.c (CONFIG_CLONE_BACKWARDS3)
            'sys_rt_sigreturn_wrapper': [], # arch/microblaze/kernel/entry.S
            'sys_mmap2': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long pgoff',
            ], # arch/microblaze/kernel/sys_microblaze.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry
            if abi != "common":
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "XTENSA" and mode == "XTENSA":
        register_list = XTENSA().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(xtensa_syscall_tbl)
        arch_specific_dic = {
            'xtensa_fadvise64_64': [
                'int fd', 'int advice', 'unsigned long long offset', 'unsigned long long len',
            ], # arch/xtensa/kernel/syscall.c
            'xtensa_shmat': [
                'int shmid', 'char __user *shmaddr', 'int shmflg',
            ], # arch/xtensa/kernel/syscall.c
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls', 'int *child_tidptr',
            ], # kernel/fork.c (CONFIG_CLONE_BACKWARDS)
            'xtensa_rt_sigreturn': [], # arch/xtensa/kernel/signal.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry
            if abi != "common":
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "CRIS" and mode == "CRIS":
        register_list = CRIS().syscall_parameters
        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(cris_syscall_tbl)
        arch_specific_dic = {
            'sys_sigreturn': [], # arch/cris/arch-v10/kernel/signal.c
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int stack_size',
                'int __user *parent_tidptr', 'int __user *child_tidptr', 'unsigned long tls',
            ], # kernel/fork.c (CONFIG_CLONE_BACKWARDS2)
            'sys_bdflush': [
                'int func', 'long data',
            ], # include/linux/syscalls.h
            'sys_sysctl': [
                'struct __sysctl_args __user *args',
            ], # include/linux/syscalls.h
            'sys_rt_sigreturn': [], # arch/cris/arch-v10/kernel/signal.c
            'sys_mmap2': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long pgoff',
            ], # arch/cris/kernel/sys_cris.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry
            if abi != "cris":
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    else:
        raise

    Table = collections.namedtuple('Table', 'arch mode table')
    Entry = collections.namedtuple('Entry', 'name params')
    Param = collections.namedtuple('Param', 'reg param')
    syscall_table = Table(arch=arch, mode=mode, table={})

    # example:
    #   syscall_table.arch: 'X86'
    #   syscall_table.mode: '64'
    #   syscall_table.table[0].name: 'read'
    #   syscall_table.table[0].params[0].reg: '$rdi'
    #   syscall_table.table[0].params[0].param: 'unsigned int fd'

    syscall_list = sorted(syscall_list, key=lambda x: x[0])
    for nr, name, args in syscall_list:
        if arch == "MIPS" and mode == "MIPS32":
            if nr >= 6000:
                args = list(zip(n32_register_list[:len(args)], args))
            else:
                args = list(zip(o32_register_list[:len(args)], args))
        else:
            args = list(zip(register_list[:len(args)], args))
        syscall_table.table[nr] = Entry(name, [Param(*p) for p in args])

    cached_syscall_table[arch, mode] = syscall_table
    return syscall_table


@register_command
class SyscallArgsCommand(GenericCommand):
    """Gets the syscall name and arguments based on the register values in the current state."""
    _cmdline_ = "syscall-args"
    _category_ = "01-a. Debugging Support - Context"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('syscall_num', metavar='SYSCALL_NUM', nargs='?', type=lambda x: int(x, 0),
                        help='syscall number you want to search.')
    _syntax_ = parser.format_help()

    def get_nr(self):
        # str or list
        syscall_register = current_arch.syscall_register

        # hppa specific. hppa syscall instruction has a delay slot and _NR may be set there.
        if is_hppa32() or is_hppa64():
            next_insn = gef_instruction_n(current_arch.pc, 1)
            if next_insn.mnemonic == "ldi" and next_insn.operands[1] == "r20":
                nr = int(next_insn.operands[0], 16)
            else:
                # already set
                nr = get_register(syscall_register)

        # s390x specific. s390x syscall number may be embedded in the instruction.
        elif is_s390x():
            insn = gef_current_instruction(current_arch.pc)
            r = re.search(syscall_register[0], str(insn))
            nr = int(r.group(1), 0)
            if nr == 0:
                syscall_register = syscall_register[1] # use $r1
                nr = get_register(syscall_register)
            else:
                syscall_register = syscall_register[0]

        # normal pattern
        else:
            nr = get_register(syscall_register)

        return syscall_register, nr

    def get_values(self, registers):
        values = []
        for reg in registers:
            if "+" not in reg:
                values.append(get_register(reg))
            else:
                _reg, _off = reg.split("+") # like `$sp + 0x10`
                values.append(read_int_from_memory(get_register(_reg) + int(_off, 0)))
        return values

    def print_syscall(self, syscall_table, syscall_register, nr):
        if syscall_table:
            syscall_name = syscall_table.table[nr].name
            parameters = [s.param for s in syscall_table.table[nr].params]
            param_names = [re.split(r" |\*", p)[-1] for p in parameters]
            registers = [s.reg for s in syscall_table.table[nr].params]
            arch = syscall_table.arch
            mode = syscall_table.mode
        else:
            syscall_name = None
            registers = current_arch.syscall_parameters
            parameters = None
            param_names = ["?"] * len(registers)
            arch = current_arch.arch
            mode = current_arch.mode

        info("Detected syscall (arch:{:s}, mode:{:s})".format(arch, mode))

        if syscall_name and parameters:
            gef_print("    " + Color.colorify("{}({})".format(syscall_name, ", ".join(parameters)), "bold yellow"))

        headers = ["Parameter", "Register", "Value"]
        info(Color.colorify("{:<20} {:<20} {}".format(*headers), get_gef_setting("theme.table_heading")))
        gef_print("    {:<20} {:<20} {:<20}".format("RET", current_arch.return_register, "-"))
        gef_print("    {:<20} {:<20} {:#x}".format("_NR", syscall_register, nr))

        values = self.get_values(registers)
        for name, register, value in zip(param_names, registers, values):
            line = "    {:<20} {:<20} ".format(name, register)
            if value is not None:
                line += to_string_dereference_from(value)
            gef_print(line)
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        if args.syscall_num is not None:
            syscall_register, nr = "-", args.syscall_num
        else:
            syscall_register, nr = self.get_nr()

        try:
            syscall_table = get_syscall_table()
            if nr not in syscall_table.table:
                warn("There is no system call for {:#x}".format(nr))
                return
        except Exception:
            syscall_table = None

        self.print_syscall(syscall_table, syscall_register, nr)
        return


@functools.lru_cache(maxsize=None)
def get_section_base_address(name):
    if name is None:
        return None
    section = process_lookup_path(name)
    if section:
        return section.page_start
    # Fail, retry with real path
    section = process_lookup_path(os.path.realpath(name))
    if section:
        return section.page_start
    return None


def get_section_base_address_by_list(names):
    for name in names:
        page_start = get_section_base_address(name)
        if page_start is not None:
            return page_start
    return None


@register_command
class CodebaseCommand(GenericCommand):
    """Show code base address."""
    _cmdline_ = "codebase"
    _category_ = "02-b. Process Information - Base Address"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        codebase = get_section_base_address(get_filepath(append_proc_root_prefix=False))
        if codebase is None:
            codebase = get_section_base_address(get_path_from_info_proc())
        if codebase is None:
            gef_print("Codebase is not found")
            return

        gef_print(titlify("Code base"))
        gdb.execute(f"set $codebase = {codebase}")
        gef_print(f"$codebase = {codebase:#x}")

        filepath = get_filepath()
        if filepath and is_pie(filepath):
            gdb.execute(f"set $piebase = {codebase}")
            gef_print(f"$piebase = {codebase:#x}")
        return


@register_command
class HeapbaseCommand(GenericCommand):
    """Show heap base address."""
    _cmdline_ = "heapbase"
    _category_ = "02-b. Process Information - Base Address"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @staticmethod
    def heap_base():
        try:
            base = parse_address("mp_->sbrk_base")
            if base != 0:
                return base
        except gdb.error:
            pass
        return get_section_base_address("[heap]")

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        heap = HeapbaseCommand.heap_base()
        if heap is None:
            gef_print("Heap is not found")
            return

        gef_print(titlify("Heap base"))
        gdb.execute(f"set $heapbase = {heap}")
        gef_print(f"$heapbase = {heap:#x}")
        return


@register_command
class LibcCommand(GenericCommand):
    """Show `libc.so` base address."""
    _cmdline_ = "libc"
    _category_ = "02-b. Process Information - Base Address"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        libc = get_section_base_address_by_list(("libc-2.", "libc.so.6"))
        if libc is None:
            err("libc is not found")
            return

        gef_print(titlify("libc info"))
        gdb.execute(f"set $libc = {libc}")
        gef_print(f"$libc = {libc:#x}")

        libc = process_lookup_path(("libc-2.", "libc.so.6"))
        libc_path = libc.path

        if is_container_attach():
            libc_path = append_proc_root(libc_path)
            if not os.path.exists(libc_path):
                return
            data = open(libc_path, "rb").read()

        elif is_remote_debug():
            data = read_remote_file(libc_path)
            if not data:
                return
        else:
            if not os.path.exists(libc_path):
                return
            data = open(libc_path, "rb").read()

        gef_print("path{:s}:\t{:s}".format(" (remote)" if is_remote_debug() else "", libc_path))
        gef_print("sha512:\t{:s}".format(hashlib.sha512(data).hexdigest()))
        gef_print("sha256:\t{:s}".format(hashlib.sha256(data).hexdigest()))
        gef_print("sha1:\t{:s}".format(hashlib.sha1(data).hexdigest()))
        gef_print("md5:\t{:s}".format(hashlib.md5(data).hexdigest()))

        strings_list = strings(data)
        version = [line for line in strings_list if line.startswith("GNU C Library")]
        if version:
            gef_print("ver:\t{:s}".format(version[0]))
        return


@register_command
class LdCommand(GenericCommand):
    """Show `ld.so` base address."""
    _cmdline_ = "ld"
    _category_ = "02-b. Process Information - Base Address"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        ld = get_section_base_address_by_list(("ld-2.", "ld-linux-"))
        if ld is None:
            gef_print("ld not found")
            return
        gef_print(titlify("ld info"))
        gdb.execute(f"set $ld = {ld}")
        gef_print(f"$ld = {ld:#x}")

        ld = process_lookup_path(("ld-2.", "ld-linux-"))
        ld_path = ld.path

        if is_container_attach():
            ld_path = append_proc_root(ld_path)
            if not os.path.exists(ld_path):
                return
            data = open(ld_path, "rb").read()

        elif is_remote_debug():
            data = read_remote_file(ld_path)
            if not data:
                return
        else:
            if not os.path.exists(ld_path):
                return
            data = open(ld_path, "rb").read()

        gef_print("path{:s}:\t{:s}".format(" (remote)" if is_remote_debug() else "", ld_path))
        gef_print("sha512:\t{:s}".format(hashlib.sha512(data).hexdigest()))
        gef_print("sha256:\t{:s}".format(hashlib.sha256(data).hexdigest()))
        gef_print("sha1:\t{:s}".format(hashlib.sha1(data).hexdigest()))
        gef_print("md5:\t{:s}".format(hashlib.md5(data).hexdigest()))

        strings_list = strings(data)
        version = [line for line in strings_list if (line.startswith("ld.so") and "version" in line)]
        if version:
            gef_print("ver:\t{:s}".format(version[0]))
        return


@register_command
class MagicCommand(GenericCommand):
    """Show Magic addresses / offsets."""
    _cmdline_ = "magic"
    _category_ = "02-g. Process Information - Symbol"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument("--fj", action='store_true', help='print _IO_xxx_jumps functions')
    parser.add_argument('filter', metavar='FILTER', nargs='*', help='filter string')
    _syntax_ = parser.format_help()

    def should_be_print(self, sym):
        if not self.filter:
            return True

        for filt in self.filter:
            if filt in sym:
                return True
        return False

    def resolve_and_print(self, sym, base):
        def get_permission(addr):
            maps = get_process_maps()
            for m in maps:
                if m.page_start <= addr and addr < m.page_end:
                    return str(m.permission)
            return "???"

        if not self.should_be_print(sym):
            return

        try:
            addr = int(gdb.parse_and_eval(f"&{sym}"))
            perm = get_permission(addr)
            if is_ascii_string(addr):
                val = read_ascii_string(addr)
                gef_print(f"{sym:42s}: {addr:#18x} [{perm:3s}] ({base:#18x} + {addr - base:#10x}) -> {val:>18s}")
            else:
                val = read_int_from_memory(addr)
                val_sym = get_symbol_string(val)
                gef_print(f"{sym:42s}: {addr:#18x} [{perm:3s}] ({base:#18x} + {addr - base:#10x}) -> {val:#18x}{val_sym}")
        except Exception:
            gef_print(f"{sym:42s}: {'Not found':>18s}")
        return

    def print_file_jumps_func(self, sym):
        if not self.should_be_print(sym):
            return

        if not self.print_file_jumps:
            return

        try:
            vtable = int(gdb.parse_and_eval(f"&{sym}"))
        except Exception:
            return

        gdb.execute("telescope {:#x} 22 --no-pager".format(vtable))
        return

    def magic(self):
        codebase = get_section_base_address(get_filepath(append_proc_root_prefix=False))
        libc = get_section_base_address_by_list(("libc-2.", "libc.so.6"))
        ld = get_section_base_address_by_list(("ld-2.", "ld-linux-", "ld-linux.so.2"))
        if libc is None or ld is None:
            gef_print("libc/ld not found")
            return

        gef_print(titlify("Legend"))
        msg = f"{'symbol':42s}: {'addr':>18s} {'perm':5s} ({'base':>18s} + {'offset':>10s}) -> {'val':>18s}"
        gef_print(Color.colorify(msg, get_gef_setting("theme.table_heading")))

        gef_print(titlify("Heap"))
        self.resolve_and_print("main_arena", libc)
        self.resolve_and_print("mp_", libc)
        self.resolve_and_print("__malloc_hook", libc)
        self.resolve_and_print("__free_hook", libc)
        self.resolve_and_print("__realloc_hook", libc)
        self.resolve_and_print("__memalign_hook", libc)
        self.resolve_and_print("__after_morecore_hook", libc)
        self.resolve_and_print("_dl_open_hook", libc)
        self.resolve_and_print("global_max_fast", libc)
        self.resolve_and_print("malloc", libc)
        self.resolve_and_print("free", libc)
        self.resolve_and_print("calloc", libc)
        self.resolve_and_print("realloc", libc)
        gef_print(titlify("I/O"))
        self.resolve_and_print("*stdin", libc)
        self.resolve_and_print("*stdout", libc)
        self.resolve_and_print("*stderr", libc)
        self.resolve_and_print("_IO_list_all", libc)
        self.resolve_and_print("_IO_file_jumps", libc)
        self.print_file_jumps_func("_IO_file_jumps")
        self.resolve_and_print("_IO_file_jumps_mmap", libc)
        self.print_file_jumps_func("_IO_file_jumps_mmap")
        self.resolve_and_print("_IO_file_jumps_maybe_mmap", libc)
        self.print_file_jumps_func("_IO_file_jumps_maybe_mmap")
        self.resolve_and_print("_IO_wfile_jumps", libc)
        self.print_file_jumps_func("_IO_wfile_jumps")
        self.resolve_and_print("_IO_wfile_jumps_mmap", libc)
        self.print_file_jumps_func("_IO_wfile_jumps_mmap")
        self.resolve_and_print("_IO_wfile_jumps_maybe_mmap", libc)
        self.print_file_jumps_func("_IO_wfile_jumps_maybe_mmap")
        self.resolve_and_print("_IO_old_file_jumps", libc)
        self.print_file_jumps_func("_IO_old_file_jumps")
        self.resolve_and_print("_IO_mem_jumps", libc)
        self.print_file_jumps_func("_IO_mem_jumps")
        self.resolve_and_print("_IO_wmem_jumps", libc)
        self.print_file_jumps_func("_IO_wmem_jumps")
        self.resolve_and_print("_IO_str_jumps", libc)
        self.print_file_jumps_func("_IO_str_jumps")
        self.resolve_and_print("_IO_strn_jumps", libc)
        self.print_file_jumps_func("_IO_strn_jumps")
        self.resolve_and_print("_IO_str_chk_jumps", libc)
        self.print_file_jumps_func("_IO_str_chk_jumps")
        self.resolve_and_print("_IO_wstr_jumps", libc)
        self.print_file_jumps_func("_IO_wstr_jumps")
        self.resolve_and_print("_IO_wstrn_jumps", libc)
        self.print_file_jumps_func("_IO_wstrn_jumps")
        self.resolve_and_print("_IO_streambuf_jumps", libc)
        self.print_file_jumps_func("_IO_streambuf_jumps")
        self.resolve_and_print("_IO_proc_jumps", libc)
        self.print_file_jumps_func("_IO_proc_jumps")
        self.resolve_and_print("_IO_old_proc_jumps", libc)
        self.print_file_jumps_func("_IO_old_proc_jumps")
        self.resolve_and_print("_IO_helper_jumps", libc)
        self.print_file_jumps_func("_IO_helper_jumps")
        self.resolve_and_print("_IO_cookie_jumps", libc)
        self.print_file_jumps_func("_IO_cookie_jumps")
        self.resolve_and_print("_IO_obstack_jumps", libc)
        self.print_file_jumps_func("_IO_obstack_jumps")
        self.resolve_and_print("open", libc)
        self.resolve_and_print("read", libc)
        self.resolve_and_print("write", libc)
        self.resolve_and_print("dup", libc)
        self.resolve_and_print("dup2", libc)
        self.resolve_and_print("dup3", libc)
        self.resolve_and_print("puts", libc)
        self.resolve_and_print("gets", libc)
        self.resolve_and_print("fputs", libc)
        self.resolve_and_print("fgets", libc)
        self.resolve_and_print("printf", libc)
        self.resolve_and_print("fprintf", libc)
        self.resolve_and_print("dprintf", libc)
        self.resolve_and_print("sprintf", libc)
        self.resolve_and_print("snprintf", libc)
        self.resolve_and_print("__printf_chk", libc)
        self.resolve_and_print("__fprintf_chk", libc)
        self.resolve_and_print("__dprintf_chk", libc)
        self.resolve_and_print("__sprintf_chk", libc)
        self.resolve_and_print("__snprintf_chk", libc)
        self.resolve_and_print("__printf_function_table", libc)
        self.resolve_and_print("__printf_arginfo_table", libc)
        self.resolve_and_print("scanf", libc)
        self.resolve_and_print("fscanf", libc)
        self.resolve_and_print("sscanf", libc)
        gef_print(titlify("Process"))
        self.resolve_and_print("system", libc)
        self.resolve_and_print("do_system", libc)
        self.resolve_and_print("execve", libc)
        self.resolve_and_print("setcontext", libc)
        self.resolve_and_print("__libc_start_main", libc)
        self.resolve_and_print("syscall", libc)
        self.resolve_and_print("ptrace", libc)
        self.resolve_and_print("prctl", libc)
        gef_print(titlify("Memory"))
        self.resolve_and_print("mmap", libc)
        self.resolve_and_print("munmap", libc)
        self.resolve_and_print("mremap", libc)
        self.resolve_and_print("mprotect", libc)
        gef_print(titlify("Stack"))
        self.resolve_and_print("__libc_argv", libc)
        self.resolve_and_print("__environ", libc)
        gef_print(titlify("Destructor"))
        self.resolve_and_print("_rtld_global->_dl_rtld_lock_recursive", ld)
        self.resolve_and_print("_rtld_global->_dl_rtld_unlock_recursive", ld)
        self.resolve_and_print("error_print_progname", libc)
        gef_print(titlify("Unwind"))
        self.resolve_and_print("'DW.ref.__gxx_personality_v0'", codebase)
        return

    def resolve_and_print_kernel(self, sym, base, maps, external_func=None):
        def get_permission(addr, maps):
            for vaddr, size, perm in maps:
                if vaddr <= addr and addr < vaddr + size:
                    return perm
            return "???"

        if not self.should_be_print(sym):
            return

        try:
            if external_func:
                addr = external_func()
            else:
                if isinstance(sym, str):
                    addr = get_ksymaddr(sym)
                    if addr is None:
                        raise # goto Not found/recognized
                elif isinstance(sym, list):
                    for s in sym:
                        addr = get_ksymaddr(s)
                        if addr:
                            sym = s
                            break
                    else: # Not found
                        sym = sym[0]
                        raise # goto Not found/recognized
            perm = get_permission(addr, maps)
            if is_ascii_string(addr):
                val = read_ascii_string(addr)
                gef_print(f"{sym:42s}: {addr:#18x} [{perm:3s}] ({base:#18x} + {addr - base:#10x}) -> {val:>18s}")
            else:
                val = read_int_from_memory(addr)
                gef_print(f"{sym:42s}: {addr:#18x} [{perm:3s}] ({base:#18x} + {addr - base:#10x}) -> {val:#18x}")
        except Exception:
            gef_print(f"{sym:42s}: {'Not found/recognized':>18s}")
        return

    def magic_kernel(self):
        info("Wait for memory scan")

        kinfo = KernelbaseCommand.get_kernel_base()
        maps = kinfo.maps
        kbase = kinfo.kbase
        kbase_size = kinfo.kbase_size
        if maps is None or kbase is None or kbase_size is None:
            return
        gef_print("{:42s}: {:#x} ({:#x} bytes)".format("kernel_base", kbase, kbase_size))

        gef_print(titlify("Legend"))
        msg = f"{'symbol':42s}: {'addr':>18s} {'perm':5s} ({'base':>18s} + {'offset':>10s}) -> {'val':>18s}"
        gef_print(Color.colorify(msg, get_gef_setting("theme.table_heading")))

        gef_print(titlify("Credential"))
        self.resolve_and_print_kernel("commit_creds", kbase, maps)
        self.resolve_and_print_kernel("prepare_kernel_cred", kbase, maps)
        self.resolve_and_print_kernel("init_cred", kbase, maps, KernelAddressHeuristicFinder.get_init_cred)
        self.resolve_and_print_kernel(["sys_setuid", "__sys_setuid"], kbase, maps)
        self.resolve_and_print_kernel("init_task", kbase, maps, KernelAddressHeuristicFinder.get_init_task)
        gef_print(titlify("Usermode helper"))
        self.resolve_and_print_kernel("call_usermodehelper", kbase, maps)
        self.resolve_and_print_kernel("run_cmd", kbase, maps)
        self.resolve_and_print_kernel("modprobe_path", kbase, maps, KernelAddressHeuristicFinder.get_modprobe_path)
        self.resolve_and_print_kernel("orderly_poweroff", kbase, maps)
        self.resolve_and_print_kernel("poweroff_cmd", kbase, maps, KernelAddressHeuristicFinder.get_poweroff_cmd)
        self.resolve_and_print_kernel("orderly_reboot", kbase, maps)
        self.resolve_and_print_kernel("reboot_cmd", kbase, maps, KernelAddressHeuristicFinder.get_reboot_cmd)
        self.resolve_and_print_kernel("core_pattern", kbase, maps, KernelAddressHeuristicFinder.get_core_pattern)
        gef_print(titlify("ROP finalizer"))
        if is_x86():
            self.resolve_and_print_kernel("swapgs_restore_regs_and_return_to_usermode", kbase, maps)
        self.resolve_and_print_kernel("msleep", kbase, maps)
        gef_print(titlify("Memory protection modifier"))
        if is_x86():
            self.resolve_and_print_kernel("native_write_cr0", kbase, maps)
            self.resolve_and_print_kernel("native_write_cr4", kbase, maps)
        self.resolve_and_print_kernel("set_memory_rw", kbase, maps)
        self.resolve_and_print_kernel("set_memory_x", kbase, maps)
        gef_print(titlify("Memory patcher"))
        self.resolve_and_print_kernel("text_poke", kbase, maps)
        self.resolve_and_print_kernel("memcpy", kbase, maps)
        self.resolve_and_print_kernel("_copy_to_user", kbase, maps)
        self.resolve_and_print_kernel("_copy_from_user", kbase, maps)
        if is_arm64():
            self.resolve_and_print_kernel("__arch_copy_to_user", kbase, maps)
            self.resolve_and_print_kernel("__arch_copy_from_user", kbase, maps)
        gef_print(titlify("Memory remapper"))
        self.resolve_and_print_kernel(["ioremap", "__ioremap"], kbase, maps)
        self.resolve_and_print_kernel(["iounmap", "__iounmap"], kbase, maps)
        self.resolve_and_print_kernel("phys_base", kbase, maps)
        gef_print(titlify("Automatically called function pointer"))
        self.resolve_and_print_kernel("kvm_clock", kbase, maps)
        self.resolve_and_print_kernel("clocksource_tsc", kbase, maps)
        gef_print(titlify("Function pointer table"))
        self.resolve_and_print_kernel("ptmx_fops", kbase, maps)
        self.resolve_and_print_kernel("perf_fops", kbase, maps)
        self.resolve_and_print_kernel("capability_hooks", kbase, maps)
        self.resolve_and_print_kernel("n_tty_ops", kbase, maps, KernelAddressHeuristicFinder.get_n_tty_ops)
        gef_print(titlify("Function pointer table array"))
        self.resolve_and_print_kernel("tty_ldiscs", kbase, maps, KernelAddressHeuristicFinder.get_tty_ldiscs)
        gef_print(titlify("SLUB"))
        self.resolve_and_print_kernel("__kmalloc", kbase, maps)
        self.resolve_and_print_kernel("kzalloc", kbase, maps)
        self.resolve_and_print_kernel("kfree", kbase, maps)
        self.resolve_and_print_kernel("kzfree", kbase, maps)
        self.resolve_and_print_kernel("slab_caches", kbase, maps, KernelAddressHeuristicFinder.get_slab_caches)
        gef_print(titlify("Dynamic resolver"))
        self.resolve_and_print_kernel("kallsyms_lookup_name", kbase, maps)
        gef_print(titlify("vDSO"))
        if is_x86():
            self.resolve_and_print_kernel("vdso_image_64", kbase, maps)
            self.resolve_and_print_kernel("vdso_image_32", kbase, maps)
            self.resolve_and_print_kernel("vdso_image_x32", kbase, maps)
        elif is_arm64():
            self.resolve_and_print_kernel("vdso_info", kbase, maps, KernelAddressHeuristicFinder.get_vdso_info)
        elif is_arm32():
            self.resolve_and_print_kernel("vdso_start", kbase, maps)
        gef_print(titlify("Others"))
        self.resolve_and_print_kernel("do_fchmodat", kbase, maps)
        self.resolve_and_print_kernel("mmap_min_addr", kbase, maps, KernelAddressHeuristicFinder.get_mmap_min_addr)
        self.resolve_and_print_kernel("__per_cpu_offset", kbase, maps, KernelAddressHeuristicFinder.get_per_cpu_offset)
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        self.print_file_jumps = args.fj
        self.filter = args.filter

        if is_qemu_system():
            self.magic_kernel()
        else:
            self.magic()
        return


@register_command
class OneGadgetCommand(GenericCommand):
    """Exec `one_gadget`."""
    _cmdline_ = "onegadget"
    _category_ = "07-b. External Command - Exploit Development"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        libc = process_lookup_path(("libc-2.", "libc.so.6"))
        if libc is None:
            err("libc is not found")
            return

        try:
            one_gadget = which("one_gadget")
            gef_print(titlify(f"{one_gadget} '{libc.path}' -l 1"))
            os.system(f"{one_gadget} '{libc.path}' -l 1")
        except Exception:
            err("Missing `one_gadget`, install with: `gem install one_gadget`.")
        return


@register_command
class SeccompCommand(GenericCommand):
    """Exec `seccomp-tools`."""
    _cmdline_ = "seccomp"
    _category_ = "07-b. External Command - Exploit Development"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        path = get_filepath()
        try:
            seccomp = which("seccomp-tools")
            gef_print(titlify(f"{seccomp} dump '{path}'"))
            os.system(f"{seccomp} dump '{path}'")
        except Exception:
            err("Missing `seccomp-tools`, install with: `gem install seccomp-tools`.")
        return


@register_command
class SysregCommand(GenericCommand):
    """Pretty-print system registers (not general parpose) from `info regiser`."""
    _cmdline_ = "sysreg"
    _category_ = "04-a. Register - View"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('filter', metavar='FILTER', nargs='*', help='filter string')
    _syntax_ = parser.format_help()

    def get_non_generic_regs(self):
        res = gdb.execute("info register", to_string=True)
        res = res.strip()
        regs = {}
        for line in res.splitlines():
            m = re.match(r"(\S+)\s*(0x\S+)\s+(0x\S+|\[.+\])", line)
            if not m:
                continue
            regname, regvalue = m.group(1), m.group(2)
            if self.filter and not any([f.lower() in regname.lower() for f in self.filter]):
                continue
            regs[regname] = int(regvalue, 16)
        regs = list(filter(lambda x: "$" + x[0] not in current_arch.all_registers, sorted(regs.items())))
        return regs # [[regname, regvalue], ...]

    def print_sysreg_compact(self):
        regs = self.get_non_generic_regs()
        if regs:
            gef_print(titlify("System registers"))
        else:
            gef_print("Not found non generic regs")
            return
        COLUMN = 3
        length = len(regs)
        length_of_each_bank = (length + COLUMN - 1) // COLUMN
        for i in range(length_of_each_bank):
            out = []
            for j in range(COLUMN):
                if len(regs) > i + j * length_of_each_bank:
                    if is_32bit():
                        msg = "{:16s} = {:#10x}".format(*regs[i + j * length_of_each_bank])
                    else:
                        msg = "{:25s} = {:#18x}".format(*regs[i + j * length_of_each_bank])
                    if regs[i + j * length_of_each_bank][1] > 0:
                        msg = Color.boldify(msg)
                    out.append(msg)
                else:
                    out.append("")
            gef_print("  |  ".join(out))
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        self.filter = args.filter
        self.print_sysreg_compact()
        return


@register_command
class MmxSetCommand(GenericCommand):
    """Simply set the value to mm."""
    _cmdline_ = "mmxset"
    _category_ = "04-b. Register - Modify"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('reg_and_value', metavar='REG=VALUE', help='MMX register and value you want to set.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} $mm0=0x1122334455667788".format(_cmdline_)

    def get_state(self, code_len):
        d = {}
        d["pc"] = get_register("$pc")
        d["code"] = read_memory(d["pc"], code_len)
        if is_x86_64():
            d["rax"] = get_register("$rax")
        else:
            d["eax"] = get_register("$eax")
        return d

    def revert_state(self, d):
        write_memory(d["pc"], d["code"], len(d["code"]))
        gdb.execute("set $pc = {:#x}".format(d["pc"]), to_string=True)
        if is_x86_64():
            gdb.execute("set $rax = {:#x}".format(d["rax"]), to_string=True)
        else:
            gdb.execute("set $eax = {:#x}".format(d["eax"]), to_string=True)
        return

    def close_stdout(self):
        self.stdout = 1
        self.stdout_bak = os.dup(self.stdout)
        f = open("/dev/null")
        os.dup2(f.fileno(), self.stdout)
        f.close()
        return

    def revert_stdout(self):
        os.dup2(self.stdout_bak, self.stdout)
        os.close(self.stdout_bak)
        return

    def execute_movq_mm(self, value, reg):
        REG_CODE = {
            "$mm0": b"\x0f\x6f\x00", # movq  mm0, qword ptr [rax]
            "$mm1": b"\x0f\x6f\x08", # movq  mm1, qword ptr [rax]
            "$mm2": b"\x0f\x6f\x10", # movq  mm2, qword ptr [rax]
            "$mm3": b"\x0f\x6f\x08", # movq  mm3, qword ptr [rax]
            "$mm4": b"\x0f\x6f\x20", # movq  mm4, qword ptr [rax]
            "$mm5": b"\x0f\x6f\x28", # movq  mm5, qword ptr [rax]
            "$mm6": b"\x0f\x6f\x30", # movq  mm6, qword ptr [rax]
            "$mm7": b"\x0f\x6f\x38", # movq  mm7, qword ptr [rax]
        }
        code = b"\xeb\xfe" + REG_CODE[reg] + p64(value) # inf-loop (to stop another thread); movq mm0, [rax]; db value
        gef_on_stop_unhook(hook_stop_handler)
        d = self.get_state(len(code))
        write_memory(d["pc"], code, len(code))
        if is_x86_64():
            ax = "rax"
        else:
            ax = "eax"
        gdb.execute("set ${:s} = {:#x}".format(ax, d["pc"] + 5), to_string=True) # points to p64(value)
        gdb.execute("set $pc = {:#x}".format(d["pc"] + 2), to_string=True) # skip "\xeb\xfe"
        self.close_stdout()
        gdb.execute("stepi", to_string=True)
        self.revert_stdout()
        self.revert_state(d)
        gef_on_stop_hook(hook_stop_handler)
        return

    @parse_args
    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, args):
        self.dont_repeat()

        # arg parse
        try:
            reg, value = args.reg_and_value.split("=")
            value = int(value, 0)
        except Exception:
            self.usage()
            return

        # check register is valid or not
        if reg not in ["$mm{:d}".format(i) for i in range(8)]:
            err("Invalid register name")
            return

        # modify
        self.execute_movq_mm(value, reg)
        return


@register_command
class MmxCommand(GenericCommand):
    """Show MMX registers."""
    _cmdline_ = "mmx"
    _category_ = "04-a. Register - View"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    def print_mmx(self):
        gef_print(titlify("MMX Register (from fpu register)"))
        regs = []

        for i in range(8):
            regname = "$st{:d}".format(i)
            result = gdb.execute(f"info registers $st{i}", to_string=True)
            r = re.findall(r"\(raw (0x[0-9a-f]+)\)", result)
            if r:
                reg = int(r[0], 16) & 0xffffffffffffffff
                regs.append(reg)

        fstat = get_register("$fstat")
        top_of_stack = (fstat >> 11) & 0b111
        regs = regs[-top_of_stack:] + regs[:-top_of_stack] # need rotate. because mmx0 != st(0)

        fmt = "{:5s}: {:s}"
        legend = ["Name", "64-bit hex"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        red = lambda x: Color.colorify("{:4s}".format(x), "bold red")
        for i in range(len(regs)):
            regname = "$mm{:d}".format(i)
            reghex = ""
            for j in range(8):
                c = (regs[i] >> (8 * j)) & 0xff
                reghex += chr(c) if 0x20 <= c < 0x7f else '.'
            gef_print("{:s} : {:#018x}  |  {:s}".format(red(regname), regs[i], reghex))
        return

    @parse_args
    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, args):
        self.dont_repeat()
        self.print_mmx()
        return


@register_command
class XmmSetCommand(GenericCommand):
    """Simply set the value to xmm / ymm."""
    _cmdline_ = "xmmset"
    _category_ = "04-b. Register - Modify"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('reg_and_value', metavar='REG=VALUE', help='XMM/YMM register and value you want to set.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} $ymm0=0x11223344556677889900aabbccddeeff9876543210".format(_cmdline_)

    @parse_args
    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, args):
        self.dont_repeat()

        # arg parse
        try:
            reg, value = args.reg_and_value.split("=")
            value = int(value, 0)
        except Exception:
            self.usage()
            return

        # check register is valid or not
        try:
            gdb.execute(f"info register {reg}", to_string=True)
        except Exception:
            err("Invalid register name")
            return

        # modify
        if "$xmm" in reg:
            for i in range(2):
                v = (value >> (64 * i)) & ((1 << 64) - 1)
                gdb.execute(f"set {reg}.v2_int64[{i}]={v:#x}", to_string=True)
        elif "$ymm" in reg:
            for i in range(4):
                v = (value >> (64 * i)) & ((1 << 64) - 1)
                gdb.execute(f"set {reg}.v4_int64[{i}]={v:#x}", to_string=True)
        else:
            err("Unsupported")
        return


@register_command
class SseCommand(GenericCommand):
    """Show SSE registers."""
    _cmdline_ = "sse"
    _category_ = "04-a. Register - View"
    _aliases_ = ["xmm"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-v', dest='verbose', action='store_true', help='also display bit information of mxcsr registers.')
    _syntax_ = parser.format_help()

    def print_sse(self):
        gef_print(titlify("SSE Data Register"))

        # xmm0-15
        regs = []
        for i in range(16 if is_x86_64() else 8):
            result = gdb.execute(f"info registers $xmm{i}", to_string=True)
            r = re.findall(r"uint128 = (0x[0-9a-f]+)", result)
            if r:
                reg = int(r[0], 16)
                regs.append(reg)
        fmt = "{:7s}: {:s}"
        legend = ["Name", "128-bit hex"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        red = lambda x: Color.colorify("{:4s}".format(x), "bold red")
        for i in range(len(regs)):
            if i == 8:
                gef_print("* xmm8-15 are introduced by AVX")
            reghex = ""
            for j in range(16):
                c = (regs[i] >> (8 * j)) & 0xff
                reghex += chr(c) if 0x20 <= c < 0x7f else '.'
            regname = "$xmm{:<2d}".format(i)
            gef_print("{:s} : {:#034x}  |  {:s}".format(red(regname), regs[i], reghex))
        return

    def print_sse_other(self):
        # mxcsr
        gef_print(titlify("MXCSR (MXCSR Control and Status Register)"))
        bit_info = [
            [15, "FZ", "Flush To Zero", ""],
            [[13, 14], "RC", "Rounding Control", "00: Round To Nearest, 01: Round Negative, 10: Round Positive, 11: Round To Zero"],
            [12, "PM", "Precision Exception Mask", ""],
            [11, "UM", "Underflow Exception Mask", ""],
            [10, "OM", "Overflow Exception Mask", ""],
            [9, "ZM", "Zero Divide Exception Mask", ""],
            [8, "DM", "Denormalized Opernad Exception Mask", ""],
            [7, "IM", "Invalid Operation Exception Mask", ""],
            [6, "DAZ", "Use as 0.0 if input data is denormalized", ""],
            [5, "PE", "Precision Exception", ""],
            [4, "UE", "Underflow Exception", ""],
            [3, "OE", "Overflow Exception", ""],
            [2, "ZE", "Zero Divide Exception", ""],
            [1, "DE", "Denormalized Operand Exception", ""],
            [0, "IE", "Invalid Operation Exception", ""],
        ]
        reg = int(gdb.execute("info registers $mxcsr", to_string=True).split()[1], 16)
        PrintBitInfo("$mxcsr", 32, None, bit_info).print(reg)
        return

    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.print_sse()
        if "-v" in argv:
            self.print_sse_other()
        else:
            info("for $mxcsr flags description, use `-v`")
        return


@register_command
class AvxCommand(GenericCommand):
    """Show AVX registers."""
    _cmdline_ = "avx"
    _category_ = "04-a. Register - View"
    _aliases_ = ["ymm"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    def print_avx(self):
        regs = []
        for i in range(16 if is_x86_64() else 8):
            try:
                result = gdb.execute(f"info registers $ymm{i}", to_string=True)
            except Exception:
                continue
            result = result.replace("\n", "")
            r = re.findall(r"v2_int128 = \{.*?\[0x0\] = (0x[0-9a-f]+),.*?\[0x1\] = (0x[0-9a-f]+).*?\}", result)
            if r:
                reg = (int(r[0][1], 16) << 128) + int(r[0][0], 16)
                regs.append(reg)
        if regs:
            gef_print(titlify("AVX Register"))
            fmt = "{:7s}: {:s}"
            legend = ["Name", "256-bit hex"]
            gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
            red = lambda x: Color.colorify("{:4s}".format(x), "bold red")
            for i in range(len(regs)):
                regname = "$ymm{:<2d}".format(i)
                reghex = ""
                for j in range(32):
                    c = (regs[i] >> (8 * j)) & 0xff
                    reghex += chr(c) if 0x20 <= c < 0x7f else '.'
                gef_print("{:s} : {:#066x}  |  {:s}".format(red(regname), regs[i], reghex))
        else:
            err("Not found avx registers")
        return

    @parse_args
    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, args):
        self.dont_repeat()
        self.print_avx()
        return


@register_command
class FpuCommand(GenericCommand):
    """Show fpu registers (x86/x64:x87-fpu, ARM/ARM64:vfp-d16)."""
    _cmdline_ = "fpu"
    _category_ = "04-a. Register - View"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-v', dest='verbose', action='store_true', help='also display bit information of fpu control registers.')
    _syntax_ = parser.format_help()

    def f2u(self, a):
        u = lambda a: struct.unpack("<I", a)[0]
        pf = lambda a: struct.pack("<f", a)
        return u(pf(a))

    def u2f(self, a):
        p = lambda a: struct.pack("<I", a & 0xffffffff)
        uf = lambda a: struct.unpack("<f", a)[0]
        return uf(p(a))

    def d2u(self, a):
        uQ = lambda a: struct.unpack("<Q", a)[0]
        pd = lambda a: struct.pack("<d", a)
        return uQ(pd(a))

    def u2d(self, a):
        pQ = lambda a: struct.pack("<Q", a & 0xffffffffffffffff)
        ud = lambda a: struct.unpack("<d", a)[0]
        return ud(pQ(a))

    def d2u80(self, a):
        value = ctypes.c_longdouble(a)
        BYTES = ctypes.POINTER(ctypes.c_byte * 10)
        ptr = ctypes.cast(ctypes.addressof(value), BYTES)
        x = ["{:02x}".format(int(x) & 0xff) for x in ptr[0][::-1]]
        return int(''.join(x), 16)

    def bits_split(self, x, bits=32):
        # 0xaaaabbbb -> 0xaaaa_bbbb
        out = ""
        for i in range(bits):
            if x & (1 << i):
                out = "1" + out
            else:
                out = "0" + out
            if i % 4 == 3:
                out = "_" + out
        return "0b" + out[1:]

    def print_fpu_arm(self):
        red = lambda x: Color.colorify("{:4s}".format(x), "bold red")

        # s0-s31, d0-d31, q0-q15
        gef_print(titlify("FPU/NEON Data Register"))
        fmt = "{:4s}: {:15s} {:10s} | {:4s}: {:28s} {:18s} | {:4s} {:34s}"
        legend = ["Name", "Value", "32-bit hex", "Name", "Value", "64-bit hex", "Name", "128-bit hex"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for i in range(32):
            regname1 = "$s{:d}".format(i)
            regname2 = "$d{:d}".format(i)
            regname3 = "$q{:d}".format(i)
            if is_32bit():
                reg1 = self.f2u(float(gdb.execute("p {}".format(regname1), to_string=True).split()[2]))
                reg2 = int(gdb.execute("p {}.u64".format(regname2), to_string=True).split()[2], 16)
                try:
                    reg3h = int(gdb.execute("p {}.u64[0]".format(regname3), to_string=True).split()[2], 16)
                    reg3l = int(gdb.execute("p {}.u64[1]".format(regname3), to_string=True).split()[2], 16)
                    reg3 = (reg3h << 64) + reg3l
                except Exception:
                    reg3 = None
            else:
                reg1 = int(gdb.execute("p {}.u".format(regname1), to_string=True).split()[2], 16)
                reg2 = int(gdb.execute("p {}.u".format(regname2), to_string=True).split()[2], 16)
                try:
                    reg3 = int(gdb.execute("p {}.u".format(regname3), to_string=True).split()[2], 16)
                except Exception:
                    reg3 = None

            fmt1 = "{:s}: {:15s} {:<#10x}".format(red(regname1), "{:<+.8e}".format(self.u2f(reg1)), reg1)
            fmt2 = "{:s}: {:28s} {:<#18x}".format(red(regname2), "{:<+.20e}".format(self.u2d(reg2)), reg2)
            if reg3 is None:
                fmt3 = "{:s}: {:s}".format(red(regname3), "Access denied")
            else:
                fmt3 = "{:s}: {:<#34x}".format(red(regname3), reg3)
            gef_print("{:s} | {:s} | {:s}".format(fmt1, fmt2, fmt3))
        return

    def print_fpu_x86(self):
        red = lambda x: Color.colorify("{:4s}".format(x), "bold red")

        # st0-7
        gef_print(titlify("FPU Data Register"))
        fmt = "{:9s} : {:27s}\t{:24s} {:18s} {:10s}"
        legend = ["Name", "Value", "80-bit hex(TWORD/XWORD)", "64-bit hex(QWORD)", "32-bit Hex(DWORD)"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))

        fstat = get_register("$fstat")
        top_of_stack = (fstat >> 11) & 0b111
        regs = ["mm{:d}".format(i) for i in range(8)]
        regs = regs[top_of_stack:] + regs[:top_of_stack] # need rotate. because mmx0 != st(0)

        for i in range(8):
            regname = "$st{:d}".format(i)
            result = gdb.execute("info registers {}".format(regname), to_string=True)
            if "invalid" in result:
                r = re.findall(r"\(raw (0x[0-9a-f]+)\)", result)
                u80 = int(r[0], 16)
                u64 = 0xfff8000000000000 # nan
                u32 = 0xffc00000 # nan
                gef_print("{:4s}({:3s}) : {:<27s}\t{:<#24x} {:<#18x} {:<#10x}".format(red(regname), regs[i], "<invalid>", u80, u64, u32))
            else:
                reg = float(result.split()[1])
                u80 = self.d2u80(reg)
                u64 = self.d2u(reg)
                u32 = self.f2u(reg)
                gef_print("{:4s}({:3s}) : {:<+.20e}\t{:<#24x} {:<#18x} {:<#10x}".format(red(regname), regs[i], reg, u80, u64, u32))
        info('XWORD: Real register value; Used at "fstp xword ptr [rax]".')
        info('QWORD: Used at "fst/fstp qword ptr [rax]".')
        info('DWORD: Used at "fst/fstp dword ptr [rax]".')
        return

    def print_fpu_arm_other(self):
        # fpscr
        gef_print(titlify("FPSCR (Floating-Point Status and Control Register)"))
        bit_info = [
            [31, "N", "Negative condition flag", ""],
            [30, "Z", "Zero condition flag", ""],
            [29, "C", "Carry condition flag", ""],
            [28, "V", "Overflow condition flag", ""],
            [27, "QC", "Cumulative saturation bit", ""],
            [26, "AHP", "Alternative Half-Precision Control", ""],
            [25, "DN", "Default NaN mode Control", ""],
            [24, "FZ", "Flush-to-zero mode Control", ""],
            [[22, 23], "RMode", "Rounding Control", "00: Round To Nearest, 01: Round Positive, 10: Round Negative, 11: Round To Zero"],
            [[20, 21], "Stride", "", "IMPLEMENTATION DEFINED"],
            [19, "FZ16", "Flush-to-zero mode Control", "When FEAT_FP16 is implemented"],
            [[16, 17, 18], "Len", "", "IMPLEMENTATION DEFINED"],
            [15, "IDE", "Input Denormal floating-point Exception trap enable", ""],
            [12, "IXE", "Inexact floating-point Exception trap enable", ""],
            [11, "UFE", "Underflow floating-point Exception trap enable", ""],
            [10, "OFE", "Overflow floating-point Exception trap enable", ""],
            [9, "DZE", "Divide by Zero floating-point Exception trap enable", ""],
            [8, "IOE", "Invalid Operation floating-point Exception trap enable", ""],
            [7, "IDC", "Input Denormal Cumulative floating-point exception bit", ""],
            [4, "IXC", "Inexact Cumulative floating-point exception bit", ""],
            [3, "UFC", "Underflow Cumulative floating-point exception bit", ""],
            [2, "OFC", "Overflow Cumulative floating-point exception bit", ""],
            [1, "DZC", "Divide by Zero Cumulative floating-point exception bit", ""],
            [0, "IOC", "Invalid Operation Cumulative floating-point exception bit", ""],
        ]
        reg = int(gdb.execute("info registers $fpscr", to_string=True).split()[1], 16)
        PrintBitInfo("$fpscr", 32, None, bit_info).print(reg)

        # fpsid
        gef_print(titlify("FPSID (Floating-Point System ID Register)"))
        bit_info = [
            [list(range(24, 32)), "Implementer", "Implementer code", ""],
            [23, "SW", "Software bit", "Implementation of floating point instructions, 0:HW, 1:SW"],
            [list(range(16, 23)), "Subarchitecture", "Subarchitecture version number", ""],
            [list(range(8, 16)), "PartNum", "Part number", "IMPLEMENTATION DEFINED"],
            [[4, 5, 6, 7], "Variant", "Variant number", "IMPLEMENTATION DEFINED"],
            [[0, 1, 2, 3], "Revision", "Revisino number", "IMPLEMENTATION DEFINED"],
        ]
        impl = {
            0x00: "Reserved for software use",
            0xc0: "Ampere Computing",
            0x41: "Arm Limited",
            0x42: "Broadcom Corporation",
            0x43: "Cavium Inc.",
            0x44: "Digital Equipment Corporation",
            0x46: "Fujitsu Ltd.",
            0x49: "Infineon Technologies AG",
            0x4d: "Motorola or Freescale Semiconductor Inc.",
            0x4e: "NVIDIA Corporation",
            0x50: "Applied Micro Circuits Corporation",
            0x51: "Qualcomm Inc.",
            0x56: "Marvell International Ltd.",
            0x69: "Intel Corporation",
        }
        reg = int(gdb.execute("info registers $fpsid", to_string=True).split()[1], 16)
        PrintBitInfo("$fpsid", 32, None, bit_info).print(reg)
        gef_print("Implementer code")
        for k, v in impl.items():
            gef_print("  {:#02x}: {:s}".format(k, v))

        # fpexc
        gef_print(titlify("FPEXC (Floating-Point Exception Control Register)"))
        bit_info = [
            [31, "EX", "Exception bit", ""],
            [30, "EN", "Enables access to the Advanced SIMD and floating-point functionality from all Exception levels", ""],
            [29, "DEX", "Defined synchronous exception on floating-point execution", ""],
            [28, "FP2V", "FPINST2 instruction valid bit", ""],
            [27, "VV", "VECITR valid bit", ""],
            [26, "TFV", "Trapped Fault Valid bit", ""],
            [[8, 9, 10], "VECITR", "Vector iteration count", ""],
            [7, "IDF", "Input Denormal trapped exception bit", ""],
            [4, "IXF", "Inexact trapped exception bit", ""],
            [3, "UFF", "Underflow trapped exception bit", ""],
            [2, "OFF", "Overflow trapped exception bit", ""],
            [1, "DZF", "Divide by Zero trapped exception bit", ""],
            [0, "IOF", "Invalid Operation trapped exception bit", ""],
        ]
        reg = int(gdb.execute("info registers $fpexc", to_string=True).split()[1], 16)
        PrintBitInfo("$fpexc", 32, None, bit_info).print(reg)
        return

    def print_fpu_arm64_other(self):
        # fpcr
        gef_print(titlify("FPCR (Floating-Point Control Register)"))
        bit_info = [
            [26, "AHP", "Alternative Half-Precision Control", ""],
            [25, "DN", "Default NaN mode Control", ""],
            [24, "FZ", "Flush-to-zero mode Control", ""],
            [[22, 23], "RMode", "Rounding Control", "00: Round To Nearest, 01: Round Positive, 10: Round Negative, 11: Round To Zero"],
            [[20, 21], "Stride", "", "Unused"],
            [19, "FZ16", "Flush-to-zero mode Control", "When FEAT_FP16 is implemented"],
            [[16, 17, 18], "Len", "", "Unused"],
            [15, "IDE", "Input Denormal floating-point Exception trap enable", ""],
            [12, "IXE", "Inexact floating-point Exception trap enable", ""],
            [11, "UFE", "Underflow floating-point Exception trap enable", ""],
            [10, "OFE", "Overflow floating-point Exception trap enable", ""],
            [9, "DZE", "Divide by Zero floating-point Exception trap enable", ""],
            [8, "IOE", "Invalid Operation floating-point Exception trap enable", ""],
        ]
        reg = int(gdb.execute("info registers $fpcr", to_string=True).split()[1], 16)
        PrintBitInfo("$fpcr", 32, None, bit_info).print(reg)

        # fpsr
        gef_print(titlify("FPCR (Floating-Point Status Register)"))
        bit_info = [
            [31, "N", "", "Unused, see $cpsr"],
            [30, "Z", "", "Unused, see $cpsr"],
            [29, "C", "", "Unused, see $cpsr"],
            [28, "V", "", "Unused, see $cpsr"],
            [27, "QC", "Cumulative saturation bit", ""],
            [7, "IDC", "Input Denormal Cumulative floating-point exception bit", ""],
            [4, "IXC", "Inexact Cumulative floating-point exception bit", ""],
            [3, "UFC", "Underflow Cumulative floating-point exception bit", ""],
            [2, "OFC", "Overflow Cumulative floating-point exception bit", ""],
            [1, "DZC", "Divide by Zero Cumulative floating-point exception bit", ""],
            [0, "IOC", "Invalid Operation Cumulative floating-point exception bit", ""],
        ]
        reg = int(gdb.execute("info registers $fpsr", to_string=True).split()[1], 16)
        PrintBitInfo("$fpsr", 32, None, bit_info).print(reg)
        return

    def print_fpu_x86_other(self):
        # fctrl
        gef_print(titlify("FCTRL (x87 FPU Control Word)"))
        bit_info = [
            [12, "X", "Infinity Control", ""],
            [[10, 11], "RC", "Rounding Control", "00: Round To Nearest, 01: Round Negative, 10: Round Positive, 11: Round To Zero"],
            [[8, 9], "PC", "Precision Control", "00: Signle Precison, 01: Reserved, 10: Double Precision, 11: Double-Extended Precision"],
            [5, "PM", "Precision Exception Mask", ""],
            [4, "UM", "Underflow Exception Mask", ""],
            [3, "OM", "Overflow Exception Mask", ""],
            [2, "ZM", "Zero Divide Exception Mask", ""],
            [1, "DM", "Denormalized Opernd Exception Mask", ""],
            [0, "IM", "Invalid Operation Exception Mask", ""],
        ]
        reg = int(gdb.execute("info registers $fctrl", to_string=True).split()[1], 16)
        PrintBitInfo("$fctrl", 16, None, bit_info).print(reg)

        # fstat
        gef_print(titlify("FSTAT (x87 FPU Status Word)"))
        bit_info = [
            [15, "B", "FPU Busy", ""],
            [14, "C3", "Condition Code", ""],
            [[11, 12, 13], "TOP", "Top of Stack Pointer", ""],
            [10, "C2", "Condition Code", ""],
            [9, "C1", "Condition Code", ""],
            [8, "C0", "Condition Code", ""],
            [7, "ES", "Exception Summary Status", ""],
            [6, "SF", "Stack Fault", ""],
            [5, "PE", "Precision Exception", ""],
            [4, "UE", "Underflow Exception", ""],
            [3, "OE", "Overflow Exception", ""],
            [2, "ZE", "Zero Divide Exception", ""],
            [1, "DE", "Denormalized Operand Exception", ""],
            [0, "IE", "Invalid Operation Exception", ""],
        ]
        reg = int(gdb.execute("info registers $fstat", to_string=True).split()[1], 16)
        PrintBitInfo("$fstat", 16, None, bit_info).print(reg)

        # ftag
        gef_print(titlify("FTAG (x87 FPU Tag Word)"))
        bit_info = [
            [[14, 15], "TAG(7)", "Reg7 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
            [[12, 13], "TAG(6)", "Reg6 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
            [[10, 11], "TAG(5)", "Reg5 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
            [[8, 9], "TAG(4)", "Reg4 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
            [[6, 7], "TAG(3)", "Reg3 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
            [[4, 5], "TAG(2)", "Reg2 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
            [[2, 3], "TAG(1)", "Reg1 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
            [[0, 1], "TAG(0)", "Reg0 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
        ]
        reg = int(gdb.execute("info registers $ftag", to_string=True).split()[1], 16)
        PrintBitInfo("$ftag", 16, None, bit_info).print(reg)

        # $fiseg, $fioff
        gef_print(titlify("FCS:FIP (x87 FPU Last Instruction Pointer)"))
        reg = int(gdb.execute("info registers $fiseg", to_string=True).split()[1], 16)
        reg = int(gdb.execute("info registers $fioff", to_string=True).split()[1], 16)
        PrintBitInfo("$fiseg(FCS)", 16, None, bit_info=[]).print(reg, split=False)
        PrintBitInfo("$fioff(FIP)", 32, None, bit_info=[]).print(reg, split=False)

        # $foseg, $fooff
        gef_print(titlify("FDS:FDP (x87 FPU Last Data(Operand) Pointer)"))
        reg = int(gdb.execute("info registers $foseg", to_string=True).split()[1], 16)
        reg = int(gdb.execute("info registers $fooff", to_string=True).split()[1], 16)
        PrintBitInfo("$foseg(FDS)", 16, None, bit_info=[]).print(reg, split=False)
        PrintBitInfo("$fooff(FDP)", 32, None, bit_info=[]).print(reg, split=False)

        # $fop
        gef_print(titlify("FOP (x87 FPU Last Instruction Opcode)"))
        reg = int(gdb.execute("info registers $fop", to_string=True).split()[1], 16)
        PrintBitInfo("$fop", 11, None, bit_info=[]).print(reg, split=False)
        return

    @parse_args
    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, args):
        self.dont_repeat()

        if is_x86():
            self.print_fpu_x86()
        elif is_arm32() or is_arm64():
            self.print_fpu_arm()

        if args.verbose:
            if is_x86():
                self.print_fpu_x86_other()
            elif is_arm32():
                self.print_fpu_arm_other()
            elif is_arm64():
                self.print_fpu_arm64_other()
        else:
            info("for fpu other register's flags description, use `-v`")
        return


@register_command
class ErrnoCommand(GenericCommand):
    """Converts errno (or argument) to its string representation."""
    _cmdline_ = "errno"
    _category_ = "02-d. Process Information - Trivial Information"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('errno', metavar='ERRNO', nargs='?', type=lambda x: int(x, 0),
                        help='show specific errno definitions.')
    parser.add_argument('--all', action='store_true', help='show all errno definitions.')
    _syntax_ = parser.format_help()

    # /usr/include/asm-generic/errno.h
    ERRNO_DICT = {
        0   : ["-",               "No error"],
        1   : ["EPERM",           "Operation not permitted"],
        2   : ["ENOENT",          "No such file or directory"],
        3   : ["ESRCH",           "No such process"],
        4   : ["EINTR",           "Interrupted system call"],
        5   : ["EIO",             "I/O error"],
        6   : ["ENXIO",           "No such device or address"],
        7   : ["E2BIG",           "Argument list too long"],
        8   : ["ENOEXEC",         "Exec format error"],
        9   : ["EBADF",           "Bad file number"],
        10  : ["ECHILD",          "No child processes"],
        11  : ["EAGAIN",          "Try again"],
        12  : ["ENOMEM",          "Out of memory"],
        13  : ["EACCES",          "Permission denied"],
        14  : ["EFAULT",          "Bad address"],
        15  : ["ENOTBLK",         "Block device required"],
        16  : ["EBUSY",           "Device or resource busy"],
        17  : ["EEXIST",          "File exists"],
        18  : ["EXDEV",           "Cross-device link"],
        19  : ["ENODEV",          "No such device"],
        20  : ["ENOTDIR",         "Not a directory"],
        21  : ["EISDIR",          "Is a directory"],
        22  : ["EINVAL",          "Invalid argument"],
        23  : ["ENFILE",          "File table overflow"],
        24  : ["EMFILE",          "Too many open files"],
        25  : ["ENOTTY",          "Not a typewriter"],
        26  : ["ETXTBSY",         "Text file busy"],
        27  : ["EFBIG",           "File too large"],
        28  : ["ENOSPC",          "No space left on device"],
        29  : ["ESPIPE",          "Illegal seek"],
        30  : ["EROFS",           "Read-only file system"],
        31  : ["EMLINK",          "Too many links"],
        32  : ["EPIPE",           "Broken pipe"],
        33  : ["EDOM",            "Math argument out of domain of func"],
        34  : ["ERANGE",          "Math result not representable"],
        35  : ["EDEADLK",         "Resource deadlock would occur"],
        36  : ["ENAMETOOLONG",    "File name too long"],
        37  : ["ENOLCK",          "No record locks available"],
        38  : ["ENOSYS",          "Invalid system call number"],
        39  : ["ENOTEMPTY",       "Directory not empty"],
        40  : ["ELOOP",           "Too many symbolic links encountered"],
        42  : ["ENOMSG",          "No message of desired type"],
        43  : ["EIDRM",           "Identifier removed"],
        44  : ["ECHRNG",          "Channel number out of range"],
        45  : ["EL2NSYNC",        "Level 2 not synchronized"],
        46  : ["EL3HLT",          "Level 3 halted"],
        47  : ["EL3RST",          "Level 3 reset"],
        48  : ["ELNRNG",          "Link number out of range"],
        49  : ["EUNATCH",         "Protocol driver not attached"],
        50  : ["ENOCSI",          "No CSI structure available"],
        51  : ["EL2HLT",          "Level 2 halted"],
        52  : ["EBADE",           "Invalid exchange"],
        53  : ["EBADR",           "Invalid request descriptor"],
        54  : ["EXFULL",          "Exchange full"],
        55  : ["ENOANO",          "No anode"],
        56  : ["EBADRQC",         "Invalid request code"],
        57  : ["EBADSLT",         "Invalid slot"],
        59  : ["EBFONT",          "Bad font file format"],
        60  : ["ENOSTR",          "Device not a stream"],
        61  : ["ENODATA",         "No data available"],
        62  : ["ETIME",           "Timer expired"],
        63  : ["ENOSR",           "Out of streams resources"],
        64  : ["ENONET",          "Machine is not on the network"],
        65  : ["ENOPKG",          "Package not installed"],
        66  : ["EREMOTE",         "Object is remote"],
        67  : ["ENOLINK",         "Link has been severed"],
        68  : ["EADV",            "Advertise error"],
        69  : ["ESRMNT",          "Srmount error"],
        70  : ["ECOMM",           "Communication error on send"],
        71  : ["EPROTO",          "Protocol error"],
        72  : ["EMULTIHOP",       "Multihop attempted"],
        73  : ["EDOTDOT",         "RFS specific error"],
        74  : ["EBADMSG",         "Not a data message"],
        75  : ["EOVERFLOW",       "Value too large for defined data type"],
        76  : ["ENOTUNIQ",        "Name not unique on network"],
        77  : ["EBADFD",          "File descriptor in bad state"],
        78  : ["EREMCHG",         "Remote address changed"],
        79  : ["ELIBACC",         "Can not access a needed shared library"],
        80  : ["ELIBBAD",         "Accessing a corrupted shared library"],
        81  : ["ELIBSCN",         ".lib section in a.out corrupted"],
        82  : ["ELIBMAX",         "Attempting to link in too many shared libraries"],
        83  : ["ELIBEXEC",        "Cannot exec a shared library directly"],
        84  : ["EILSEQ",          "Illegal byte sequence"],
        85  : ["ERESTART",        "Interrupted system call should be restarted"],
        86  : ["ESTRPIPE",        "Streams pipe error"],
        87  : ["EUSERS",          "Too many users"],
        88  : ["ENOTSOCK",        "Socket operation on non-socket"],
        89  : ["EDESTADDRREQ",    "Destination address required"],
        90  : ["EMSGSIZE",        "Message too long"],
        91  : ["EPROTOTYPE",      "Protocol wrong type for socket"],
        92  : ["ENOPROTOOPT",     "Protocol not available"],
        93  : ["EPROTONOSUPPORT", "Protocol not supported"],
        94  : ["ESOCKTNOSUPPORT", "Socket type not supported"],
        95  : ["EOPNOTSUPP",      "Operation not supported on transport endpoint"],
        96  : ["EPFNOSUPPORT",    "Protocol family not supported"],
        97  : ["EAFNOSUPPORT",    "Address family not supported by protocol"],
        98  : ["EADDRINUSE",      "Address already in use"],
        99  : ["EADDRNOTAVAIL",   "Cannot assign requested address"],
        100 : ["ENETDOWN",        "Network is down"],
        101 : ["ENETUNREACH",     "Network is unreachable"],
        102 : ["ENETRESET",       "Network dropped connection because of reset"],
        103 : ["ECONNABORTED",    "Software caused connection abort"],
        104 : ["ECONNRESET",      "Connection reset by peer"],
        105 : ["ENOBUFS",         "No buffer space available"],
        106 : ["EISCONN",         "Transport endpoint is already connected"],
        107 : ["ENOTCONN",        "Transport endpoint is not connected"],
        108 : ["ESHUTDOWN",       "Cannot send after transport endpoint shutdown"],
        109 : ["ETOOMANYREFS",    "Too many references: cannot splice"],
        110 : ["ETIMEDOUT",       "Connection timed out"],
        111 : ["ECONNREFUSED",    "Connection refused"],
        112 : ["EHOSTDOWN",       "Host is down"],
        113 : ["EHOSTUNREACH",    "No route to host"],
        114 : ["EALREADY",        "Operation already in progress"],
        115 : ["EINPROGRESS",     "Operation now in progress"],
        116 : ["ESTALE",          "Stale file handle"],
        117 : ["EUCLEAN",         "Structure needs cleaning"],
        118 : ["ENOTNAM",         "Not a XENIX named type file"],
        119 : ["ENAVAIL",         "No XENIX semaphores available"],
        120 : ["EISNAM",          "Is a named type file"],
        121 : ["EREMOTEIO",       "Remote I/O error"],
        122 : ["EDQUOT",          "Quota exceeded"],
        123 : ["ENOMEDIUM",       "No medium found"],
        124 : ["EMEDIUMTYPE",     "Wrong medium type"],
        125 : ["ECANCELED",       "Operation Canceled"],
        126 : ["ENOKEY",          "Required key not available"],
        127 : ["EKEYEXPIRED",     "Key has expired"],
        128 : ["EKEYREVOKED",     "Key has been revoked"],
        129 : ["EKEYREJECTED",    "Key was rejected by service"],
        130 : ["EOWNERDEAD",      "Owner died"],
        131 : ["ENOTRECOVERABLE", "State not recoverable"],
        132 : ["ERFKILL",         "Operation not possible due to RF-kill"],
        133 : ["EHWPOISON",       "Memory page has hardware error"],
    }

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()

        if args.all:
            for val, es in sorted(self.ERRNO_DICT.items()):
                gef_print("{:3d} (={:#4x}): {:<15s}: \"{:s}\"".format(val, val, es[0], es[1]))
            return

        if args.errno is None:
            if not is_alive():
                warn("No debugging session active")
                return
            try:
                val = parse_address("*__errno_location()")
            except Exception:
                err("Failed to get *__errno_location()")
                return
        else:
            val = args.errno

        if val > 0xffff:
            if current_arch and current_arch.ptrsize == 4:
                val = struct.unpack("<i", struct.pack("<I", val))[0]
            elif current_arch and current_arch.ptrsize == 8:
                val = struct.unpack("<q", struct.pack("<Q", val))[0]
            elif current_arch is None:
                val = struct.unpack("<q", struct.pack("<Q", val))[0]
            else:
                err("not support this pointer size.")
                return

        if val < 0:
            val = -val

        if val in self.ERRNO_DICT:
            es = self.ERRNO_DICT[val]
            gef_print("{:3d} (={:#4x}): {:<15s}: \"{:s}\"".format(val, val, es[0], es[1]))
        else:
            err("not found value in ERRNO_DICT (1~{:d})".format(len(self.ERRNO_DICT)))
        return


@register_command
class ExtractHeapAddrCommand(GenericCommand):
    """Extract heap address from protected `fd` pointer of single linked-list. (introduced from glibc 2.32)"""
    _cmdline_ = "extract-heap-addr"
    _category_ = "06-a. Heap - Glibc"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('value', metavar='VALUE', nargs='?', type=lambda x: int(x, 0), help='the value you want to extract.')
    group.add_argument('--source', action='store_true', help='shows the source instead of displaying extractedd value.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} 0x000055500000C7F9".format(_cmdline_)

    def reveal(self, fd):
        # https://smallkirby.hatenablog.com/entry/safeunlinking
        L = fd >> 36
        for i in range(3):
            temp = (fd >> (36 - (i + 1) * 8)) & 0xff
            element = ((L >> 4) ^ temp) & 0xff
            L = (L << 8) + element
        return L << 12

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        if args.source:
            s = inspect.getsource(ExtractHeapAddrCommand.reveal).rstrip()
            gef_print(s)
            return

        ptr = args.value
        extracted_ptr = self.reveal(ptr)
        gef_print("Protected fd pointer: {:#x} -> Extracted heap address: {:#x} (=fd & ~0xfff)".format(ptr, extracted_ptr))
        return


@register_command
class FindFakeFastCommand(GenericCommand):
    """Find candidate fake fast chunks from rw memory."""
    _cmdline_ = "find-fake-fast"
    _category_ = "06-a. Heap - Glibc"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--include-heap', action='store_true', help='heap is also included in the search target.')
    parser.add_argument('--aligned', action='store_true', help='search only aligned chunks.')
    parser.add_argument('size', metavar='SIZE', type=parse_address, help='search target size.')
    _syntax_ = parser.format_help()

    def print_result(self, m, pos, size_candidate):
        path = "unknown" if m.path == "" else m.path
        info("Found at {:#x} in {:s} [{:s}]".format(m.page_start + pos, repr(path), str(m.permission)))

        if current_arch.ptrsize == 4:
            res = gdb.execute("x/6xw {:#x}".format(m.page_start + pos), to_string=True)
        else:
            res = gdb.execute("x/6xg {:#x}".format(m.page_start + pos), to_string=True)
        flag = []
        flag += [Color.colorify("NON_MAIN_ARENA", "bold yellow") if (size_candidate & 0b100) else Color.colorify("NON_MAIN_ARENA", "normal")]
        flag += [Color.colorify("IS_MMAPED", "bold blue") if (size_candidate & 0b10) else Color.colorify("IS_MMAPED", "normal")]
        flag += [Color.colorify("PREV_INUSE", "bold red") if (size_candidate & 0b1) else Color.colorify("PREV_INUSED", "normal")]
        gef_print("    [{:s}]".format(' '.join(flag)))
        for line in res.splitlines():
            gef_print("    {:s}".format(line))

    def find_fake_fast(self, target_size):
        mask = ~0x7 if current_arch.ptrsize == 4 else ~0xf
        target_size &= mask
        vmmap = get_process_maps()
        unpack = u32 if current_arch.ptrsize == 4 else u64
        for m in vmmap:
            if not (m.permission & Permission.READ) or not (m.permission & Permission.WRITE):
                continue
            if m.path == "[vvar]":
                continue
            if not self.include_heap and m.path == "[heap]":
                continue
            data = read_memory(m.page_start, m.size)
            # Scanning page-by-page
            for pos in range(0, m.size, gef_getpagesize()):
                # fast check for all zero, because there may be huge mmap-ed memory
                if b"\0" * gef_getpagesize() == data[pos:pos + gef_getpagesize()]:
                    continue
                # this page has some data
                unit = 0x10 if self.aligned else 1
                for posb in range(pos, pos + gef_getpagesize(), unit):
                    size_candidate = data[posb + current_arch.ptrsize:posb + current_arch.ptrsize * 2]
                    if len(size_candidate) != current_arch.ptrsize:
                        break
                    size_candidate = unpack(size_candidate)
                    if (size_candidate & mask) != target_size:
                        continue
                    self.print_result(m, posb, size_candidate)
        return

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()
        self.include_heap = args.include_heap
        self.aligned = args.aligned
        self.find_fake_fast(args.size)
        return


@register_command
class VisualHeapCommand(GenericCommand):
    """Visualize chunks on a heap."""
    _cmdline_ = "visual-heap"
    _category_ = "06-a. Heap - Glibc"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('location', metavar='LOCATION', nargs='?', type=parse_address,
                        help='the address you want to interpret as the beginning of a contiguous chunk. (default: arena.heap_base)')
    parser.add_argument('-a', dest='arena_addr', type=parse_address,
                        help='the address you want to interpret as an arena. (default: main_arena)')
    parser.add_argument('-c', dest='max_count', type=parse_address,
                        help='Maximum count to parse. It is used when there is a very large amount of chunks.')
    parser.add_argument('--full', action='store_true', help='display the same line without omitting.')
    parser.add_argument('-n', '--no-pager', action='store_true', help='do not use less.')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def subinfo(self, addr):
        s = ""
        for k, v in self.tcache_list.items():
            if addr in v:
                s += "{} {}".format(LEFT_ARROW, "tcache[{}]".format(k))
        for k, v in self.fastbin_list.items():
            if addr in v:
                s += "{} {}".format(LEFT_ARROW, "fastbin[{}]".format(k))
        for k, v in self.unsortedbin_list.items():
            if addr in v:
                s += "{} {}".format(LEFT_ARROW, "unsortedbin")
        for k, v in self.smallbin_list.items():
            if addr in v:
                s += "{} {}".format(LEFT_ARROW, "smallbin[{}]".format(k))
        for k, v in self.largebin_list.items():
            if addr in v:
                s += "{} {}".format(LEFT_ARROW, "largebin[{}]".format(k))
        if addr == self.top:
            s += "{} {}".format(LEFT_ARROW, "top chunk")
        return s

    def generate_visual_chunk(self, chunk, color_func):
        ptrsize = current_arch.ptrsize
        unpack = u32 if ptrsize == 4 else u64
        data = slicer(chunk.data, ptrsize * 2)
        group_line_threshold = 8

        addr = chunk.chunk_base_address
        width = ptrsize * 2 + 2
        done = False
        for blk, blks in itertools.groupby(data):
            repeat_count = len(list(blks))
            d1, d2 = unpack(blk[:ptrsize]), unpack(blk[ptrsize:])
            dascii = ''.join(map(lambda x: chr(x) if 0x20 <= x < 0x7f else '.', blk))

            if self.full or repeat_count < group_line_threshold:
                for i in range(repeat_count):
                    sub_info = self.subinfo(addr)
                    dump = f"{addr:#x}: {d1:#0{width:d}x} {d2:#0{width:d}x} | {dascii:s} | {sub_info:s}"
                    self.out.append(color_func(dump))
                    addr += ptrsize * 2
                    if addr > self.top + ptrsize * 4:
                        dump = Color.boldify("...")
                        self.out.append(dump)
                        done = True
                        break
            else:
                sub_info = self.subinfo(addr)
                dump = f"{addr:#x}: {d1:#0{width:d}x} {d2:#0{width:d}x} | {dascii:s} | {sub_info:s}"
                self.out.append(color_func(dump))
                dump = "* {:#d} lines, {:#x} bytes".format(repeat_count - 1, (repeat_count - 1) * ptrsize * 2)
                self.out.append(color_func(dump))
                addr += ptrsize * 2 * repeat_count

            if done:
                break

        return

    def generate_visual_heap(self, max_count):
        sect = process_lookup_address(self.dump_start)
        addr = self.dump_start
        i = 0
        color = [Color.redify, Color.greenify, Color.blueify, Color.yellowify]
        self.out = []
        while addr < sect.page_end:
            chunk = GlibcChunk(addr + current_arch.ptrsize * 2)
            # corrupt check
            if addr != self.top and addr + chunk.size > self.top:
                msg = "{} Corrupted (addr + chunk.size > self.top)".format(Color.colorify("[!]", "bold red"))
                self.out.append(msg)
                chunk.data = read_memory(addr, self.top - addr + 0x10)
                self.generate_visual_chunk(chunk, Color.grayify)
                break
            elif addr + chunk.size > sect.page_end:
                msg = "{} Corrupted (addr + chunk.size > sect.page_end)".format(Color.colorify("[!]", "bold red"))
                self.out.append(msg)
                chunk.data = read_memory(addr, self.top - addr + 0x10)
                self.generate_visual_chunk(chunk, Color.grayify)
                break
            # maybe not corrupted
            try:
                chunk.data = read_memory(addr, chunk.size)
            except gdb.MemoryError:
                break
            color_func = color[i % len(color)]
            self.generate_visual_chunk(chunk, color_func)
            addr += chunk.size
            i += 1

            if max_count and max_count < i:
                break
        return

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        self.full = args.full

        if args.arena_addr:
            self.arena = get_thread_arena(args.arena_addr)
        else:
            self.arena = get_main_arena()

        if self.arena is None:
            err("No valid arena")
            return

        if self.arena.heap_base is None:
            err("Heap is not initialized")
            return

        if args.location:
            self.dump_start = args.location
        else:
            self.dump_start = self.arena.heap_base
            # specific pattern
            if current_arch.ptrsize == 4 and self.arena.is_main_arena():
                self.dump_start += 8

        try:
            self.tcache_list = self.arena.tcache_list() if self.arena else []
            self.fastbin_list = self.arena.fastbin_list() if self.arena else []
            self.unsortedbin_list = self.arena.unsortedbin_list() if self.arena else []
            self.smallbin_list = self.arena.smallbin_list() if self.arena else []
            self.largebin_list = self.arena.largebin_list() if self.arena else []
            self.top = int(self.arena.top) if self.arena else None
        except gdb.MemoryError as e:
            err("Memoryr read error: {}".format(e))
            return

        try:
            self.generate_visual_heap(args.max_count)
        except Exception:
            pass
        gef_print('\n'.join(self.out), less=not args.no_pager)
        return


@register_command
class U2dCommand(GenericCommand):
    """Translate type (unsigned long <-> double/float)."""
    _cmdline_ = "u2d"
    _category_ = "09-a. Misc - Translation"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('value', metavar='VALUE', help='the hex value or double value.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} 0xdeadbeef\n".format(_cmdline_)
    _example_ += "{:s} 0.12345\n".format(_cmdline_)
    _example_ += "{:s} 1.2345e-1\n".format(_cmdline_)
    _example_ += " * only ~64bit supported (Unsupported 80bit, 128bit)"

    def f2u(self, x):
        u = lambda a: struct.unpack("<I", a)[0]
        pf = lambda a: struct.pack("<f", a)
        return u(pf(x))

    def u2f(self, x):
        p = lambda a: struct.pack("<I", a & 0xffffffff)
        uf = lambda a: struct.unpack("<f", a)[0]
        return uf(p(x))

    def d2u(self, x):
        uQ = lambda a: struct.unpack("<Q", a)[0]
        pd = lambda a: struct.pack("<d", a)
        return uQ(pd(x))

    def u2d(self, x):
        pQ = lambda a: struct.pack("<Q", a & 0xffffffffffffffff)
        ud = lambda a: struct.unpack("<d", a)[0]
        return ud(pQ(x))

    def translate_from_float(self, n):
        gef_print(titlify("double -> unsigned long long"))
        gef_print(Color.cyanify("double -> ull (reinterpret_cast)"))
        gef_print("  {:.20e} ---> {:#018x}".format(n, self.d2u(n)))
        gef_print(titlify("float -> float"))
        gef_print(Color.cyanify("float -> uint (reinterpret_cast)"))
        gef_print("  {:.20e} ---> {:#010x}".format(n, self.f2u(n)))
        return

    def translate_from_int(self, n):
        n &= 0xffffffffffffffff
        gef_print(titlify("unsigned long long <-> double"))
        gef_print(Color.cyanify("ull -> double (reinterpret_cast)"))
        gef_print("  {:#018x} ---> {:.20e}".format(n, self.u2d(n)))
        gef_print(Color.cyanify("ull -> double -> ull (static_cast)"))
        gef_print("  {:#018x} ---> {:#018x} ---> {:#018x}".format(n, self.d2u(float(n)), int(self.u2d(self.d2u(float(n))))))
        gef_print(Color.cyanify("double -> ull (reinterpret_cast)"))
        gef_print("  {:#018x} ---> {:#018x}".format(n, int(self.u2d(n))))

        n &= 0xffffffff
        gef_print(titlify("unsigned int <-> float"))
        gef_print(Color.cyanify("uint -> float (reinterpret_cast)"))
        gef_print("  {:#010x} ---> {:.20e}".format(n, self.u2f(n)))
        gef_print(Color.cyanify("uint -> float -> uint (static_cast)"))
        gef_print("  {:#010x} ---> {:#010x} ---> {:#010x}".format(n, self.f2u(float(n)), int(self.u2f(self.f2u(float(n))))))
        gef_print(Color.cyanify("float -> uint (reinterpret_cast)"))
        gef_print("  {:#010x} ---> {:#010x}".format(n, int(self.u2f(n))))
        return

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()

        try:
            if "." in args.value:
                n = float(args.value)
                self.translate_from_float(n)
            else:
                n = int(args.value, 0)
                self.translate_from_int(n)
        except Exception:
            self.usage()
        return


@register_command
class PackCommand(GenericCommand):
    """Translate integer -> string."""
    _cmdline_ = "pack"
    _category_ = "09-a. Misc - Translation"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('value', metavar='VALUE', type=lambda x: int(x, 0), help='the value you want to translate.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} 0xdeadbeef".format(_cmdline_)

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()

        gef_print("pack8:   {}".format(p8(args.value & 0xff)))
        gef_print("pack16:  {}".format(p16(args.value & 0xffff)))
        gef_print("pack32:  {}".format(p32(args.value & 0xffffffff)))
        gef_print("pack64:  {}".format(p64(args.value & 0xffffffffffffffff)))
        low = args.value & 0xffffffffffffffff
        high = (args.value >> 64) & 0xffffffffffffffff
        val128 = p64(low) + p64(high)
        gef_print("pack128: {}".format(val128))

        gef_print("pack8-hex:   {}".format(p8(args.value & 0xff).hex()))
        gef_print("pack16-hex:  {}".format(p16(args.value & 0xffff).hex()))
        gef_print("pack32-hex:  {}".format(p32(args.value & 0xffffffff).hex()))
        gef_print("pack64-hex:  {}".format(p64(args.value & 0xffffffffffffffff).hex()))
        gef_print("pack128-hex: {}".format(val128.hex()))
        return


@register_command
class UnpackCommand(GenericCommand):
    """Translate string -> integer."""
    _cmdline_ = "unpack"
    _category_ = "09-a. Misc - Translation"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('value', metavar='"double-escaped string"', help='the value you want to translate.')
    _syntax_ = parser.format_help()

    _example_ = '{:s} "\\\\x41\\\\x42\\\\x43\\\\x44"'.format(_cmdline_)

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()

        try:
            value = codecs.escape_decode(args.value)[0] + b"\0" * 16
        except binascii.Error:
            gef_print("Could not decode '\\xXX' encoded string \"{}\"".format(args.value))
            return
        gef_print("unpack8:   {:#04x}".format(u8(value[:1])))
        gef_print("unpack16:  {:#06x}".format(u16(value[:2])))
        gef_print("unpack32:  {:#010x}".format(u32(value[:4])))
        gef_print("unpack64:  {:#018x}".format(u64(value[:8])))
        low, high = value[:8], value[8:16]
        gef_print("unpack128: {:#034x}".format((u64(high) << 64) | u64(low)))
        return


@register_command
class TohexCommand(GenericCommand):
    """Translate bytes -> hex."""
    _cmdline_ = "tohex"
    _category_ = "09-a. Misc - Translation"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('value', metavar='"double-escaped string"', help='the value you want to translate.')
    _syntax_ = parser.format_help()

    _example_ = '{:s} "\\\\x41\\\\x42\\\\x43\\\\x44"'.format(_cmdline_)

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()

        try:
            value = codecs.escape_decode(args.value)[0]
        except binascii.Error:
            gef_print("Could not decode '\\xXX' encoded string \"{}\"".format(args.value))
            return

        gef_print(binascii.hexlify(value))
        return


@register_command
class UnhexCommand(GenericCommand):
    """Translate hex -> bytes."""
    _cmdline_ = "unhex"
    _category_ = "09-a. Misc - Translation"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('value', metavar='"hex-string"', help='the value you want to translate.')
    _syntax_ = parser.format_help()

    _example_ = '{:s} "41414242 43434444"'.format(_cmdline_)

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()

        code = args.value.replace(" ", "")
        try:
            value = binascii.unhexlify(code)
        except binascii.Error:
            gef_print("Could not unhexlify")
            return

        gef_print(value)
        return


@register_command
class ByteswapCommand(GenericCommand):
    """Translate endian (little-endian <-> big-endian)."""
    _cmdline_ = "byteswap"
    _category_ = "09-a. Misc - Translation"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('value', metavar='VALUE', type=lambda x: int(x, 0), help='the value you want to translate.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} 0xdeadbeef".format(_cmdline_)

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()

        p = lambda a: struct.pack("<I", a & 0xffffffff)
        ube = lambda a: struct.unpack(">I", a)[0]
        pQ = lambda a: struct.pack("<Q", a & 0xffffffffffffffff)
        uQbe = lambda a: struct.unpack(">Q", a)[0]
        converted32 = ube(p(args.value))
        converted64 = uQbe(pQ(args.value))

        gef_print("{:#x} -> 64bit byteswap -> {:#x}".format(args.value, converted64))
        gef_print("{:#x} -> 32bit byteswap -> {:#x}".format(args.value & 0xffffffff, converted32))
        return


class KernelAddressHeuristicFinder:
    """A class that heuristically finds a specific symbol in the kernel."""

    @staticmethod
    def get_saved_command_line():
        # plan 1
        cmdline_proc_show = get_ksymaddr("cmdline_proc_show")
        if cmdline_proc_show:
            res = gdb.execute("x/10i {:#x}".format(cmdline_proc_show), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"QWORD PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"DWORD PTR ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"ldr\s+\S+,\s*\[\S+,\s*#(\d+)\]", line)
                        if m:
                            return base + int(m.group(1), 0)
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)
        return None

    @staticmethod
    def get_current_task():
        if is_x86():
            # plan 1 (directly)
            current_task = get_ksymaddr("current_task")
            if current_task:
                return current_task

            # plan 2 (available v4.1-rc1 or later)
            common_cpu_up = get_ksymaddr("common_cpu_up")
            if common_cpu_up:
                res = gdb.execute("x/30i {:#x}".format(common_cpu_up), to_string=True)
                if is_x86_64():
                    for line in res.splitlines():
                        m = re.search(r"mov\s+\w+,(0x\w+)", line)
                        if m:
                            v = int(m.group(1), 16) & 0xffffffffffffffff
                            if v != 0:
                                return v
                elif is_x86_32():
                    for line in res.splitlines():
                        m = re.search(r"mov\s+\w+,(0x\w+)", line)
                        if m:
                            v = int(m.group(1), 16) & 0xffffffff
                            if v != 0:
                                return v
        elif is_arm32():
            current_thread_info = current_arch.sp & ~0x1fff
            v = read_int_from_memory(current_thread_info + current_arch.ptrsize * 3)
            return v
        elif is_arm64():
            return get_register("$SP_EL0")
        return None

    @staticmethod
    def get_init_task():
        # plan 1 (directly)
        init_task = get_ksymaddr("init_task")
        if init_task:
            return init_task

        # plan 2 (available v2.6.29.3 or later)
        chroot_fs_refs = get_ksymaddr("chroot_fs_refs")
        if chroot_fs_refs:
            res = gdb.execute("x/30i {:#x}".format(chroot_fs_refs), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"QWORD PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                count = 0
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            addr = base + int(m.group(1), 16) # add 1 time
                            if count == 1:
                                return addr # 2nd pair of (adrp + add) is target
                            else:
                                base = None
                                count += 1
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)
        return None

    @staticmethod
    def get_init_cred():
        # plan 1 (directly)
        init_cred = get_ksymaddr("init_cred")
        if init_cred:
            return init_cred

    @staticmethod
    def get_modules():
        # plan 1 (directly)
        modules = get_ksymaddr("modules")
        if modules:
            return modules

        # plan 2 (available v3.7.5 or later)
        find_module_all = get_ksymaddr("find_module_all")
        if find_module_all:
            res = gdb.execute("x/20i {:#x}".format(find_module_all), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"QWORD PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                bases = {}
                add1time = {}
                for line in res.splitlines():
                    m = re.search(r"adrp\s+(\S+),\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        base = int(m.group(2), 16)
                        bases[reg] = base
                        continue
                    m = re.search(r"add\s+(\S+),\s*(\S+),\s*#(0x\w+)", line)
                    if m:
                        dstreg = m.group(1)
                        srcreg = m.group(2)
                        v = int(m.group(3), 16)
                        if srcreg in bases:
                            add1time[dstreg] = bases[srcreg] + v
                            continue
                    m = re.search(r"ldr\s+\S+,\s*\[(\S+),\s*#(\d+)\]", line)
                    if m:
                        srcreg = m.group(1)
                        v = int(m.group(2), 0)
                        if srcreg in add1time:
                            return add1time[srcreg] + v
            elif is_arm32():
                bases = {}
                add1time = {}
                for line in res.splitlines():
                    m = re.search(r"movw\s+(\S+),.+;\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        base = int(m.group(2), 16)
                        bases[reg] = base
                        continue
                    m = re.search(r"movt\s+(\S+),.+;\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        v = int(m.group(2), 16) << 16
                        if reg in bases:
                            add1time[reg] = bases[reg] + v
                            continue
                    m = re.search(r"ldr\s+\S+,\s*\[(\S+),\s*#(\d+)\]", line)
                    if m:
                        reg = m.group(1)
                        v = int(m.group(2), 0)
                        if reg in add1time:
                            return add1time[reg] + v
        return None

    @staticmethod
    def get_chrdevs():
        # plan 1 (directly)
        chrdevs = get_ksymaddr("chrdevs")
        if chrdevs:
            return chrdevs

        # plan 2
        chrdev_show = get_ksymaddr("chrdev_show")
        if chrdev_show:
            res = gdb.execute("x/30i {:#x}".format(chrdev_show), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"QWORD PTR \[.*\*8([-+]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"\[.*\*4([+-]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                count = 0
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            addr = base + int(m.group(1), 16) # add 1 time
                            if count == 1:
                                return addr # 2nd pair of (adrp + add) is target
                            else:
                                base = None
                                count += 1
            elif is_arm32():
                bases = {}
                add1time = {}
                for line in res.splitlines():
                    m = re.search(r"movw\s+(\S+),.+;\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        base = int(m.group(2), 16)
                        bases[reg] = base
                        continue
                    m = re.search(r"movt\s+(\S+),.+;\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        v = int(m.group(2), 16) << 16
                        if reg in bases:
                            add1time[reg] = bases[reg] + v
                            continue
                    m = re.search(r"ldr\s+\S+,\s*\[(\S+),.*#\d+\]", line)
                    if m:
                        reg = m.group(1)
                        if reg in add1time:
                            return add1time[reg]
            return None

    @staticmethod
    def get_cdev_map():
        # plan 1 (directly)
        cdev_map = get_ksymaddr("cdev_map")
        if cdev_map:
            return cdev_map

        # plan 2
        cdev_del = get_ksymaddr("cdev_del")
        if cdev_del:
            res = gdb.execute("x/30i {:#x}".format(cdev_del), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"QWORD PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"ldr\s+\S+,\s*\[\S+,\s*#(\d+)\]", line)
                        if m:
                            return base + int(m.group(1), 0)
            elif is_arm32():
                bases = {}
                add1time = {}
                for line in res.splitlines():
                    m = re.search(r"movw\s+(\S+),.+;\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        base = int(m.group(2), 16)
                        bases[reg] = base
                        continue
                    m = re.search(r"movt\s+(\S+),.+;\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        v = int(m.group(2), 16) << 16
                        if reg in bases:
                            add1time[reg] = bases[reg] + v
                            continue
                    m = re.search(r"ldr\s+\S+,\s*\[(\S+),\s*#(\d+)\]", line)
                    if m:
                        reg = m.group(1)
                        v = int(m.group(2), 0)
                        if reg in add1time:
                            return add1time[reg] + v
        return None

    @staticmethod
    def get_sys_call_table_x64():
        # plan 1 (directly)
        if is_x86_64():
            sys_call_table = get_ksymaddr("sys_call_table")
        else:
            return None
        if sys_call_table:
            return sys_call_table

        # plan 2 (available v4.6-rc1 or later)
        do_syscall_64 = get_ksymaddr("do_syscall_64")
        if do_syscall_64:
            res = gdb.execute("x/30i {:#x}".format(do_syscall_64), to_string=True)
            for line in res.splitlines():
                m = re.search(r"[DQ]WORD PTR \[.*\*8([-+]0x\S+)\]", line)
                if m:
                    v = int(m.group(1), 16) & 0xffffffffffffffff
                    if v != 0:
                        return v
        return None

    @staticmethod
    def get_sys_call_table_x32():
        # plan 1 (directly)
        if is_x86_64():
            sys_call_table = get_ksymaddr("x32_sys_call_table")
        else:
            return None
        if sys_call_table:
            return sys_call_table

        # plan 2 (available v4.6-rc1 or later)
        do_syscall_64 = get_ksymaddr("do_syscall_64")
        if do_syscall_64:
            count = 0
            res = gdb.execute("x/30i {:#x}".format(do_syscall_64), to_string=True)
            for line in res.splitlines():
                m = re.search(r"[DQ]WORD PTR \[.*\*8([-+]0x\S+)\]", line)
                if m and count == 0:
                    count += 1
                    continue
                elif m and count == 1:
                    v = int(m.group(1), 16) & 0xffffffffffffffff
                    if v != 0:
                        return v
        return None

    @staticmethod
    def get_sys_call_table_x86():
        # plan 1 (directly)
        if is_x86_64():
            sys_call_table = get_ksymaddr("ia32_sys_call_table")
        elif is_x86_32():
            sys_call_table = get_ksymaddr("sys_call_table")
        else:
            return None
        if sys_call_table:
            return sys_call_table

        # plan 2 (available v4.6-rc1 or later)
        do_int80_syscall_32 = get_ksymaddr("do_int80_syscall_32")
        if do_int80_syscall_32:
            res = gdb.execute("x/20i {:#x}".format(do_int80_syscall_32), to_string=True)
            for line in res.splitlines():
                if is_x86_32():
                    m = re.search(r"\[eax\*4([+-]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
                if is_x86_64():
                    m = re.search(r"\[rax\*8([+-]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
        return None

    @staticmethod
    def get_sys_call_table_arm32():
        # plan 1 (directly)
        if is_arm32():
            sys_call_table = get_ksymaddr("sys_call_table")
        else:
            return None
        if sys_call_table:
            return sys_call_table

        # plan 2 is nothing
        # because `sys_call_table` symbol is embeded in .text area
        # I couldn't come up with the detection logic.
        return None

    @staticmethod
    def get_sys_call_table_arm64():
        # plan 1 (directly)
        if is_arm64():
            sys_call_table = get_ksymaddr("sys_call_table")
        else:
            return None
        if sys_call_table:
            return sys_call_table

        # plan 2 (available v3.7-rc1 or later)
        el0_svc = get_ksymaddr("do_el0_svc") or get_ksymaddr("el0_svc")
        if el0_svc:
            res = gdb.execute("x/20i {:#x}".format(el0_svc), to_string=True)
            base = None
            for line in res.splitlines():
                if base is None:
                    m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                    if m:
                        base = int(m.group(1), 16)
                else:
                    m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                    if m:
                        return base + int(m.group(1), 16)
        return None

    @staticmethod
    def get_sys_call_table_arm64_compat():
        # plan 1 (directly)
        if is_arm64():
            sys_call_table = get_ksymaddr("compat_sys_call_table")
        else:
            return None
        if sys_call_table:
            return sys_call_table

        # plan 2 (available v3.7-rc1 or later)
        el0_svc_compat = get_ksymaddr("do_el0_svc_compat") or get_ksymaddr("el0_svc_compat")
        if el0_svc_compat:
            res = gdb.execute("x/20i {:#x}".format(el0_svc_compat), to_string=True)
            base = None
            for line in res.splitlines():
                if base is None:
                    m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                    if m:
                        base = int(m.group(1), 16)
                else:
                    m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                    if m:
                        return base + int(m.group(1), 16)
        return None

    @staticmethod
    def get_per_cpu_offset():
        # plan 1 (directly)
        __per_cpu_offset = get_ksymaddr("__per_cpu_offset")
        if __per_cpu_offset:
            return __per_cpu_offset

        # plan 2
        nr_iowait_cpu = get_ksymaddr("nr_iowait_cpu")
        if nr_iowait_cpu:
            res = gdb.execute("x/10i {:#x}".format(nr_iowait_cpu), to_string=True)
            if is_x86_64():
                # pattern 1
                for line in res.splitlines():
                    m = re.search(r"add.*QWORD PTR \[.*([-+]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
                # pattern 2
                for line in res.splitlines():
                    m = re.search(r"DWORD PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                # pattern 1
                for line in res.splitlines():
                    m = re.search(r"DWORD PTR \[.*([-+]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            return base + int(m.group(1), 16)
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)
        return None

    @staticmethod
    def get_slab_caches():
        # plan 1 (directly)
        slab_caches = get_ksymaddr("slab_caches")
        if slab_caches:
            return slab_caches

        # plan 2 (available v4.9-rc1 or later)
        slub_cpu_dead = get_ksymaddr("slub_cpu_dead")
        if slub_cpu_dead:
            res = gdb.execute("x/20i {:#x}".format(slub_cpu_dead), to_string=True)
            if is_x86():
                count = 0
                for line in res.splitlines():
                    m = re.search(r"(?:# |,)(0x\S{8,})", line)
                    if not m:
                        continue
                    if count == 1:
                        return int(m.group(1), 16)
                    count += 1
            elif is_arm64():
                count = 0
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            addr = base + int(m.group(1), 16) # add 1 time
                            if count == 1:
                                return addr # 2nd pair of (adrp + add) is target
                            else:
                                base = None
                                count += 1
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)

        # plan 3 (available v4.10.17 or before)
        memcg_update_all_caches = get_ksymaddr("memcg_update_all_caches")
        if memcg_update_all_caches:
            res = gdb.execute("x/20i {:#x}".format(memcg_update_all_caches), to_string=True)
            if is_x86():
                for line in res.splitlines():
                    m = re.search(r"(?:# |,)(0x\S{8,})", line)
                    if m:
                        if is_64bit():
                            return int(m.group(1), 16) & 0xffffffffffffffff
                        else:
                            return int(m.group(1), 16) & 0xffffffff
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            return base + int(m.group(1), 16)
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)
        return None

    @staticmethod
    def get_modprobe_path():
        # plan 1 (directly)
        modprobe_path = get_ksymaddr("modprobe_path")
        if modprobe_path:
            return modprobe_path

        # plan 2 (available v3.11-rc1 or later)
        request_module = get_ksymaddr("__request_module")
        if request_module:
            res = gdb.execute("x/30i {:#x}".format(request_module), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"BYTE PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"BYTE PTR ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"ldrb\s+\S+,\s*\[\S+,\s*#(\d+)\]", line)
                        if m:
                            return base + int(m.group(1), 0)
            elif is_arm32():
                addr = 0
                for line in res.splitlines():
                    m = re.search(r"movw.*;\s*(0x\S+)", line)
                    if m:
                        addr_high = addr & 0xffff0000
                        addr = addr_high | int(m.group(1), 16)
                        continue
                    m = re.search(r"movt.*;\s*(0x\S+)", line)
                    if m:
                        addr_low = addr & 0xffff
                        addr = (int(m.group(1), 16) << 16) | addr_low
                        continue
                    if "ldrb" in line:
                        return addr
        return None

    @staticmethod
    def get_poweroff_cmd():
        # plan 1 (directly)
        poweroff_cmd = get_ksymaddr("poweroff_cmd")
        if poweroff_cmd:
            return poweroff_cmd

        # plan 2 (available v4.1-rc1 or later)
        poweroff_work_func = get_ksymaddr("poweroff_work_func")
        if poweroff_work_func:
            res = gdb.execute("x/20i {:#x}".format(poweroff_work_func), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"mov\s+rdi\s*,\s*(0x\w+)", line) # search run_cmd
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
                for line in res.splitlines():
                    m = re.search(r"mov\s+rsi\s*,\s*(0x\w+)", line) # search argv_split
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"mov\s+e[a-d]x\s*,\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                bases = {}
                add1time = {}
                for line in res.splitlines():
                    m = re.search(r"adrp\s+(\S+),\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        base = int(m.group(2), 16)
                        bases[reg] = base
                        continue
                    m = re.search(r"add\s+(\S+),\s*(\S+),\s*#(0x\w+)", line)
                    if m:
                        dstreg = m.group(1)
                        srcreg = m.group(2)
                        v = int(m.group(3), 16)
                        if srcreg in add1time:
                            return add1time[srcreg] + v
                        if srcreg in bases:
                            add1time[dstreg] = bases[srcreg] + v
                            continue
            elif is_arm32():
                addr = 0
                for line in res.splitlines():
                    m = re.search(r"ldr.*;\s*(0x\S+)", line)
                    if m:
                        addr = int(m.group(1), 16)
                        try:
                            return read_int_from_memory(addr)
                        except Exception:
                            pass
        return None

    @staticmethod
    def get_reboot_cmd():
        # plan 1 (directly)
        reboot_cmd = get_ksymaddr("reboot_cmd")
        if reboot_cmd:
            return reboot_cmd

        # plan 2 (available v4.1-rc1 or later)
        reboot_work_func = get_ksymaddr("reboot_work_func")
        if reboot_work_func:
            res = gdb.execute("x/10i {:#x}".format(reboot_work_func), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"mov\s+rdi\s*,\s*(0x\w+)", line) # search run_cmd
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
                for line in res.splitlines():
                    m = re.search(r"mov\s+rsi\s*,\s*(0x\w+)", line) # search argv_split
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"mov\s+e[a-d]x\s*,\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            return base + int(m.group(1), 16)
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)
        return None

    @staticmethod
    def get_core_pattern():
        # plan 1 (directly)
        core_pattern = get_ksymaddr("core_pattern")
        if core_pattern:
            return core_pattern

        # plan 2 (available v3.6-rc1 or later)
        validate_coredump_safety = get_ksymaddr("validate_coredump_safety.part.0")
        if validate_coredump_safety:
            res = gdb.execute("x/10i {:#x}".format(validate_coredump_safety), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"BYTE PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"BYTE PTR ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"ldrb\s+\S+,\s*\[\S+,\s*#(\d+)\]", line)
                        if m:
                            return base + int(m.group(1), 0)
            elif is_arm32():
                addr = 0
                for line in res.splitlines():
                    m = re.search(r"movw.*;\s*(0x\S+)", line)
                    if m:
                        addr_high = addr & 0xffff0000
                        addr = addr_high | int(m.group(1), 16)
                        continue
                    m = re.search(r"movt.*;\s*(0x\S+)", line)
                    if m:
                        addr_low = addr & 0xffff
                        addr = (int(m.group(1), 16) << 16) | addr_low
                        continue
                    if "ldrb" in line:
                        return addr

        # plan 3 (available v3.6-rc1 or later)
        proc_dostring_coredump = get_ksymaddr("proc_dostring_coredump")
        if proc_dostring_coredump:
            res = gdb.execute("x/50i {:#x}".format(proc_dostring_coredump), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"BYTE PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"BYTE PTR ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                    if m:
                        base = int(m.group(1), 16)
                        continue
                    if base:
                        m = re.search(r"ldrb\s+\S+,\s*\[\S+,\s*#(\d+)\]", line)
                        if m:
                            return base + int(m.group(1), 0)
            elif is_arm32():
                addr = 0
                for line in res.splitlines():
                    m = re.search(r"movw.*;\s*(0x\S+)", line)
                    if m:
                        addr_high = addr & 0xffff0000
                        addr = addr_high | int(m.group(1), 16)
                        continue
                    m = re.search(r"movt.*;\s*(0x\S+)", line)
                    if m:
                        addr_low = addr & 0xffff
                        addr = (int(m.group(1), 16) << 16) | addr_low
                        continue
                    if "ldrb" in line:
                        return addr
        return None

    @staticmethod
    def get_n_tty_ops():
        # plan 1 (directly)
        n_tty_ops = get_ksymaddr("n_tty_ops")
        if n_tty_ops:
            return n_tty_ops

        # plan 2 (available v4.6-rc1 or later)
        n_tty_inherit_ops = get_ksymaddr("n_tty_inherit_ops")
        if n_tty_inherit_ops:
            res = gdb.execute("x/20i {:#x}".format(n_tty_inherit_ops), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"mov\s+r\S+,\s*(0x\S+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r",\s*DWORD PTR \[.*([+-]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
                for line in res.splitlines():
                    m = re.search(r"mov\s+\S+,\s*(0x[0-9a-f]{8})", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            return base + int(m.group(1), 0)
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)
        return None

    @staticmethod
    def get_tty_ldiscs():
        # plan 1 (directly)
        tty_ldiscs = get_ksymaddr("tty_ldiscs")
        if tty_ldiscs:
            return tty_ldiscs

        # plan 2 (available v2.6.37-rc2 or later)
        tty_register_ldisc = get_ksymaddr("tty_register_ldisc")
        if tty_register_ldisc:
            res = gdb.execute("x/20i {:#x}".format(tty_register_ldisc), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"QWORD PTR \[.*\*8([-+]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"DWORD PTR \[.*\*4([+-]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            return base + int(m.group(1), 0) + 8
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16) + 4
        return None

    @staticmethod
    def get_mmap_min_addr():
        # plan 1 (directly)
        mmap_min_addr = get_ksymaddr("mmap_min_addr")
        if mmap_min_addr:
            return mmap_min_addr

        # plan 2 (available v4.19.27 or later)
        expand_downwards = get_ksymaddr("expand_downwards")
        if expand_downwards:
            res = gdb.execute("x/20i {:#x}".format(expand_downwards), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"QWORD PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"ldr\s+\S+,\s*\[\S+,\s*#(\d+)\]", line)
                        if m:
                            return base + int(m.group(1), 0)
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)
        return None

    @staticmethod
    def get_vdso_info():
        # plan 1 (directly)
        vdso_info = get_ksymaddr("vdso_info")
        if vdso_info:
            return vdso_info

        # plan 2 (available v5.3-rc1 or later)
        if is_arm64():
            vdso_init = get_ksymaddr("__vdso_init")
            if vdso_init:
                res = gdb.execute("x/20i {:#x}".format(vdso_init), to_string=True)
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            return base + int(m.group(1), 0)
        return None


@register_command
class KernelbaseCommand(GenericCommand):
    """Show kernel base address."""
    _cmdline_ = "kbase"
    _category_ = "08-b. Qemu-system Cooperation - Linux"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @staticmethod
    @functools.lru_cache(maxsize=None)
    def get_maps():
        maps = []
        res = get_maps_by_pagewalk("pagewalk -q --simple")
        res = sorted(set(res.splitlines()))
        res = list(filter(lambda line: line.endswith("]"), res))
        res = list(filter(lambda line: "[+]" not in line, res))
        res = list(filter(lambda line: "*" not in line, res))

        if is_x86():
            for line in res:
                line = line.split()
                if line[6] != "KERN":
                    continue
                vaddr = int(line[0].split("-")[0], 16)
                size = int(line[2], 16)
                perm = line[5][1:] # [xxx
                maps.append([vaddr, size, perm])

        elif is_arm32():
            for line in res:
                line = line.split()
                if line[5] != "[PL0/---":
                    continue
                vaddr = int(line[0].split("-")[0], 16)
                size = int(line[2], 16)
                perm = line[6][4:7] # PL1/xxx
                maps.append([vaddr, size, perm])

        elif is_arm64():
            for line in res:
                line = line.split()
                if line[5] != "[EL0/---":
                    continue
                vaddr = int(line[0].split("-")[0], 16)
                size = int(line[2], 16)
                perm = line[6][4:7] # EL1/xxx
                maps.append([vaddr, size, perm])

        if maps == []:
            if is_x86():
                warn("Make sure you are in ring0 (=kernel mode)")
            elif is_arm32():
                warn("Make sure you are in supervisor mode (=kernel mode)")
                warn("Make sure qemu 3.x or higher")
            elif is_arm64():
                warn("Make sure you are in EL1 (=kernel mode)")
                warn("Make sure qemu 3.x or higher")
            return None
        else:
            return maps

    @staticmethod
    def get_kernel_base():
        dic = {
            "maps": KernelbaseCommand.get_maps(),
            "kbase": None,
            "kbase_size": None,
            "krobase": None,
            "krobase_size": None,
            "krwbase": None,
            "krwbase_size": None,
            "has_none": False,
        }
        Kinfo = collections.namedtuple("Kinfo", dic.keys())

        # maps is not found, so fast return
        if dic["maps"] is None:
            dic["has_none"] = None in dic.values()
            return Kinfo(*dic.values())

        # search kbase
        for i, (vaddr, size, perm) in enumerate(dic["maps"]):
            if perm == "R-X" and size >= 0x100000:
                dic["kbase"] = vaddr
                dic["kbase_size"] = size
                maps_after_kbase = dic["maps"][i + 1:]
                break
        else:
            # not found, maybe old kernel
            for i, (vaddr, size, perm) in enumerate(dic["maps"]):
                if perm == "RWX" and size >= 0x100000:
                    dic["kbase"] = vaddr
                    dic["kbase_size"] = size
                    maps_after_kbase = dic["maps"][i + 1:]
                    break
            else:
                # Not found, so fast return
                dic["has_none"] = None in dic.values()
                return Kinfo(*dic.values())

        # search kernel RO base - logic 1
        for i, (vaddr, size, perm) in enumerate(maps_after_kbase):
            if perm == "R--":
                if dic["krobase"] is None:
                    if size > 0x1000: # ignore ranges that are too small
                        dic["krobase"] = vaddr
                        dic["krobase_size"] = size
                        maps_after_krobase = maps_after_kbase[i + 1:]
                elif dic["krobase"] + dic["krobase_size"] == vaddr:
                    dic["krobase_size"] += size # merge contiguous region
                    maps_after_krobase = maps_after_kbase[i + 1:]
                else:
                    break

        # search kernel RO base - logic 2
        if dic["krobase"] is None:
            # maybe old kernel (no-NX)
            # Detected kbase(R-X) range already includes rodata, so use heuristic search
            #    [  .text  ] <- maybe .text is larger than 0x3000 (it fails in certain cases if 0x2000)
            #    [  .text  ]
            #    [  .text  ]
            #    [  .text  ] <- end of this area has [0x00, 0x00, 0x00, ...]
            #    [  .rodata  ]
            #    [  .rodata  ]
            #    [  .rodata  ]
            start = dic["kbase"] + gef_getpagesize() * 3
            end = dic["kbase"] + dic["kbase_size"]
            for addr in range(start, end, gef_getpagesize()):
                data = read_memory(addr - 0x20, 0x20)
                if data == b"\0" * 0x20:
                    dic["krobase"] = addr
                    dic["krobase_size"] = end - dic["krobase"]
                    dic["kbase_size"] -= dic["krobase_size"]
                    maps_after_krobase = maps_after_kbase
                    break
            else:
                dic["has_none"] = None in dic.values()
                return Kinfo(*dic.values())

        # search kernel RW base
        def search_perm(target_perm):
            rw = None
            for vaddr, size, perm in maps_after_krobase:
                if perm == target_perm:
                    if rw is None:
                        if size > 0x1000:
                            rw = [vaddr, size]
                    elif rw[0] + rw[1] == vaddr:
                        rw = [rw[0], rw[1] + size] # merge contiguous region
            return rw

        res = search_perm("RW-")
        if res:
            dic["krwbase"] = res[0]
            dic["krwbase_size"] = res[1]
        else:
            res = search_perm("RWX") # old x86/arm kernel
            if res:
                dic["krwbase"] = res[0]
                dic["krwbase_size"] = res[1]
            else:
                # Not found
                pass

        dic["has_none"] = None in dic.values()
        return Kinfo(*dic.values())

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        # resolve kbase, krobase
        info("Wait for memory scan")
        kinfo = self.get_kernel_base()
        if kinfo.has_none:
            err("Failed to resolve")
            return
        gef_print(titlify("Kernel base (heuristic)"))
        gef_print("kernel text:   {:#x} ({:#x} bytes)".format(kinfo.kbase, kinfo.kbase_size))
        gef_print("kernel rodata: {:#x} ({:#x} bytes)".format(kinfo.krobase, kinfo.krobase_size))
        gef_print("kernel data:   {:#x} ({:#x} bytes)".format(kinfo.krwbase, kinfo.krwbase_size))
        return


@register_command
class KernelVersionCommand(GenericCommand):
    """Display kernel version string under qemu-system."""
    _cmdline_ = "kversion"
    _category_ = "08-b. Qemu-system Cooperation - Linux"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    def kernel_version(self):
        info("Wait for memory scan")
        kinfo = KernelbaseCommand.get_kernel_base()
        print(kinfo)
        if kinfo.has_none:
            err("Failed to resolve")
            return None

        # resolve area
        area = []
        for addr in kinfo.maps:
            if addr[0] < kinfo.kbase:
                continue
            if addr[0] >= kinfo.krwbase:
                continue
            area.append([addr[0], addr[0] + addr[1]])
        if area == []:
            return None

        for start, end in area:
            try:
                data = read_memory(start, end - start)
            except gdb.MemoryError:
                continue
            data = ''.join([chr(x) for x in data])
            r = re.findall(r"(Linux version (?:\d+\.[\d.]*\d)[ -~]+)", data)
            if not r:
                continue
            kernel_version_string = r[0]
            idx = data.find(kernel_version_string)
            return start + idx, kernel_version_string
        return None

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        ret = self.kernel_version()
        if ret is None:
            err("Parse failed")
            return
        addr, kernel_version_string = ret
        gef_print(titlify("Kernel version (heuristic)"))
        gef_print("{:#x}: {:s}".format(addr, kernel_version_string))
        return


@register_command
class KernelCmdlineCommand(GenericCommand):
    """Display kernel cmdline string under qemu-system."""
    _cmdline_ = "kcmdline"
    _category_ = "08-b. Qemu-system Cooperation - Linux"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    def kernel_cmdline(self):
        saved_command_line = KernelAddressHeuristicFinder.get_saved_command_line()
        if saved_command_line is None:
            return None
        try:
            ptr = read_int_from_memory(saved_command_line)
            cmdline = read_cstring_from_memory(ptr)
            return ptr, cmdline
        except Exception:
            return None

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        info("Wait for memory scan")

        ret = self.kernel_cmdline()
        if ret is None:
            err("Parse failed")
            return
        addr, kernel_cmdline_string = ret
        gef_print(titlify("Kernel cmdline (heuristic)"))
        gef_print("{:#x}: '{:s}'".format(addr, kernel_cmdline_string))
        return


@register_command
class KernelCurrentCommand(GenericCommand):
    """Display current task under qemu-system."""
    _cmdline_ = "kcurrent"
    _category_ = "08-b. Qemu-system Cooperation - Linux"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    def get_cpu_offset(self):
        # resolve __per_cpu_offset
        self.__per_cpu_offset = KernelAddressHeuristicFinder.get_per_cpu_offset()
        if self.__per_cpu_offset is None:
            err("Failed to resolve `__per_cpu_offset`")
            return False
        else:
            info("__per_cpu_offset: {:#x}".format(self.__per_cpu_offset))

        # resolve each cpu_offset
        self.cpu_offset = [read_int_from_memory(self.__per_cpu_offset)]
        i = 1
        while True:
            off = read_int_from_memory(self.__per_cpu_offset + i * 8)
            if off == self.cpu_offset[-1]:
                self.cpu_offset = self.cpu_offset[:-1]
                break
            self.cpu_offset.append(off)
            i += 1
        return True

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        info("Wait for memory scan")
        current_task = KernelAddressHeuristicFinder.get_current_task()
        if current_task is None:
            err("Failed to resolve `current_task`")
            return
        info("current_task: {:#x}".format(current_task))

        if is_arm32() or is_arm64():
            gef_print(titlify("Kernel current task_struct (heuristic)"))
            gef_print("current: {:#x}".format(current_task))
            return

        elif is_x86():
            if is_32bit():
                mask = 0x80000000
            else:
                mask = 0x80000000_00000000
            if (current_task & mask) == mask:
                task = read_int_from_memory(current_task)
                if is_valid_addr(task):
                    gef_print(titlify("Kernel current task_struct (heuristic)"))
                    gef_print("current: {:#x}".format(task))
                    return

            if not self.get_cpu_offset():
                return
            gef_print(titlify("Kernel current task_struct (heuristic)"))
            for i, offset in enumerate(self.cpu_offset):
                task = read_int_from_memory(current_task + offset)
                gef_print("current (cpu{:d}): {:#x}".format(i, task))
        return


@register_command
class KernelTaskCommand(GenericCommand):
    """Display process list under qemu-system."""
    _cmdline_ = "ktask"
    _category_ = "08-b. Qemu-system Cooperation - Linux"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-f', '--filter', action='append', default=[], help='REGEXP filter.')
    parser.add_argument('-m', dest='mm', action='store_true', help='print memory map each process.')
    parser.add_argument('-n', '--no-pager', action='store_true', help='do not use less.')
    _syntax_ = parser.format_help()

    def get_offset_task(self, init_task):
        # search init_task->tasks
        for i in range(0x200):
            offset_tasks = i * current_arch.ptrsize
            pos = init_task + offset_tasks
            value_list = [pos]
            # validating candidate offset
            while True:
                # read check
                try:
                    pos = read_int_from_memory(pos)
                except Exception: # memory read error
                    found = False
                    break
                # list validate
                if pos in value_list[1:]: # incomplete infinity loop detected
                    found = False
                    break
                if pos == value_list[0] and len(value_list) == 1: # self reference
                    found = False
                    break
                if pos == value_list[0] and len(value_list) > 1: # maybe link list
                    found = True
                    break
                value_list.append(pos)
            if found:
                info("offsetof(task_struct, tasks): {:#x}".format(offset_tasks))
                return offset_tasks
        err("Not found init_task->tasks")
        return None

    def get_task_list(self, init_task, offset_tasks):
        pos = init_task + offset_tasks
        task_list = [pos]
        # validating candidate offset
        while True:
            pos = read_int_from_memory(pos)
            if pos in task_list:
                break
            task_list.append(pos)
        info("Number of tasks: {:d}".format(len(task_list)))
        return [x - offset_tasks for x in task_list]

    def get_offset_mm(self, task_addr, offset_tasks):
        """
            struct list_head        tasks;
        #ifdef CONFIG_SMP
            struct plist_node {
                int              prio;
                struct list_head prio_list;
                struct list_head node_list;
            }                       pushable_tasks;

            struct rb_node {
                unsigned long  __rb_parent_color;
                struct rb_node *rb_right;
                struct rb_node *rb_left;
            }                       pushable_dl_tasks;
        #endif

            struct mm_struct        *mm;
            struct mm_struct        *active_mm;
        """
        offset_mm = offset_tasks + 2 * current_arch.ptrsize
        r = read_int_from_memory(task_addr + offset_mm)
        if 0 < r <= 0xffffffff:
            # maybe prio, so CONFIG_SMP is y
            offset_mm = offset_tasks + 10 * current_arch.ptrsize
        info("offsetof(task_struct, mm): {:#x}".format(offset_mm))
        return offset_mm

    def get_offset_comm(self, task_addrs):
        for i in range(0x300):
            offset_comm = i * current_arch.ptrsize
            valid = True
            for task in task_addrs:
                if not is_ascii_string(task + offset_comm):
                    valid = False
                    break
                s = read_cstring_from_memory(task + offset_comm)
                if s == "swapper/0": # Very common name, so for speeding up, we assume that offset is found
                    break
                if len(s) < 2:
                    valid = False
                    break
            if valid:
                info("offsetof(task_struct, comm): {:#x}".format(offset_comm))
                return offset_comm
        err("Not found task->comm[TASK_CMM_LEN]")
        return None

    def get_offset_cred(self, task_addrs, offset_comm):
        """
        struct task_struct {
        ...
            const struct cred __rcu        *real_cred;    // These may point to the same address
            const struct cred __rcu        *cred;         // These may point to the same address
        #ifdef CONFIG_KEYS
            struct key                     *cached_requested_key;
        #endif
            char                           comm[TASK_COMM_LEN];
        """
        # backward search from `comm`
        for i in range(0x100):
            offset_cred = offset_comm - ((i + 1) * current_arch.ptrsize)
            for task in task_addrs:
                val1 = read_int_from_memory(task + offset_cred)
                val2 = read_int_from_memory(task + offset_cred - current_arch.ptrsize)
                if val1 == val2 and val1 != 0:
                    info("offsetof(task_struct, cred): {:#x}".format(offset_cred))
                    return offset_cred
        err("Not found task->cred")
        return None

    def get_offset_uid(self, init_task_cred_ptr):
        """
        struct cred {
            atomic_t       usage;
        #ifdef CONFIG_DEBUG_CREDENTIALS
            atomic_t       subscribers;     /* number of processes subscribed */
            void           *put_addr;
            unsigned       magic;
        #endif
            kuid_t         uid;             /* real UID of the task */
            kgid_t         gid;             /* real GID of the task */
            kuid_t         suid;            /* saved UID of the task */
            kgid_t         sgid;            /* saved GID of the task */
            kuid_t         euid;            /* effective UID of the task */
            kgid_t         egid;            /* effective GID of the task */
            kuid_t         fsuid;           /* UID for VFS ops */
            kgid_t         fsgid;           /* GID for VFS ops */
            unsigned       securebits;      /* SUID-less security management */
            kernel_cap_t   cap_inheritable; /* caps our children can inherit */
            kernel_cap_t   cap_permitted;   /* caps we're permitted */
	        kernel_cap_t   cap_effective;   /* caps we can actually use */
	        kernel_cap_t   cap_bset;        /* capability bounding set */
	        kernel_cap_t   cap_ambient;     /* Ambient capability set */

        [Example x64]
            0xffffffff820460c0:     0x0000000000000004      0x0000000000000000
            0xffffffff820460d0:     0x0000000000000000      0x0000000000000000
            0xffffffff820460e0:     0x0000000000000000      0x0000000000000000
            0xffffffff820460f0:     0x0000003fffffffff      0x0000003fffffffff
            0xffffffff82046100:     0x0000003fffffffff      0x0000000000000000
            0xffffffff82046110:     0x0000000000000000      0x0000000000000000
        """
        init_task_cred = read_int_from_memory(init_task_cred_ptr)
        uid_gid_size = 4 * 8 # uid_t:4byte. len([uid,gid,suid,sgid,euid,egid,fsuid,fsgid]) == 8
        offset_uid = 4
        ret = read_memory(init_task_cred + offset_uid, uid_gid_size)
        if ret == b"\0" * uid_gid_size:
            pass
        else:
            offset_uid += 4 + current_arch.ptrsize + 4
        info("offsetof(cred, uid): {:#x}".format(offset_uid))
        return offset_uid

    def get_mm(self, task, offset_mm):
        mm = read_int_from_memory(task + offset_mm)
        if mm == 0:
            return []

        vm_area_struct = read_int_from_memory(mm) # vm_area_struct

        """
        struct vm_area_struct {
            /* The first cache line has the info for VMA tree walking. */

            unsigned long vm_start;          /* Our start address within vm_mm. */
            unsigned long vm_end;            /* The first byte after our end address within vm_mm. */

            struct vm_area_struct *vm_next, *vm_prev;
            struct rb_node vm_rb;
            unsigned long rb_subtree_gap;
            struct mm_struct *vm_mm;         /* The address space we belong to. */

            pgprot_t vm_page_prot;
            unsigned long vm_flags;          /* Flags, see mm.h. */

            struct {
                struct rb_node rb;
                unsigned long rb_subtree_last;
            } shared;

            struct list_head anon_vma_chain; /* Serialized by mmap_lock & page_table_lock */
            struct anon_vma *anon_vma;       /* Serialized by page_table_lock */
            const struct vm_operations_struct *vm_ops; /* Function pointers to deal with this struct. */
            unsigned long vm_pgoff;          /* Offset (within vm_file) in PAGE_SIZE units */
            struct file * vm_file;           /* File we map to (can be NULL). */
        """

        if self.offset_vm_flags is None:
            current = vm_area_struct
            while True:
                x = read_int_from_memory(current)
                if x == mm:
                    break
                current += current_arch.ptrsize
            offset_vm_mm = current - vm_area_struct
            info("offsetof(vm_area_struct, vm_mm): {:#x}".format(offset_vm_mm))

            # now, `current` points vm_mm
            while True:
                x = read_int_from_memory(current + current_arch.ptrsize) # read one unit ahead
                if is_32bit():
                    mask = 0xc000_0000
                else:
                    mask = 0xffff_0000_0000_0000
                if (x & mask) == mask:
                    break
                current += current_arch.ptrsize
            offset_vm_flags = current - vm_area_struct
            info("offsetof(vm_area_struct, vm_flags): {:#x}".format(offset_vm_flags))
            self.offset_vm_flags = offset_vm_flags

            # now, `current` points vm_flags
            current += current_arch.ptrsize
            while True:
                x = read_int_from_memory(current)
                y = read_int_from_memory(current + current_arch.ptrsize) # read one unit ahead
                if is_32bit():
                    mask = 0xc000_0000
                else:
                    mask = 0xffff_0000_0000_0000
                if (x & mask) == (y & mask) == mask and x == y:
                    break
                current += current_arch.ptrsize

            # now, `current` points anon_vma_chain
            offset_anon_vma_chain = current - vm_area_struct
            offset_vm_file = offset_anon_vma_chain + current_arch.ptrsize * 5
            info("offsetof(vm_area_struct, vm_file): {:#x}".format(offset_vm_file))
            self.offset_vm_file = offset_vm_file

        vm_areas = []
        VmArea = collections.namedtuple("VmArea", "start end flags file")
        current = vm_area_struct
        while current:
            vm_start = read_int_from_memory(current)
            vm_end = read_int_from_memory(current + current_arch.ptrsize)
            vm_flags =  read_int_from_memory(current + self.offset_vm_flags)
            vm_file =  read_int_from_memory(current + self.offset_vm_file)
            filepath = self.get_filepath(vm_file)
            perm = Permission(value=vm_flags)
            vm_areas.append(VmArea(vm_start, vm_end, str(perm), filepath))
            current = read_int_from_memory(current + current_arch.ptrsize * 2)
        return vm_areas

    def get_filepath(self, location):
        if not is_valid_addr(location):
            return ""

        """
        struct file {
            union {
                struct llist_node   fu_llist;
                struct rcu_head     fu_rcuhead;
            } f_u;
            struct path {
                struct vfsmount *mnt;
                struct dentry   *dentry;
            } f_path;
        """
        dentry = read_int_from_memory(location + current_arch.ptrsize * 3)


        """
        struct dentry {
            /* RCU lookup touched fields */
            unsigned int d_flags;           /* protected by d_lock */
            seqcount_spinlock_t d_seq;      /* per dentry seqlock */
            struct hlist_bl_node d_hash;    /* lookup hash list */
            struct dentry *d_parent;        /* parent directory */
            struct qstr d_name;
            struct inode *d_inode;          /* Where the name belongs to - NULL is negative */
            unsigned char d_iname[DNAME_INLINE_LEN];    /* small names */
        """
        if self.offset_d_iname is None:
            current = dentry
            while True:
                x = read_int_from_memory(current)
                if 0 < x - current <= 0x20:
                    self.offset_d_iname = x - dentry
                    break
                current += current_arch.ptrsize
            info("offsetof(dentry, d_iname): {:#x}".format(self.offset_d_iname))

            current -= current_arch.ptrsize
            # now, `current` points qstr.size
            while True:
                x = read_int_from_memory(current)
                if is_32bit():
                    mask = 0xc000_0000
                else:
                    mask = 0xffff_0000_0000_0000
                if (x & mask) == mask:
                    self.offset_d_parent = current - dentry
                    break
                current -= current_arch.ptrsize
            info("offsetof(dentry, d_parent): {:#x}".format(self.offset_d_parent))

        filepath = []
        current = dentry
        while True:
            name = read_cstring_from_memory(current + self.offset_d_iname)
            d_parent = read_int_from_memory(current + self.offset_d_parent)
            filepath.append(name)
            if d_parent == current:
                break
            current = d_parent
        return os.path.join(*filepath[::-1])

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        info("Wait for memory scan")

        init_task = KernelAddressHeuristicFinder.get_init_task()
        if init_task is None:
            err("Not found symbol")
            return
        gef_print(titlify("Kernel tasks (heuristic)"))
        info("init_task: {:#x}".format(init_task))

        offset_task = self.get_offset_task(init_task)
        if offset_task is None:
            return

        task_addrs = self.get_task_list(init_task, offset_task)
        if task_addrs is None:
            return

        if args.mm:
            self.offset_vm_flags = None
            self.offset_vm_file = None
            self.offset_d_iname = None
            self.offset_d_parent = None
            offset_mm = self.get_offset_mm(task_addrs[0], offset_task)
            if offset_mm is None:
                return

        offset_comm = self.get_offset_comm(task_addrs)
        if offset_comm is None:
            return

        offset_cred = self.get_offset_cred(task_addrs, offset_comm)
        if offset_cred is None:
            return

        offset_uid = self.get_offset_uid(task_addrs[0] + offset_cred)
        if offset_uid is None:
            return

        out = []
        ids_str = ["uid", "gid", "suid", "sgid", "euid", "egid", "fsuid", "fsgid"]
        fmt = "{:<18s}: {:<16s} {:<18s} [{:>5s} {:>5s} {:>5s} {:>5s} {:>5s} {:>5s} {:>5s} {:>5s}] {:<10s}"
        legend = ["task", "task->comm", "task->cred", *ids_str, "securebits"]
        out.append(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for task in task_addrs:
            comm_string = read_cstring_from_memory(task + offset_comm)
            if args.filter:
                if not any([re.search(f, comm_string) for f in args.filter]):
                    continue
            cred = read_int_from_memory(task + offset_cred)
            uids = [u32(read_memory(cred + offset_uid + j * 4, 4)) for j in range(8)]
            securebits = u32(read_memory(cred + offset_uid + 32, 4))
            fmt = "{:#018x}: {:<16s} {:#018x} [{:>5d},{:>5d},{:>5d},{:>5d},{:>5d},{:>5d},{:>5d},{:>5d}] {:#10x}"
            out.append(fmt.format(task, comm_string, cred, *uids, securebits))

            if args.mm:
                mms = self.get_mm(task, offset_mm)
                if mms:
                    out.append(titlify("memory map of `{:s}`".format(comm_string)))
                for mm in mms:
                    out.append("  {:#018x}-{:#018x} {:s} {:s}".format(mm.start, mm.end, mm.flags, mm.file))
                if mms:
                    out.append(titlify(""))
        gef_print('\n'.join(out), less=not args.no_pager)
        return


@register_command
class KernelModuleCommand(GenericCommand):
    """Display module list under qemu-system."""
    _cmdline_ = "kmod"
    _category_ = "08-b. Qemu-system Cooperation - Linux"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    def get_modules_list(self):
        modules = KernelAddressHeuristicFinder.get_modules()
        if modules is None:
            err("Not found symbol")
            return None
        gef_print(titlify("Kernel modules (heuristic)"))
        info("modules: {:#x}".format(modules))

        module_addrs = []
        current = modules
        while True:
            addr = read_int_from_memory(current)
            if addr == modules:
                break
            module_addrs.append(addr)
            current = addr
        return module_addrs

    def get_offset_name(self, module_addrs):
        for i in range(0x100):
            offset_name = i * current_arch.ptrsize
            valid = True
            for module in module_addrs:
                if not is_ascii_string(module + offset_name):
                    valid = False
                    break
                s = read_cstring_from_memory(module + offset_name)
                if len(s) < 2:
                    valid = False
                    break
            if valid:
                info("offsetof(module, name): {:#x}".format(offset_name))
                return offset_name
        err("Not found module->name[MODULE_NAME_LEN]]")
        return None

    def get_offset_layout(self, module_addrs):
        """
            struct module {
                enum module_state state;
                /* Member of list of modules */
                struct list_head list;
                /* Unique handle for this module */
                char name[MODULE_NAME_LEN];
            #ifdef CONFIG_STACKTRACE_BUILD_ID
                /* Module build ID */
                unsigned char build_id[BUILD_ID_SIZE_MAX];
            #endif
                /* Sysfs stuff. */
                struct module_kobject mkobj;
                struct module_attribute *modinfo_attrs;
                const char *version;
                const char *srcversion;
                struct kobject *holders_dir;
                /* Exported symbols */
                const struct kernel_symbol *syms;
                const s32 *crcs;
                unsigned int num_syms;
            #ifdef CONFIG_CFI_CLANG
                cfi_check_fn cfi_check;
            #endif
                /* Kernel parameters. */
            #ifdef CONFIG_SYSFS
                struct mutex param_lock;
            #endif
                struct kernel_param *kp;
                unsigned int num_kp;
                /* GPL-only exported symbols. */
                unsigned int num_gpl_syms;
                const struct kernel_symbol *gpl_syms;
                const s32 *gpl_crcs;
                bool using_gplonly_symbols;
            #ifdef CONFIG_MODULE_SIG
                /* Signature was verified. */
                bool sig_ok;
            #endif
                bool async_probe_requested;
                /* Exception table */
                unsigned int num_exentries;
                struct exception_table_entry *extable;
                /* Startup function. */
                int (*init)(void);
                /* Core layout: rbtree is accessed frequently, so keep together. */
                struct module_layout core_layout __module_layout_align;
                struct module_layout init_layout;
                ...
        }

        struct module_layout {
            /* The actual code + data. */
            void *base;
            /* Total size. */
            unsigned int size;
            /* The size of the executable code.  */
            unsigned int text_size;
            /* Size of RO section of the module (text+rodata) */
            unsigned int ro_size;
            /* Size of RO after init section */
            unsigned int ro_after_init_size;
        #ifdef CONFIG_MODULES_TREE_LOOKUP
            struct mod_tree_node mtn;
        #endif
        };

        [Example arm32]
            gef> x/128xw 0x00000000bf22b084
            0xbf22b084:     0xbf1bb044      0xc1696530      0x00006773      0x00000000
            0xbf22b094:     0x00000000      0x00000000      0x00000000      0x00000000
            0xbf22b0a4:     0x00000000      0x00000000      0x00000000      0x00000000
            0xbf22b0b4:     0x00000000      0x00000000      0x00000000      0x00000000
            0xbf22b0c4:     0x00000000      0xc1ec2d00      0xc1a11d80      0xbf1bb08c
            0xbf22b0d4:     0xc1a11d8c      0xc1a11d80      0xc1628e38      0xc8e0b2c0
            0xbf22b0e4:     0x00000003      0x00000007      0xbf22b080      0x00000000
            0xbf22b0f4:     0xc8d4f380      0x00000000      0xc1e47400      0xc8f6d900
            0xbf22b104:     0xc8f6d080      0xc8004300      0x00000000      0x00000000
            0xbf22b114:     0x00000000      0x00000000      0x00000000      0x00000000
            0xbf22b124:     0xbf22b124      0xbf22b124      0xbf22a990      0x00000003
            0xbf22b134:     0x00000000      0x00000000      0x00000000      0x00000001
            0xbf22b144:     0x00000000      0x00000000      0x00000000      0x00000000
            0xbf22b154:     0x00000000      0xbf17e000      0x00000000      0x00000000
            0xbf22b164:     0x00000000      0x00000000      0x00000000      0x00000000
            0xbf22b174:     0x00000000      0x00000000      0x00000000      0xbf225000 <- init_layout.base
            0xbf22b184:     0x00008000      0x00005000      0x00006000      0x00006000
        """
        for i in range(300):
            offset_layout = i * current_arch.ptrsize
            valid = True
            for module in module_addrs:
                # base align check
                cand_base = read_int_from_memory(module + offset_layout)
                if cand_base == 0 or cand_base & 0xfff:
                    valid = False
                    break
                # size align check
                cand_size = u32(read_memory(module + offset_layout + current_arch.ptrsize + 4 * 0, 4))
                if cand_size == 0 or cand_size & 0xfff:
                    valid = False
                    break
                # text_size align check
                cand_text_size = u32(read_memory(module + offset_layout + current_arch.ptrsize + 4 * 1, 4))
                if cand_text_size == 0 or cand_text_size & 0xfff:
                    valid = False
                    break
                # ro_size align check
                cand_ro_size = u32(read_memory(module + offset_layout + current_arch.ptrsize + 4 * 2, 4))
                if cand_ro_size == 0 or cand_ro_size & 0xfff:
                    valid = False
                    break
                # ro_after_init_size align check
                cand_ro_after_init_size = u32(read_memory(module + offset_layout + current_arch.ptrsize + 4 * 3, 4))
                if cand_ro_after_init_size == 0 or cand_ro_after_init_size & 0xfff:
                    valid = False
                    break
            if valid:
                info("offsetof(module, init_layout): {:#x}".format(offset_layout))
                return offset_layout
        err("Not found module->init_layout")
        return None

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        info("Wait for memory scan")

        module_addrs = self.get_modules_list()
        if module_addrs is None:
            return

        offset_name = self.get_offset_name(module_addrs)
        if offset_name is None:
            return

        offset_layout = self.get_offset_layout(module_addrs)
        if offset_layout is None:
            return

        fmt = "{:<18s}: {:<18s} {:<18s} {:<18s}"
        legend = ["module", "module->name", "base", "size"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for module in module_addrs:
            name_string = read_cstring_from_memory(module + offset_name)
            base = read_int_from_memory(module + offset_layout)
            size = u32(read_memory(module + offset_layout + 4, 4))
            gef_print("{:#018x}: {:<18s} {:#018x} {:#018x}".format(module, name_string, base, size))
        return


@register_command
class KernelCharacterDevicesCommand(GenericCommand):
    """Display character device list under qemu-system."""
    _cmdline_ = "kcdev"
    _category_ = "08-b. Qemu-system Cooperation - Linux"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    # character device is managed at chrdevs[] and cdev_map.
    # we use each of them for getting structure information.

    def get_chrdev_list(self): # [chrdev, chrdev, chrdev, ...]
        """
        #define CHRDEV_MAJOR_HASH_SIZE 255
        static struct char_device_struct {
            struct char_device_struct *next;
            unsigned int major;
            unsigned int baseminor;
            int minorct;
            char name[64];
            struct cdev *cdev; /* will die */
        } *chrdevs[CHRDEV_MAJOR_HASH_SIZE];
        """
        chrdevs = KernelAddressHeuristicFinder.get_chrdevs()
        if chrdevs is None:
            err("Not found symbol")
            return None
        gef_print(titlify("Kernel character devices (heuristic)"))
        info("chrdevs: {:#x}".format(chrdevs))

        chrdev_addrs = []
        for i in range(255):
            addr = read_int_from_memory(chrdevs + i * current_arch.ptrsize)
            while addr and addr not in chrdev_addrs:
                chrdev_addrs.append(addr)
                addr = read_int_from_memory(addr)
        return chrdev_addrs

    def get_cdev_list(self): # [[cdev, major, minor], [...] ...]
        """
        struct kobj_map {
            struct probe {
                struct probe *next;
                dev_t dev;
                unsigned long range;
                struct module *owner;
                kobj_probe_t *get;
                int (*lock)(dev_t, void *);
                void *data;                  // -> cdev
            } *probes[255];
            struct mutex *lock;
        };
        static struct kobj_map *cdev_map;

        struct cdev {
            struct kobject kobj;
            struct module *owner;
            const struct file_operations *ops;
            struct list_head list;
            dev_t dev;
            unsigned int count;
        } __randomize_layout;

        struct kobject {
            const char *name;
            struct list_head entry;
            struct kobject *parent;
            struct kset *kset;
            const struct kobj_type *ktype;
            struct kernfs_node *sd; /* sysfs directory entry */
            struct kref kref;
        #ifdef CONFIG_DEBUG_KOBJECT_RELEASE
            struct delayed_work release;
        #endif
            unsigned int state_initialized:1;
            unsigned int state_in_sysfs:1;
            unsigned int state_add_uevent_sent:1;
            unsigned int state_remove_uevent_sent:1;
            unsigned int uevent_suppress:1;
        };
        """
        cdev_map = KernelAddressHeuristicFinder.get_cdev_map()
        if cdev_map is None:
            err("Not found symbol")
            return None
        info("cdev_map: {:#x}".format(cdev_map))

        try:
            cdev_map_ = read_int_from_memory(cdev_map)
            info("*cdev_map: {:#x}".format(cdev_map_))
        except Exception:
            err("cdev_map is not initialized")
            return None

        cdev_addrs = []
        seen = []
        for i in range(255):
            addr = read_int_from_memory(cdev_map_ + i * current_arch.ptrsize)
            while addr:
                cdev = read_int_from_memory(addr + 6 * current_arch.ptrsize)
                dev = u32(read_memory(addr + current_arch.ptrsize, 4))
                major = dev >> 20
                minor = dev & ((1 << 20) - 1)
                if cdev and cdev not in seen:
                    cdev_addrs.append([cdev, major, minor])
                    seen.append(cdev)
                addr = read_int_from_memory(addr)
        return cdev_addrs

    def get_offset_ops(self, cdevs):
        for i in range(3, 0x20):
            offset_list = i * current_arch.ptrsize
            valid = True
            for cdev in cdevs:
                pos_next = cdev + offset_list
                pos_prev = cdev + offset_list + current_arch.ptrsize
                list_entry_next = [pos_next]
                list_entry_prev = [pos_prev]
                while valid:
                    # read check
                    try:
                        pos_next = read_int_from_memory(pos_next)
                        pos_prev = read_int_from_memory(pos_prev) + current_arch.ptrsize
                    except Exception: # memory read error
                        valid = False
                        break
                    # list validate
                    if pos_next in list_entry_next[1:]: # incomplete infinity loop detected
                        valid = False
                        break
                    if pos_prev in list_entry_prev[1:]: # incomplete infinity loop detected
                        valid = False
                        break
                    if pos_next == list_entry_next[0] and pos_prev == list_entry_prev[0]:
                        break
                    list_entry_next.append(pos_next)
                    list_entry_prev.append(pos_prev)
                if not valid:
                    break
            else:
                # for loop is finished until last element
                if valid:
                    offset_ops = offset_list - current_arch.ptrsize
                    info("offsetof(cdev, ops): {:#x}".format(offset_ops))
                    return offset_ops
        err("Not found offsetof(cdev, ops)")
        return None

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        info("Wait for memory scan")

        chrdev_addrs = self.get_chrdev_list()
        if chrdev_addrs is None:
            return
        cdev_addrs = self.get_cdev_list()
        if cdev_addrs is None:
            return

        # merge chrdev (from chrdevs)
        merged = {}
        for chrdev in chrdev_addrs:
            major = u32(read_memory(chrdev + current_arch.ptrsize, 4))
            minor = u32(read_memory(chrdev + current_arch.ptrsize + 4, 4))
            name_string = read_cstring_from_memory(chrdev + current_arch.ptrsize + 4 * 3) or "<None>"
            off = chrdev + current_arch.ptrsize + 4 * 3 + 64
            while off % current_arch.ptrsize: # align
                off += 1
            cdev = read_int_from_memory(off)
            merged[major, minor] = {"chrdev": chrdev, "name": name_string, "cdev": cdev}

        # merge cdev (from cdev_map)
        for cdev, major, minor in cdev_addrs:
            kobj = read_int_from_memory(cdev)
            name_string = read_cstring_from_memory(kobj) or "<None>"

            if (major, minor) in merged:
                if merged[major, minor]["cdev"] == 0:
                    merged[major, minor]["cdev"] = cdev
                if merged[major, minor]["name"] == "<None>":
                    merged[major, minor]["name"] = name_string
            else:
                merged[major, minor] = {"chrdev": 0x0, "name": name_string, "cdev": cdev}

        # add ops info
        off_ops = self.get_offset_ops([v["cdev"] for k, v in merged.items() if v["cdev"]])
        if off_ops is None:
            return
        for k in merged.keys():
            if merged[k]["cdev"]:
                merged[k]["ops"] = read_int_from_memory(merged[k]["cdev"] + off_ops)
            else:
                merged[k]["ops"] = 0x0
            merged[k]["ops_sym"] = get_symbol_string(merged[k]["ops"])

        # add parent info
        for k in merged.keys():
            if merged[k]["cdev"]:
                parent = read_int_from_memory(merged[k]["cdev"] + current_arch.ptrsize * 3)
                merged[k]["parent"] = parent
                if parent:
                    name = read_int_from_memory(parent)
                    if name:
                        merged[k]["parent_name"] = read_cstring_from_memory(name) or "<None>"
                    else:
                        merged[k]["parent_name"] = "<None>"
                else:
                    merged[k]["parent_name"] = "<None>"
            else:
                merged[k]["parent"] = 0x0
                merged[k]["parent_name"] = "<None>"

        # print
        fmt = "{:<18s}: {:<18s} {:<6s} {:<6s} {:<18s} {:<18s} {:18s} {:<s}"
        legend = ["chrdev", "name", "major", "minor", "cdev", "cdev->kobj.parent", "parent_name", "cdev->ops"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for (major, minor), m in sorted(merged.items()):
            fmt = "{:#018x}: {:<18s} {:<6d} {:<6d} {:#018x} {:#018x} {:<18s} {:#018x}{:s}"
            gef_print(fmt.format(m["chrdev"], m["name"], major, minor, m["cdev"], m["parent"], m["parent_name"], m["ops"], m["ops_sym"]))
        return


@register_command
class KernelFopsCommand(GenericCommand):
    """Display fops members under qemu-system."""
    _cmdline_ = "kfops"
    _category_ = "08-b. Qemu-system Cooperation - Linux"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument("address", metavar='ADDRESS', nargs='?', type=parse_address, help='the address interpreted as fops.')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def get_member(self):
        members = [
            ["ptr", "owner"],
            ["func_ptr", "llseek"],
            ["func_ptr", "read"],
            ["func_ptr", "write"],
            ["func_ptr", "read_iter"],
            ["func_ptr", "write_iter"],
            ["func_ptr", "iopoll"],
            ["func_ptr", "iterate"],
            ["func_ptr", "iterate_shared"],
            ["func_ptr", "poll"],
            ["func_ptr", "unlocked_ioctl"],
            ["func_ptr", "compat_ioctl"],
            ["func_ptr", "mmap"],
            ["ulong",    "mmap_supported_flags"],
            ["func_ptr", "open"],
            ["func_ptr", "flush"],
            ["func_ptr", "release"],
            ["func_ptr", "fsync"],
            ["func_ptr", "fasync"],
            ["func_ptr", "lock"],
            ["func_ptr", "sendpage"],
            ["func_ptr", "get_unmapped_area"],
            ["func_ptr", "check_flags"],
            ["func_ptr", "flock"],
            ["func_ptr", "splice_write"],
            ["func_ptr", "splice_read"],
            ["func_ptr", "setlease"],
            ["func_ptr", "fallocate"],
            ["func_ptr", "show_fdinfo"],
            ["(func_ptr)", "(mmap_capabilities)"], # only exists when CONFIG_MMU
            ["func_ptr", "copy_file_range"],
            ["func_ptr", "remap_file_range"],
            ["func_ptr", "fadvise"],
        ]
        return members

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        members = self.get_member()

        if args.address:
            try:
                addrs = [read_int_from_memory(args.address + current_arch.ptrsize * i) for i in range(len(members))]
            except gdb.MemoryError:
                err("Memory read error")
                return

            fmt = "[{:3s}] {:<10s} {:<20s} {:s}"
            legend = ["idx", "type", "name", "value"]
            gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
            for idx, ((type, name), address) in enumerate(zip(members, addrs)):
                sym = get_symbol_string(address)
                gef_print("[{:3d}] {:10s} {:20s} {:#018x}{:s}".format(idx, type, name, address, sym))

        else:
            fmt = "[{:3s}] {:<10s} {:<20s}"
            legend = ["idx", "type", "name"]
            gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
            for idx, (type, name) in enumerate(members):
                gef_print("[{:3d}] {:10s} {:20s}".format(idx, type, name))
        return


@register_command
class AsciiSearchCommand(GenericCommand):
    """Search ASCII string recursively from specific location."""
    _cmdline_ = "ascii-search"
    _category_ = "03-a. Memory - Search"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('location', metavar='LOCATION', type=parse_address,
                        help='the location you want to search from.')
    parser.add_argument('-f', '--filter', action='append', default=[], help='REGEXP filter.')
    parser.add_argument('-d', '--depth', default=3, type=int, help='recursive depth. (default: %(default)s)')
    parser.add_argument('-r', '--range', default=0x40, type=lambda x: int(x, 16), help='search range. (default: %(default)s)')
    _syntax_ = parser.format_help()

    def search_ascii(self, locations, search_range, depth, max_depth):
        if depth == 0:
            return
        for offset in range(0, search_range, current_arch.ptrsize):
            target = locations[-1] + offset
            if not is_valid_addr(target):
                continue

            cstr = None
            try:
                cstr = read_ascii_string(target)
            except UnicodeDecodeError:
                pass

            if cstr:
                if not self.filter or any([re.search(filt, cstr) for filt in self.filter]):
                    for d, loc in enumerate(locations):
                        gef_print("{:s}{:#x}".format("  " * d, loc))
                    gef_print("{:s}{:#x}: {:s}".format("  " * (d + 1), target, repr(cstr)))
            v = read_int_from_memory(target)
            if is_valid_addr(v):
                self.search_ascii(locations + [v], search_range, depth - 1, max_depth)
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()
        self.filter = args.filter
        self.search_ascii([args.location], args.range, args.depth, args.depth)
        return


@register_command
class SyscallTableViewCommand(GenericCommand):
    """Display syscall_table entries under qemu-system."""
    _cmdline_ = "syscall-table-view"
    _category_ = "08-b. Qemu-system Cooperation - Linux"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-f', '--filter', action='append', default=[], help='REGEXP filter.')
    _syntax_ = parser.format_help()

    _example_ = "{:s}\n".format(_cmdline_)
    _example_ += "{:s} --filter write".format(_cmdline_)

    def syscall_table_view(self, sys_call_table_addr):
        if sys_call_table_addr is None:
            err("Not found symbol")
            return
        # scan
        i = 0
        seen = {}
        table = []
        while True:
            addr = sys_call_table_addr + i * current_arch.ptrsize
            try:
                syscall_function_addr = read_int_from_memory(addr)
            except gdb.MemoryError:
                break
            if is_x86() and syscall_function_addr % 0x10: # should be aligned
                break
            elif (is_arm32() or is_arm64()) and syscall_function_addr % 4: # should be aligned
                break
            try:
                read_int_from_memory(syscall_function_addr) # if entry is valid, no error
            except gdb.MemoryError:
                break
            symbol = get_symbol_string(syscall_function_addr, nosymbol_string=" <NO_SYMBOL>")
            seen[syscall_function_addr] = seen.get(syscall_function_addr, 0) + 1
            table.append([i, addr, syscall_function_addr, symbol])
            i += 1
        # print
        fmt = "{:5s} {:18s}: {:18s} {:s}"
        legend = ["Index", "Table Address", "Function Address", "Symbol"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for i, addr, syscall_function_addr, symbol in table:
            if seen[syscall_function_addr] == 1: # valid entry
                msg = "[{:03d}] {:#018x}: {:#018x}{:s}".format(i, addr, syscall_function_addr, symbol)
            else: # invalid entry
                msg = "[{:03d}] {:#018x}: ".format(i, addr) + Color.grayify("{:#018x}{:s}".format(syscall_function_addr, symbol))
            if not self.filter:
                gef_print(msg)
            else:
                for filt in self.filter:
                    if re.search(filt, msg):
                        gef_print(msg)
        return

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, args):
        self.dont_repeat()

        self.filter = args.filter

        if is_x86_32():
            gef_print(titlify("sys_call_table (x86)"))
            self.syscall_table_view(KernelAddressHeuristicFinder.get_sys_call_table_x86())
        elif is_x86_64():
            gef_print(titlify("sys_call_table (x64)"))
            self.syscall_table_view(KernelAddressHeuristicFinder.get_sys_call_table_x64())
            gef_print(titlify("ia32_sys_call_table"))
            self.syscall_table_view(KernelAddressHeuristicFinder.get_sys_call_table_x86())
            gef_print(titlify("x32_sys_call_table"))
            self.syscall_table_view(KernelAddressHeuristicFinder.get_sys_call_table_x32())
        elif is_arm32():
            gef_print(titlify("sys_call_table (arm32)"))
            self.syscall_table_view(KernelAddressHeuristicFinder.get_sys_call_table_arm32())
        elif is_arm64():
            gef_print(titlify("sys_call_table (arm64)"))
            self.syscall_table_view(KernelAddressHeuristicFinder.get_sys_call_table_arm64())
            gef_print(titlify("compat_sys_call_table (arm32)"))
            self.syscall_table_view(KernelAddressHeuristicFinder.get_sys_call_table_arm64_compat())
        return


@register_command
class CetStatusCommand(GenericCommand):
    """Show Intel CET settings."""
    _cmdline_ = "cet-status"
    _category_ = "02-f. Process Information - Security"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    def get_state(self, code_len):
        d = {}
        d["pc"] = current_arch.pc
        d["sp"] = current_arch.sp
        d["code"] = read_memory(d["pc"], code_len)
        d["reg"] = {}
        for reg in current_arch.gpr_registers:
            d["reg"][reg] = get_register(reg)
        d["stack"] = {}
        for i in range(3):
            addr = d["sp"] + current_arch.ptrsize * i
            d["stack"][addr] = read_memory(addr, current_arch.ptrsize)
        return d

    def revert_state(self, d):
        write_memory(d["pc"], d["code"], len(d["code"]))
        gdb.execute("set $pc = {:#x}".format(d["pc"]), to_string=True)
        for regname, regvalue in d["reg"].items():
            gdb.execute("set {:s} = {:#x}".format(regname, regvalue), to_string=True)
        for addr, value in d["stack"].items():
            write_memory(addr, value, len(value))
        return

    def close_stdout(self):
        self.stdout = 1
        self.stdout_bak = os.dup(self.stdout)
        f = open("/dev/null")
        os.dup2(f.fileno(), self.stdout)
        f.close()
        return

    def revert_stdout(self):
        os.dup2(self.stdout_bak, self.stdout)
        os.close(self.stdout_bak)
        return

    def get_result(self):
        r = {}
        r["ret"] = get_register("$rax" if is_x86_64() else "$eax")
        r["data"] = []
        for i in range(3):
            addr = get_register("$rsi" if is_x86_64() else "$ecx") + current_arch.ptrsize * i
            v = read_int_from_memory(addr)
            r["data"].append(v)
        return r

    def execute_get_cet_status(self):
        if is_x86_64():
            code = b"\xeb\xfe\x0f\x05" # inf-loop (to stop another thread); syscall
        else:
            code = b"\xeb\xfe\xcd\x80" # inf-loop (to stop another thread); int 0x80
        gef_on_stop_unhook(hook_stop_handler)
        d = self.get_state(len(code))
        write_memory(d["pc"], code, len(code))
        if is_x86_64():
            gdb.execute("set $rax = 0x9e", to_string=True) # arch_prctl
            gdb.execute("set $rdi = 0x3001", to_string=True) # ARCH_CET_STATUS
            gdb.execute("set $rsi = $rsp", to_string=True) # buffer
        else:
            gdb.execute("set $eax = 0x180", to_string=True) # arch_prctl
            gdb.execute("set $ebx = 0x3001", to_string=True) # ARCH_CET_STATUS
            gdb.execute("set $ecx = $esp", to_string=True) # buffer
        gdb.execute("set $pc = {:#x}".format(d["pc"] + 2), to_string=True) # skip "\xeb\xfe"
        self.close_stdout()
        gdb.execute("stepi", to_string=True)
        self.revert_stdout()
        r = self.get_result()
        self.revert_state(d)
        gef_on_stop_hook(hook_stop_handler)
        return r

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, args):
        self.dont_repeat()

        try:
            r = self.execute_get_cet_status()
        except Exception:
            err("Execute code fails. Memory write feature may not be supported.")
            return

        if r["ret"] != 0:
            err("OS does not support CET")
            return

        gef_print("ShadowStack/IndirectBranchTracking status: {:#x}".format(r["data"][0]))
        if r["data"][0] & 0b10:
            msg = Color.colorify("Enabled", "bold green")
        else:
            msg = Color.colorify("Disabled", "bold red")
        gef_print("  ShadowStack: {:s}".format(msg))
        if r["data"][0] & 0b01:
            msg = Color.colorify("Enabled", "bold green")
        else:
            msg = Color.colorify("Disabled", "bold red")
        gef_print("  IndirectBrannchTracking: {:s}".format(msg))
        gef_print("ShadowStack Base Address: {:#x}".format(r["data"][1]))
        gef_print("ShadowStack Size: {:#x}".format(r["data"][2]))
        return


@register_command
class TlsCommand(GenericCommand):
    """Show TLS base address."""
    _cmdline_ = "tls"
    _category_ = "02-b. Process Information - Base Address"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @staticmethod
    def get_tls_heuristic():
        reset_gef_caches(all=True)
        vmmap = get_process_maps()
        for m in vmmap[::-1]:
            if m.path != "<explored>" and m.path.startswith(("/", "[")):
                continue
            data = read_memory(m.page_start, m.size)
            data = slice_unpack(data, current_arch.ptrsize)
            addr = [x for x in range(m.page_start, m.page_end, current_arch.ptrsize)]
            assert len(data) == len(addr)
            """
            x86
            0x3f7a4040|+0x0000|000: 0x3f7a4040  ->  [loop detected]
            0x3f7a4044|+0x0004|001: 0x3f7a45b8  ->  0x00000001
            0x3f7a4048|+0x0008|002: 0x3f7a4040  ->  [loop detected]
            0x3f7a404c|+0x000c|003: 0x00000000
            0x3f7a4050|+0x0010|004: 0x3f7e3810  ->  0x8dc380cd
            0x3f7a4054|+0x0014|005: 0xb5653400  <-  canary
            0x3f7a4058|+0x0018|006: 0x9dd17d94

            x64
            0x0000004001a8c0c0|+0x0000|000: 0x0000004001a8c0c0  ->  [loop detected]
            0x0000004001a8c0c8|+0x0008|001: 0x0000004001a8cad0  ->  0x0000000000000001
            0x0000004001a8c0d0|+0x0010|002: 0x0000004001a8c0c0  ->  [loop detected]
            0x0000004001a8c0d8|+0x0018|003: 0x0000000000000000
            0x0000004001a8c0e0|+0x0020|004: 0x0000000000000000
            0x0000004001a8c0e8|+0x0028|005: 0xaef406f5ae952a00  <-  canary
            0x0000004001a8c0f0|+0x0030|006: 0x0dc290ff2805b4c8
            """
            for i in range(len(data) - 2):
                if data[i] != addr[i]:
                    continue
                if data[i + 2] != addr[i]:
                    continue

                canary = gef_read_canary()
                if canary:
                    # if canary is found, use it to check
                    if data[i + 5] != canary[0]:
                        continue
                else:
                    # if canary is not found, maybe not yet initialized
                    return 0
                return addr[i]

        return 0

    @staticmethod
    def getfs():
        if is_remote_debug():
            if is_x86_64():
                return TlsCommand.get_tls_heuristic()
            else:
                return 0
        # fast path
        fs = get_register("$fs_base")
        if fs is not None:
            return fs
        # slow path
        PTRACE_ARCH_PRCTL = 30
        ARCH_GET_FS = 0x1003
        pid, lwpid, tid = gdb.selected_thread().ptid
        ppvoid = ctypes.POINTER(ctypes.c_void_p)
        value = ppvoid(ctypes.c_void_p())
        value.contents.value = 0
        libc = ctypes.CDLL('libc.so.6')
        result = libc.ptrace(PTRACE_ARCH_PRCTL, lwpid, value, ARCH_GET_FS)
        if result == 0:
            return value.contents.value or 0
        else:
            return 0

    @staticmethod
    def getgs():
        if is_remote_debug():
            if is_x86_32():
                return TlsCommand.get_tls_heuristic()
            else:
                return 0
        # fast path
        gs = get_register("$gs_base")
        if gs is not None:
            return gs
        # slow path
        PTRACE_ARCH_PRCTL = 30
        ARCH_GET_GS = 0x1004
        pid, lwpid, tid = gdb.selected_thread().ptid
        ppvoid = ctypes.POINTER(ctypes.c_void_p)
        value = ppvoid(ctypes.c_void_p())
        value.contents.value = 0
        libc = ctypes.CDLL('libc.so.6')
        result = libc.ptrace(PTRACE_ARCH_PRCTL, lwpid, value, ARCH_GET_GS)
        if result == 0:
            return value.contents.value or 0
        else:
            return 0

    @staticmethod
    def get_tls():
        if is_qemu_system():
            return None
        elif is_x86_64():
            return TlsCommand.getfs()
        elif is_x86_32():
            return TlsCommand.getgs()
        return None

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, args):
        self.dont_repeat()

        if is_x86_64():
            fsvalue = self.getfs()
            if fsvalue:
                gef_print(titlify("TLS-0x80"))
                gdb.execute("telescope {:#x} 16 --no-pager".format(fsvalue - 0x80))
                gef_print(titlify("TLS"))
                gdb.execute("telescope {:#x} 16 --no-pager".format(fsvalue))
                gef_print("set $tls = {:#x}".format(fsvalue))
                gdb.execute("set $tls = {:#x}".format(fsvalue))
        elif is_x86_32():
            gsvalue = self.getgs()
            if gsvalue:
                gef_print(titlify("TLS-0x40"))
                gdb.execute("telescope {:#x} 16 --no-pager".format(gsvalue - 0x40))
                gef_print(titlify("TLS"))
                gdb.execute("telescope {:#x} 16 --no-pager".format(gsvalue))
                gef_print("set $tls = {:#x}".format(gsvalue))
                gdb.execute("set $tls = {:#x}".format(gsvalue))
        elif is_arm32():
            if not safe_parse_and_eval("__aeabi_read_tp"):
                err("Not found symbol (__aeabi_read_tp)")
                return
            gef_print("p $tls = (unsigned int)__aeabi_read_tp()")
            tls = gdb.execute("p $tls = (unsigned int)__aeabi_read_tp()", to_string=True)
            if tls:
                gef_print(titlify("TLS-0x40"))
                gdb.execute("telescope $tls-0x40 16 --no-pager")
                gef_print(titlify("TLS"))
                gdb.execute("telescope $tls 16 --no-pager")
        elif is_arm64():
            gef_print("p $tls = $TPIDR_EL0")
            tls = gdb.execute("p $tls = $TPIDR_EL0", to_string=True)
            if tls:
                gef_print(titlify("TLS-0x80"))
                gdb.execute("telescope $tls-0x80 16 --no-pager")
                gef_print(titlify("TLS"))
                gdb.execute("telescope $tls 16 --no-pager")
        return


@register_command
class FsbaseCommand(GenericCommand):
    """Show fsbase address."""
    _cmdline_ = "fsbase"
    _category_ = "02-b. Process Information - Base Address"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, args):
        self.dont_repeat()
        fs_base = TlsCommand.getfs()
        gef_print("$fs_base = {:#x}".format(fs_base))
        return


@register_command
class GsbaseCommand(GenericCommand):
    """Show gsbase address."""
    _cmdline_ = "gsbase"
    _category_ = "02-b. Process Information - Base Address"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, args):
        self.dont_repeat()
        gs_base = TlsCommand.getgs()
        gef_print("$gs_base = {:#x}".format(gs_base))

        return


@register_command
class IdtInfoCommand(GenericCommand):
    """Print IDT entries."""
    _cmdline_ = "idtinfo"
    _aliases_ = ["int"]
    _category_ = "04-a. Register - View"

    _INTERRUPT_DESCRIPTION_ = {0: "Divide Error Exception (#DE)", 1: "Debug Exception (#DB)", 2: "NMI Interrupt" , 3: "Breakpoint Exception (#BP)", 4: "Overflow Exception (#OF)" , 5: "BOUND Range Exceeded Exception (#BR)" , 6: "Invalid Opcode Exception (#UD)" , 7: "Device Not Available Exception (#NM)" , 8: "Double Fault Exception (#DF)" , 9: "Coprocessor Segment Overrun" , 10: "Invalid TSS Exception (#TS)" , 11: "Segment Not Present (#NP)" , 12: "Stack Fault Exception (#SS)" , 13: "General Protection Exception (#GP)" , 14: "Page-Fault Exception (#PF)", 16: "x87 FPU Floating-Point Error (#MF)" , 17: "Alignment Check Exception (#AC)" , 18: "Machine-Check Exception (#MC)" , 19: "SIMD Floating-Point Exception (#XM)" , 20: "Virtualization Exception (#VE)" , 21: "Control Protection Exception (#CP)" }
    _GATE_TYPE_32_ = { 0x5: "Task Gate", 0x6: "16-bit Interrupt Gate", 0x7: "16-bit Trap Gate", 0xE: "32-bit Interrupt Gate", 0xF: "32-bit Trap Gate" }
    _GATE_TYPE_64_ = { 0xE: "64-bit Interrupt Gate", 0xF: "64-bit Trap Gate" }

    def parse_arg(arg):
        if "," in arg:
            arg = arg.split(",")
            assert 2 <= len(arg) <= 3
            arg = list(map(lambda x: int(x, 0), arg))

            if len(arg) == 2:
                if arg[0] > arg[1]:
                    arg[0], arg[1] = arg[1], arg[0]

            arg[1] += 1
            return range(*arg)
        else:
            return int(arg, 0)

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument("idt_numbers", type=parse_arg, nargs='*', help='idt number to get information of, it can be an integer or a range separated by a comma')
    parser.add_argument("--null", action='store_true' , help='print also null idt entries')
    _syntax_ = parser.format_help()



    @staticmethod
    def idt_unpack(vals):

        if isinstance(vals, list):
            val = vals[0] # for TSS/LDT
        else:
            val = vals # for normal

        # parse
        _idt = {}
        _idt['value'] = val

        _idt['base'] = val & 0xffff
        _idt['segment'] = (val >> 16) & 0xffff
        _idt['ist'] = (val >> 32) & 0b111
        _idt['gate_type'] = (val >> 40) & (0b1111)
        _idt['dpl'] = (val >> 45) & (0b11)
        _idt['present'] = (val >> 47) & (0b1)
        _idt['base'] = _idt['base'] | ((val >> 32) & (0xffff0000))
        _idt['base'] = ((val >> 32) & (0xffffffff00000000)) | _idt['base']

        Idt = collections.namedtuple("Gdt", _idt.keys())
        return Idt(*_idt.values())

    @staticmethod
    def idtval2str(value, color=False):
        c = Color.boldify if color else lambda x: x
        gdt = IdtInfoCommand.idt_unpack(value)

        gate_type_description = IdtInfoCommand._GATE_TYPE_64_

        if gdt.gate_type in gate_type_description:
            gate_type = f"{gdt.gate_type:#x} ({gate_type_description[gdt.gate_type]})"
        else:
            gate_type = f"{gdt.gate_type:#x} (?)"

        if gdt.present == 0:
            return "IDT entry is not present"
        else:
            fmt = ""
            fmt += "{:#036x}".format(gdt.value) + " : "
            fmt += "{:<#018x}".format(gdt.base) + " : "

            flags = []
            flags.append(f"segment={gdt.segment:#x}")
            flags.append(f"ist={gdt.ist}")
            flags.append(f"gt={gate_type}")
            flags.append(f"dpl={gdt.dpl}")
            flags.append(f"P={gdt.present}")

            fmt = fmt + ", ".join(flags)
            return fmt

    @staticmethod
    def idtval2str_legend():
        fmt = "[   #] {:40s}: {:36s} : {:18s} : {:s}"
        return fmt.format("idt name", "value", "base", "flags")


    # print useful idt descriptor
    def print_idt_entry(self, entries, null):
        gef_print(titlify("IDT Entries (x64 sample)"))

        c = Color.boldify

        registers_color = get_gef_setting("theme.dereference_register_value")
        # print legend
        legend = self.idtval2str_legend()
        gef_print(Color.colorify(legend, get_gef_setting("theme.table_heading")))

        for (i, print_flag, segname, value) in entries:
            if value != 0 or null:
                fmt = "[0x{:>02x}] {:40s}: ".format(i, segname) + self.idtval2str(value, color=True)
                gef_print(fmt)
        return


    def print_idt(self, idt_numbers, null):
        if is_x86_64():
            res = gdb.execute("monitor info registers", to_string=True)

            # IDTR
            red = lambda x: Color.colorify(x, "bold red")
            yellow = lambda x: Color.colorify(x, "bold yellow")

            gef_print(titlify("IDTR (Interrupt Descriptor Table Register)"))
            idtr = re.search(r"IDT\s*=\s*(\S+) (\S+)", res)
            base, limit = [int(idtr.group(i), 16) for i in range(1, 3)]

            gef_print("{:s} = {:s}:{:s}".format(red("IDTR"), yellow("{:#x}".format(base)), yellow("{:#x}".format(limit))))
            gef_print("base : {:s}: starting address of IDT (Interrupt Descriptor Table)".format(Color.boldify("{:#x}".format(base))))
            gef_print("limit: {:s}: (size of IDT) - 1".format(Color.boldify("{:#x}".format(limit))))

            inferior = gdb.inferiors()[0]

            idt_entries = []

            if len(idt_numbers) > 0:
                idt_entries_number = set()
                null = True

                for idt_num in idt_numbers:
                    if isinstance(idt_num, range):
                        idt_entries_number = idt_entries_number.union(idt_num)
                    else:
                        idt_entries_number.add(idt_num)

            else:
                idt_entries_number = range(0x100)

            for i in idt_entries_number:
                if 0 <= i < 0xff:
                    idt_raw = inferior.read_memory(base + i * 0x10, 0x10).tobytes()
                    idt_value = int.from_bytes(idt_raw, "little")

                    if i in self._INTERRUPT_DESCRIPTION_:
                        idt_entries.append((i, True, self._INTERRUPT_DESCRIPTION_[i], idt_value))
                    else:
                        idt_entries.append((i, True, f"User defined Int {i:#x}", idt_value))

            if any(map(lambda x : 0 <= x[0] <= 0xff, idt_entries)):
                self.print_idt_entry(idt_entries, null)
            else:
                gef_print(titlify("IDT Entries (x64 sample)"))
                info("You entered an invalid interrupts")

        return

    @parse_args
    @only_if_specific_arch(arch=["x86_64"])
    def do_invoke(self, args):
        self.dont_repeat()
        self.print_idt(**vars(args))
        return


@register_command
class GdtInfoCommand(GenericCommand):
    """Print GDT entries sample."""
    _cmdline_ = "gdtinfo"
    _category_ = "04-a. Register - View"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-v', dest='verbose', action='store_true', help='also display bit information of gdt entries.')
    _syntax_ = parser.format_help()

    @staticmethod
    def seg2str(v):
        rpl = v & 0b11
        ti = (v >> 2) & 0b1
        index = (v >> 3)
        return f"{v:#4x} (=rpl:{rpl}, ti:{ti}, index:{index})"

    # dump segment register
    def print_seg_info(self):
        if not is_alive():
            return
        gef_print(titlify("Current register values"))
        red = lambda x: Color.colorify("{:4s}".format(x), "bold red")
        for k in ['cs', 'ds', 'es', 'fs', 'gs', 'ss']:
            v = get_register(k)
            gef_print("{:s}: {:s}".format(red(k), self.seg2str(v)))
        gef_print(" * rpl: Requested Privilege Level (0:Ring0, 3:Ring3)")
        gef_print(" * ti: Table Indicator (0:GDT, 1:LDT)")
        gef_print(" * index: Index of GDT/LDT")
        gef_print(" * segment register value = (index << 3) | (ti << 2) | rpl")
        gef_print(" * commonly used cs values:")
        gef_print("   - x64 code: 0x33")
        gef_print("   - x86 code (on x64): 0x23")
        gef_print("   - x86 code (native): 0x73")
        return

    # struct desc_struct -> dictionary(each value)
    @staticmethod
    def gdt_unpack(vals):
        if isinstance(vals, list):
            val = vals[0] # for TSS/LDT
        else:
            val = vals # for normal

        # parse
        _gdt = {}
        _gdt['value'] = val

        _gdt['limit0'] = val & 0xffff
        _gdt['base0'] = (val >> 16) & 0xffff
        _gdt['base1'] = (val >> 32) & 0xff
        _gdt['access_bytes'] = (val >> 40) & 0xff
        _gdt['limit1'] = (val >> 48) & 0x0f
        _gdt['flag_bytes'] = (val >> 52) & 0x0f
        _gdt['base2'] = (val >> 56) & 0xff

        _gdt['p'] = (_gdt['access_bytes'] >> 7) & 0x01
        _gdt['dpl'] = (_gdt['access_bytes'] >> 5) & 0x03
        _gdt['s'] = (_gdt['access_bytes'] >> 4) & 0x01
        _gdt['type_bytes'] = _gdt['access_bytes'] & 0x0f
        _gdt['ex'] = (_gdt['access_bytes'] >> 3) & 0x01
        _gdt['dc'] = (_gdt['access_bytes'] >> 2) & 0x01
        _gdt['rw'] = (_gdt['access_bytes'] >> 1) & 0x01
        _gdt['ac'] = (_gdt['access_bytes'] >> 0) & 0x01

        _gdt['gr'] = (_gdt['flag_bytes'] >> 3) & 0x01
        _gdt['db'] = (_gdt['flag_bytes'] >> 2) & 0x01
        _gdt['l'] = (_gdt['flag_bytes'] >> 1) & 0x01
        _gdt['avl'] = (_gdt['flag_bytes'] >> 0) & 0x01
        _gdt['FLAGS'] = (_gdt['flag_bytes'] << 12) | _gdt['access_bytes'] # for easy use

        grsize = {0: 1, 1: 4096}[_gdt['gr']]
        _gdt['limit'] = ((_gdt['limit1'] << 16) | _gdt['limit0']) * grsize
        _gdt['base'] = (_gdt['base2'] << 24) | (_gdt['base1'] << 16) | _gdt['base0']

        # create memo
        if _gdt['ex'] == 0: # data
            _gdt['ex_s'] = "DATA"
            _gdt['rw_s'] = ["RO", "RW"][_gdt['rw']]
            _gdt['dc_s'] = ["UP", "DN"][_gdt['dc']]
        else: # code
            _gdt['ex_s'] = "CODE"
            _gdt['rw_s'] = ["RO", "RX"][_gdt['rw']]
            _gdt['dc_s'] = ["NC", "CO"][_gdt['dc']]

        _gdt['s_s'] = ["SYS", "C/D"][_gdt['s']]
        dbl = (_gdt['db'] << 1) | _gdt['l']
        _gdt['dbl'] = "{:d}".format(dbl)
        _gdt['dbl_s'] = ["16bit", "64bit", "32bit", "(N/A)"][dbl]

        # for TSS/LDT
        if isinstance(vals, list):
            val = vals[1]
            _gdt['value2'] = _gdt['value']
            _gdt['value'] = val
            _gdt['base3'] = val & 0xffffffff
            _gdt['base'] = (_gdt['base3'] << 32) | _gdt['base']

        Gdt = collections.namedtuple("Gdt", _gdt.keys())
        return Gdt(*_gdt.values())

    @staticmethod
    def segval2str(value, value_only=False, color=False):
        c = Color.boldify if color else lambda x: x
        if value_only:
            return c("{:#018x}".format(value))
        gdt = GdtInfoCommand.gdt_unpack(value)
        if gdt.value == 0:
            return c("{:#018x}".format(gdt.value))
        else:
            fmt = ""
            fmt += c("{:#018x}".format(gdt.value)) + " : "
            fmt += c("{:>#18x}".format(gdt.base)) + " "
            fmt += c("{:>#10x}".format(gdt.limit)) + " "
            fmt += c("{:>2d}".format(gdt.gr)) + " "
            fmt += c("{:s}".format(gdt.dbl)) + "({:s}) ".format(gdt.dbl_s)
            fmt += c("{:>3d}".format(gdt.avl)) + " "
            fmt += c("{:d}".format(gdt.p)) + " "
            fmt += c("{:>3}".format(gdt.dpl)) + " "
            fmt += c("{:d}".format(gdt.s)) + "({:s}) ".format(gdt.s_s)
            fmt += c("{:d}".format(gdt.ex)) + "({:s}) ".format(gdt.ex_s)
            fmt += c("{:d}".format(gdt.dc)) + "({:s}) ".format(gdt.dc_s)
            fmt += c("{:d}".format(gdt.rw)) + "({:s}) ".format(gdt.rw_s)
            fmt += c("{:d}".format(gdt.ac))
            return fmt

    @staticmethod
    def segval2str_legend():
        fmt = "[ #] {:20s}: {:18s} : {:>18s} {:s} {:s} {:s}      {:>s} {:s} {:s} {:s}      {:s}      {:s}    {:s}    {:s}"
        return fmt.format("segment name", "value", "base", "limit/size", "gr", "dbl", "avl", "p", "dpl", "s", "ex", "dc", "rw", "ac")

    @staticmethod
    def get_segreg_list():
        regs = {}
        if is_alive():
            for k in ['cs', 'ds', 'es', 'fs', 'gs', 'ss']:
                v = get_register(k)
                ti = (v >> 2) & 0b1
                index = int(v >> 3)
                if v != 0 and ti == 0:
                    regs[index] = regs.get(index, []) + [k]
        return regs

    @staticmethod
    def is_emulated32():
        if is_qemu_usermode():
            return False

        if is_qemu_system():
            return False

        for m in get_process_maps():
            # native x86:
            # 0xbffdf000 0xc0000000 0x021000 0x000000 rw- [stack]
            # emulated x86 on x86_64
            # 0xfffdd000 0xffffe000 0x021000 0x000000 rw- [stack]
            if m.path == "[stack]":
                return (m.page_start >> 28) == 0xf
        else:
            return False # by default it considers on native

    # print useful gdt fixed entry
    def print_gdt_entry(self, entries):
        if is_x86_64() or self.is_emulated32():
            gef_print(titlify("GDT Entry (x64 sample)"))
        else:
            gef_print(titlify("GDT Entry (x86 sample)"))
        info("*** This is an {:s} (GDT/LDT exist per-CPU) ***".format(Color.boldify("EXAMPLE")))
        registers_color = get_gef_setting("theme.dereference_register_value")
        # print legend
        legend = self.segval2str_legend()
        gef_print(Color.colorify(legend, get_gef_setting("theme.table_heading")))
        # regs check
        regs = self.get_segreg_list()
        # parse entry
        for (i, print_flag, segname, value) in entries:
            # get segment regs value
            reglist = ', '.join(regs.get(i, []))
            if reglist:
                reglist = LEFT_ARROW + reglist
            # decode and print
            if print_flag:
                fmt = "[{:>2d}] {:20s}: ".format(i, segname) + self.segval2str(value) + " " + Color.colorify(f"{reglist:s}", registers_color)
            else:
                fmt = "[{:>2d}] {:20s}: {:#018x} ".format(i, segname, value) + Color.colorify(f"{reglist:s}", registers_color)
            gef_print(fmt)
        return

    @staticmethod
    def print_gdt_entry_legend():
        gef_print(titlify("legend (Normal GDT entry)"))
        gef_print("              <flag_bytes->        <----access_bytes ---->")
        gef_print("                                             <type_bytes->")
        gef_print("31            23          19       15                    7             0bit")
        gef_print("------------------------------------------------------------------------")
        gef_print("|             |G |D |  |A |        |  |   |  |E |D |W |A |             |")
        gef_print("| BASE2 31:24 |  |/ |L |V | LIMIT1 |P |DPL|S |  |  |  |  | BASE1 23:16 | 4byte")
        gef_print("|             |R |B |  |L | 19:16  |  |   |  |X |C |R |C |             |")
        gef_print("------------------------------------------------------------------------")
        gef_print("|            BASE0 15:0            |           LIMIT0 15:0             | 0byte")
        gef_print("------------------------------------------------------------------------")
        gef_print(" * base               : Start address")
        gef_print(" * limit              : Segment size (4KB unit if gr==1)")
        gef_print(" * access_bytes")
        gef_print("   * p                : Segment Present Flag (0:SegmentNotInMemory, 1:SegmentInMemory)")
        gef_print("   * dpl              : Descriptor Privilege Level (0:Ring0, 3:Ring3)")
        gef_print("   * s                : Descriptor Type Flag (0:System Segment, 1:Code/Data Segment)")
        gef_print("   * type_bytes")
        gef_print("     * ex             : Segment type (0:Data, 1:Code)")
        gef_print("     * dc (Code Seg)  : Conforming bit (0:NoConform, 1:Conform)")
        gef_print("     * dc (Data Seg)  : Direction bit (0:Up, 1:Down)")
        gef_print("     * rw (Code Seg)  : Read/Exec bit (0:ReadOnly, 1:Read/Exec)")
        gef_print("     * rw (Data Seg)  : Read/Write bit (0:ReadOnly, 1:Read/Write)")
        gef_print("     * ac             : Access bit (0:NotAccessed, 1:Accessed)")
        gef_print(" * flag_bytes")
        gef_print("   * gr               : Granularity Flag (0:SegLimitAsByte, 1:SegLimitAs4KB)")
        gef_print("   * db               : Default Operation size (0:16bitSeg, 1:32bitSeg)")
        gef_print("   * l (Code Seg)     : 64-bits Code Segment Flag (0:32bit, 1:64bit)")
        gef_print("   * l (Data Seg)     : Reserved (0)")
        gef_print("   * avl              : Available bit (0)")
        gef_print(titlify("legend (GDT entry for TSS/LDT)"))
        gef_print("31            23          19       15                    7             0bit")
        gef_print("------------------------------------------------------------------------")
        gef_print("|                           ZERO1 (x64 only)                           | 12byte")
        gef_print("------------------------------------------------------------------------")
        gef_print("|                        BASE3 47:32 (x64 only)                        | 8byte")
        gef_print("------------------------------------------------------------------------")
        gef_print("|             |G |        |        |  |   |  |E |D |W |A |             |")
        gef_print("| BASE2 31:24 |  | ZERO0  | LIMIT1 |P |DPL|S |  |  |  |  | BASE1 23:16 | 4byte")
        gef_print("|             |R |        | 19:16  |  |   |  |X |C |R |C |             |")
        gef_print("------------------------------------------------------------------------")
        gef_print("|            BASE0 15:0            |           LIMIT0 15:0             | 0byte")
        gef_print("------------------------------------------------------------------------")
        gef_print(" * limit (tss)        : __KERNEL_TSS_LIMIT(=0x206f(x64) / 0x206b(x86))")
        gef_print(" * limit (ldt)        : (LDT entries * 8) - 1")
        return

    def print_gdt(self, print_flags_info):
        self.print_seg_info()
        if is_x86_64() or self.is_emulated32():
            self.print_gdt_entry([
                # idx, print flag, segment name,        value
                (0,    True,       "NULL",              0x0000000000000000),
                (1,    True,       "KERNEL32_CS",       0x00cf9b000000ffff),
                (2,    True,       "KERNEL_CS",         0x00af9b000000ffff),
                (3,    True,       "KERNEL_DS",         0x00cf93000000ffff),
                (4,    True,       "DEFAULT_USER32_CS", 0x00cffb000000ffff),
                (5,    True,       "DEFAULT_USER_DS",   0x00cff3000000ffff),
                (6,    True,       "DEFAULT_USER_CS",   0x00affb000000ffff),
                (8,    False,      "TSS-part1",         0x00008b000000206f),
                (9,    True,       "TSS-part2",         [0x00008b000000206f, 0x00000000fffffe00]),
                (10,   True,       "LDT-part1",         0x0000000000000000),
                (11,   True,       "LDT-part2",         0x0000000000000000),
                (12,   True,       "TLS_#1",            0x0000000000000000),
                (13,   True,       "TLS_#2",            0x0000000000000000),
                (14,   True,       "TLS_#3",            0x0000000000000000),
                (15,   True,       "CPUNODE",           0x0040f50000000000),
            ])
        else:
            self.print_gdt_entry([
                # idx, print flag, segment name,        value
                (0,    True,       "NULL",              0x0000000000000000),
                (1,    True,       "RESERVED",          0x0000000000000000),
                (2,    True,       "RESERVED",          0x0000000000000000),
                (3,    True,       "RESERVED",          0x0000000000000000),
                (4,    True,       "UNUSED",            0x0000000000000000),
                (5,    True,       "UNUSED",            0x0000000000000000),
                (6,    True,       "TLS#1",             0x0000000000000000),
                (7,    True,       "TLS#2",             0x0000000000000000),
                (8,    True,       "TLS#3",             0x0000000000000000),
                (9,    True,       "RESERVED",          0x0000000000000000),
                (10,   True,       "RESERVED",          0x0000000000000000),
                (11,   True,       "RESERVED",          0x0000000000000000),
                (12,   True,       "KERNEL_CS",         0x00cf9a000000ffff),
                (13,   True,       "KERNEL_DS",         0x00cf93000000ffff),
                (14,   True,       "DEFAULT_USER_CS",   0x00cffa000000ffff),
                (15,   True,       "DEFAULT_USER_DS",   0x00cff3000000ffff),
                (16,   True,       "TSS",               0xff008b804000206b),
                (17,   True,       "LDT",               0x0000000000000000),
                (18,   True,       "PNPBIOS_CS32",      0x00409a000000ffff),
                (19,   True,       "PNPBIOS_CS16",      0x00009a000000ffff),
                (20,   True,       "PNPBIOS_DS",        0x000092000000ffff),
                (21,   True,       "PNPBIOS_TS1",       0x0000920000000000),
                (22,   True,       "PNPBIOS_TS2",       0x0000920000000000),
                (23,   True,       "APMBIOS_BASE",      0x00409a000000ffff),
                (24,   True,       "APMBIOS",           0x00009a000000ffff),
                (25,   True,       "APMBIOS",           0x004092000000ffff),
                (26,   True,       "ESPFIX_SS",         0x00cf92000000ffff),
                (27,   True,       "PERCPU",            0x038f93708000ffff),
                (28,   True,       "STACK_CANARY",      0x0000000000000000),
                (29,   True,       "UNUSED",            0x0000000000000000),
                (30,   True,       "UNUSED",            0x0000000000000000),
                (31,   True,       "DOUBLEFAULT_TSS",   0xc40089706000206b),
            ])
        if print_flags_info:
            self.print_gdt_entry_legend()
        else:
            info("for flags description, use `-v`")
        return

    @parse_args
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, args):
        self.dont_repeat()
        self.print_gdt(args.verbose)
        info("if qemu-system, use `qreg -v` to confirm real GDT value")
        return


@register_command
class MemoryCompareCommand(GenericCommand):
    """Compares the memory contents of two locations."""
    _cmdline_ = "memcmp"
    _category_ = "03-b. Memory - View"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--phys1', action='store_true', help='treat LOCATION1 as a physical address.')
    parser.add_argument('location1', metavar='LOCATION1', type=parse_address, help='first address for comparison.')
    parser.add_argument('--phys2', action='store_true', help='treat LOCATION2 as a physical address.')
    parser.add_argument('location2', metavar='LOCATION2', type=parse_address, help='second address for comparison.')
    parser.add_argument('size', metavar='SIZE', type=parse_address, help='the size for comparison.')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def memcmp(self, from1_phys, from1, from2_phys, from2, size):
        try:
            if from1_phys:
                from1data = read_physmem(from1, size)
            else:
                from1data = read_memory(from1, size)
        except Exception:
            err("Read error {:#x}".format(from1))
            return

        try:
            if from2_phys:
                from2data = read_physmem(from2, size)
            else:
                from2data = read_memory(from2, size)
        except Exception:
            err("Read error {:#x}".format(from2))
            return

        diff_found = False
        asterisk = True
        for pos in range(0, size, 16):
            f1_bin = from1data[pos : pos + 16]
            f2_bin = from2data[pos : pos + 16]
            if f1_bin == f2_bin:
                if asterisk is False:
                    gef_print("*")
                    asterisk = True
                continue

            addr1 = from1 + pos
            addr2 = from2 + pos

            diff_found = True
            asterisk = False
            f1_hex = []
            f2_hex = []
            f1_ascii = []
            f2_ascii = []
            for i in range(min(len(f1_bin), 16)):
                if f1_bin[i] == f2_bin[i]:
                    color_func = lambda x: x
                else:
                    color_func = Color.boldify
                f1_hex.append(color_func("{:02x}".format(f1_bin[i])))
                f2_hex.append(color_func("{:02x}".format(f2_bin[i])))
                f1_ascii.append(color_func(chr(f1_bin[i]) if 0x20 <= f1_bin[i] < 0x7f else "."))
                f2_ascii.append(color_func(chr(f2_bin[i]) if 0x20 <= f2_bin[i] < 0x7f else "."))
            f1_hex_s = ' '.join(f1_hex) + " " * ((16 - len(f1_hex)) * 3)
            f2_hex_s = ' '.join(f2_hex) + " " * ((16 - len(f2_hex)) * 3)
            f1_ascii_s = ''.join(f1_ascii) + " " * (16 - len(f1_ascii))
            f2_ascii_s = ''.join(f2_ascii) + " " * (16 - len(f2_ascii))
            msg = "{:#018x}: {:s} | {:s} | {:#018x}: {:s} | {:s} |".format(addr1, f1_hex_s, f1_ascii_s, addr2, f2_hex_s, f2_ascii_s)
            gef_print(msg)

        if diff_found is False:
            info("Not found diff")
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        if args.phys1 or args.phys2:
            if not is_qemu_system():
                err("Unsupported")
                return

        if args.size == 0:
            info("The size is zero, maybe wrong.")

        self.memcmp(args.phys1, args.location1, args.phys2, args.location2, args.size)
        return


@register_command
class MemoryCopyCommand(GenericCommand):
    """Copies the contents of one memory to another."""
    _cmdline_ = "memcpy"
    _category_ = "03-c. Memory - Patch"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--phys1', action='store_true', help='treat TO_ADDRESS as a physical address.')
    parser.add_argument('to_addr', metavar='TO_ADDRESS', type=parse_address, help='destionation of memcmp.')
    parser.add_argument('--phys2', action='store_true', help='treat FROM_ADDRESS as a physical address.')
    parser.add_argument('from_addr', metavar='FROM_ADDRESS', type=parse_address, help='source of memcmp.')
    parser.add_argument('size', metavar='SIZE', type=parse_address, help='the size for memcmp.')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def memcpy(self, to_phys, to_addr, from_phys, from_addr, size):
        try:
            if from_phys:
                data = read_physmem(from_addr, size)
            else:
                data = read_memory(from_addr, size)
        except Exception:
            err("Read error {:#x}".format(from_addr))
            return

        info("Read count: {:#x}".format(len(data)))

        try:
            if to_phys:
                written = write_physmem(to_addr, data)
            else:
                written = write_memory(to_addr, data, len(data))
        except Exception:
            err("Write error {:#x}".format(to_addr))
            return

        info("Write count: {:#x}".format(written))
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        if args.phys1 or args.phys2:
            if not is_qemu_system():
                err("Unsupported")
                return

        if args.size == 0:
            info("The size is zero, maybe wrong.")

        self.memcpy(args.phys1, args.to_addr, args.phys2, args.from_addr, args.size)
        return


@register_command
class HashMemoryCommand(GenericCommand):
    """Caluculate memory hash."""
    _cmdline_ = "hash-memory"
    _category_ = "03-d. Memory - Calculation"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('location', metavar='LOCATION', type=parse_address, help='start address for hash calculation.')
    parser.add_argument('size', metavar='SIZE', type=parse_address, help='the size for hash calculation.')
    parser.add_argument('-v', dest='verbose', action='store_true', help='also print crc.')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def calc_hash(self, type, h, start_address, end_address):
        step = 0x400 * gef_getpagesize()
        if is_qemu_system():
            step = gef_getpagesize()

        for chunk_addr in range(start_address, end_address, step):
            if chunk_addr + step > end_address:
                chunk_size = end_address - chunk_addr
            else:
                chunk_size = step

            try:
                mem = read_memory(chunk_addr, chunk_size)
            except gdb.MemoryError:
                err("Memory read error")
                return False

            try:
                if type == 1:
                    h.update(mem)
                elif type == 2:
                    h.process(mem)
            except ValueError:
                return None

            del mem
        if type == 1:
            return h.hexdigest()
        elif type == 2:
            return h.finalhex()
        return None

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        gef_print("Address: {:#x}".format(args.location))
        gef_print("Size: {:#x}".format(args.size))

        # common
        hash_dic1 = {
            "md5": hashlib.md5(),
            "sha1": hashlib.sha1(),
            "sha224": hashlib.sha224(),
            "sha256": hashlib.sha256(),
            "sha384": hashlib.sha384(),
            "sha512": hashlib.sha512(),
            "sha3-224": hashlib.sha3_224(),
            "sha3-256": hashlib.sha3_256(),
            "sha3-384": hashlib.sha3_384(),
            "sha3-512": hashlib.sha3_512(),
        }
        for hname, hfunc in hash_dic1.items():
            h = self.calc_hash(1, hfunc, args.location, args.location + args.size)
            if h is False:
                return
            if h is None:
                continue
            gef_print("{:20s}: {:s} ({:d}-bit)".format(hname, h, len(h) * 4))

        if not args.verbose:
            return

        # crc
        try:
            crccheck = __import__("crccheck")
        except ImportError:
            msg = "Missing `crccheck` package for Python, install with: `pip install crccheck`."
            raise ImportWarning(msg)

        for name in crccheck.crc.__dict__:
            if not name.startswith("Crc"):
                continue
            if name.startswith("Crccheck"):
                continue
            try:
                hfunc = getattr(crccheck.crc, name)()
            except TypeError:
                continue
            h = self.calc_hash(2, hfunc, args.location, args.location + args.size)
            if h is False:
                return
            if h is None:
                continue
            gef_print("{:20s}: {:s} ({:d}-bit)".format(name, h, len(h) * 4))
        return


@register_command
class IsMemoryZeroCommand(GenericCommand):
    """Checks if all the memory in the specified range is 0x00, 0xff."""
    _cmdline_ = "is-mem-zero"
    _category_ = "03-d. Memory - Calculation"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--phys', action='store_true', help='treat ADDRESS as a physical address.')
    parser.add_argument('addr', metavar='ADDRESS', type=parse_address, help='target address for checking.')
    parser.add_argument('size', metavar='SIZE', type=parse_address, help='the size for checking.')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def memcheck(self, phys_mode, addr, size):
        start = addr
        end = addr + size
        is_zero = True
        is_ff = True
        current = addr
        while current < end:
            read_size = min(end - current, 0x1000)
            try:
                if phys_mode:
                    data = read_physmem(current, read_size)
                else:
                    data = read_memory(current, read_size)
            except Exception:
                err("Read error {:#x}".format(addr))
                return
            if data == b"\0" * len(data):
                is_ff = False
            elif data == b"\xff" * len(data):
                is_zero = False
            else:
                is_zero = False
                is_ff = False
            if is_zero is False and is_ff is False:
                break
            current += 0x1000

        if is_zero:
            info("{:#x} - {:#x} is {:s}".format(start, end, Color.colorify("All 0x00", "bold yellow")))
        elif is_ff:
            info("{:#x} - {:#x} is {:s}".format(start, end, Color.colorify("All 0xFF", "bold yellow")))
        else:
            info("{:#x} - {:#x} is {:s}".format(start, end, Color.colorify("NON-ZERO", "bold red")))
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        if args.phys:
            if not is_qemu_system():
                err("Unsupported")
                return

        if args.size == 0:
            info("The size is zero, maybe wrong.")

        self.memcheck(args.phys, args.addr, args.size)
        return


@register_command
class MultiLineCommand(GenericCommand):
    """Execute multiple GDB commands in sequence."""
    _cmdline_ = "multi-line"
    _category_ = "01-c. Debugging Support - Basic Command Extension"
    _aliases_ = ["ml"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('cmd', metavar='GDB_CMD;', nargs='+', help='semicolon-separated gdb command.')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_COMMAND)
        return

    def do_command(self, commands):
        if commands == []:
            return True

        # make comnand string
        cmd = ""
        for c in commands:
            if "\\" in c or " " in c:
                cmd += " " + repr(c)
            else:
                cmd += " " + c
        cmd = cmd.strip()

        # blank command, so skip
        if cmd.replace(" ", "") == "":
            return True

        gef_print(titlify(cmd))
        try:
            gdb.execute(cmd)
        except Exception as e:
            gef_print(e)
            return False # fail
        return True

    # Need not @parse_args because argparse can't stop interpreting options for user specified command.
    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) == 1 and argv[0] == "-h":
            self.usage()
            return

        commands = []
        for arg in argv:
            if arg.endswith(";"):
                commands.append(arg.rstrip(";").lstrip(";"))
                if self.do_command(commands) is False:
                    break
                commands = []
            elif arg.startswith(";"):
                if self.do_command(commands) is False:
                    break
                commands = []
                commands.append(arg.lstrip(";"))
            elif arg == ";":
                if self.do_command(commands) is False:
                    break
                commands = []
            else:
                commands.append(arg)
        else:
            self.do_command(commands)
        return


@register_command
class TimeCommand(GenericCommand):
    """Measures the time of the GDB command."""
    _cmdline_ = "time"
    _category_ = "01-c. Debugging Support - Basic Command Extension"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('cmd', metavar='GDB_CMD', help='gdb command.')
    parser.add_argument('arg', metavar='ARG', nargs='*', help='arguments of gdb command.')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_COMMAND)
        return

    # Need not @parse_args because argparse can't stop interpreting options for user specified command.
    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) == 1 and argv[0] == "-h":
            self.usage()
            return

        start_time_real = time.perf_counter()
        start_time_proc = time.process_time()

        cmd = ""
        for c in argv:
            if "\\" in c or " " in c:
                cmd += " " + repr(c)
            else:
                cmd += " " + c
        cmd = cmd.strip()

        gef_print(titlify(cmd))
        try:
            gdb.execute(cmd)
        except Exception:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            gef_print(exc_value)
            return

        end_time_real = time.perf_counter()
        end_time_proc = time.process_time()
        gef_print(titlify("time elapsed"))
        gef_print("Real: {:.3f} s".format(end_time_real - start_time_real))
        gef_print("CPU:  {:.3f} s".format(end_time_proc - start_time_proc))
        return


@register_command
class LsCommand(GenericCommand):
    """`ls` command wrapper."""
    _cmdline_ = "ls"
    _category_ = "07-a. External Command - General"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('arg', metavar='ARG', nargs='*', help='arguments of ls command.')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_FILENAME)
        return

    # Need not @parse_args because argparse can't stop interpreting options for user specified command.
    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) == 1 and argv[0] == "-h":
            self.usage()
            return

        try:
            ls = which("ls")
        except Exception:
            err("Missing `ls` command")
            return

        try:
            result = gef_execute_external([ls, "-la", "--color=always"] + argv, as_list=True)
            for line in result:
                gef_print(line)
        except Exception:
            gef_print("file/dir is not found")
        return


@register_command
class CatCommand(GenericCommand):
    """`cat` command wrapper."""
    _cmdline_ = "cat"
    _category_ = "07-a. External Command - General"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('arg', metavar='ARG', nargs='*', help='arguments of cat command.')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_FILENAME)
        return

    # Need not @parse_args because argparse can't stop interpreting options for user specified command.
    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) == 1 and argv[0] == "-h":
            self.usage()
            return

        if len(argv) == 0:
            return

        try:
            cat = which("cat")
        except Exception:
            err("Missing `cat` command")
            return

        try:
            result = gef_execute_external([cat] + argv, as_list=True)
            for line in result:
                gef_print(line.replace("\0", "\\x00"))
        except Exception:
            gef_print("file not found")
        return


@register_command
class IiCommand(GenericCommand):
    """Shortcut `x/50i $pc`."""
    _cmdline_ = "ii"
    _category_ = "01-e. Debugging Support - Assemble"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('location', metavar='LOCATION', nargs='?', type=parse_address, help='the dump start adress.')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def is_all_zero(self, addr, N):
        res = read_memory(addr, N)
        return res == b"\0" * N

    def is_all_ff(self, addr, N):
        res = read_memory(addr, N)
        return res == b"\xff" * N

    def ii(self, addr, N):
        if isinstance(addr, int):
            if N >= 50 and self.is_all_zero(addr, N):
                info("all targeted area is 0x00")
                return
            if N >= 50 and self.is_all_ff(addr, N):
                info("all targeted area is 0xff")
                return
            res = gdb.execute("x/{:d}i {:#x}".format(N, addr), to_string=True)
        else:
            res = gdb.execute("x/{:d}i {:s}".format(N, addr), to_string=True)

        for line in res.splitlines():
            line = line.rstrip()
            try:
                if is_arm32():
                    addr = int(line.split("; ")[-1], 16)
                elif is_x86_64():
                    addr = int(line.split("# ")[-1], 16)
                else:
                    raise
                val = read_int_from_memory(addr)
                line += " -> [{:#x}]".format(val)
            except Exception:
                pass
            gef_print(line)
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        N = 50
        try:
            if args.location is None:
                self.ii("$pc", N)
            else:
                self.ii(args.location, N)
        except gdb.MemoryError:
            err("Memory read error")
        return


@register_command
class ConstGrepCommand(GenericCommand):
    """Grep for lines with #define in files under /usr/include."""
    _cmdline_ = "constgrep"
    _category_ = "09-b. Misc - Search"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('pattern', metavar='GREP_PATTERN', help='filter by regex.')
    _syntax_ = parser.format_help()

    _example_ = "constgrep '__NR_*'"

    def read_normalize(self, path):
        try:
            content = open(path, "rb").read()
        except Exception:
            return None
        content = content.replace(b"\\\n", b"")
        content = content.replace(b"\t", b" ")
        content = content.replace(b"  ", b" ")
        for i in range(0x80, 0x100):
            content = content.replace(bytes([i]), b"")
        try:
            content = content.decode("UTF-8")
        except Exception:
            err("decode error: " + path)
            return None
        return content

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()

        srcdir = "/usr/include"
        pattern = re.compile(r"^#define\s+\S*" + args.pattern)
        for cur, dirs, files in os.walk(srcdir):
            for f in files:
                path = os.path.join(cur, f)
                content = self.read_normalize(path)
                if content is None:
                    continue
                for line in content.splitlines():
                    if pattern.search(line):
                        gef_print("{:s}: {:s}".format(Color.redify(path), line))
        return


@register_command
class SlubDumpCommand(GenericCommand):
    """Dump slab freelist with kenrel memory scanning."""
    # Thanks to https://github.com/PaoloMonti42/salt
    _cmdline_ = "slub-dump"
    _category_ = "08-b. Qemu-system Cooperation - Linux"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('cache_name', metavar='SLUB_CACHE_NAME', nargs='*', help='filter by specific slub cache name.')
    parser.add_argument('--cpu', type=int, help="filter by specific cpu.")
    parser.add_argument('--no-xor', action='store_true', help='skip xor to chunk->next.')
    parser.add_argument('--list', action='store_true', help='list up all slub cache names.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} kmalloc-256          # dump kmalloc-256 from all cpus\n".format(_cmdline_)
    _example_ += "{:s} kmalloc-256 --cpu 1  # dump kmalloc-256 from cpu 1\n".format(_cmdline_)
    _example_ += "{:s} kmalloc-256 --no-xor # skip xor to chunk->next\n".format(_cmdline_)
    _example_ += "{:s} --list               # list up slab cache names\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "Search flow:\n"
    _example_ += "1. get address of `__per_cpu_offset`\n"
    _example_ += "2. get address of `slab_caches`\n"
    _example_ += "3. parse member of `kmem_cache`\n"
    _example_ += "4. walk slub\n"
    _example_ += "THIS FEATURE IS EXPERIMENTAL AND HEURISTIC.\n"
    _example_ += "\n"
    _example_ += "Simplified SLUB structure:\n"
    _example_ += "                         +-kmem_cache-+         +-kmem_cache-+   +-kmem_cache-+\n"
    _example_ += "                         | cpu_slab   |---+     | cpu_slab   |   | cpu_slab   |\n"
    _example_ += "                         | obj_size   |   |     | obj_size   |   | obj_size   |\n"
    _example_ += "                         | offset     |---|-+   | offset     |   | offset     |\n"
    _example_ += "       +-slab_caches-+   | name       |   | |   | name       |   | name       |\n"
    _example_ += " ...<->| list_head   |<->| list_head  |<------->| list_head  |<->| list_head  |<-> ...\n"
    _example_ += "       +-------------+   | random     |   | |   | random     |   | random     |\n"
    _example_ += "                         +------------+   | |   +------------+   +------------+\n"
    _example_ += "                                          | |\n"
    _example_ += "    +-__per_cpu_offset-+                  | |\n"
    _example_ += "    | cpu0_offset      |---+--------------+ |\n"
    _example_ += "    | cpu1_offset      |   |                |\n"
    _example_ += "    | cpu2_offset      |   |        +-------+\n"
    _example_ += "    | ...              |   |        |\n"
    _example_ += "    +------------------+   |        |\n"
    _example_ += "                           |        |\n"
    _example_ += "      +--------------------+        |\n"
    _example_ += "      |                             |\n"
    _example_ += "      |                 +-chunk--------+  +-chunk--------+  +-chunk--------+\n"
    _example_ += "      |                 | ^         |  |  | ^            |  | ^            |\n"
    _example_ += "      v                 | |offset <-+  |  | |offset      |  | |offset      |\n"
    _example_ += "    +-kmem_cache_cpu-+  | v            |  | v            |  | v            |\n"
    _example_ += "    | freelist       |->| next         |->| next         |->| next         |->NULL\n"
    _example_ += "    |                |  |              |  |              |  |              |\n"
    _example_ += "    +----------------+  +--------------+  +--------------+  +--------------+\n"
    _example_ += "                        * next has 3 patterns.\n"
    _example_ += "                          1. next\n"
    _example_ += "                          2. xor(next, random)\n"
    _example_ += "                          3. xor(byteswap(next), random)"

    """
    struct kmem_cache {
        struct kmem_cache_cpu *cpu_slab;         // In fact, the offset value, not the pointer
        slab_flags_t flags;                      // unsigned int (+ padding 4 byte)
        unsigned long min_partial;
        unsigned int size;
        unsigned int object_size;
        struct reciprocal_value {                //
            u32 m;                               //
            u8 sh1, sh2;                         // (+ padding 2 byte)
        } reciprocal_size;                       // if kernel >= 5.9-rc1
        unsigned int offset;
        unsigned int cpu_partial;                // if CONFIG_SLUB_CPU_PARTIAL=y
        struct kmem_cache_order_objects oo;
        struct kmem_cache_order_objects max;
        struct kmem_cache_order_objects min;
        gfp_t allocflags;
        int refcount;
        void (*ctor)(void *);
        unsigned int inuse;
        unsigned int align;
        unsigned int red_left_pad;
        const char *name;
        struct list_head list; <-----> struct list_head <-----> struct list_head <-----> ...
        struct kobject kobj;                     // if CONFIG_SYSFS=y
        struct work struct kobj_remove_work;     // if CONFIG_SYSFS=y && kernel < 5.9-rc1
        struct memcg_cache_params memcg_params;  // if CONFIG_MEMCG=y && kernel < 5.9-rc1
        unsigned int max_attr_size;              // if CONFIG_MEMCG=y && kernel < 5.9-rc1
        struct kset *memcg_kset;                 // if CONFIG_MEMCG=y && CONFIG_SYSFS=y && kernel < 5.9-rc1
        unsigned long random;                    // if CONFIG_SLAB_FREELIST_HARDENED=y
        unsigned int remote_node_defrag_ratio;   // if CONFIG_NUMA=y
        unsigned int *random_seq;                // if CONFIG_SLAB_FREELIST_RANDOM=y
        struct kasan_cache kasan_info;           // if CONFIG_KASAN=y
        unsigned int useroffset;
        unsigned int usersize;
        struct kmem_cache_node *node[64];
    }

    struct kmem_cache_cpu {
        void **freelist;
        unsigned long tid;
        struct page *page;
        struct page *partial;                    // if CONFIG_SLUB_CPU_PARTIAL=y
        unsigned stat[NR_SLUB_STAT_ITEMS];       // if CONFIG_SLUB_STATS=y
    }
    """

    def init_offset(self):
        # resolve __per_cpu_offset
        self.__per_cpu_offset = KernelAddressHeuristicFinder.get_per_cpu_offset()
        if self.__per_cpu_offset is None:
            err("Failed to resolve `__per_cpu_offset`")
            return False
        else:
            info("__per_cpu_offset: {:#x}".format(self.__per_cpu_offset))

        # resolve each cpu_offset
        self.cpu_offset = [read_int_from_memory(self.__per_cpu_offset)]
        i = 1
        while True:
            off = read_int_from_memory(self.__per_cpu_offset + i * 8)
            if off == self.cpu_offset[-1]:
                self.cpu_offset = self.cpu_offset[:-1]
                break
            self.cpu_offset.append(off)
            i += 1

        # resolve slab_caches
        self.slab_caches = KernelAddressHeuristicFinder.get_slab_caches()
        if self.slab_caches is None:
            err("Failed to resolve `slab_caches`")
            return False
        else:
            info("slab_caches: {:#x}".format(self.slab_caches))

        # offsetof(kmem_cache, list)
        current = list_next = read_int_from_memory(self.slab_caches)
        for off in range(0, 0x70, current_arch.ptrsize): # backward search for the start of `struct kmem_cache`
            val = read_int_from_memory(current - off)
            # search condition 1 (rare case)
            if (is_32bit() and (val & 0x80000000)) or (is_64bit() and (val & 0x8000000000000000)):
                try:
                    b = read_memory(val, 0x100)
                    if b == b"\x00" * 0x100: # read ok, but data is none. `off` just points `struct kmem_cache->cpu_slab`
                        break
                except gdb.MemoryError: # read error, so this is not address. `off` just points `struct kmem_cache->cpu_slab`
                    break
            # search condition 2 (normal case)
            a = read_int_from_memory(current - off - current_arch.ptrsize * 1)
            b = read_int_from_memory(current - off - current_arch.ptrsize * 2)
            if (a == b == 0) or (a == b == 0xcccccccc) or (a == b == 0xcccccccccccccccc):
                # normal case: [..., 0x0, 0x0, struct kmem_cache, ...]
                # rare case: [..., 0xcccccccc, 0xcccccccc, struct kmem_cache, ...]
                # rare case: [..., 0xcccccccccccccccc, 0xcccccccccccccccc, struct kmem_caches, ...]
                break
        else:
            # not found, so try x64 specific condition
            for diff in [0, 0x40]: # 0x80 or 0x40 align
                off = (current & 0x7f) + diff
                flags = read_int_from_memory(current - off + current_arch.ptrsize)
                if is_x86_64() and (flags & 0xfffffffffbf00fff) == 0x0000000040000000: # heuristic flags value
                    break
            else:
                err("offsetof(kmem_cache, list): Not Found")
                raise
        self.kmem_cache_offset_list = off
        info("offsetof(kmem_cache, list): {:#x}".format(self.kmem_cache_offset_list))

        # offsetof(kmem_cache, name)
        self.kmem_cache_offset_name = self.kmem_cache_offset_list - current_arch.ptrsize
        info("offsetof(kmem_cache, name): {:#x}".format(self.kmem_cache_offset_name))

        # offsetof(kmem_cache, offset)
        top = list_next - self.kmem_cache_offset_list
        objsize = u32(read_memory(top + current_arch.ptrsize * 3 + 4, 4))
        maybe_recip = u32(read_memory(top + current_arch.ptrsize * 3 + 4 + 4, 4))
        if objsize < maybe_recip or (maybe_recip % 8) != 0:
            self.kmem_cache_offset_offset = current_arch.ptrsize * 3 + 4 + 4 + current_arch.ptrsize
        else:
            self.kmem_cache_offset_offset = current_arch.ptrsize * 3 + 4 + 4
        info("offsetof(kmem_cache, offset): {:#x}".format(self.kmem_cache_offset_offset))

        # offsetof(kmem_cache, random)
        if self.no_xor:
            self.kmem_cache_offset_random = None
        else:
            current = top
            for i in range(64): # walk from list for heuristic search
                val = read_int_from_memory(current + i * current_arch.ptrsize)
                if is_64bit():
                    if (val >> 48) in [0, 0xffff, 0xfffe, 0xdead, current >> 48]: # for la57: current >> 48
                        continue
                    if (val >> 32) == (val & 0xffffffff):
                        continue
                    if "{:064b}".format(val).count("1") < 6: # low entrorpy is not `random`
                        continue
                    if "{:064b}".format(val).count("1") > 64 - 6: # low entrorpy is not `random`
                        continue
                    self.kmem_cache_offset_random = i * current_arch.ptrsize
                    info("offsetof(kmem_cache, random): {:#x}".format(self.kmem_cache_offset_random))
                    break
                elif is_32bit():
                    if (val >> 8) in [0, 0xffffff]: # 0x000000**, 0xffffff** are not `random`
                        continue
                    if (val & ~0x0f0ff000) == 0x40000000: # flag are not `random`
                        continue
                    if "{:032b}".format(val).count("1") < 6: # low entrorpy is not `random`
                        continue
                    if "{:032b}".format(val).count("1") > 32 - 6: # low entrorpy is not `random`
                        continue
                    if (val & 0xf) % 4 != 0: # not aligned, it is maybe `random`
                        self.kmem_cache_offset_random = i * current_arch.ptrsize
                        info("offsetof(kmem_cache, random): {:#x}".format(self.kmem_cache_offset_random))
                        break
                    try:
                        read_int_from_memory(val) # if no error, it is not `random`
                        continue
                    except Exception:
                        self.kmem_cache_offset_random = i * current_arch.ptrsize
                        info("offsetof(kmem_cache, random): {:#x}".format(self.kmem_cache_offset_random))
                        break
            else:
                info("offsetof(kmem_cache, random): Not found")
                self.kmem_cache_offset_random = None # maybe CONFIG_SLAB_FREELIST_HARDENED=n

        # offsetof(kmem_cache, cpu_slab)
        self.kmem_cache_offset_cpu_slab = 0
        # offsetof(kmem_cache, object_size)
        self.kmem_cache_offset_object_size = current_arch.ptrsize * 3 + 4
        # offsetof(kmem_cache_cpu, freelist)
        self.kmem_cache_cpu_offset_freelist = 0
        return True

    def get_next_kmem_cache(self, addr, point_to_base=True):
        if point_to_base:
            addr += self.kmem_cache_offset_list
        return read_int_from_memory(addr) - self.kmem_cache_offset_list

    def get_objsize(self, addr):
        return u32(read_memory(addr + self.kmem_cache_offset_object_size, 4))

    def get_offset(self, addr):
        return u32(read_memory(addr + self.kmem_cache_offset_offset, 4))

    def get_name(self, addr):
        name_addr = read_int_from_memory(addr + self.kmem_cache_offset_name)
        return read_cstring_from_memory(name_addr)

    def get_random(self, addr):
        if self.kmem_cache_offset_random is None:
            return 0
        else:
            return read_int_from_memory(addr + self.kmem_cache_offset_random)

    def get_kmem_cache_cpu(self, addr, cpu):
        cpu_slab = read_int_from_memory(addr + self.kmem_cache_offset_cpu_slab)
        kmem_cache_cpu = cpu_slab + self.cpu_offset[cpu]
        if is_64bit():
            return kmem_cache_cpu & 0xffffffffffffffff
        else:
            return kmem_cache_cpu & 0xffffffff

    def get_freelist(self, addr):
        return read_int_from_memory(addr + self.kmem_cache_cpu_offset_freelist)

    def byteswap(self, x):
        if is_64bit():
            bits = 64
        else:
            bits = 32
        s = 0
        for i in range(0, bits, 8):
            s += ((x >> i) & 0xff) << (bits - (i + 8))
        return s

    def pointer_xor(self, addr, chunk, cache):
        def pattern1(addr, chunk, cache):
            return chunk ^ addr ^ cache['random']

        def pattern2(addr, chunk, cache):
            return chunk ^ self.byteswap(addr) ^ cache['random']

        if is_64bit():
            shift_bits = 48
        else:
            shift_bits = 24

        if self.swap is False:
            chunk = pattern1(addr, chunk, cache)
        elif self.swap is True:
            chunk = pattern2(addr, chunk, cache)

        elif self.swap is None: # swap type is unknown, try heuristic check
            if pattern1(addr, chunk, cache) == 0:
                chunk = pattern1(addr, chunk, cache)
                self.swap = False
            elif (chunk >> shift_bits) == (cache['random'] >> shift_bits):
                chunk = pattern1(addr, chunk, cache)
                self.swap = False
            else:
                chunk = pattern2(addr, chunk, cache)
                self.swap = True
        return chunk

    def walk_caches(self, cpu):
        current_kmem_cache = self.get_next_kmem_cache(self.slab_caches, point_to_base=False)
        self.parsed_caches = [{'name': 'slab_caches', 'next': current_kmem_cache}]
        self.swap = None

        while current_kmem_cache + self.kmem_cache_offset_list != self.slab_caches:
            new_cache = {}
            # parse member
            new_cache['address'] = current_kmem_cache
            new_cache['objsize'] = self.get_objsize(current_kmem_cache)
            new_cache['offset'] = self.get_offset(current_kmem_cache)
            new_cache['name'] = self.get_name(current_kmem_cache)
            new_cache['random'] = self.get_random(current_kmem_cache)
            # parse free_list
            new_cache['kmem_cache_cpu'] = self.get_kmem_cache_cpu(current_kmem_cache, cpu)
            chunk = self.get_freelist(new_cache['kmem_cache_cpu'])
            new_cache['freelist'] = [chunk]
            while chunk:
                try:
                    addr = chunk + new_cache['offset']
                    chunk = read_int_from_memory(addr) # get next chunk
                except Exception:
                    new_cache['freelist'].append("{:s}".format(Color.colorify("Corrupted (Memory access denied)", "bold yellow")))
                    break
                if self.kmem_cache_offset_random is not None: # fix if randomized
                    chunk = self.pointer_xor(addr, chunk, new_cache)
                if chunk % 8:
                    new_cache['freelist'].append("{:#x}: {:s}".format(chunk, Color.colorify("Corrupted (Not aligned)", "bold yellow")))
                    break
                if chunk in new_cache['freelist']:
                    new_cache['freelist'].append("{:#x}: {:s}".format(chunk, Color.colorify("Corrupted (Loop detected)", "bold yellow")))
                    break
                new_cache['freelist'].append(chunk)
            # goto next
            new_cache['next'] = current_kmem_cache = self.get_next_kmem_cache(current_kmem_cache)
            self.parsed_caches.append(new_cache)
        return

    def dump_caches(self, targets, cpu):
        gef_print('  ' + '-' * 14)
        gef_print(' | ' + ' ' * 11 + ' |')
        gef_print(' |        slab_caches @ {:#x}'.format(self.slab_caches))
        gef_print(' | ' + ' ' * 11 + ' |')
        if targets != []:
            gef_print(' | ' + ' ' * 10 + ' ...')
            gef_print(' | ' + ' ' * 11 + ' |')
        gef_print(' | ' + ' ' * 11 + ' v')
        for c in self.parsed_caches[1:]:
            if targets != [] and not c['name'] in targets:
                continue
            gef_print(' |   name: {:s}'.format(c['name']))
            gef_print(' |   kmem_cache: {:#x}'.format(c['address']))
            gef_print(' |   kmem_cache_cpu (cpu{:d}): {:#x}'.format(cpu, c['kmem_cache_cpu']))
            gef_print(' |   offset (offset to next pointer in chunk): {:#x}'.format(c['offset']))
            gef_print(' |   objsize: {:s}'.format(Color.colorify("{:#x}".format(c['objsize']), "bold pink")))
            if c['random']:
                if self.no_xor is False and self.swap is True:
                    gef_print(' |   random (xor key): {:#x} ^ byteswap(address of chunk->next)'.format(c['random']))
                else:
                    gef_print(' |   random (xor key): {:#x} ^ address of chunk->next'.format(c['random']))
            if len(c['freelist']) > 0:
                if isinstance(c['freelist'][0], str):
                    gef_print(' |   freelist:   {:s}'.format(c['freelist'][0]))
                else:
                    gef_print(' |   freelist:   {:s}'.format(Color.colorify("{:#x}".format(c['freelist'][0]), "bold yellow")))
                for f in c['freelist'][1:]:
                    if isinstance(f, str):
                        gef_print(' | ' + ' ' * 14 + '{:s}'.format(f))
                    else:
                        gef_print(' | ' + ' ' * 14 + '{:s}'.format(Color.colorify("{:#x}".format(f), "bold yellow")))
            gef_print(' |   next: {:#x}'.format(c['next']))
            gef_print(' | ' + ' ' * 11 + ' |')
            if targets != []:
                gef_print(' | ' + ' ' * 10 + ' ...')
            gef_print(' | ' + ' ' * 11 + ' |')
            gef_print(' | ' + ' ' * 11 + ' v')
        gef_print('  <' + '-' * 13)
        return

    def dump_names(self):
        gef_print(Color.colorify("Object Size              : Name", get_gef_setting("theme.table_heading")))
        for c in sorted(self.parsed_caches[1:], key=lambda x: x['objsize']):
            gef_print("{:5d} byte ({:#6x} bytes): {:s}".format(c['objsize'], c['objsize'], c['name']))
        return

    def slabwalk(self, targets):
        if self.init_offset() is False:
            err("Initialize failed")
            return

        if self.listup:
            self.walk_caches(0)
            self.dump_names()
            return

        if self.cpuN is None:
            for i in range(len(self.cpu_offset)):
                gef_print(titlify("CPU {:d}".format(i)))
                self.walk_caches(i)
                self.dump_caches(targets, i)
        else:
            if len(self.cpu_offset) > self.cpuN:
                gef_print(titlify("CPU {:d}".format(self.cpuN)))
                self.walk_caches(self.cpuN)
                self.dump_caches(targets, self.cpuN)
            else:
                err("CPU number is invalid (valid range:{:d}-{:d})".format(0, len(self.cpu_offset) - 1))
        return

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, args):
        self.dont_repeat()

        self.cpuN = args.cpu
        self.no_xor = args.no_xor
        self.listup = args.list

        info("Wait for memory scan")

        try:
            self.slabwalk(args.cache_name)
        except Exception:
            err("Memory corrupted")
        return


@register_command
class KsymaddrRemoteCommand(GenericCommand):
    """Solve kernel symbols from kallsyms table using kenrel memory scanning."""
    _cmdline_ = "ksymaddr-remote"
    _category_ = "08-b. Qemu-system Cooperation - Linux"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('keyword', metavar='KEYWORD', nargs='*', help='filter by specific symbol name.')
    parser.add_argument('--print-all', action='store_true', help='print all symbols found.')
    parser.add_argument('--head', metavar='N', type=int, default=-1, help="filter by first N hit.")
    parser.add_argument('--exact', action='store_true', help='use exact match.')
    parser.add_argument('--meta', action='store_true', help='print meta data for debug.')
    parser.add_argument('--silent', action='store_true', help='enable quiet mode.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} --print-all                      # print all symbols found\n".format(_cmdline_)
    _example_ += "{:s} cred --head 30                   # print symbols included `cred` with only first 30 hit\n".format(_cmdline_)
    _example_ += "{:s} cred --silent                    # print symbols included `cred` with quiet mode\n".format(_cmdline_)
    _example_ += "{:s} commit_creds prepare_kernel_cred # OR search\n".format(_cmdline_)
    _example_ += "Search flow:\n"
    _example_ += "1. get address of kernel_base\n"
    _example_ += "2. get address of kernel_base_rodata\n"
    _example_ += "3. get address of kallsyms_relative_base\n"
    _example_ += "4. get address of kallsyms_names\n"
    _example_ += "5. get address of kallsyms_offsets\n"
    _example_ += "6. get address of kallsyms_token_table\n"
    _example_ += "7. get address of kallsyms_token_index\n"
    _example_ += "8. walk kallsyms\n"
    _example_ += "THIS FEATURE IS EXPERIMENTAL AND HEURISTIC."

    def __init__(self, *args, **kwargs):
        super().__init__()
        self.initialized = False
        self.maps = None
        self.kallsyms = []
        return

    def expand_symbol(self, off):
        data = off
        len_ = self.kallsyms_names[data]

        data += 1

        symbol = ""
        skipped_first = False
        off = len_ + 1
        while len_:
            tptr = self.kallsyms_token_index[self.kallsyms_names[data]]

            data += 1
            len_ -= 1

            while True:
                c = self.kallsyms_token_table[tptr]
                if c == 0:
                    break
                if skipped_first:
                    symbol += chr(c)
                else:
                    skipped_first = True
                tptr += 1
        return off, symbol


    def kallsyms_sym_address(self, idx):
        if self.kallsyms_relative_base is None:
            relative_base = 0
        else:
            relative_base = self.kallsyms_relative_base

        val = self.kallsyms_offsets[idx]
        if not self.CONFIG_KALLSYMS_ABSOLUTE_PERCPU:
            return relative_base + val
        if val >= 0:
            return val
        else:
            return relative_base - 1 - val

    def kallsyms_get_symbol_type(self, off):
        idx1 = self.kallsyms_names[off + 1]
        idx2 = self.kallsyms_token_index[idx1]
        typ = self.kallsyms_token_table[idx2]
        return chr(typ)

    def resolve_kallsyms(self):
        if self.kallsyms != []: # resolved already
            return
        off = 0

        for i in range(self.kallsyms_num_syms):
            print(i, end="\r") 
            offdiff, symbol = self.expand_symbol(off)
            typ = self.kallsyms_get_symbol_type(off)
            off += offdiff
            addr = self.kallsyms_sym_address(i)
            self.kallsyms.append([addr, symbol, typ])
        return

    def print_kallsyms(self, keywords):
        if is_32bit():
            fmt = "{:#010x} {:s} {:s}"
        else:
            fmt = "{:#018x} {:s} {:s}"
        print_count = 0
        for addr, symbol, typ in self.kallsyms:
            if print_count == self.head:
                break
            if self.print_all:
                gef_print(fmt.format(addr, typ, symbol))
                print_count += 1
            else:
                for k in keywords:
                    text = fmt.format(addr, typ, symbol)
                    if self.exact and k == symbol:
                        gef_print(text)
                        print_count += 1
                        break
                    elif not self.exact and k in text:
                        gef_print(text)
                        print_count += 1
                        break
        return

    # Initialize variables in different ways, depending on the situation.
    #
    # The variables need to find are as follows.
    # 1. kallsyms_relative_base
    # 2. kallsyms_num_syms
    # 3. kallsyms_names
    # 4. CONFIG_KALLSYMS_ABSOLUTE_PERCPU is enabled or not
    # 5. kallsyms_offsets
    # 6. kallsyms_markers
    # 7. kallsyms_token_table
    # 8. kallsyms_token_index
    #
    # The method for searching the above variables is different for 64bit / 32bit.
    # It also depends on whether each variable in memory has a large padding (called sparse) or not (called normal).
    #
    # Variables to use
    #   self.kbase:         address of kernel .text
    #   self.krobase:       address of kernel .rodata
    #   self.RO_REGION:     data of .rodata; bytes([0xef, 0xbe, 0xad, 0xde...])
    #   self.RO_REGION_u32: data of .rodata; [0xdeadbeef, ...]
    #   self.RO_REGION_u64: data of .rodata; [0x00000000deadbeef, ...]

    # 32bit is very complicated. 64bit is simple
    def initialize32_kallsyms_relative_base(self):
        # 1. find kbase from rodata
        if is_x86_32():
            # recent kernel (buildroot:5.4.58, debian11.3:5.10.0-13)
            for idx, tmp in enumerate(self.RO_REGION_u32[:-1]):
                if tmp & 0xfff: # should be aligned
                    continue
                if (tmp & 0xffff0000) != (self.kbase & 0xffff0000): # holds around kbase
                    continue
                if self.RO_REGION_u32[idx + 1] > 0x4ffff: # next address is kallsyms_num_syms. too large number is fail
                    continue
                if 0 < self.RO_REGION_u32[idx + 1] < 0x100 : # next address is kallsyms_num_syms. too small number is fail
                    continue
                self.kallsyms_relative_base = tmp
                self.kallsyms_relative_base_off = idx
                self.kallsyms_relative_base_addr = self.krobase + self.kallsyms_relative_base_off * 4
                return

            # i386 (ooofs:4.4.223)
            for i, val in enumerate(self.RO_REGION_u32[::-1]): # use backward search because if found multiple then select the last one
                if val == self.kbase:
                    pos = len(self.RO_REGION_u32) - i - 1
                    # found contiguous, go prev as possilbe
                    while self.RO_REGION_u32[pos] == self.RO_REGION_u32[pos - 1]:
                        pos -= 1
                    self.kallsyms_relative_base = self.kbase
                    self.kallsyms_relative_base_off = pos
                    self.kallsyms_relative_base_addr = self.krobase + self.kallsyms_relative_base_off * 4
                    return

        elif is_arm32():
            # recent kernel (debian 11.3:5.10.0-14)
            for idx, tmp in enumerate(self.RO_REGION_u32[:-1]):
                if tmp & 0xfff: # should be aligned
                    continue
                if (tmp & 0xffff0000) != (self.kbase & 0xffff0000): # holds around kbase
                    continue
                if self.RO_REGION_u32[idx + 1] > 0x4ffff: # next address is kallsyms_num_syms. too large number is fail
                    continue
                if 0 < self.RO_REGION_u32[idx + 1] < 0x100 : # next address is kallsyms_num_syms. too small number is fail
                    continue
                self.kallsyms_relative_base = tmp
                self.kallsyms_relative_base_off = idx
                self.kallsyms_relative_base_addr = self.krobase + self.kallsyms_relative_base_off * 4
                return

            # ARM has specific relative_base (buildroot:5.4.58, debian10.4:4.19.0-9)
            for i in range(4):
                try:
                    kbase_diff = -(0x100000 * i + 0xf8000)
                    self.kallsyms_relative_base = self.kbase + kbase_diff
                    self.kallsyms_relative_base_off = self.RO_REGION_u32.index(self.kallsyms_relative_base)
                    self.kallsyms_relative_base_addr = self.krobase + self.kallsyms_relative_base_off * 4
                    if self.meta:
                        info("kbase difference is {:#x}".format(kbase_diff))
                    return
                except Exception:
                    pass

        # not found
        if not self.silent:
            err("Failed to identified kallsyms_relative_base (not found kernel_base in kernel_robase)")
        self.kallsyms_relative_base = None
        self.kallsyms_relative_base_off = None
        self.kallsyms_relative_base_addr = None
        return

    def initialize32_sparse_kallsyms_num_syms(self):
        # 1. next to it (16 bytes aligned)
        self.kallsyms_num_syms_addr = self.kallsyms_relative_base_addr + 0x10
        self.kallsyms_num_syms_off = self.kallsyms_relative_base_off + 4
        self.kallsyms_num_syms = self.RO_REGION_u32[self.kallsyms_num_syms_off]
        return

    def initialize32_sparse_kallsyms_names(self):
        # 1. next to it (16 bytes aligned)
        self.kallsyms_names_addr = self.kallsyms_num_syms_addr + 0x10
        self.kallsyms_names_off = self.kallsyms_num_syms_off + 4
        return

    def initialize32_sparse_CONFIG_KALLSYMS_ABSOLUTE_PERCPU(self):
        # 1. walk to prev and found non-zero value
        # 2. if the MSB of the element is on, then it is pattern 4 at kallsyms_sym_address() in root/kernel/kallsyms.c.
        #    so not pattern 2, therefore, CONFIG_KALLSYMS_ABSOLUTE_PERCPU = True
        pos = self.kallsyms_relative_base_off - 4
        while self.RO_REGION_u32[pos] == 0:
            pos -= 1
        self.CONFIG_KALLSYMS_ABSOLUTE_PERCPU = (((self.RO_REGION_u32[pos] >> 31) & 1) == 1)
        return

    def initialize32_sparse_kallsyms_offsets(self):
        # 1. calc
        if self.kallsyms_relative_base is None:
            self.kallsyms_offsets_addr = self.kallsyms_num_syms_addr - self.kallsyms_num_syms * 4
        else:
            self.kallsyms_offsets_addr = self.kallsyms_relative_base_addr - self.kallsyms_num_syms * 4
        self.kallsyms_offsets_addr &= ~0xf # 16 bytes aligned
        return

    def initialize32_sparse_kallsyms_markers(self):
        # 1. walk to next until zero value
        # 2. align
        pos = self.kallsyms_names_off
        while True:
            if self.RO_REGION_u32[pos] == 0 and pos % 4 == 0:
                self.kallsyms_markers_off = pos
                self.kallsyms_markers_addr = self.krobase + pos * 4
                break
            pos += 1
        return

    def initialize32_sparse_kallsyms_token_table(self):
        # 1. walk to next until zero value
        # 2. align
        pos = self.kallsyms_markers_off
        while True: # use pos above
            v = self.RO_REGION_u32[pos]
            if v & 0xff000000 > 0 or (self.RO_REGION_u32[pos - 1] > 0 and self.RO_REGION_u32[pos - 1] * 4 < v):
                self.kallsyms_token_table_addr = self.krobase + pos * 4
                break
            pos += 4
        return

    def initialize32_sparse_kallsyms_token_index(self):
        # 1. walk to next until contiguous zero value. it is end of marker of kallsyms_token_table
        # 2. align
        pos = self.kallsyms_token_table_addr - self.krobase
        while True:
            if self.RO_REGION[pos] == 0 and self.RO_REGION[pos + 1] == 0:
                pos += 1
                while pos % 16: # need align
                    pos += 1
                self.kallsyms_token_index_addr = self.krobase + pos
                break
            pos += 1
        return

    def initialize32_normal_kallsyms_num_syms(self):
        # 1. next to it
        self.kallsyms_num_syms_addr = self.kallsyms_relative_base_addr + 0x4
        self.kallsyms_num_syms_off = self.kallsyms_relative_base_off + 1
        self.kallsyms_num_syms = self.RO_REGION_u32[self.kallsyms_num_syms_off]
        return

    def initialize32_normal_kallsyms_names(self):
        # 1. next to it
        self.kallsyms_names_addr = self.kallsyms_num_syms_addr + 0x4
        self.kallsyms_names_off = self.kallsyms_num_syms_off + 1
        return

    def initialize32_normal_CONFIG_KALLSYMS_ABSOLUTE_PERCPU(self):
        # 1. prev to it
        # 2. if the MSB of the element is on, then it is pattern 4 at kallsyms_sym_address() in root/kernel/kallsyms.c.
        #    so not pattern 2, therefore, CONFIG_KALLSYMS_ABSOLUTE_PERCPU = True
        pos = self.kallsyms_relative_base_off - 4
        self.CONFIG_KALLSYMS_ABSOLUTE_PERCPU = (((self.RO_REGION_u32[pos] >> 31) & 1) == 1)
        return

    def initialize32_normal_kallsyms_offsets(self):
        # 1. calc
        if self.kallsyms_relative_base is None:
            self.kallsyms_offsets_addr = self.kallsyms_num_syms_addr - self.kallsyms_num_syms * 4
        else:
            self.kallsyms_offsets_addr = self.kallsyms_relative_base_addr - self.kallsyms_num_syms * 4
        return

    def initialize32_normal_kallsyms_markers(self):
        # 1. walk to next until zero value
        # 2. align
        pos = self.kallsyms_names_off
        while True:
            if self.RO_REGION_u32[pos] == 0: # search kallsyms_markers
                self.kallsyms_markers_off = pos
                self.kallsyms_markers_addr = self.krobase + pos * 4 # need not align
                break
            pos += 1
        return

    def initialize32_normal_kallsyms_token_table(self):
        # 1. walk to next until specific value
        # 2. align
        pos = self.kallsyms_markers_off
        pos += 1 # skip first zero
        while True:
            v = self.RO_REGION_u32[pos]
            """
            0xcc7c3ee0:     0x00069468      0x0006a096      0x0006aebe      0x0006baaa
            0xcc7c3ef0:     0x0006c5b4      0x0006d186      0x0006dc59     [0x005f7366] <-- begining of kallsyms_token_table
            0xcc7c3f00:     0x00657374      0x61007474      0x7400646e      0x006e6f69      (heuristic: prev_value * 4 < this_value)
            0xcc7c3f10:     0x66006f66      0x5f656572      0x65735f00      0x656d0074
            0xcc7c3f20:     0x6474006d      0x005f7200      0x74006354      0x63005f6f
            """
            if v == 0 or (v & 0xff000000) > 0 or (self.RO_REGION_u32[pos - 1] > 0 and self.RO_REGION_u32[pos - 1] * 4 < v) :
                self.kallsyms_token_table_addr = self.krobase + pos * 4 # need not align
                break
            pos += 1
        return

    def initialize32_normal_kallsyms_token_index(self):
        # 1. walk to next until contiguous zero value. it is end of marker of kallsyms_token_table
        # 2. align
        pos = self.kallsyms_token_table_addr - self.krobase
        while True:
            if self.RO_REGION[pos] == 0 and self.RO_REGION[pos + 1] == 0:
                pos += 1
                while pos % 4: # need align
                    pos += 1
                self.kallsyms_token_index_addr = self.krobase + pos
                break
            pos += 1
        return

    def initialize64_kallsyms_relative_base(self):
        # 1. find kbase from rodata
        for idx, tmp in enumerate(self.RO_REGION_u64[:-1]):
            if tmp & 0xffff: # kbase should be aligned
                continue
            if (tmp & 0xfffffffffff00000) != (self.kbase & 0xfffffffffff00000): # the candidate holds around kbase (usually just kbase)
                continue
            if self.RO_REGION_u64[idx + 1] > 0x4ffff: # next element is kallsyms_num_syms. too large number is fail
                continue
            self.kallsyms_relative_base = tmp
            self.kallsyms_relative_base_off = idx
            self.kallsyms_relative_base_addr = self.krobase + self.kallsyms_relative_base_off * 8
            return
        if not self.silent:
            err("Failed to identified kallsyms_relative_base (not found kernel_base in kernel_robase)")
        self.kallsyms_relative_base = None
        self.kallsyms_relative_base_off = None
        self.kallsyms_relative_base_addr = None
        return

    def initialize64_sparse_kallsyms_num_syms(self):
        # 1. next to it (256 bytes aligned)
        self.kallsyms_num_syms_addr = self.kallsyms_relative_base_addr + 0x100
        self.kallsyms_num_syms_off = self.kallsyms_relative_base_off + 32
        self.kallsyms_num_syms = self.RO_REGION_u64[self.kallsyms_num_syms_off]
        return

    def initialize64_sparse_kallsyms_names(self):
        # 1. next to it (256 bytes aligned)
        self.kallsyms_names_addr = self.kallsyms_num_syms_addr + 0x100
        self.kallsyms_names_off = self.kallsyms_num_syms_off + 32
        return

    def initialize64_sparse_CONFIG_KALLSYMS_ABSOLUTE_PERCPU(self):
        # 1. walk to prev and found non-zero value
        # 2. if the MSB of the element is on, then it is pattern 4 at kallsyms_sym_address() in root/kernel/kallsyms.c.
        #    so not pattern 2, therefore, CONFIG_KALLSYMS_ABSOLUTE_PERCPU = True
        # pos = self.kallsyms_relative_base_off * 2 # from u64 pos to u32 pos
        pos = self.kallsyms_relative_base_off * 2 - 4 # from u64 pos to u32 pos
        while self.RO_REGION_u32[pos] == 0:
            pos -= 1
        self.CONFIG_KALLSYMS_ABSOLUTE_PERCPU = (((self.RO_REGION_u32[pos] >> 31) & 1) == 1)
        return

    def initialize64_sparse_kallsyms_offsets(self):
        # 1. calc
        if self.kallsyms_relative_base is None:
            self.kallsyms_offsets_addr = self.kallsyms_num_syms_addr - self.kallsyms_num_syms * 8
        else:
            self.kallsyms_offsets_addr = self.kallsyms_relative_base_addr - self.kallsyms_num_syms * 4
        self.kallsyms_offsets_addr &= ~0xff # 256 bytes aligned
        return

    def initialize64_sparse_kallsyms_markers(self):
        # 1. walk to next until zero value
        # 2. align
        pos = self.kallsyms_names_off
        while True:
            if self.RO_REGION_u64[pos] == 0 and pos % 32 == 0:
                self.kallsyms_markers_off = pos
                self.kallsyms_markers_addr = self.krobase + pos * 8
                break
            pos += 1
        return

    def initialize64_sparse_kallsyms_token_table(self):
        # 1. walk to next until zero value
        # 2. align
        pos = self.kallsyms_markers_off
        while True: # use pos above
            v = self.RO_REGION_u64[pos]
            if v & 0xffffffffff000000 > 0 or (self.RO_REGION_u64[pos - 1] > 0 and self.RO_REGION_u64[pos - 1] * 4 < v):
                self.kallsyms_token_table_addr = self.krobase + pos * 8
                break
            pos += 32
        return

    def initialize64_sparse_kallsyms_token_index(self):
        # 1. walk to next until contiguous zero value. it is end of marker of kallsyms_token_table
        # 2. align
        pos = self.kallsyms_token_table_addr - self.krobase
        while True:
            if self.RO_REGION[pos] == 0 and self.RO_REGION[pos + 1] == 0:
                pos += 1
                while pos % 256: # need align
                    pos += 1
                self.kallsyms_token_index_addr = self.krobase + pos
                break
            pos += 1
        return

    def initialize64_normal_kallsyms_num_syms(self):
        # 1. next to it
        self.kallsyms_num_syms_addr = self.kallsyms_relative_base_addr + 0x8
        self.kallsyms_num_syms_off = self.kallsyms_relative_base_off + 1
        self.kallsyms_num_syms = self.RO_REGION_u64[self.kallsyms_num_syms_off]

        return

    def initialize64_normal_kallsyms_names(self):
        # 1. next to it
        self.kallsyms_names_addr = self.kallsyms_num_syms_addr + 0x8
        self.kallsyms_names_off = self.kallsyms_num_syms_off + 1
        return

    def initialize64_normal_CONFIG_KALLSYMS_ABSOLUTE_PERCPU(self):
        # 1. prev to it
        # 2. if the MSB of the element is on, then it is pattern 4 at kallsyms_sym_address() in root/kernel/kallsyms.c.
        #    so not pattern 2, therefore, CONFIG_KALLSYMS_ABSOLUTE_PERCPU = True
        # pos = self.kallsyms_relative_base_off * 2 # from u64 pos to u32 pos
        pos = self.kallsyms_relative_base_off * 2 - 4 # from u64 pos to u32 pos
        self.CONFIG_KALLSYMS_ABSOLUTE_PERCPU = (((self.RO_REGION_u32[pos] >> 31) & 1) == 1)

        return

    def initialize64_normal_kallsyms_offsets(self):
        # 1. calc
        # 2. align
        if self.kallsyms_relative_base is None:
            self.kallsyms_offsets_addr = self.kallsyms_num_syms_addr - self.kallsyms_num_syms * 8
        else:
            self.kallsyms_offsets_addr = self.kallsyms_relative_base_addr - self.kallsyms_num_syms * 4  
        self.kallsyms_offsets_addr &= ~0x7
        return

    def initialize64_normal_kallsyms_markers(self):
        # 1. walk to next until zero value
        # 2. align
        pos = self.kallsyms_names_off * 2 - 4 # needs twice to use RO_REGION_u32
        while True:
            if self.RO_REGION_u32[pos] == 0: # search kallsyms_markers
                while pos % 2: # need align
                    pos += 1
                self.kallsyms_markers_off = pos
                self.kallsyms_markers_addr = self.krobase + pos * 4
                break
            pos += 2
        return

    def initialize64_normal_kallsyms_token_table(self):
        # 1. check array type is u32 or u64
        # 2. walk to next until specific value
        # 3. align
        pos = self.kallsyms_markers_off
        if self.RO_REGION_u32[pos] == 0 and self.RO_REGION_u32[pos + 1] == 0: # u64 mode
            if self.meta:
                info("u64 mode at initialize64_normal_kallsyms_token_table")
            """
                0xffffffff987aaf80:     0x0000000000086329      0x000000000008724d
                0xffffffff987aaf90:     0x3131323038656565 *    0x6572007365725f00
                0xffffffff987aafa0:     0x65735f0074736967      0x6c6261005f360074
                0xffffffff987aafb0:     0x656565006c660065      0x2e00656b00647400
            """
            pos = pos // 2 + 1 # skip first zero
            while True:
                if self.RO_REGION_u64[pos] == 0 or (self.RO_REGION_u64[pos] & 0xffffffffff000000) > 0:
                    self.kallsyms_token_table_addr = self.krobase + pos * 8
                    break
                pos += 1
        else: # u32 mode
            if self.meta:
                info("u32 mode at initialize64_normal_kallsyms_token_table")
            """
            [pattern 1 krce]
                0xffffffffbd101840:     0x000595e8      0x0005a026      0x0005a966      0x00000000
                0xffffffffbd101850:     0x00686361 *    0x00706572      0x63007674      0x00636568
                0xffffffffbd101860:     0x7465735f      0x34367800      0x0079735f      0x00343678
                0xffffffffbd101870:     0x00726f63      0x66006354      0x6900726f      0x74005f63
            [pattern 2 poe]
                0xffffffff9a866400:     0x0010c631      0x0010d091      0x0010db64      0x0010e677
                0xffffffff9a866410:     0x0010f0f2      0x00000000      0x00646e61 *    0x61727474
                0xffffffff9a866420:     0x005f6563      0x69676572      0x72657473      0x6f74005f
                0xffffffff9a866430:     0x332e005f      0x6e696600      0x74786500      0x78005f34
            [pattern 3 own buildroot]
                0xffffffff9d0e9dd0:     0x000506f3      0x00051205      0x00051dfc      0x000529fc
                0xffffffff9d0e9de0:     0x0005354d      0x00053fdc      0x00054a51      0x000554e1
                0xffffffff9d0e9df0:     0x6c006563 *    0x62740061      0x00767400      0x7465735f
                0xffffffff9d0e9e00:     0x666e6900      0x676e6900      0x006c6f00      0x00726f66
            [pattern 4 kone_gadget]
                0xffffffff81cfbff0:     0x00056381      0x00056f2b      0x00057a59      0x00058451
                0xffffffff81cfc000:     0x00058ebd      0x0005994f      0x00686361 *    0x7465735f
                0xffffffff81cfc010:     0x65686300      0x6f630063      0x76740072      0x70657200
                0xffffffff81cfc020:     0x726f6600      0x34367800      0x0079735f      0x00343678
            """
            # pos += 1 # skip first zero
            # pos += 2 # we want to use (pos, pos-1, pos-2), so avoid bug
            pos_u8 = pos * 4
            probs = 0
            is_null_byte = False
            len_symbol = 0
            num_symbols = 0
            symbol_name = ""

            while True:
                for i in range(4):
                    pos_u8 += 1


                    if self.RO_REGION[pos_u8] in [97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 95, 46, 63]:
                        probs += 1
                        len_symbol += 1
                        is_null_byte = False
                        symbol_name += chr(self.RO_REGION[pos_u8])
                    elif is_null_byte == False and self.RO_REGION[pos_u8] == 0 and probs != 0:
                        is_null_byte = True
                        probs += 1
                        num_symbols += 1
                        symbol_name = ""
                    else:
                        is_null_byte = True
                        probs = 0
                        num_symbols = 0
                        symbol_name = ""

                    if num_symbols > 100:
                        offset = (pos_u8-probs+1) & ~0x7
                        self.kallsyms_token_table_addr = self.krobase + offset
                        return

                diff1 = self.RO_REGION_u32[pos - 1] - self.RO_REGION_u32[pos - 2]
                diff2 = self.RO_REGION_u32[pos - 0] - self.RO_REGION_u32[pos - 1]

                # if diff1 * 100 < diff2: # pattern 3, 4
                #     self.kallsyms_token_table_addr = self.krobase + pos * 4
                #     # break

                # pos += 1
        return

    def initialize64_normal_kallsyms_token_index(self):
        # 1. walk to next until contiguous zero value. it is end of marker of kallsyms_token_table
        # 2. align
        pos = self.kallsyms_token_table_addr - self.krobase
        while True:
            if self.RO_REGION[pos] == 0 and self.RO_REGION[pos + 1] == 0:
                pos += 1
                while pos % 8: # need align
                    pos += 1
                self.kallsyms_token_index_addr = self.krobase + pos
                break
            pos += 1
        return

    def initialize32_kallsyms_num_syms_2(self):
        # 1. walk next
        # because used aboslute value, similar addresses are lined up
        # 0xc1940888:     0xc1000000      0xc1000000      0xc10000bc      0xc10000cc
        # 0xc1940898:     0xc10000ed      0xc1000165      0xc10001e7      0xc1000239
        # ...
        # 0xc198f0ac:     0xc1e85000      0xc1e95000      0xc1e9b000      0xc1e9b000
        # 0xc198f0bc:     0x00013a0d <- kallsyms_num_syms_addr
        pos = self.kallsyms_relative_base_off
        while True:
            val = self.RO_REGION_u32[pos]
            if val != 0 and (val >> 20) == 0:
                self.kallsyms_num_syms_addr = self.krobase + pos * 4
                self.kallsyms_num_syms_off = pos
                self.kallsyms_num_syms = val
                break
            pos += 1
        return

    def initialize64_kallsyms_num_syms_2(self):
        # 1. walk next
        # because used aboslute value, similar addresses are lined up
        pos = self.kallsyms_relative_base_off
        while True:
            val = self.RO_REGION_u64[pos]
            if val != 0 and (val >> 32) == 0:
                self.kallsyms_num_syms_addr = self.krobase + pos * 8
                self.kallsyms_num_syms_off = pos
                self.kallsyms_num_syms = val
                break
            pos += 1
        return

    def initialize32(self):
        self.RO_REGION = read_memory(self.krobase, self.krobase_size)
        self.RO_REGION_u32 = [u32(self.RO_REGION[i:i + 4]) for i in range(0, len(self.RO_REGION), 4)]
        self.initialize32_kallsyms_relative_base()

        if self.kallsyms_relative_base_off is None:
            return None

        # rare case (maybe no kASLR kernel)
        if self.RO_REGION_u32[self.kallsyms_relative_base_off + 1] == self.RO_REGION_u32[self.kallsyms_relative_base_off]:
            self.initialize32_kallsyms_num_syms_2() # common to sparse and normal
            # do not use kallsyms_relative_base, use absolute value
            self.kallsyms_relative_base = None
            if self.RO_REGION_u32[self.kallsyms_num_syms_off + 1] == 0: # sparse mode (rare case)
                if self.meta:
                    info("does not detect relative_base. treat as sparse mode (rare case)")
                # all variables placed as 16 bytes aligned
                self.initialize32_sparse_kallsyms_names()
                self.initialize32_sparse_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
                self.initialize32_sparse_kallsyms_offsets()
                self.initialize32_sparse_kallsyms_markers()
                self.initialize32_sparse_kallsyms_token_table()
                self.initialize32_sparse_kallsyms_token_index()
            else: # normal mode (rare case)
                if self.meta:
                    info("does not detect relative_base, treat as normal mode (rare case)")
                self.initialize32_normal_kallsyms_names()
                self.initialize32_normal_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
                self.initialize32_normal_kallsyms_offsets()
                self.initialize32_normal_kallsyms_markers()
                self.initialize32_normal_kallsyms_token_table()
                self.initialize32_normal_kallsyms_token_index()
        elif self.RO_REGION_u32[self.kallsyms_relative_base_off + 1] == 0: # sparse mode
            if self.meta:
                info("detect relative_base, treat as sparse mode")
            # all variables placed as 16 bytes aligned
            self.initialize32_sparse_kallsyms_num_syms()
            self.initialize32_sparse_kallsyms_names()
            self.initialize32_sparse_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
            self.initialize32_sparse_kallsyms_offsets()
            self.initialize32_sparse_kallsyms_markers()
            self.initialize32_sparse_kallsyms_token_table()
            self.initialize32_sparse_kallsyms_token_index()
        else: # normal mode
            if self.meta:
                info("detect relative_base, treat as normal mode")
            self.initialize32_normal_kallsyms_num_syms()
            self.initialize32_normal_kallsyms_names()
            self.initialize32_normal_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
            self.initialize32_normal_kallsyms_offsets()
            self.initialize32_normal_kallsyms_markers()
            self.initialize32_normal_kallsyms_token_table()
            self.initialize32_normal_kallsyms_token_index()
        return True

    def initialize64(self):
        self.RO_REGION = read_memory(self.krobase, self.krobase_size)
        self.RO_REGION_u64 = [u64(self.RO_REGION[i:i + 8]) for i in range(0, len(self.RO_REGION), 8)]
        self.RO_REGION_u32 = [u32(self.RO_REGION[i:i + 4]) for i in range(0, len(self.RO_REGION), 4)]
        self.initialize64_kallsyms_relative_base()

        if self.RO_REGION_u64[self.kallsyms_relative_base_off + 1] == self.RO_REGION_u64[self.kallsyms_relative_base_off]: # rare case
            self.initialize64_kallsyms_num_syms_2() # common to sparse and normal
            # do not use kallsyms_relative_base, use absolute value
            self.kallsyms_relative_base = None
            if self.RO_REGION_u64[self.kallsyms_num_syms_off + 1] == 0: # sparse mode (rare case)
                if self.meta:
                    info("does not detect relative_base, treat as sparse mode (rare case)")
                # all variables placed as 256 bytes aligned
                self.initialize64_sparse_kallsyms_names()
                self.initialize64_sparse_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
                self.initialize64_sparse_kallsyms_offsets()
                self.initialize64_sparse_kallsyms_markers()
                self.initialize64_sparse_kallsyms_token_table()
                self.initialize64_sparse_kallsyms_token_index()
            else: # normal mode (rare case)
                if self.meta:
                    info("does not detect relative_base, treat as normal mode (rare case)")
                self.initialize64_normal_kallsyms_names()
                self.initialize64_normal_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
                self.initialize64_normal_kallsyms_offsets()
                self.initialize64_normal_kallsyms_markers()
                self.initialize64_normal_kallsyms_token_table()
                self.initialize64_normal_kallsyms_token_index()
        elif self.RO_REGION_u64[self.kallsyms_relative_base_off + 1] == 0: # sparse mode
            if self.meta:
                info("detect relative_base, treat as sparse mode")
            # all variables placed as 256 bytes aligned
            self.initialize64_sparse_kallsyms_num_syms()
            self.initialize64_sparse_kallsyms_names()
            self.initialize64_sparse_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
            self.initialize64_sparse_kallsyms_offsets()
            self.initialize64_sparse_kallsyms_markers()
            self.initialize64_sparse_kallsyms_token_table()
            self.initialize64_sparse_kallsyms_token_index()
        else: # normal mode
            if self.meta:
                info("detect relative_base, treat as normal mode")
            self.initialize64_normal_kallsyms_num_syms()
            self.initialize64_normal_kallsyms_names()
            self.initialize64_normal_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
            self.initialize64_normal_kallsyms_offsets()
            self.initialize64_normal_kallsyms_markers()
            self.initialize64_normal_kallsyms_token_table()
            self.initialize64_normal_kallsyms_token_index()
        return True

    def print_meta(self, force=False):
        if self.meta or force:
            try:
                info("kernel_base:            {:#x}".format(self.kbase)) # to search kallsyms_*
                info("kernel_robase:          {:#x}".format(self.krobase)) # to search kallsyms_*
                if self.kallsyms_relative_base:
                    info("kallsyms_relative_base: {:#x}: {:#x}".format(self.kallsyms_relative_base_addr, self.kallsyms_relative_base))
                    info("kallsyms_num_syms:      {:#x}: {:#x}".format(self.kallsyms_num_syms_addr, self.kallsyms_num_syms))
                    gdb.execute("x/4x{} {}".format(["w", "g"][is_64bit()], self.kallsyms_relative_base_addr))
                else:
                    info("kallsyms_relative_base: None")
                    info("kallsyms_num_syms:      {:#x}: {:#x}".format(self.kallsyms_num_syms_addr, self.kallsyms_num_syms))
                    gdb.execute("x/4x{} {}".format(["w", "g"][is_64bit()], self.kallsyms_num_syms_addr))
                info("kallsyms_names          {:#x}".format(self.kallsyms_names_addr)) # to lookup symbol
                gdb.execute("x/8x{} {}".format(["w", "g"][is_64bit()], self.kallsyms_names_addr - 0x10))
                info("CONFIG_KALLSYMS_ABSOLUTE_PERCPU: {:d}".format(self.CONFIG_KALLSYMS_ABSOLUTE_PERCPU)) # to calculate address
                info("kallsyms_offsets:       {:#x}".format(self.kallsyms_offsets_addr)) # to lookup symbol
                gdb.execute("x/8x{} {}".format(["w", "g"][is_64bit()], self.kallsyms_offsets_addr - 0x10))
                info("kallsyms_markers:       {:#x}".format(self.kallsyms_markers_addr)) # to search kallsyms_*
                gdb.execute("x/8x{} {}".format(["w", "g"][is_64bit()], self.kallsyms_markers_addr - 0x10))
                info("kallsyms_token_table:   {:#x}".format(self.kallsyms_token_table_addr)) # to calculate address
                gdb.execute("x/8x{} {}".format(["w", "g"][is_64bit()], self.kallsyms_token_table_addr - 0x10))
                info("kallsyms_token_index:   {:#x}".format(self.kallsyms_token_index_addr)) # to calculate address
                gdb.execute("x/8x{} {}".format(["w", "g"][is_64bit()], self.kallsyms_token_index_addr - 0x10))
            except Exception:
                pass
        return

    def initialize(self):
        if self.initialized:
            self.print_meta()
            return True
        # get kernel memory maps
        if not self.silent:
            info("Wait for memory scan")
        kinfo = KernelbaseCommand.get_kernel_base()
        if kinfo.has_none:
            err("Failed to resolve")
            return None
        self.maps = kinfo.maps
        self.kbase = kinfo.kbase
        self.kbase_size = kinfo.kbase_size
        self.krobase = kinfo.krobase
        self.krobase_size = kinfo.krobase_size
        # resolve some address
        if is_32bit():
            res = self.initialize32()
        elif is_64bit():
            res = self.initialize64()

        if res:
            # prepare each byte array
            if self.kallsyms_relative_base is None:
                r = self.RO_REGION[self.kallsyms_offsets_addr - self.krobase: self.kallsyms_num_syms_addr - self.krobase]
                if is_64bit():
                    self.kallsyms_offsets = [u64(r[i:i + 8]) for i in range(0, len(r), 8)] # unsigned 64bit
                else:
                    self.kallsyms_offsets = [u32(r[i:i + 4]) for i in range(0, len(r), 4)] # unsigned 32bit
            else:
                r = self.RO_REGION[self.kallsyms_offsets_addr - self.krobase: self.kallsyms_relative_base_addr - self.krobase]
                self.kallsyms_offsets = [u32(r[i:i + 4], s=True) for i in range(0, len(r), 4)] # signed 32bit

            r = self.RO_REGION[self.kallsyms_names_addr - self.krobase: self.kallsyms_markers_addr - self.krobase]
            self.kallsyms_names = [u8(r[i:i + 1]) for i in range(0, len(r), 1)] # 8bit
            r = self.RO_REGION[self.kallsyms_token_table_addr - self.krobase: self.kallsyms_token_index_addr - self.krobase]
            self.kallsyms_token_table = [u8(r[i:i + 1]) for i in range(0, len(r), 1)] # 8bit
            r = self.RO_REGION[self.kallsyms_token_index_addr - self.krobase:] # fixed table size
            self.kallsyms_token_index = [u16(r[i:i + 2]) for i in range(0, len(r), 2)] # 16bit
            self.initialized = True
        # finish
        self.print_meta()
        return True if res else False

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, args):
        self.dont_repeat()

        self.meta = args.meta
        self.silent = args.silent
        self.exact = args.exact
        self.head = args.head
        self.print_all = args.print_all
        if args.keyword == []:
            self.print_all = True

        if not self.initialize():
            return
        self.resolve_kallsyms()
        self.print_kallsyms(args.keyword)
        return


@register_command
class VmlinuxToElfApplyCommand(GenericCommand):
    """Apply symbol from kallsyms in memory using vmlinux-to-elf (too slow but more accurate)."""
    _cmdline_ = "vmlinux-to-elf-apply"
    _category_ = "08-b. Qemu-system Cooperation - Linux"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--reparse', action='store_true',
                        help='force applying vmlinux-to-elf again. (default: reuse if vmlinux-to-elf-dump-memory.elf exists')
    _syntax_ = parser.format_help()

    @staticmethod
    def dump_kernel_elf(dumped_mem_file, symboled_vmlinux_file, force=False):
        """Dump the kernel from the memory, then apply vmlinux-to-elf to create symboled ELF."""
        # check
        try:
            vmlinux2elf = which("vmlinux-to-elf")
        except FileNotFoundError as e:
            err("{}".format(e))
            return None

        # resolve kbase, krobase
        info("Wait for memory scan")

        kinfo = KernelbaseCommand.get_kernel_base()
        if kinfo.has_none:
            err("Failed to resolve")
            return None
        gef_print("kernel base:   {:#x} ({:#x} bytes)".format(kinfo.kbase, kinfo.kbase_size))
        gef_print("kernel rodata: {:#x} ({:#x} bytes)".format(kinfo.krobase, kinfo.krobase_size))
        gef_print("kernel data:   {:#x} ({:#x} bytes)".format(kinfo.krwbase, kinfo.krwbase_size))

        # resolve area
        area = []
        for addr in kinfo.maps:
            if addr[0] < kinfo.kbase:
                continue
            if addr[0] >= kinfo.krwbase:
                continue
            area.append([addr[0], addr[0] + addr[1]])
        if area == []:
            err("area is blank")
            return None

        # check if it can be reused
        if not force and os.path.exists(symboled_vmlinux_file):
            data = open(symboled_vmlinux_file, "rb").read()
            data = ''.join([chr(x) for x in data])
            r1 = re.findall(r"(Linux version (?:\d+\.[\d.]*\d)[ -~]+)", data)

            data = read_memory(kinfo.krobase, kinfo.krobase_size)
            data = ''.join([chr(x) for x in data])
            r2 = re.findall(r"(Linux version (?:\d+\.[\d.]*\d)[ -~]+)", data)

            if r1 and r2 and r1[0] != r2[0]:
                info("Run vmlinux-to-elf again because the kernel version is different")
                force = True

        # dump memory
        if force or (not os.path.exists(dumped_mem_file) and not os.path.exists(symboled_vmlinux_file)):
            # remove old file
            if os.path.exists(dumped_mem_file):
                info("Remove old {}".format(dumped_mem_file))
                os.unlink(dumped_mem_file)

            # dump
            info("Dumping memory")
            old_end_addr = None
            for i, (start_addr, end_addr) in enumerate(area):
                if i == 0:
                    gef_print("Dumping area:     {:#x} - {:#x}".format(start_addr, end_addr))
                    try:
                        gdb.execute("dump memory {} {:#x} {:#x}".format(dumped_mem_file, start_addr, end_addr), to_string=True)
                    except gdb.MemoryError:
                        err("Memory read error. Make sure the context is in supervisor mode / Ring-0")
                        return None
                else:
                    size_diff = start_addr - old_end_addr
                    if size_diff:
                        gef_print("Non-mapping area: {:#x} - {:#x} (ZERO fill)".format(old_end_addr, start_addr))
                        open(dumped_mem_file, "a").write("\0" * size_diff)
                    gef_print("Dumping area:     {:#x} - {:#x}".format(start_addr, end_addr))
                    try:
                        gdb.execute("append memory {} {:#x} {:#x}".format(dumped_mem_file, start_addr, end_addr), to_string=True)
                    except gdb.MemoryError:
                        err("Memory read error. Make sure the context is in supervisor mode / Ring-0")
                        return None
                old_end_addr = end_addr
            gef_print("Dumped to {}".format(dumped_mem_file))
        else:
            # reuse by default
            pass

        # apply vmlinux-to-elf
        if force or not os.path.exists(symboled_vmlinux_file):
            cmd = "{} '{}' '{}' --base-address={:#x}".format(vmlinux2elf, dumped_mem_file, symboled_vmlinux_file, kinfo.kbase)
            info("Execute `{:s}`".format(cmd))
            os.system(cmd)
        else:
            # reuse by default
            pass

        # Error
        if not os.path.exists(symboled_vmlinux_file):
            return None
        if os.path.getsize(symboled_vmlinux_file) == 0:
            return None

        # Success
        return kinfo

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, args):
        self.dont_repeat()

        dumped_mem_file = os.path.join(GEF_TEMP_DIR, "vmlinux-to-elf-dump-memory.raw")
        symboled_vmlinux_file = os.path.join(GEF_TEMP_DIR, "vmlinux-to-elf-dump-memory.elf")
        kinfo = self.dump_kernel_elf(dumped_mem_file, symboled_vmlinux_file, force=args.reparse)
        if kinfo is None:
            err("Failed to create kernel ELF")
            return

        # load symbol
        info("Adding symbol")
        # Prior to gdb 8.x, add-symbol-file command requires a .text address
        #   gdb 9.x: Usage: add-symbol-file FILE [-readnow | -readnever] [-o OFF] [ADDR] [-s SECT-NAME SECT-ADDR]...
        #   gdb 8.x: Usage: add-symbol-file FILE ADDR [-readnow | -readnever | -s SECT-NAME SECT-ADDR]...
        # But the created ELF has no .text, only a .kernel
        # Applying an empty symbol has no effect, so tentatively specify the same address as the .kernel.
        cmd = "add-symbol-file {} {:#x} -s .kernel {:#x}".format(symboled_vmlinux_file, kinfo.kbase, kinfo.kbase)
        info(cmd)
        gdb.execute(cmd)
        return


@register_command
class TcmallocDumpCommand(GenericCommand):
    """tcmalloc thread_heap freelist viewer (supported x86_64 only)."""
    _cmdline_ = "tcmalloc-dump"
    _category_ = "06-b. Heap - Other"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    subparsers = parser.add_subparsers(title='command', required=True)
    subparsers.add_parser('chrome')
    subparsers.add_parser('old')
    subparsers.add_parser('now')
    _syntax_ = parser.format_help()

    def __init__(self, *args, **kwargs):
        prefix = kwargs.get("prefix", True)
        super().__init__(prefix=prefix)
        self.initialized = None
        return

    def get_central_cache_(self):
        try:
            return parse_address("&'tcmalloc::Static::central_cache_'")
        except Exception:
            return None

    def get_thread_heaps_(self):
        try:
            return parse_address("&'tcmalloc::ThreadCache::thread_heaps_'")
        except Exception:
            return None

    def get_sizemap(self):
        try:
            return parse_address("&'tcmalloc::Static::sizemap_'")
        except Exception:
            return None

    def get_tls_addr(self, lwpid):
        PTRACE_ARCH_PRCTL = 30
        ARCH_GET_FS = 0x1003
        ppvoid = ctypes.POINTER(ctypes.c_void_p)
        fsvalue = ppvoid(ctypes.c_void_p())
        fsvalue.contents.value = 0
        libc = ctypes.CDLL('libc.so.6')
        result = libc.ptrace(PTRACE_ARCH_PRCTL, lwpid, fsvalue, ARCH_GET_FS)
        if result == 0:
            return fsvalue.contents.value
        else:
            return None

    def get_thread_list(self): # create dict: {tls_addr: lwpid}
        dic = {}
        lwpids = []
        for inf in gdb.inferiors():
            lwpids += [x.ptid[1] for x in inf.threads()]
        for lwpid in lwpids:
            tls = self.get_tls_addr(lwpid)
            if tls is not None:
                dic[tls] = lwpid
        return dic

    def get_thread_name_list(self): # create dict: {lwpid: name}
        lines = gdb.execute("info threads", to_string=True)
        dic = {}
        for line in lines.splitlines():
            r = re.findall(r'\(?LWP (\d+)\)? "(.+?)"', line)
            if not r:
                continue
            lwpid, name = int(r[0][0]), r[0][1]
            dic[lwpid] = name
        return dic

    def dump_thread_heap_freelist_single(self, freelist, idx):
        if self.FreeList_print_target_index is None:
            pass
        elif self.FreeList_print_target_index != idx:
            return

        seen = []
        chunk = read_int_from_memory(freelist + self.FreeList_offset_list)
        length = read_int_from_memory(freelist + self.FreeList_offset_length) & 0xffffffff
        real_length = 0
        error = False
        if chunk != 0: # freelist exists
            chunklist_string = ""
            while chunk != 0:
                real_length += 1
                seen.append(chunk)
                # print threshold check
                if real_length < self.FreeList_print_threshold:
                    chunklist_string += " -> " + Color.colorify(f"{chunk:#x}", "bold yellow underline")
                else:
                    if not chunklist_string.endswith(" -> ..."):
                        chunklist_string += " -> ..."
                # corrupted memory check
                try:
                    chunk = read_int_from_memory(chunk)
                except Exception:
                    if chunklist_string.endswith(" -> ..."):
                        chunklist_string += " -> " + Color.colorify(f"{seen[-2]:#x}", "bold yellow underline")
                        chunklist_string += " -> " + Color.colorify(f"{chunk:#x}", "bold red underline")
                    chunklist_string += " (corrupted)"
                    error = True
                    break
                # heap key decode
                chunk ^= self.get_heap_key()
                # loop check
                if chunk in seen:
                    chunklist_string += " -> " + Color.colorify(f"{chunk:#x}", "bold red underline") + " (loop)"
                    error = True
                    break
            # corrupted length check
            if length != real_length and error is False:
                chunklist_string += " (length currupted)"
                error = True
            # print
            chunksize = self.index_to_size(freelist, idx)
            if chunksize is None:
                gef_print(f"freelist[idx={idx:2d}, size=unknown, len={length:d}] @ {freelist:#x}{chunklist_string}")
            else:
                chunksize = Color.colorify("{:#x}".format(chunksize), "bold pink")
                gef_print(f"freelist[idx={idx:2d}, size={chunksize}, len={length:d}] @ {freelist:#x}{chunklist_string}")
        return

    def dump_thread_heap_freelist_array(self, thread_heap):
        # lwpid check
        tls = read_int_from_memory(thread_heap + self.ThreadCache_offset_tls)
        lwpid = self.get_thread_list()[tls]
        _, current_lwpid, _ = gdb.selected_thread().ptid
        name = self.get_thread_name_list()[lwpid]

        if self.FreeList_print_target_thread == "all":
            pass
        elif self.FreeList_print_target_thread == "self" and lwpid != current_lwpid:
            return
        elif isinstance(self.FreeList_print_target_thread, list) and name not in self.FreeList_print_target_thread:
            return

        current_or_not = "(current thread)" if lwpid == current_lwpid else ""
        gef_print(titlify(f"thread cache [lwpid={lwpid}{current_or_not:s},name=\"{name}\"] @ {thread_heap:#x} freelist"))

        freelist = thread_heap + self.ThreadCache_offset_freelist_array
        for i in range(self.ThreadCache_freelist_slot_count):
            self.dump_thread_heap_freelist_single(freelist, i)
            freelist += self.sizeof_FreeList
        return

    def dump_thread_heaps(self):
        thread_heap_head = self.get_thread_heaps_()
        if thread_heap_head is None:
            err("Not found tcmalloc::ThreadCache::thread_heaps_")
            return
        gef_print(titlify(f"thread_heaps_ (head) @ {thread_heap_head:#x}"))

        heap_key = self.get_heap_key()
        if heap_key != 0:
            gef_print(f"heap_key: {heap_key:#x} (xor chunk->fd)")

        thread_heap = read_int_from_memory(thread_heap_head)
        while thread_heap:
            self.dump_thread_heap_freelist_array(thread_heap)
            thread_heap = read_int_from_memory(thread_heap + self.ThreadCache_offset_next)
        return

    def dump_central_cache_freelist_single(self, freelist, _i, _j):
        seen = []
        chunk = read_int_from_memory(freelist + self.FreeList_offset_list)
        real_length = 0
        if chunk != 0: # freelist exists
            chunklist_string = ""
            while chunk != 0:
                real_length += 1
                seen.append(chunk)
                # print threshold check
                if real_length < self.FreeList_print_threshold:
                    chunklist_string += " -> " + Color.colorify(f"{chunk:#x}", "bold yellow underline")
                else:
                    if not chunklist_string.endswith(" -> ..."):
                        chunklist_string += " -> ..."
                # corrupted memory check
                try:
                    chunk = read_int_from_memory(chunk)
                except Exception:
                    if chunklist_string.endswith(" -> ..."):
                        chunklist_string += " -> " + Color.colorify(f"{seen[-2]:#x}", "bold yellow underline")
                        chunklist_string += " -> " + Color.colorify(f"{chunk:#x}", "bold red underline")
                    chunklist_string += " (corrupted)"
                    break
                # heap key decode
                chunk ^= self.get_heap_key()
                # loop check
                if chunk in seen:
                    chunklist_string += " -> " + Color.colorify(f"{chunk:#x}", "bold red underline") + " (loop)"
                    break
            # print
            gef_print(f"central_cache_[{_i}].tc_slot[{_j}] @ {freelist:#x}{chunklist_string}")
        return

    def dump_central_cache(self):
        central_cache_ = self.get_central_cache_()
        if central_cache_ is None:
            err("Not found tcmalloc::Static::central_cache_")
            return
        gef_print(titlify(f"central_cache_ @ {central_cache_:#x}"))

        heap_key = self.get_heap_key()
        if heap_key != 0:
            gef_print(f"heap_key: {heap_key:#x} (xor chunk->fd)")

        for i in range(self.CentralCache_array_count):
            central_cache_i = central_cache_ + i * self.sizeof_CentralCache # &central_cache[i]

            # check slot count
            used_slots = read_int_from_memory(central_cache_i + self.CentralCache_offset_used_slots_) & 0xffffffff
            max_slots = self.CentralCache_freelist_slot_count
            if used_slots == 0:
                continue

            # calc class -> size
            size_class = read_int_from_memory(central_cache_i + self.CentralCache_offset_size_class_)
            print("size_class @ {:#x} = {:#x}".format(central_cache_i + self.CentralCache_offset_size_class_, size_class))
            class_to_size_array = [
                0,     16,    32,    48,    64,   80,    96,    112,   128,   144,
                160,   176,   192,   208,   224,  240,   256,   288,   320,   352,
                384,   448,   512,   576,   640,  704,   768,   896,   1024,  1152,
                1280,  1536,  1792,  2048,  2304, 2560,  2816,  3072,  3328,  4096,
                4608,  5120,  6144,  6656,  8192, 10240, 12288, 13312, 16384, 20480,
                24576, 28672, 32768,
            ]
            size_byte = class_to_size_array[size_class]

            # dump
            gef_print(titlify(f"central_cache_[{i}] @ {central_cache_i:#x} (used_slots:{used_slots}/{max_slots}, chunk_size:{size_byte:#x})"))
            tc_slots = central_cache_i + self.CentralCache_offset_tc_slots_ # &central_cache[i].tc_slots_
            for j in range(min(used_slots, self.CentralCache_freelist_slot_count)):
                addr = tc_slots + j * 0x10 # &central_cache[i].tc_slots_[j]
                self.dump_central_cache_freelist_single(addr, i, j)
        return

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        if not self.initialized:
            self.usage()
            return

        if not is_x86_64():
            err("Unsupported")
            return

        self.FreeList_print_threshold = args.print_threshold
        self.FreeList_print_target_index = args.target_idx

        if args.name == "central":
            self.dump_central_cache()
            return

        if args.name in ["all", "self"]:
            self.FreeList_print_target_thread = args.name
        else:
            self.FreeList_print_target_thread = args.name.split(",")
        self.dump_thread_heaps()
        return


@register_command
class TcmallocDumpChromeCommand(TcmallocDumpCommand):
    """tcmalloc (chrome edition (improved from google-perftools-2.5)) freelist viewer (supported x86_64 only)."""
    _cmdline_ = "tcmalloc-dump chrome"
    _category_ = "06-b. Heap - Other"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--th', dest='print_threshold', type=int, default=5,
                        help='number of chunks to display per freelist. (default: %(default)s)')
    parser.add_argument('--idx', dest='target_idx', type=int, help='dump target index.')
    parser.add_argument('name', metavar='self|all|central|NAME', nargs='?', default='self', help='target thread cache name')
    _syntax_ = parser.format_help()

    _example_ = "{:s}\n".format(_cmdline_)
    _example_ += "{:s} self                              # (default) print freelist of thread cache for current thread\n".format(_cmdline_)
    _example_ += "{:s} all                               # print freelist of thread cache for all thread\n".format(_cmdline_)
    _example_ += '{:s} "Chrome_DevTools,Bluez D-Bus thr" # print freelist of thread cache for specified thread(s)\n'.format(_cmdline_)
    _example_ += "{:s} central                           # print freelist of central cache\n".format(_cmdline_)
    _example_ += "{:s} --th 10 --idx 32                  # Number of chunks to display per freelist = 10, target idx = 32.\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS EXPERIMENTAL AND HEURISTIC."

    def __init__(self):
        super().__init__(prefix=False)
        # chromium/third_party/tcmalloc/chromium/src/common.h
        kClassSizesMax = 96
        #kMaxSize = 32 * 1024
        #kClassArraySize = ((kMaxSize + 127 + (120 << 7)) >> 7) + 1
        # chromium/third_party/tcmalloc/chromium/src/thread_cache.h
        """
        00000000 ThreadCache     struc ; (sizeof=0xC48, align=0x8)
        00000000 list_           FreeList 96 dup(?) # kClassSizesMax
        00000C00 size_           dd ?
        00000C04 max_size_       dd ?
        00000C08 total_bytes_allocated_ dd ?
        00000C0C unused          dd ?
        00000C10 sampler_        Sampler ?
        00000C28 tid_            dq ?
        00000C30 in_setspecific_ db ?
        00000C31 unused2         db 7 dup(?)
        00000C38 next_           dq ?
        00000C40 prev_           dq ?
        00000C48 ThreadCache     ends
        """
        self.ThreadCache_offset_next = 0xc38
        self.ThreadCache_offset_freelist_array = 0x0
        self.ThreadCache_offset_tls = 0xc28 # actually this is not tid, but TLS base address
        self.ThreadCache_freelist_slot_count = kClassSizesMax
        # chromium/third_party/tcmalloc/chromium/src/thread_cache.h
        """
        00000000 FreeList        struc ; (sizeof=0x20, align=0x8)
        00000000 list_           dq ?
        00000008 length_         dd ?
        0000000C lowater_        dd ?
        00000010 max_length_     dd ?
        00000014 length_overages_ dd ?
        00000018 size_           dd ?
        0000001C unused          dd ?
        00000020 FreeList        ends
        """
        self.sizeof_FreeList = 0x20
        self.FreeList_offset_list = 0x0
        self.FreeList_offset_length = 0x8
        self.FreeList_offset_size = 0x18
        # chromium/third_party/tcmalloc/chromium/src/central_freelist.h
        kMaxNumTransferEntries = 64
        self.CentralCache_freelist_slot_count = kMaxNumTransferEntries
        # chromium/third_party/tcmalloc/chromium/src/static_vars.cc
        self.CentralCache_array_count = kClassSizesMax
        # chromium/third_party/tcmalloc/chromium/src/central_freelist.h
        """
        struct TCEntry {
          void *head;  // Head of chain of objects.
          void *tail;  // Tail of chain of objects.
        };
        class central_cache_[kClassSizesMax=96]
          0x0   SpinLock lock_;
          0x8   size_t   size_class_;     // My size class
          0x10  Span     empty_;          // Dummy header for list of empty spans
          0x40  Span     nonempty_;       // Dummy header for list of non-empty spans
          0x70  size_t   num_spans_;      // Number of spans in empty_ plus nonempty_
          0x78  size_t   counter_;        // Number of free objects in cache entry
          0x80  TCEntry tc_slots_[kMaxNumTransferEntries=64]
          0x480 int32_t used_slots_;
          0x484 int32_t cache_size_;
          0x488 int32_t max_cache_size_;
          0x48c char pad[0x34];
        } // size:0x4c0, total_size:0x1c800
        """
        self.sizeof_TCEntry = 0x10
        self.sizeof_CentralCache = 0x4c0
        self.CentralCache_offset_size_class_ = 0x8
        self.CentralCache_offset_tc_slots_ = 0x80
        self.CentralCache_offset_used_slots_ = 0x480
        # settings
        self.initialized = True
        return

    def get_heap_key(self):
        # chromium/third_party/tcmalloc/chromium/src/thread_cache.cc
        aslr = parse_address("TCMalloc_SystemAlloc")
        return (~(aslr >> 13)) & 0xffffffffffffffff

    def index_to_size(self, freelist, t): # freelist_index -> chunk_size
        size = read_int_from_memory(freelist + self.FreeList_offset_size)
        return size


@register_command
class TcmallocDumpOldCommand(TcmallocDumpCommand):
    """tcmalloc (google-perftools-2.5 edition) freelist viewer (supported x86_64 only)."""
    _cmdline_ = "tcmalloc-dump old"
    _category_ = "06-b. Heap - Other"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--th', dest='print_threshold', type=int, default=5,
                        help='number of chunks to display per freelist. (default: %(default)s)')
    parser.add_argument('--idx', dest='target_idx', type=int, help='dump target index.')
    parser.add_argument('name', metavar='self|all|central|NAME', nargs='?', default='self', help='target thread cache name')
    _syntax_ = parser.format_help()

    _example_ = "{:s}\n".format(_cmdline_)
    _example_ += "{:s} self                              # (default) print freelist of thread cache for current thread\n".format(_cmdline_)
    _example_ += "{:s} all                               # print freelist of thread cache for all thread\n".format(_cmdline_)
    _example_ += '{:s} "Chrome_DevTools,Bluez D-Bus thr" # print freelist of thread cache for specified thread(s)\n'.format(_cmdline_)
    _example_ += "{:s} central                           # print freelist of central cache\n".format(_cmdline_)
    _example_ += "{:s} --th 10 --idx 32                  # Number of chunks to display per freelist = 10, target idx = 32.\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS EXPERIMENTAL AND HEURISTIC."

    def __init__(self):
        super().__init__(prefix=False)
        # google-perftools-2.5/src/common.h
        kBaseClasses = 9 # or 16
        kNumClasses = kBaseClasses + 79 # or 73 or 69
        kMaxSize = 256 * 1024
        kClassArraySize = ((kMaxSize + 127 + (120 << 7)) >> 7) + 1
        kClassSizesMax = 88 # 128
        # google-perftools-2.5/src/thread_cache.h
        """
        00000000 ThreadCache     struc ; (sizeof=0x880)
        00000000 next_           dq ?
        00000008 prev_           dq ?
        00000010 size_           dq ?
        00000018 max_size_       dq ?
        00000020 sampler_        Sampler ?
        00000030 list_           FreeList 88 dup(?) # kNumClasses
        00000870 tid_            dq ?
        00000878 in_setspecific_ db ?
        00000879 unused          db 7 dup(?)
        00000880 ThreadCache     ends
        """
        self.ThreadCache_offset_next = 0x0
        self.ThreadCache_offset_freelist_array = 0x30
        self.ThreadCache_offset_tls = 0x870 # actually this is not tid, but TLS base address
        self.ThreadCache_freelist_slot_count = kNumClasses
        # google-perftools-2.5/src/thread_cache.h
        """
        00000000 FreeList        struc ; (sizeof=0x18)
        00000000 list_           dq ?
        00000008 length_         dd ?
        0000000C lowater_        dd ?
        00000010 max_length_     dd ?
        00000014 length_overages_ dd ?
        00000018 FreeList        ends
        """
        self.sizeof_FreeList = 0x18
        self.FreeList_offset_list = 0x0
        self.FreeList_offset_length = 0x8
        # google-perftools-2.5/src/common.h
        """
        00000000 SizeMap         struc ; (sizeof=0xF60)
        00000000 num_objects_to_move_ dd 88 dup(?) # kNumClasses
        00000160 class_array_    db 2169 dup(?) # kClassArraySize
        000009D9 field_9D9       db 7 dup(?)
        000009E0 class_to_size_  dq 88 dup(?) # kNumClasses
        00000CA0 class_to_pages_ dq 88 dup(?) # kNumClasses
        00000F60 SizeMap         ends
        """
        self.SizeMap_offset_class_array = kNumClasses * 4
        self.SizeMap_offset_class_to_size = self.SizeMap_offset_class_array + ((kClassArraySize + 7) // 8 * 8)
        # google-perftools-2.5/src/central_freelist.h
        kMaxNumTransferEntries = 64
        self.CentralCache_freelist_slot_count = kMaxNumTransferEntries
        # google-perftools-2.5/src/static_vars.cc
        self.CentralCache_array_count = kClassSizesMax
        # google-perftools-2.5/src/central_freelist.h
        """
        struct TCEntry {
          void *head;  // Head of chain of objects.
          void *tail;  // Tail of chain of objects.
        };
        class central_cache_[kClassSizesMax=128]
          0x0   SpinLock lock_;
          0x8   size_t   size_class_;     // My size class
          0x10  Span     empty_;          // Dummy header for list of empty spans
          0x40  Span     nonempty_;       // Dummy header for list of non-empty spans
          0x70  size_t   num_spans_;      // Number of spans in empty_ plus nonempty_
          0x78  size_t   counter_;        // Number of free objects in cache entry
          0x80  TCEntry tc_slots_[kMaxNumTransferEntries=64]
          0x480 int32_t used_slots_;
          0x484 int32_t cache_size_;
          0x488 int32_t max_cache_size_;
          0x48c char pad[0x34];
        } // size:0x4c0, total_size:0x26000
        """
        self.sizeof_TCEntry = 0x10
        self.sizeof_CentralCache = 0x4c0
        self.CentralCache_offset_size_class_ = 0x8
        self.CentralCache_offset_tc_slots_ = 0x80
        self.CentralCache_offset_used_slots_ = 0x480
        # settings
        self.initialized = True
        return

    def get_heap_key(self):
        return 0

    def index_to_size(self, freelist, t): # freelist_index -> chunk_size
        sizemap = self.get_sizemap()
        if sizemap is None:
            return None
        size = read_int_from_memory(sizemap + self.SizeMap_offset_class_to_size + 8 * t)
        return size


@register_command
class TcmallocDumpNewCommand(TcmallocDumpCommand):
    """tcmalloc (google-perftools-2.9.1 edition) freelist viewer (supported x86_64 only)."""
    _cmdline_ = "tcmalloc-dump new"
    _category_ = "06-b. Heap - Other"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--th', dest='print_threshold', type=int, default=5,
                        help='number of chunks to display per freelist. (default: %(default)s)')
    parser.add_argument('--idx', dest='target_idx', type=int, help='dump target index.')
    parser.add_argument('name', metavar='self|all|central|NAME', nargs='?', default='self', help='target thread cache name')
    _syntax_ = parser.format_help()

    _example_ = "{:s}\n".format(_cmdline_)
    _example_ += "{:s} self                              # (default) print freelist of thread cache for current thread\n".format(_cmdline_)
    _example_ += "{:s} all                               # print freelist of thread cache for all thread\n".format(_cmdline_)
    _example_ += '{:s} "Chrome_DevTools,Bluez D-Bus thr" # print freelist of thread cache for specified thread(s)\n'.format(_cmdline_)
    _example_ += "{:s} central                           # print freelist of central cache\n".format(_cmdline_)
    _example_ += "{:s} --th 10 --idx 32                  # Number of chunks to display per freelist = 10, target idx = 32.\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS EXPERIMENTAL AND HEURISTIC."

    def __init__(self):
        super().__init__(prefix=False)
        # google-perftools-2.9.1/src/common.h
        kClassSizesMax = 128
        #kMaxSize = 256 * 1024
        #kClassArraySize = ((kMaxSize + 127 + (120 << 7)) >> 7) + 1
        # google-perftools-2.9.1/src/thread_cache.h
        """
        00000000 ThreadCache     struc ; (sizeof=0x1040, align=0x8)
        00000000 list_           FreeList 128 dup(?) # kClassSizesMax
        00001000 size_           dd ?
        00001004 max_size_       dd ?
        00001008 sampler_        Sampler ?
        00001020 tid_            dq ?
        00001028 in_setspecific_ db ?
        00001029 unused          db 7 dup(?)
        00001030 next_           dq ?
        00001038 prev_           dq ?
        00001040 ThreadCache     ends
        """
        self.ThreadCache_offset_next = 0x1030
        self.ThreadCache_offset_freelist_array = 0x0
        self.ThreadCache_offset_tls = 0x1020 # actually this is not tid, but TLS base address
        self.ThreadCache_freelist_slot_count = kClassSizesMax
        # google-perftools-2.9.1/src/thread_cache.h
        """
        00000000 FreeList        struc ; (sizeof=0x20, align=0x8)
        00000000 list_           dq ?
        00000008 length_         dd ?
        0000000C lowater_        dd ?
        00000010 max_length_     dd ?
        00000014 length_overages_ dd ?
        00000018 size_           dd ?
        0000001C unused          dd ?
        00000020 FreeList        ends
        """
        self.sizeof_FreeList = 0x20
        self.FreeList_offset_list = 0x0
        self.FreeList_offset_length = 0x8
        self.FreeList_offset_size = 0x18
        # google-perftools-2.9.1/src/central_freelist.h
        kMaxNumTransferEntries = 64
        self.CentralCache_freelist_slot_count = kMaxNumTransferEntries
        # google-perftools-2.9.1/src/static_vars.cc
        self.CentralCache_array_count = kClassSizesMax
        # google-perftools-2.9.1/src/central_freelist.h
        """
        struct TCEntry {
          void *head;  // Head of chain of objects.
          void *tail;  // Tail of chain of objects.
        };
        class central_cache_[kClassSizesMax=128]
          0x0   SpinLock lock_;
          0x8   size_t   size_class_;     // My size class
          0x10  Span     empty_;          // Dummy header for list of empty spans
          0x40  Span     nonempty_;       // Dummy header for list of non-empty spans
          0x70  size_t   num_spans_;      // Number of spans in empty_ plus nonempty_
          0x78  size_t   counter_;        // Number of free objects in cache entry
          0x80  TCEntry tc_slots_[kMaxNumTransferEntries=64]
          0x480 int32_t used_slots_;
          0x484 int32_t cache_size_;
          0x488 int32_t max_cache_size_;
          0x48c char pad[0x34];
        } // size:0x4c0, total_size:0x26000
        """
        self.sizeof_TCEntry = 0x10
        self.sizeof_CentralCache = 0x4c0
        self.CentralCache_offset_size_class_ = 0x8
        self.CentralCache_offset_tc_slots_ = 0x80
        self.CentralCache_offset_used_slots_ = 0x480
        # settings
        self.initialized = True
        return

    def get_heap_key(self):
        return 0

    def index_to_size(self, freelist, t): # freelist_index -> chunk_size
        size = read_int_from_memory(freelist + self.FreeList_offset_size)
        return size

    def get_central_cache_(self):
        # central_caches_ has ATTRIBUTE_HIDDEN, so the symbol is removed. so we need heuristic search.
        #
        # In the source code, there is size_map_ just above.
        #
        #   google-perftools-2.9.1/src/static_vars.cc
        #     ...
        #     SizeMap Static::sizemap_; <----- here
        #     CentralFreeListPadded Static::central_cache_[kClassSizesMax];
        #     ...
        #
        # And sizemap_ is initialized at the beginning of tcmalloc::Static::InitStaticVars(),
        # so the addresses are loaded.
        #
        #   google-perftools-2.9.1/src/static_vars.cc
        #   ...
        #   void Static::InitStaticVars() {
        #     sizemap_.Init(); <----- here
        #     span_allocator_.Init();
        #   ...
        #
        # This is a sample.
        #   0x7ffff7c26110 <tcmalloc::Static::InitStaticVars()>:      endbr64
        #   0x7ffff7c26114 <tcmalloc::Static::InitStaticVars()+4>:    push   rbp
        #   0x7ffff7c26115 <tcmalloc::Static::InitStaticVars()+5>:    lea    rdi,[rip+0x1d1dc4]   # 0x7ffff7df7ee0 <----- here
        #   0x7ffff7c2611c <tcmalloc::Static::InitStaticVars()+12>:   push   rbx
        #   0x7ffff7c2611d <tcmalloc::Static::InitStaticVars()+13>:   sub    rsp,0x8
        #   0x7ffff7c26121 <tcmalloc::Static::InitStaticVars()+17>:   call   0x7ffff7c20d80 <tcmalloc::SizeMap::Init()>
        #   ...
        #
        # The size of central_cache_ is 0x26000, so 0x7ffff7df7ee0 - 0x26000 is central_cache_.

        try:
            init_static_vars = parse_address("&'tcmalloc::Static::InitStaticVars()'")
        except Exception:
            return None
        res = gdb.execute("x/10i {:#x}".format(init_static_vars), to_string=True)
        sizeof_central_cache_ = 0x26000
        for line in res.splitlines():
            m = re.search(r"\[rip\+0x\w+\].*#\s*(0x\w+)", line) # maybe size_map
            if m:
                v = int(m.group(1), 16) & 0xffffffffffffffff
                return v - sizeof_central_cache_
        else:
            return None


@register_command
class PartitionAllocDumpCommand(GenericCommand):
    """PartitionAlloc freelist viewer for chromium stable (supported x64/x86/ARM64/ARM only)."""
    _cmdline_ = "partition-alloc-dump"
    _category_ = "06-b. Heap - Other"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('target_buffer_root', choices=['fast_malloc', 'array_buffer', 'buffer', 'fm', 'ab', 'b'],
                        help='the target.buffer_root')
    parser.add_argument('-v', dest='verbose', action='store_true', help='display also empty slots.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} array_buffer # walk from array_buffer_root_\n".format(_cmdline_)
    _example_ += "{:s} ab           # same above\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS EXPERIMENTAL AND HEURISTIC.\n"
    _example_ += "Chromium mainline is too fast to develop. So if parse is failed, you need fix this gef.py."

    """
    partition alloc freelist is following.

     +-root-----------------+
     | ...                  |    +---> +-extent------------+  +-> +-extent------------+  +-> ...
     | next_super_page      |    |     | next              | -+   | next              | -+
     | next_partition_page  |    |     +-------------------+      +-------------------+
     | ...                  |    |
     | first_extent         | ---+
     | direct_map_list      | -------> +-direct_map_extent-+  +-> +-direct_map_extent-+  +-> ...
     | ...                  |          | bucket            |  |   | bucket            |  |
     |                      |          | next_extent       | -+   | next_extent       | -+
     |                      |          +-------------------+      +-------------------+
     |                      |
     +-bucket[0](0x20)------+
     | head                 | -------> +-slot_span---------+  +-> +-slot_span---------+  +-> ...
     | slot_size            | <------- | bucket            |  |   | bucket            |  |
     | ...                  |    +---- | freelist_head     |  |   | freelist_head     |  |
     +-bucket[1](0x20)------+    |     | next_slot_span    | -+   | next_slot_span    | -+
     | head                 |    |     +-------------------+      +-------------------+
     | slot_size            |    |
     | ...                  |    |
     +----------------------+    |
     | ...                  |    |
     |                      |    +---> +-slot--------------+
     |                      |          | next              | --+
     +----------------------+          | (freed)           |   |
                                       +-slot--------------+   |
                                       |                   |   |
                                       | (used)            |   |
                                       +-slot--------------+ <-+
                                   +-- | next              |
                                   |   | (freed)           |
                                   |   +-slot--------------+
                                   |   |                   |
                                   |   | (used)            |
                                   +-> +-slot--------------+
                                       | next              | --> NULL
                                       | (freed)           |
                                       +-slot--------------+
                                       |                   |
                                       |                   |
                                       +-------------------+

    `extent`, `slot_span` and `slot` are in super_page.

          +-super_page-(2MB)----+
     4KB  | Guard Page          |
          +---------------------+
     4KB  | extent * 1          |
          | slot_span * 126     |
          | unused * 1          |
          +---------------------+
     8KB  | Guard Page          |
          +---------------------+
     16KB | Partition Page #1   |
          |   slot              |
          |   slot              |
          |   ...               |
          +---------------------+
          | ...                 |
          +---------------------+
     16KB | Partition Page #126 |
          |   slot              |
          |   slot              |
          |   ...               |
          +---------------------+
     12KB | Unused              |
          +---------------------+
      4KB | Guard Page          |
          +---------------------+
    """

    def get_roots_heuristic(self):
        """searches for fast_malloc_root, array_buffer_root_ and buffer_root_"""
        # the pointers to each root are in the RW area.
        # first, we list up the RW area.
        filepath = get_filepath(append_proc_root_prefix=False)
        if is_64bit():
            codebase = get_section_base_address(filepath)
            mask = 0x0000ffff00000000
            chromium_rw_maps = [p for p in get_process_maps() if p.permission.value == Permission.READ | Permission.WRITE]
            chromium_rw_maps = [p for p in chromium_rw_maps if (p.page_start & mask) == (codebase & mask) and p.path != filepath]
        elif is_32bit():
            mask = 0xff000000
            heapbase = HeapbaseCommand.heap_base()
            chromium_rw_maps = [p for p in get_process_maps() if p.permission.value == Permission.READ | Permission.WRITE]
            chromium_rw_maps = [p for p in chromium_rw_maps if p.page_start < heapbase and p.path != filepath]

        # n_gram([1,2,3,4,5],3) -> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
        def n_gram(target, n):
            for idx in range(len(target) - n + 1):
                yield target[idx:idx + n]

        # Check the RW area
        roots = []
        for maps in chromium_rw_maps:
            # explode to each qword (if 64 bit arch) or dword (if 32 bit arch)
            datas = slice_unpack(read_memory(maps.page_start, maps.size), current_arch.ptrsize)
            addrs = [x for x in range(maps.page_start, maps.page_end, current_arch.ptrsize)]

            """
            https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/platform/wtf/allocator/partitions.cc
            base::ThreadSafePartitionRoot* Partitions::fast_malloc_root_ = nullptr;
            base::ThreadSafePartitionRoot* Partitions::array_buffer_root_ = nullptr;
            base::ThreadSafePartitionRoot* Partitions::buffer_root_ = nullptr;

            0x564883728440 <WTF::Partitions::fast_malloc_root_>:    0x0000000000000000
            0x564883728448 <WTF::Partitions::array_buffer_root_>:   0x000056488372a380
            0x564883728450 <WTF::Partitions::buffer_root_>: 0x0000564883729400
            0x564883728458 <guard variable for WTF::Partitions::Initialize()::initialized>: 0x0000000100000101
            ...
            0x55c7e358d480 <WTF::Partitions::InitializeOnce()::fast_malloc_allocator>:      0x0000000000000000
            ...
            0x55c7e358e400 <WTF::Partitions::InitializeOnce()::buffer_allocator>:   0x0000000100000001
            ...
            0x55c7e358f380 <WTF::Partitions::InitializeArrayBufferPartition()::array_buffer_allocator>:     0x0000000100000001
            """
            # check consecutive quadruples
            for addr, data in zip(n_gram(addrs, 4), n_gram(datas, 4)):
                # root pointer address and root address are close (see above example)
                if data[0] != 0 and (addr[0] & mask) != (data[0] & mask):
                    # fast_malloc_root_ may be zero. but if non-zero, it holds address close to itself
                    continue
                if (addr[1] & mask) != (data[1] & mask):
                    # array_buffer_root_ is must be non-zero. it holds address close to itself
                    continue
                if (addr[2] & mask) != (data[2] & mask):
                    # buffer_root_ is must be non-zero. it holds address close to itself
                    continue
                # they should be aligned
                if data[0] & 0x7:
                    continue
                if data[1] & 0x7:
                    continue
                if data[2] & 0x7:
                    continue
                # initialized must be bool 0x01
                if (data[3] & 0xff) != 0x01:
                    continue
                # check root size
                buffer_root_size = data[1] - data[2]
                if buffer_root_size < 0x300: # 0x300 is heuristic value
                    continue
                if buffer_root_size > 0x2000: # 0x2000 is heuristic value
                    continue
                # check root struct.
                """
                The first 64 bytes of root are mostly 0 due to padding considering the cache line.
                This is same both at 64-bit and 32bit arch.
                0x55719118e380: 0x0000000100000001      0x0000000000000000     <--- here may be used
                0x55719118e390: 0x0000000000000000      0x0000000000000000     <--- here may be used
                0x55719118e3a0: 0x0000000000000000      0x0000000000000000     <--- hare may be not used
                0x55719118e3b0: 0x0000000000000000      0x0000000000000000     <--- here may be not used
                """
                if read_memory(data[1], 64)[32:] != b"\0" * 32:
                    continue
                if read_memory(data[2], 64)[32:] != b"\0" * 32:
                    continue
                # add candidate
                root_candidate = [
                    ["fast_malloc_root_", addr[0]],
                    ["array_buffer_root_", addr[1]],
                    ["buffer_root_", addr[2]],
                ]
                roots.append(root_candidate)

        # debug print
        if len(roots) == 0:
            err("roots were not found. try check code")
            return []

        elif len(roots) == 1:
            root = roots[0]
            for r in root:
                info("found: {:s}: {:#x}".format(r[0], r[1]))
            return roots[0] # [["fast_malloc_root_", addr], ["array_buffer_root_", addr], ["buffer_root_", addr]]

        else:
            err("candidates for root are found in multiple places. try check code")
            for root in roots:
                for r in root:
                    gef_print("  candidate: {:20s} {:#x}".format(r[0], r[1]))
                gef_print()
            return []

    def get_roots(self):
        def get_root(root_string):
            try:
                root_addr = parse_address("&'WTF::Partitions::{:s}'".format(root_string))
                return [[root_string, root_addr]]
            except Exception:
                return []

        roots = []
        # try from symbols
        for root_string in ["fast_malloc_root_", "array_buffer_root_", "buffer_root_"]:
            roots += get_root(root_string)
        # maybe no symbols, try heuristic
        if len(roots) == 0:
            info("Symbol is not found. It will use heuristic search")
            roots = self.get_roots_heuristic()
        # retry checking
        if len(roots) == 0:
            info("Symbol is not found.")
        return roots

    def get_sentinel_slot_spans(self):
        """sentinel_slot_span is default slot_span, so search it"""
        sentinel = []
        try:
            t = parse_address("&'base::internal::SlotSpanMetadata<true>::sentinel_slot_span_'")
            sentinel.append(t)
        except Exception:
            pass
        try:
            f = parse_address("&'base::internal::SlotSpanMetadata<false>::sentinel_slot_span_'")
            sentinel.append(f)
        except Exception:
            pass
        return sentinel

    def byteswap(self, x):
        p = lambda a: struct.pack("<I", a & 0xffffffff)
        ube = lambda a: struct.unpack(">I", a)[0]
        pQ = lambda a: struct.pack("<Q", a & 0xffffffffffffffff)
        uQbe = lambda a: struct.unpack(">Q", a)[0]
        if is_64bit():
            converted = uQbe(pQ(x))
        elif is_32bit():
            converted = ube(p(x))
        return converted

    def read_root(self, addr, name):
        ptrsize = current_arch.ptrsize
        _root = {}
        _root["name"] = name
        _root["addr"] = current = read_int_from_memory(addr)
        """
        https://source.chromium.org/chromium/chromium/src/+/main:base/allocator/partition_allocator/partition_root.h
        struct base::PartitionRoot {
            union {
                struct Flags {
                    QuarantineMode quarantine_mode; // uint8_t
                    ScanMode scan_mode;             // uint8_t
                    BucketDistribution bucket_distribution = BucketDistribution::kCoarser; // uint8_t
                    bool with_thread_cache = false;
                    bool allow_aligned_alloc;
                    bool allow_cookie;
                    bool brp_enabled_;
                    bool brp_zapping_enabled_;
                    //bool mac11_malloc_size_hack_enabled_ = false;
                    bool use_configurable_pool;
                    //int pkey;
                    //uint32_t extras_size;
                    //uint32_t extras_offset;
                }
                uint8_t one_cacheline[internal::kPartitionCachelineSize]; // 64 bytes
            }
            ::partition_alloc::Lock lock_;  // 8 bytes
            Bucket buckets[internal::kNumBuckets] = {};
            Bucket sentinel_bucket{};
            bool initialized = false;
            std::atomic<size_t> total_size_of_committed_pages{0};
            std::atomic<size_t> max_size_of_committed_pages{0};
            std::atomic<size_t> total_size_of_super_pages{0};
            std::atomic<size_t> total_size_of_direct_mapped_pages{0};
            size_t total_size_of_allocated_bytes PA_GUARDED_BY(lock_) = 0;
            size_t max_size_of_allocated_bytes PA_GUARDED_BY(lock_) = 0;
            std::atomic<uint64_t> syscall_count{};
            std::atomic<uint64_t> syscall_total_time_ns{};
            std::atomic<size_t> total_size_of_brp_quarantined_bytes{0};
            std::atomic<size_t> total_count_of_brp_quarantined_slots{0};
            std::atomic<size_t> cumulative_size_of_brp_quarantined_bytes{0};
            std::atomic<size_t> cumulative_count_of_brp_quarantined_slots{0};
            size_t empty_slot_spans_dirty_bytes PA_GUARDED_BY(lock_) = 0;
            int max_empty_slot_spans_dirty_bytes_shift = 3;
            uintptr_t next_super_page = 0;
            uintptr_t next_partition_page = 0;
            uintptr_t next_partition_page_end = 0;
            SuperPageExtentEntry* current_extent = nullptr;
            SuperPageExtentEntry* first_extent = nullptr;
            DirectMapExtent* direct_map_list PA_GUARDED_BY(lock_) = nullptr;
            SlotSpan* global_empty_slot_span_ring[internal::kMaxFreeableSpans] PA_GUARDED_BY(lock_) = {};
            int16_t global_empty_slot_span_ring_index PA_GUARDED_BY(lock_) = 0;
            int16_t global_empty_slot_span_ring_size PA_GUARDED_BY(lock_) = internal::kDefaultEmptySlotSpanRingSize;
            uintptr_t inverted_self = 0;
            std::atomic<int> thread_caches_being_constructed_{0};
            bool quarantine_always_for_testing = false;
            //partition_alloc::PartitionTag current_partition_tag = 0; // if ARM MTE is enable
            //uintptr_t next_tag_bitmap_page = 0; // if ARM MTE is enable
        }
        """
        x = u64(read_memory(current, 8))
        current += 64 # sizeof(union {...})

        _root["lock_"] = u64(read_memory(current, 8))
        current += 8

        # for 32bit, there is 2 patterns because aligned or packed
        if is_32bit():
            if self.align_pad is None:
                x = read_int_from_memory(current)
                if x == 0:
                    self.align_pad = True
                else:
                    self.align_pad = False
            if self.align_pad:
                current += ptrsize

        _root["buckets"] = []
        while True:
            if read_int_from_memory(current) == 1: # search `bool initialized`
                break
            bucket, current = self.read_bucket(current)
            _root["buckets"].append(bucket)
        _root["sentinel_bucket"] = _root["buckets"].pop()

        _root["initialized"] = read_int_from_memory(current) & 0xff
        current += ptrsize # with pad
        _root["total_size_of_committed_pages"] = read_int_from_memory(current)
        current += ptrsize
        _root["max_size_of_committed_pages"] = read_int_from_memory(current)
        current += ptrsize
        _root["total_size_of_super_pages"] = read_int_from_memory(current)
        current += ptrsize
        _root["total_size_of_direct_mapped_pages"] = read_int_from_memory(current)
        current += ptrsize
        _root["total_size_of_allocated_bytes"] = read_int_from_memory(current)
        current += ptrsize
        _root["max_size_of_allocated_bytes"] = read_int_from_memory(current)
        current += ptrsize
        _root["syscall_count"] = read_int_from_memory(current)
        current += ptrsize
        _root["syscall_total_time_ns"] = read_int_from_memory(current)
        current += ptrsize
        _root["total_size_of_brp_quarantined_bytes"] = read_int_from_memory(current)
        current += ptrsize
        _root["total_count_of_brp_quarantined_slots"] = read_int_from_memory(current)
        current += ptrsize
        _root["cumulative_size_of_brp_quarantined_bytes"] = read_int_from_memory(current)
        current += ptrsize
        _root["cumulative_count_of_brp_quarantined_slots"] = read_int_from_memory(current)
        current += ptrsize
        _root["empty_slot_spans_dirty_bytes"] = u32(read_memory(current, 4))
        current += ptrsize # with pad
        _root["max_empty_slot_spans_dirty_bytes_shift"] = u32(read_memory(current, 4))
        current += ptrsize # with pad
        _root["next_super_page"] = read_int_from_memory(current)
        current += ptrsize
        _root["next_partition_page"] = read_int_from_memory(current)
        current += ptrsize
        _root["next_partition_page_end"] = read_int_from_memory(current)
        current += ptrsize
        _root["current_extent"] = read_int_from_memory(current)
        current += ptrsize
        _root["first_extent"] = read_int_from_memory(current)
        current += ptrsize
        _root["direct_map_list"] = read_int_from_memory(current)
        current += ptrsize

        _root["global_empty_slot_span_ring"] = []
        inv = _root["addr"] ^ ((1 << (current_arch.ptrsize * 8)) - 1)
        while True:
            if read_int_from_memory(current + ptrsize) == inv: # search `inverted_self`
                break
            x = read_int_from_memory(current)
            current += ptrsize
            _root["global_empty_slot_span_ring"].append(x)

        _root["global_empty_slot_span_ring_index"] = u16(read_memory(current, 2))
        current += 2
        _root["global_empty_slot_span_ring_size"] = u16(read_memory(current, 2))
        current += ptrsize - 2 # with pad
        _root["inverted_self"] = read_int_from_memory(current)
        current += ptrsize
        _root["thread_caches_being_constructed_"] = u32(read_memory(current, 4))
        current += 4
        _root["quarantine_always_for_testing"] = u32(read_memory(current, 4)) & 0xff
        current += 4

        Root = collections.namedtuple("Root", _root.keys())
        root = Root(*_root.values())
        return root, current

    def read_bucket(self, addr):
        ptrsize = current_arch.ptrsize
        _bucket = {}
        _bucket["addr"] = current = addr
        """
        https://source.chromium.org/chromium/chromium/src/+/main:base/allocator/partition_allocator/partition_bucket.h
        struct base::internal::PartitionBucket {
            SlotSpanMetadata<thread_safe>* active_slot_spans_head;
            SlotSpanMetadata<thread_safe>* empty_slot_spans_head;
            SlotSpanMetadata<thread_safe>* decommitted_slot_spans_head;
            uint32_t slot_size;
            uint32_t num_system_pages_per_slot_span : 8;
            uint32_t num_full_slot_spans : 24;
            uint64_t slot_size_reciprocal;
        };
        """
        _bucket["active_slot_spans_head"] = read_int_from_memory(current)
        current += ptrsize
        _bucket["empty_slot_spans_head"] = read_int_from_memory(current)
        current += ptrsize
        _bucket["decommitted_slot_spans_head"] = read_int_from_memory(current)
        current += ptrsize
        _bucket["slot_size"] = u32(read_memory(current, 4))
        current += 4
        x = u32(read_memory(current, 4))
        _bucket["num_system_pages_per_slot_span"] = x & 0xff
        _bucket["num_full_slot_spans"] = (x >> 8) & 0xffffff
        current += 4

        # for 32bit, there is 2 patterns because aligned or packed
        if is_32bit() and self.align_pad:
            current += 4
        _bucket["slot_size_reciprocal"] = u64(read_memory(current, 8))
        current += 8

        Bucket = collections.namedtuple("Bucket", _bucket.keys())
        bucket = Bucket(*_bucket.values())
        return bucket, current

    def read_extent(self, addr):
        ptrsize = current_arch.ptrsize
        _extent = {}
        _extent["addr"] = current = addr
        _extent["super_page_base"] = current - 0x1000
        """
        https://source.chromium.org/chromium/chromium/src/+/main:base/allocator/partition_allocator/partition_page.h
        struct PartitionSuperPageExtentEntry {
          PartitionRootBase* root;
          PartitionSuperPageExtentEntry* next;
          uint16_t number_of_consecutive_super_pages;
          uint16_t number_of_nonempty_slot_spans;
        };
        """
        _extent["root"] = read_int_from_memory(current)
        current += ptrsize
        _extent["next"] = read_int_from_memory(current)
        current += ptrsize
        _extent["number_of_consecutive_super_pages"] = u16(read_memory(current, 2))
        current += 2
        _extent["number_of_nonempty_slot_spans"] = u16(read_memory(current, 2))
        current += 2
        _extent["super_page_end"] = _extent["super_page_base"] + _extent["number_of_consecutive_super_pages"] * 0x200000

        Extent = collections.namedtuple("Extent", _extent.keys())
        extent = Extent(*_extent.values())
        return extent, current

    def read_direct_map(self, addr):
        ptrsize = current_arch.ptrsize
        _direct_map = {}
        _direct_map["addr"] = current = addr
        """
        https://source.chromium.org/chromium/chromium/src/+/main:base/allocator/partition_allocator/partition_direct_map_extent.h
        struct PartitionDirectMapExtent {
          PartitionDirectMapExtent<thread_safe>* next_extent;
          PartitionDirectMapExtent<thread_safe>* prev_extent;
          PartitionBucket<thread_safe>* bucket;
          size_t reservation_size;
          size_t padding_for_alignment;
        };
        """
        _direct_map["next_extent"] = read_int_from_memory(current)
        current += ptrsize
        _direct_map["prev_extent"] = read_int_from_memory(current)
        current += ptrsize
        _direct_map["bucket"] = read_int_from_memory(current)
        current += ptrsize
        _direct_map["reservation_size"] = read_int_from_memory(current)
        current += ptrsize
        _direct_map["padding_for_alignment"] = read_int_from_memory(current)
        current += ptrsize

        DirectMap = collections.namedtuple("DirectMap", _direct_map.keys())
        direct_map = DirectMap(*_direct_map.values())
        return direct_map, current

    def read_slot_span(self, addr):
        ptrsize = current_arch.ptrsize
        _slot_span = {}
        _slot_span["addr"] = current = addr
        _slot_span["super_page_addr"] = (_slot_span["addr"] & gef_getpagesize_mask()) - gef_getpagesize()
        _slot_span["partition_page_index"] = (_slot_span["addr"] & (gef_getpagesize() - 1)) // 0x20
        _slot_span["partition_page_start"] = _slot_span["super_page_addr"] + _slot_span["partition_page_index"] * gef_getpagesize() * 4
        """
        https://source.chromium.org/chromium/chromium/src/+/main:base/allocator/partition_allocator/partition_page.h
        struct SlotSpanMetadata {
          PartitionFreelistEntry* freelist_head = nullptr;
          SlotSpanMetadata<thread_safe>* next_slot_span = nullptr;
          PartitionBucket<thread_safe>* const bucket = nullptr;
          uint32_t marked_full : 1
          uint32_t num_allocated_slots : kMaxSlotsPerSlotSpanBits; // 13 bits
          uint32_t num_unprovisioned_slots : kMaxSlotsPerSlotSpanBits; // 13 bits
          const uint32_t can_store_raw_size_ : 1;
          uint32_t freelist_is_sorted_ : 1;
          uint32_t unused1_ : (32 - 1 - 2 * kMaxSlotsPerSlotSpanBits - 1 - 1); // 3 bits
          uint16_t in_empty_cache_ : 1;
          uint16_t empty_cache_index_ : kEmptyCacheIndexBits; // 7 bits
          uint16_t unused2_ : (16 - 1 - kEmptyCacheIndexBits); // 8 bits
        }
        """
        _slot_span["freelist_head"] = read_int_from_memory(current)
        current += ptrsize
        _slot_span["next_slot_span"] = read_int_from_memory(current)
        current += ptrsize
        _slot_span["bucket"] = read_int_from_memory(current)
        current += ptrsize
        x = u32(read_memory(current, 4))
        current += 4
        _slot_span["marked_full"] = (x >> 0) & 1
        _slot_span["num_allocated_slots"] = (x >> 1) & 0x1fff
        _slot_span["num_unprovisioned_slots"] = (x >> 14) & 0x1fff
        _slot_span["can_store_raw_size_"] = (x >> 27) & 1
        _slot_span["freelist_is_sorted_"] = (x >> 28) & 1
        _slot_span["unused1_"] = (x >> 29) & 0x7
        x = u16(read_memory(current, 2))
        current += 2
        _slot_span["in_empty_cache_"] = (x >> 0) & 1
        _slot_span["empty_cache_index_"] = (x >> 1) & 0x7f
        _slot_span["unused2_"] = (x >> 8) & 0xff

        SlotSpan = collections.namedtuple("SlotSpan", _slot_span.keys())
        slot_span = SlotSpan(*_slot_span.values())
        return slot_span, current

    def print_root(self, root):
        gef_print(titlify("*{} @ {:#x}".format(root.name, root.addr)))
        gef_print("uint8_t one_cacheline[64]:                             ...")
        gef_print("::partition_alloc::Lock lock_;                         {:#x}".format(root.lock_))
        gef_print("Bucket buckets[{:3d}]:".format(len(root.buckets)))
        for idx, bucket in enumerate(root.buckets):
            self.print_bucket(bucket, root, idx)
        if self.verbose:
            gef_print("Bucket sentinel_bucket:")
            self.print_bucket(root.sentinel_bucket, root)
        else:
            gef_print("Bucket sentinel_bucket:                                ...")
        gef_print("bool initialized:                                      {:#x}".format(root.initialized))
        gef_print("std::atomic<size_t> total_size_of_committed_pages:     {:#x}".format(root.total_size_of_committed_pages))
        gef_print("std::atomic<size_t> max_size_of_committed_pages:       {:#x}".format(root.max_size_of_committed_pages))
        gef_print("std::atomic<size_t> total_size_of_super_pages:         {:#x}".format(root.total_size_of_super_pages))
        gef_print("std::atomic<size_t> total_size_of_direct_mapped_pages: {:#x}".format(root.total_size_of_direct_mapped_pages))
        gef_print("size_t total_size_of_allocated_bytes:                  {:#x}".format(root.total_size_of_allocated_bytes))
        gef_print("size_t max_size_of_allocated_bytes:                    {:#x}".format(root.max_size_of_allocated_bytes))
        gef_print("std::atomic<uint64_t> syscall_count:                   {:#x}".format(root.syscall_count))
        gef_print("std::atomic<uint64_t> syscall_total_time_ns:           {:#x}".format(root.syscall_total_time_ns))
        gef_print("std::atomic<size_t> total_size_of_brp_quarantined_bytes:{:#x}".format(root.total_size_of_brp_quarantined_bytes))
        gef_print("std::atomic<size_t> total_count_of_brp_quarantined_slots:{:#x}".format(root.total_count_of_brp_quarantined_slots))
        gef_print("std::atomic<size_t> cumulative_size_of_brp_quarantined_bytes:{:#x}".format(root.cumulative_size_of_brp_quarantined_bytes))
        gef_print("std::atomic<size_t> cumulative_count_of_brp_quarantined_slots:{:#x}".format(root.cumulative_count_of_brp_quarantined_slots))
        gef_print("size_t empty_slot_spans_dirty_bytes:                   {:#x}".format(root.empty_slot_spans_dirty_bytes))
        gef_print("int max_empty_slot_spans_dirty_bytes_shift:            {:#x}".format(root.max_empty_slot_spans_dirty_bytes_shift))
        gef_print("uintptr_t next_super_page:                             {:#x}".format(root.next_super_page))
        gef_print("uintptr_t next_partition_page:                         {:#x}".format(root.next_partition_page))
        gef_print("uintptr_t next_partition_page_end:                     {:#x}".format(root.next_partition_page_end))
        gef_print("SuperPageExtentEntry* current_extent:                  {:#x}".format(root.current_extent))
        self.print_extent_list(root.current_extent)
        gef_print("SuperPageExtentEntry* first_extent:                    {:#x}".format(root.first_extent))
        self.print_extent_list(root.first_extent)
        gef_print("DirectMapExtent* direct_map_list:                      {:#x}".format(root.direct_map_list))
        self.print_direct_map_list(root.direct_map_list, root)
        ring_len = len(root.global_empty_slot_span_ring)
        if self.verbose:
            gef_print("SlotSpan* global_empty_slot_span_ring[{:2d}]:".format(ring_len))
            for i in range(len(root.global_empty_slot_span_ring)):
                gef_print("    global_empty_slot_span_ring[{:2d}]:                       {:#x}".format(i, root.global_empty_slot_span_ring[i]))
        else:
            gef_print("SlotSpan* global_empty_slot_span_ring[{:2d}]:             ...".format(ring_len))
        gef_print("int16_t global_empty_slot_span_ring_index:             {:#x}".format(root.global_empty_slot_span_ring_index))
        gef_print("int16_t global_empty_slot_span_ring_size:              {:#x}".format(root.global_empty_slot_span_ring_size))
        inv_inv = root.inverted_self ^ ((1 << (current_arch.ptrsize * 8)) - 1)
        gef_print("uintptr_t inverted_self:                               {:#x} (=~{:#x})".format(root.inverted_self, inv_inv))
        gef_print("std::atomic<int> thread_caches_being_constructed_:     {:#x}".format(root.thread_caches_being_constructed_))
        gef_print("bool quarantine_always_for_testing:                    {:#x}".format(root.quarantine_always_for_testing))
        return

    def print_extent_list(self, head):
        try:
            current = head
            while current:
                extent, _ = self.read_extent(current)
                gef_print("    -> extent @{:<#14x}".format(extent.addr))
                gef_print("           root:{:<#14x} ".format(extent.root))
                super_page_info = "{:<#14x} - {:<#14x}".format(extent.super_page_base, extent.super_page_end)
                page_info = "(total 0x200000(2MB) * {:d} pages)".format(extent.number_of_consecutive_super_pages)
                gef_print("           super_page:{:s} {:s}".format(Color.colorify(super_page_info, "bold yellow"), page_info))
                gef_print("           non_empty_slot_spans:{:d} ".format(extent.number_of_nonempty_slot_spans))
                gef_print("           next:{:<#14x}".format(extent.next))
                current = extent.next
        except Exception:
            err("Corrupted?")
        return

    def print_direct_map_list(self, head, root):
        try:
            current = head
            while current:
                direct_map, _ = self.read_direct_map(current)
                gef_print("    -> direct_map @{:<#14x}: ".format(direct_map.addr))
                gef_print("           next_extent:{:<#14x} ".format(direct_map.next_extent))
                gef_print("           prev_extent:{:<#14x} ".format(direct_map.prev_extent))
                gef_print("           bucket:{:<#14x} ".format(direct_map.bucket))
                gef_print("           reservation_size:{:#x}".format(direct_map.reservation_size))
                gef_print("           padding_for_alignment:{:#x}".format(direct_map.padding_for_alignment))
                bucket, _ = self.read_bucket(direct_map.bucket)
                self.print_bucket(bucket, root)
                current = direct_map.next_extent
        except Exception:
            err("Corrupted?")
        return

    def print_bucket(self, bucket, root, idx=None):
        sentinel1 = self.get_sentinel_slot_spans() # from symbol
        sentinel2 = [root.sentinel_bucket.active_slot_spans_head] # from heuristic search
        sentinel = list(set(sentinel1 + sentinel2)) # uniq

        if not self.verbose:
            if bucket.active_slot_spans_head in sentinel + [0x0]:
                return # skip printing

        slot_size = Color.colorify("{:#7x}".format(bucket.slot_size), "bold pink")
        if idx is not None:
            gef_print("    buckets[{:3d}](slot_size:{:s}) @{:<#14x}".format(idx, slot_size, bucket.addr))
        else:
            gef_print("    bucket(slot_size:{:s}) @{:<#14x}".format(slot_size, bucket.addr))
        gef_print("        num_system_pages_per_slot_span:{:<#4x} ".format(bucket.num_system_pages_per_slot_span))
        gef_print("        num_full_slot_spans:{:<#4x} ".format(bucket.num_full_slot_spans))
        gef_print("        slot_size_reciprocal:{:#x}".format(bucket.slot_size_reciprocal))

        if self.verbose:
            target_list = ["active_slot_spans_head", "empty_slot_spans_head", "decommitted_slot_spans_head"]
        else:
            target_list = ["active_slot_spans_head"]

        for key in target_list:
            head = getattr(bucket, key)
            # sentinel can be ignored, so skip
            if not self.verbose and (head in sentinel + [0x0]):
                continue
            if head in sentinel:
                # print sentinel (verbose)
                gef_print("        {:s}:sentinel_pages".format(Color.colorify(key, "bold cyan underline")))
            else:
                # default
                gef_print("        {:s}:{:<#14x}".format(Color.colorify(key, "bold cyan underline"), head))
            self.print_slot_span(head, bucket)
        return

    def print_slot_span(self, head, bucket):
        current = head
        while current:
            try:
                slot_span, _ = self.read_slot_span(current)
            except Exception:
                err("Corrupted?")
                break
            text_fmt = "            -> slot_span @{:<#14x} (#{:3d} of super_page @{:<#14x})"
            gef_print(text_fmt.format(slot_span.addr, slot_span.partition_page_index, slot_span.super_page_addr))
            gef_print("                   next_slot_span:{:<#14x} ".format(slot_span.next_slot_span))
            page_start = slot_span.partition_page_start
            page_end = slot_span.partition_page_start + bucket.num_system_pages_per_slot_span * gef_getpagesize()
            gef_print("                   slot_span_area:{:#x}-{:#x} ".format(page_start, page_end))
            gef_print("                   num_allocated_slots:{:#x}".format(slot_span.num_allocated_slots))
            self.print_freelist(slot_span.freelist_head, bucket, slot_span)
            current = slot_span.next_slot_span
        return

    def print_freelist(self, head, bucket, slot_span):
        gef_print("                   freelist_head:{:<#14x} ".format(head))

        slot_size = bucket.slot_size
        page_start = slot_span.partition_page_start
        page_end = slot_span.partition_page_start + bucket.num_system_pages_per_slot_span * gef_getpagesize()

        text = ""
        cnt = 0
        chunk = head
        seen = []
        while chunk:
            if cnt % 7 == 0:
                if cnt > 0:
                    text += "\n"
                text += " " * 23

            if chunk in seen:
                text += Color.colorify("-> {:<#14x} (loop) ".format(chunk), "bold red")
                break

            if not ((page_start <= chunk < page_end) and ((chunk - page_start) % slot_size == 0)):
                text += Color.colorify("-> {:<#14x} (corrupted) ".format(chunk), "bold red")
                break

            try:
                next_chunk = self.byteswap(read_int_from_memory(chunk))
            except Exception:
                text += Color.colorify("-> {:<#14x} (corrupted) ".format(chunk), "bold red")
                break

            text += "-> " + Color.colorify("{:<#14x} ".format(chunk), "bold yellow")
            cnt += 1
            seen.append(chunk)
            chunk = next_chunk

        if cnt > 0:
            text += "(num: {:#x})".format(cnt)

        if text:
            gef_print(text)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        if is_32bit():
            self.align_pad = None

        if "-h" in argv:
            self.usage()
            return

        self.verbose = False
        if "-v" in argv:
            self.verbose = True
            argv.remove("-v")

        if len(argv) != 1:
            self.usage()
            return

        if not argv[0] in ["fast_malloc", "fm", "array_buffer", "ab", "buffer", "b", "all"]:
            self.usage()
            return
        target = argv[0]

        for name, addr in self.get_roots():
            ok = False
            if target == "all":
                ok = True
            elif target in ["fast_malloc", "fm"] and name == "fast_malloc_root_":
                ok = True
            elif target in ["array_buffer", "ab"] and name == "array_buffer_root_":
                ok = True
            elif target in ["buffer", "b"] and name == "buffer_root_":
                ok = True

            if ok:
                try:
                    root, _ = self.read_root(addr, name)
                except Exception:
                    mem_value = read_int_from_memory(addr)
                    err("Parse error {:s}: @ {:#x} -> {:#x}".format(name, addr, mem_value))
                    continue
                self.print_root(root)
        return


@register_command
class MuslDumpCommand(GenericCommand):
    """musl v1.2.2 (src/malloc/mallocng) heap reusable chunks viewer. (x64/x86 only)"""
    # See https://h-noson.hatenablog.jp/entry/2021/05/03/161933#-177pts-mooosl
    _cmdline_ = "musl-dump"
    _category_ = "06-b. Heap - Other"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('command', nargs='?', default='unused', choices=['ctx', 'unused'],
                        help='dump mode (default: %(default)s).')
    parser.add_argument('--idx', type=int, help='the active index of dump target.')
    parser.add_argument('-v', dest='verbose', action='store_true', help='also dump an empty active index.')
    _syntax_ = parser.format_help()

    def get_malloc_context_heuristic(self):
        try:
            # search malloc
            malloc = parse_address("malloc")
            info("malloc: {:#x}".format(malloc))

            # search __libc_malloc_impl
            """
            [pattern 1]
               0x7ffff7d7dde0 <malloc>:     jmp    0x7ffff7d8ece2 <__libc_malloc_impl>

            [pattern 2]
               0x7ffff7f71650 <malloc>:     endbr64
               0x7ffff7f71654 <malloc+4>:   jmp    0x7ffff7f72ff0

            [pattern 3]
               0xf7f78bf0 <malloc>: jmp    0xf7f8bc3c
            """
            res = gdb.execute("x/10i {:#x}".format(malloc), to_string=True)
            for line in res.splitlines():
                m = re.search(r"jmp\s*(0x\w+)", line)
                if not m:
                    continue
                __libc_malloc_impl = int(m.group(1), 16)
                break
            info("__libc_malloc_impl: {:#x}".format(__libc_malloc_impl))

            # search __malloc_alloc_meta
            """
            [pattern 1]
               0x7ffff7d8ed0a <__libc_malloc_impl+40>:      call   0x7ffff7d88dc1 <__errno_location>
               0x7ffff7d8ed34 <__libc_malloc_impl+82>:      call   0x7ffff7da0c3b <mmap64>
               0x7ffff7d8ed48 <__libc_malloc_impl+102>:     call   0x7ffff7d8e36b <wrlock>
               0x7ffff7d8ed4d <__libc_malloc_impl+107>:     call   0x7ffff7d8e382 <step_seq>
               0x7ffff7d8ed52 <__libc_malloc_impl+112>:     call   0x7ffff7d8e45a <__malloc_alloc_meta>

            [pattern 2]
               0x7ffff7f7303b:      call   0x7ffff7f8a640 <mmap64>
               0x7ffff7f73074:      call   0x7ffff7f72290

            [pattern 3]
               0xf7f8bc40:  call   0xf7f7cf84
               0xf7f8bc67:  call   0xf7f84e85 <__errno_location>
               0xf7f8bc88:  call   0xf7f9cd53 <mmap64>
               0xf7f8bc9b:  call   0xf7f8b3aa
               0xf7f8bca0:  call   0xf7f8b3d2
               0xf7f8bca5:  call   0xf7f8b439
            """
            __malloc_alloc_meta_candidate = []
            res = gdb.execute("x/100i {:#x}".format(__libc_malloc_impl), to_string=True)
            for line in res.splitlines():
                m = re.search(r"call\s*(0x\w+)", line)
                if not m:
                    continue
                addr = int(m.group(1), 16)
                __malloc_alloc_meta_candidate.append(addr)

            # search __malloc_context
            """
            [patttern 1]
               0x7ffff7d8e45a <__malloc_alloc_meta>:        push   r12
               0x7ffff7d8e45c <__malloc_alloc_meta+2>:      push   rbp
               0x7ffff7d8e45d <__malloc_alloc_meta+3>:      push   rbx
               0x7ffff7d8e45e <__malloc_alloc_meta+4>:      sub    rsp,0x10
               0x7ffff7d8e462 <__malloc_alloc_meta+8>:      cmp    DWORD PTR [rip+0x26d67f],0x0  # 0x7ffff7ffbae8 <__malloc_context+8>

            [patttern 2]
               0x7ffff7f72290:      endbr64
               0x7ffff7f72294:      push   r12
               0x7ffff7f72296:      push   rbp
               0x7ffff7f72297:      push   rbx
               0x7ffff7f72298:      sub    rsp,0x10
               0x7ffff7f7229c:      mov    rax,QWORD PTR fs:0x28
               0x7ffff7f722a5:      mov    QWORD PTR [rsp+0x8],rax
               0x7ffff7f722aa:      xor    eax,eax
               0x7ffff7f722ac:      mov    eax,DWORD PTR [rip+0x89816]  # 0x7ffff7ffbac8
               0x7ffff7f722b2:      test   eax,eax

            [pattern 3]
               0xf7f8b439:  push   ebp
               0xf7f8b43a:  push   edi
               0xf7f8b43b:  push   esi
               0xf7f8b43c:  push   ebx
               0xf7f8b43d:  call   0xf7f7cf84
               0xf7f8b442:  add    ebx,0x6fbbe       # libc_bss_base
               0xf7f8b448:  sub    esp,0x1c
               0xf7f8b44b:  cmp    DWORD PTR [ebx+0x708],0x0
            """
            for cand in __malloc_alloc_meta_candidate:
                info("alloc_meta (candidate): {:#x}".format(cand))
                res = gdb.execute("x/10i {:#x}".format(cand), to_string=True)
                for line in res.splitlines():
                    if is_x86_64():
                        m = re.search(r"DWORD PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                        if not m:
                            continue
                        __malloc_context_init_done = int(m.group(1), 16)
                    else:
                        m = re.search(r"DWORD PTR \[e[abcd]x\+(0x\w+)\]", line)
                        if not m:
                            continue
                        __malloc_context_init_done_offset = int(m.group(1), 16)
                        rw_maps = [p for p in get_process_maps() if p.permission.value == Permission.READ | Permission.WRITE]
                        rw_maps = [p for p in rw_maps if "libc.so" in p.path]
                        libc_bss_base = rw_maps[0].page_start
                        __malloc_context_init_done = libc_bss_base + __malloc_context_init_done_offset
                    # check
                    value = u32(read_memory(__malloc_context_init_done, 4))
                    if value not in [0, 1]: # init_done is 1 or 0
                        continue
                    # found
                    info("__malloc_context.init_done: {:#x}".format(__malloc_context_init_done))
                    __malloc_context = __malloc_context_init_done - current_arch.ptrsize
                    x = read_int_from_memory(__malloc_context)
                    if x == gef_getpagesize():
                        __malloc_context -= current_arch.ptrsize
                    info("__malloc_context: {:#x}".format(__malloc_context))
                    return __malloc_context
            return None
        except Exception:
            err("Not found &__malloc_context")
            return None

    def get_malloc_context(self):
        try:
            return parse_address("&__malloc_context")
        except Exception:
            info("Symbol is not found. It will use heuristic search")
            return self.get_malloc_context_heuristic()

    def class_to_size(self, cl):
        class_to_size_list = [
            1, 2, 3, 4, 5, 6, 7, 8,
            9, 10, 12, 15,
            18, 20, 25, 31,
            36, 42, 50, 63,
            72, 84, 102, 127,
            146, 170, 204, 255,
            292, 340, 409, 511,
            584, 682, 818, 1023,
            1169, 1364, 1637, 2047,
            2340, 2730, 3276, 4095,
            4680, 5460, 6552, 8191,
        ]
        assert cl < len(class_to_size_list)
        return class_to_size_list[cl] * 0x10

    def read_ctx(self):
        ptrsize = current_arch.ptrsize
        _ctx = {}
        _ctx["addr"] = current = self.get_malloc_context()
        if current is None:
            return None
        """
        struct malloc_context {
            uint64_t secret;
        #ifndef PAGESIZE
            size_t pagesize;
        #endif
            int init_done;
            unsigned mmap_counter;
            struct meta *free_meta_head;
            struct meta *avail_meta;
            size_t avail_meta_count;
            size_t avail_meta_area_count;
            size_t meta_alloc_shift;
            struct meta_area *meta_area_head;
            struct meta_area *meta_area_tail;
            unsigned char *avail_meta_areas;
            struct meta *active[48];
            size_t usage_by_class[48];
            uint8_t unmap_seq[32];
            uint8_t bounces[32];
            uint8_t seq;
            uintptr_t brk;
        };
        """
        _ctx["secret"] = u64(read_memory(current, 8))
        current += 8
        x = read_int_from_memory(current)
        if x == gef_getpagesize():
            _ctx["pagesize"] = x
            current += ptrsize
        else:
            _ctx["pagesize"] = None

        _ctx["init_done"] = u32(read_memory(current, 4))
        current += 4
        _ctx["mmap_counter"] = u32(read_memory(current, 4))
        current += 4
        _ctx["free_meta_head"] = read_int_from_memory(current)
        current += ptrsize
        _ctx["avail_meta"] = read_int_from_memory(current)
        current += ptrsize
        _ctx["avail_meta_count"] = read_int_from_memory(current)
        current += ptrsize
        _ctx["avail_meta_area_count"] = read_int_from_memory(current)
        current += ptrsize
        _ctx["alloc_shift"] = read_int_from_memory(current)
        current += ptrsize
        _ctx["meta_area_head"] = read_int_from_memory(current)
        current += ptrsize
        _ctx["meta_area_tail"] = read_int_from_memory(current)
        current += ptrsize
        _ctx["avail_meta_areas"] = read_int_from_memory(current)
        current += ptrsize
        _ctx["active"] = []
        for i in range(48):
            _ctx["active"].append(read_int_from_memory(current))
            current += ptrsize
        _ctx["usage_by_class"] = []
        for i in range(48):
            _ctx["usage_by_class"].append(read_int_from_memory(current))
            current += ptrsize
        _ctx["unmap_seq"] = read_memory(current, 32)
        current += 32
        _ctx["bounces"] = read_memory(current, 32)
        current += 32
        _ctx["seq"] = ord(read_memory(current, 1))
        current += ptrsize # with padding
        _ctx["brk"] = read_int_from_memory(current)
        current += ptrsize

        Ctx = collections.namedtuple("Ctx", _ctx.keys())
        return Ctx(*_ctx.values())

    def print_ctx(self, ctx):
        gef_print(titlify("__malloc_context: {:#x}".format(ctx.addr)))
        gef_print("  uint64_t secret:                    {:#x}".format(ctx.secret))
        if ctx.pagesize:
            gef_print("  size_t pagesize:                    {:#x}".format(ctx.pagesize))
        gef_print("  int init_done:                      {:#x}".format(ctx.init_done))
        gef_print("  unsigned int mmap_counter:          {:#x}".format(ctx.mmap_counter))
        gef_print("  struct meta* free_meta_head:        {:#x}".format(ctx.free_meta_head))
        gef_print("  struct meta* avail_meta:            {:#x}".format(ctx.avail_meta))
        gef_print("  size_t avail_meta_count:            {:#x}".format(ctx.avail_meta_count))
        gef_print("  size_t avail_meta_area_count:       {:#x}".format(ctx.avail_meta_area_count))
        gef_print("  size_t alloc_shift:                 {:#x}".format(ctx.alloc_shift))
        gef_print("  struct meta_area* meta_area_head:   {:#x}".format(ctx.meta_area_head))
        gef_print("  struct meta_area* meta_area_tail:   {:#x}".format(ctx.meta_area_tail))
        gef_print("  unsigned char* avail_meta_areas:    {:#x}".format(ctx.avail_meta_areas))
        gef_print("  struct meta* active[48]:")
        for i in range(48):
            gef_print("     active[{:2d}] (for chunk_size={:#7x}):     {:#x}".format(i, self.class_to_size(i), ctx.active[i]))
        gef_print("  size_t usage_by_class[48]:")
        for i in range(48):
            gef_print("     usage_by_class[{:2d}]:                     {:#x}".format(i, ctx.usage_by_class[i]))
        gef_print("  uint8_t unmap_seq[32]:              {}".format(' '.join(["%02x" % x for x in ctx.unmap_seq])))
        gef_print("  uint8_t bounces[32]:                {}".format(' '.join(["%02x" % x for x in ctx.bounces])))
        gef_print("  uint8_t seq:                        {:#x}".format(ctx.seq))
        gef_print("  uintptr_t brk:                      {:#x}".format(ctx.brk))
        return

    def read_meta(self, addr):
        ptrsize = current_arch.ptrsize
        _meta = {}
        _meta["addr"] = current = addr
        """
        struct meta {
            struct meta *prev;
            struct meta *next;
            struct group *mem;
            volatile int avail_mask;
            volatile int freed_mask;
            uintptr_t last_idx:5;
            uintptr_t freeable:1;
            uintptr_t sizeclass:6;
            uintptr_t maplen:8*sizeof(uintptr_t)-12;
        };
        """
        _meta["prev"] = read_int_from_memory(current)
        current += ptrsize
        _meta["next"] = read_int_from_memory(current)
        current += ptrsize
        _meta["mem"] = read_int_from_memory(current)
        current += ptrsize
        _meta["avail_mask"] = u32(read_memory(current, 4))
        current += 4
        _meta["freed_mask"] = u32(read_memory(current, 4))
        current += 4
        x = read_int_from_memory(current)
        _meta["last_idx"] = x & 0b11111
        _meta["freeable"] = (x >> 5) & 0b1
        _meta["sizeclass"] = (x >> 6) & 0b111111
        _meta["maplen"] = (x >> 12)
        current += ptrsize

        Meta = collections.namedtuple("Meta", _meta.keys())
        return Meta(*_meta.values())

    def make_state(self, meta):
        avail_mask = meta.avail_mask
        freed_mask = meta.freed_mask

        text = ""
        for i in range(meta.last_idx + 1):
            if avail_mask & 1:
                text = "A" + text
            elif freed_mask & 1:
                text = "F" + text
            else:
                text = "U" + text
            avail_mask >>= 1
            freed_mask >>= 1
        return text

    def read_group(self, meta, offset):
        ptrsize = current_arch.ptrsize
        _group = {}
        _group["addr"] = current = meta.mem + offset
        _group["data"] = read_memory(_group["addr"], self.class_to_size(meta.sizeclass))
        """
        from source code:
        struct group {
            struct meta *meta;
            unsigned char active_idx:5;
            char pad[UNIT - sizeof(struct meta *) - 1]; // UNIT = 16
            unsigned char storage[];
        };

        however, the actual usage is as follows. (x64)
        struct group {
            struct meta *meta;
            unsigned int slot_offset32;
            unsigned char is_slot_offset32;
            unsigned char slot_index:5;
            unsigned char reserved:3;
            unsigned short slot_offset16;
        }
        """
        _group["meta"] = read_int_from_memory(current)
        current += ptrsize
        x = u32(read_memory(current, 4))
        current += 4 if is_x86_64() else 8
        y = u32(read_memory(current, 4))
        _group["reserved"] = (x >> 13) & 0b111
        _group["slot_idx"] = (y >> 8) & 0b11111
        if y & 0xff:
            _group["slot_offset"] = x
        else:
            _group["slot_offset"] = (y >> 16) & 0xffff
        current += ptrsize

        Group = collections.namedtuple("Group", _group.keys())
        return Group(*_group.values())

    def dump_chunk(self, group, state):
        ptrsize = current_arch.ptrsize

        subinfo = "state:{:5s} meta:{:<#14x} reserved:{:#x}".format(state, group.meta, group.reserved)
        if state == "Used":
            subinfo += " slot_idx:{:<#3x} slot_offset:{:#x}".format(group.slot_idx, group.slot_offset)

        data = slicer(group.data, ptrsize * 2)
        addr = group.addr
        group_line_threshold = 8

        # create dump text
        unpack = u32 if ptrsize == 4 else u64
        width = ptrsize * 2 + 2
        dump = ""
        done = False
        for blk, blks in itertools.groupby(data):
            repeat_count = len(list(blks))
            d1, d2 = unpack(blk[:ptrsize]), unpack(blk[ptrsize:])
            dascii = ''.join(list(map(lambda x: chr(x) if 0x20 <= x < 0x7f else '.', list(blk))))
            if repeat_count < group_line_threshold:
                for i in range(repeat_count):
                    dump += f"{addr:#x}: {d1:#0{width:d}x} {d2:#0{width:d}x} | {dascii:s} | " + subinfo + "\n"
                    addr += ptrsize * 2
                    if subinfo:
                        subinfo = ""
            else:
                dump += f"{addr:#x}: {d1:#0{width:d}x} {d2:#0{width:d}x} | {dascii:s} | " + subinfo + "\n"
                dump += "* {:#d} lines, {:#x} bytes \n".format(repeat_count - 1, (repeat_count - 1) * ptrsize * 2)
                addr += ptrsize * 2 * repeat_count
                if subinfo:
                    subinfo = ""
            if done:
                break

        # print
        dump = dump.rstrip()
        if state == "Used":
            gef_print(dump)
        else:
            gef_print(Color.grayify(dump))
        return

    def print_meta(self, ctx):
        gef_print(Color.colorify("Legend for `Unused chunks list`: A:Avail F:Freed U:Used", "yellow"))
        gef_print(Color.colorify("  1. Search most right 'A' and return it", "yellow"))
        gef_print(Color.colorify("  2. Search most right 'F' and return it", "yellow"))
        gef_print(Color.colorify("  3. If nothing is found, create new meta", "yellow"))

        # iterate __malloc_context.active
        for idx in range(48):
            print(idx)
            if self.active_idx is not None and idx != self.active_idx:
                continue
            current = ctx.active[idx]
            if current == 0:
                continue

            gef_print(titlify("active[{:2d}] (chunk_size={:#x})".format(idx, self.class_to_size(idx))))

            # iterate list of meta
            seen = []
            while current not in seen:
                meta = self.read_meta(current)
                gef_print("meta @ {:#x}".format(meta.addr))
                text = "  "
                text += "prev:{:#x} next:{:#x} ".format(meta.prev, meta.next)
                text += Color.colorify("mem:{:#x} ".format(meta.mem), "bold cyan")
                text += "avail_mask:{:#x} freed_mask:{:#x} ".format(meta.avail_mask, meta.freed_mask)
                text += "last_idx:{:#x} freeable:{:#x} ".format(meta.last_idx, meta.freeable)
                text += "sizeclass:{:#x} maplen:{:#x}".format(meta.sizeclass, meta.maplen)
                gef_print(text)

                state = self.make_state(meta)
                gef_print("  Unused chunks list: {}".format(repr(state)))

                # dump chunks
                if state != "F" or self.verbose:
                    dic = {"A": "Avail", "F": "Freed", "U": "Used"}
                    for i in range(meta.last_idx + 1):
                        offset = self.class_to_size(idx) * i
                        group = self.read_group(meta, offset)
                        self.dump_chunk(group, dic[state[-i - 1]])
                    gef_print("")

                seen.append(current)
                current = meta.next
        return

    @parse_args
    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, args):
        self.dont_repeat()

        self.verbose = args.verbose
        self.active_idx = args.idx

        ctx = self.read_ctx()
        if ctx is None:
            return
        if args.command == "ctx":
            self.print_ctx(ctx)
        elif args.command == "unused":
            self.print_meta(ctx)
        return


@register_command
class XphysAddrCommand(GenericCommand):
    """Dump physical memory via qemu-monitor."""
    _cmdline_ = "xp"
    _category_ = "08-a. Qemu-system Cooperation - General"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('option', metavar='OPTION', nargs='*', help='the argument of xp.')
    parser.add_argument('address', metavar='ADDRESS', type=parse_address, help='dump target address.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} /16xg 0x11223344".format(_cmdline_)

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, args):
        result = gdb.execute("monitor xp {:s} {:#x}".format(' '.join(args.option), args.address), to_string=True)
        gef_print(result.strip())
        return


@register_command
class XSecureMemAddrCommand(GenericCommand):
    """Dump secure memory via qemu-system memory map."""
    _cmdline_ = "xsm"
    _category_ = "08-c. Qemu-system Cooperation - TrustZone"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--phys', action='store_true', help='treat ADDRESS as physical address.')
    group.add_argument('--off', action='store_true', help='treat ADDRESS as offset of secure memory top.')
    group.add_argument('--virt', action='store_true', help='treat ADDRESS as virtual address.')
    parser.add_argument("format", metavar='/FMT', help='specified output format.')
    parser.add_argument('location', metavar='ADDRESS', type=parse_address, help='dump target address.')
    parser.add_argument('-v', dest='verbose', action='store_true', help='verbose output.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} /16xw --phys 0xe11e3d0  # absolute (physical/non-ASLR) address of secure memory\n".format(_cmdline_)
    _example_ += "{:s} /16xw --off 0x11e3d0    # the offset from secure memory area\n".format(_cmdline_)
    _example_ += "{:s} /16xw --virt 0x783ae3d0 # secure memory ASLR is supported".format(_cmdline_)

    @staticmethod
    def get_secure_memory_base_and_size(verbose=False):
        result = gdb.execute("monitor info mtree -f", to_string=True)
        for line in result.splitlines():
            m = re.search(r"([0-9a-f]{16})-([0-9a-f]{16}).*virt.secure-ram", line)
            if m:
                secure_memory_base = int(m.group(1), 16)
                secure_memory_size = int(m.group(2), 16) + 1 - secure_memory_base
                break
        else:
            return None, None
        if verbose:
            start = secure_memory_base
            end = secure_memory_base + secure_memory_size
            info("secure memory base: {:#x}-{:#x} ({:#x} bytes)".format(start, end, secure_memory_size))
        return secure_memory_base, secure_memory_size

    @staticmethod
    def get_secure_memory_qemu_map(secure_memory_base, secure_memory_size, verbose=False):
        qemu_system_pid = get_pid()
        if qemu_system_pid is None:
            err("Not found qemu-system pid")
            return None
        # fast path
        ret = gdb.execute("monitor gpa2hva {:#x}".format(secure_memory_base), to_string=True)
        r = re.search("is (0x[0-9a-f]+)", ret)
        if r:
            secure_memory_page_addr = int(r.group(1), 16)
            sm = process_lookup_address(secure_memory_page_addr)
            if sm:
                if verbose:
                    info("secure memory page of pid {:d}: {:#x}".format(qemu_system_pid, secure_memory_page_addr))
                return sm

        # slow path
        maps = get_process_maps_linux(qemu_system_pid)
        secure_memory_maps = [m for m in maps if m.size == secure_memory_size]
        if len(secure_memory_maps) == 1:
            if verbose:
                secure_memory_page_addr = secure_memory_maps[0].page_start
                info("secure memory page of pid {:d}: {:#x}".format(qemu_system_pid, secure_memory_page_addr))
            return secure_memory_maps[0]
        return None

    @staticmethod
    def virt2phys(vaddr, verbose=False): # vaddr -> addr1 or None
        maps = V2PCommand.get_maps(FORCE_PREFIX_S=True, verbose=verbose)
        if maps is None:
            return None
        for vstart, vend, pstart, pend in maps:
            if vstart <= vaddr < vend:
                offset = vaddr - vstart
                paddr = pstart + offset
                if verbose:
                    info("virt2phys: {:#x} -> {:#x}".format(vaddr, paddr))
                return paddr
        return None

    @staticmethod
    def phys2virt(paddr, verbose=False): # paddr -> [addr1, addr2, ...] or []
        maps = V2PCommand.get_maps(FORCE_PREFIX_S=True, verbose=verbose)
        if maps is None:
            return []
        result = []
        for vstart, vend, pstart, pend in maps:
            if pstart <= paddr < pend:
                offset = paddr - pstart
                vaddr = vstart + offset
                if verbose:
                    info("phys2virt: {:#x} -> {:#x}".format(paddr, vaddr))
                result.append(vaddr)
        return result

    @staticmethod
    def read_secure_memory(sm, offset, dump_size, verbose=False):
        qemu_system_pid = get_pid()
        if qemu_system_pid is None:
            err("Not found qemu-system pid")
            return None

        if dump_size > sm.size:
            dump_size = sm.size

        if verbose:
            info("target offset: {:#x}".format(offset))
            info("read address: {:#x}, size:{:#x}".format(sm.page_start + offset, dump_size))

        with open("/proc/{:d}/mem".format(qemu_system_pid), "rb") as fd:
            try:
                fd.seek(sm.page_start + offset, 0)
                data = fd.read(dump_size)
            except Exception:
                return None
        if verbose:
            info("read size result: {:#x}".format(len(data)))
        return data

    def print_secure_memory_x(self, target, data):
        for i, data16 in enumerate(slicer(data, 16)):
            addr = int(target) + i * 0x10
            data_units = slicer(data16, self.dump_unit)
            if self.dump_unit == 1:
                data_units_hex = ["{:#04x}".format(ord(x)) for x in data_units]
            elif self.dump_unit == 2:
                data_units_hex = ["{:#06x}".format(u16(x)) for x in data_units]
            elif self.dump_unit == 4:
                data_units_hex = ["{:#010x}".format(u32(x)) for x in data_units]
            elif self.dump_unit == 8:
                data_units_hex = ["{:#018x}".format(u64(x)) for x in data_units]
            gef_print("{:#018x}: {:s}".format(addr, ' '.join(data_units_hex)))
        return

    def print_secure_memory_i(self, target, data):
        kwargs = {}
        kwargs["code"] = data.hex()
        if is_arm32():
            kwargs["arch"] = "ARM"
            if target & 1:
                kwargs["mode"] = "THUMB"
            else:
                kwargs["mode"] = "ARM"
        elif is_arm64():
            kwargs["arch"] = "ARM64"
            kwargs["mode"] = "ARM"

        try:
            for insn in capstone_disassemble(target, self.dump_count, **kwargs):
                insn_fmt = "{:12o}"
                text_insn = insn_fmt.format(insn)
                msg = "{} {}".format(" " * 5, text_insn)
                gef_print(msg)
        except gdb.error:
            pass
        return

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["ARM32", "ARM64"])
    def do_invoke(self, args):
        self.dont_repeat()

        self.dump_type = "x"
        self.dump_unit = current_arch.ptrsize
        self.dump_count = 1
        if args.format:
            if args.format.startswith("/"):
                m = re.search(r"/(\d*)(\S*)", args.format)
                if m:
                    if m.group(1):
                        self.dump_count = int(m.group(1))
                    for c in m.group(2):
                        if c in ["x", "i"]:
                            self.dump_type = c
                        elif c in ["b", "h", "w", "g"]:
                            self.dump_unit = {"b": 1, "h": 2, "w": 4, "g": 8}[c]
                        else:
                            err("Unsupported format: {}".format(c))
                            return
        else:
            self.usage()
            return

        # initialize
        sm_base, sm_size = self.get_secure_memory_base_and_size(args.verbose)
        if sm_base is None or sm_size is None:
            err("Not found memory tree of secure memory (see monitor info mtree -f)")
            return
        sm = self.get_secure_memory_qemu_map(sm_base, sm_size, args.verbose)
        if sm is None:
            err("Not found secure memory maps")
            return

        # dump
        if args.phys:
            if sm_base <= args.location < sm_base + sm_size:
                target_offset = args.location - sm_base
            else:
                err("Phys {:#x} is not default secure memory (unsupported)".format(args.location))
                return
        elif args.off:
            if 0 <= args.location < sm_size:
                target_offset = args.location
            else:
                err("Offset {:#x} is not default secure memory (unsupported)".format(args.location))
                return
        elif args.virt:
            target_phys = self.virt2phys(args.location, args.verbose)
            if target_phys is None:
                err("Not found physical address")
                return
            if sm_base <= target_phys < sm_base + sm_size:
                target_offset = target_phys - sm_base
            else:
                err("Virt {:#x} is not default secure memory (unsupported)".format(args.location))
                return

        if self.dump_type == "x":
            dump_size = self.dump_count * self.dump_unit
        elif self.dump_type == "i":
            dump_size = self.dump_count * 4 # ARM opcode is at most 4byte
            if target_offset & 1:
                target_offset -= 1
        data = self.read_secure_memory(sm, target_offset, dump_size, args.verbose)
        if data is None:
            err("Read error")
            return

        # print
        if self.dump_type == "x":
            self.print_secure_memory_x(args.location, data)
        elif self.dump_type == "i":
            self.print_secure_memory_i(args.location, data)
        return


# The wsm command directly modifies /proc/<PID>/mem of qemu-system.
# However, even though the memory change was successful, it may not be reflected in the behavior of the code.
# I don't know the cause, but I'm guessing it's because qemu has an internal cache.
# Apparently setting a breakpoint ignores this cache, so setting a temporary breakpoint avoids this problem.
class TemporaryDummyBreakpoint(gdb.Breakpoint):
    """Create a breakpoint to avoid gdb cache problem"""
    def __init__(self):
        super().__init__("*{:#x}".format(0x0), type=gdb.BP_BREAKPOINT, internal=True, temporary=True)
        return

    def stop(self):
        return False


@register_command
class WSecureMemAddrCommand(GenericCommand):
    """Write secure memory via qemu-system memory map."""
    _cmdline_ = "wsm"
    _category_ = "08-c. Qemu-system Cooperation - TrustZone"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('mode', choices=['byte', 'short', 'dword', 'qword', 'string', 'hex'],
                        help='The mode that represents the value of the argument. You have to choose one or the other.')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--phys', action='store_true', help='treat ADDRESS as physical address.')
    group.add_argument('--off', action='store_true', help='treat ADDRESS as offset of secure memory top.')
    group.add_argument('--virt', action='store_true', help='treat ADDRESS as virtual address.')
    parser.add_argument('value', metavar='VALUE', help='write value.')
    parser.add_argument('location', metavar='ADDRESS', type=parse_address, help='write target address.')
    parser.add_argument('-v', dest='verbose', action='store_true', help='verbose output.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} dword 0x41414141 --phys 0xe11e3d0            # absolute (physical/non-ASLR) address of secure memory\n".format(_cmdline_)
    _example_ += '{:s} string "\\\\x41\\\\x41\\\\x41\\\\x41" --off 0x11e3d0 # the offset of secure memory\n'.format(_cmdline_)
    _example_ += '{:s} hex "4141 4141" --off 0x11e3d0               # hex string is supported (invalid character is ignored)\n'.format(_cmdline_)
    _example_ += "{:s} byte 0x41 --virt 0x783ae3d0                  # secure memory ASLR is supported".format(_cmdline_)

    @staticmethod
    def write_secure_memory(sm, offset, data, verbose=False):
        qemu_system_pid = get_pid()
        if qemu_system_pid is None:
            return None

        write_size = len(data)
        if write_size > sm.size:
            write_size = sm.size
            data = data[:write_size]

        if verbose:
            info("target offset: {:#x}".format(offset))
            info("write address: {:#x}, size:{:#x}".format(sm.page_start + offset, write_size))

        with open("/proc/{:d}/mem".format(qemu_system_pid), "r+b") as fd:
            try:
                fd.seek(sm.page_start + offset, 0)
                ret = fd.write(data)
            except Exception:
                return None
        if verbose:
            info("written size result: {:#x}".format(ret))

        # avoid qemu-system caches
        TemporaryDummyBreakpoint()

        # By default, "context code" uses gdb_disassemble.
        # However, due to gdb's internal cache, changes to secure memory may not be reflected in the disassembled results.
        # Therefore, if capstone is available, change it to disassemble by capstone.
        if get_gef_setting("context.use_capstone") is False:
            set_gef_setting("context.use_capstone", True)
        return ret

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["ARM32", "ARM64"])
    def do_invoke(self, args):
        self.dont_repeat()

        try:
            if args.mode == "byte":
                data = p8(int(args.value, 0))
            elif args.mode == "short":
                data = p16(int(args.value, 0))
            elif args.mode == "dword":
                data = p32(int(args.value, 0))
            elif args.mode == "qword":
                data = p64(int(args.value, 0))
            elif args.mode == "string":
                try:
                    data = codecs.escape_decode(args.value)[0]
                except binascii.Error:
                    gef_print("Could not decode '\\xXX' encoded string")
                    return
            elif args.mode == "hex":
                _data = ""
                for c in args.value.lower():
                    if c in '0123456789abcdef':
                        _data += c
                data = bytes.fromhex(_data)
        except Exception:
            self.usage()
            return

        # initialize
        sm_base, sm_size = XSecureMemAddrCommand.get_secure_memory_base_and_size(args.verbose)
        if sm_base is None or sm_size is None:
            err("Not found memory tree of secure memory (see monitor info mtree -f)")
            return
        sm = XSecureMemAddrCommand.get_secure_memory_qemu_map(sm_base, sm_size, args.verbose)
        if sm is None:
            err("Not found secure memory maps")
            return

        # write
        if args.phys:
            if sm_base <= args.location < sm_base + sm_size:
                target_offset = args.location - sm_base
            else:
                err("Phys {:#x} is not default secure memory (unsupported)".format(args.location))
                return
        elif args.off:
            if 0 <= args.location < sm_size:
                target_offset = args.location
            else:
                err("Offset {:#x} is not default secure memory (unsupported)".format(args.location))
                return
        elif args.virt:
            target_phys = XSecureMemAddrCommand.virt2phys(args.location, args.verbose)
            if target_phys is None:
                err("Not found physical address")
                return
            if sm_base <= target_phys < sm_base + sm_size:
                target_offset = target_phys - sm_base
            else:
                err("Virt {:#x} is not default secure memory (unsupported)".format(args.location))
                return
        ret = self.write_secure_memory(sm, target_offset, data, args.verbose)
        if ret is None:
            err("Write memory error")
        return


@register_command
class BreakSecureMemAddrCommand(GenericCommand):
    """Set a breakpoint in virtual memory by specifying the physical memory of the secure world."""
    _cmdline_ = "bsm"
    _category_ = "08-c. Qemu-system Cooperation - TrustZone"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('location', metavar='PHYS_ADDRESS', type=parse_address,
                        help='the target physical address you want to set a breakpoint.')
    parser.add_argument('-v', dest='verbose', action='store_true', help='verbose output.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} 0xe1008d8".format(_cmdline_)

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["ARM32", "ARM64"])
    def do_invoke(self, args):
        self.dont_repeat()
        if args.verbose:
            info("phys address: {:#x}".format(args.location))
        virt_addrs = XSecureMemAddrCommand.phys2virt(args.location, args.verbose)
        for virt_addr in virt_addrs:
            gdb.execute("break *{:#x}".format(virt_addr))
        return


class OpteeThreadEnterUserModeBreakpoint(gdb.Breakpoint):
    """Create a breakpoint to thread_enter_user_mode"""
    def __init__(self, vaddr, ta_offset):
        super().__init__("*{:#x}".format(vaddr), type=gdb.BP_BREAKPOINT, internal=True)
        self.count = 0
        self.ta_offset = ta_offset
        return

    @staticmethod
    def get_ta_loaded_address():
        if is_arm32():
            res = get_maps_by_pagewalk("pagewalk -q -S")
            res = sorted(set(res.splitlines()))
            res = list(filter(lambda line: "PL0/R-X" in line, res))
        elif is_arm64():
            res = get_maps_by_pagewalk("pagewalk 1 -q")
            res = sorted(set(res.splitlines()))
            res = list(filter(lambda line: "EL0/R-X" in line, res))
        maps = []
        for line in res:
            vrange, prange, *_ = line.split()
            vstart, vend = [int(x, 16) for x in vrange.split("-")]
            pstart, pend = [int(x, 16) for x in prange.split("-")]
            maps.append((vstart, vend, pstart, pend))
        if len(maps) == 2:
            return maps[1]
        else:
            return None

    def stop(self):
        if self.count != 1:
            self.count += 1
            return False

        ta_address = self.get_ta_loaded_address()
        if ta_address is None:
            err("TA address is not found")
            self.enabled = False
            return False

        ta_vstart, ta_vend, _, _ = ta_address
        info("TA address: {:#x}".format(ta_vstart))

        ta_vsize = ta_vend - ta_vstart
        if self.ta_offset >= ta_vsize:
            err("TA offset {:#x} is greater than the size of TA R-X area ({:#x})".format(self.ta_offset, ta_vsize))
            self.enabled = False
            return False

        gdb.execute("break *{:#x}".format(ta_vstart + self.ta_offset))
        self.enabled = False
        return False


@register_command
class OpteeBreakTaAddrCommand(GenericCommand):
    """Set a breakpoint to OPTEE-TA."""
    _cmdline_ = "optee-break-ta"
    _category_ = "08-c. Qemu-system Cooperation - TrustZone"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('thread_enter_user_mode', metavar='PHYS_ADDR_thread_enter_user_mode', type=parse_address,
                        help='The physical address of `thread_enter_user_mode` in OPTEE-OS.')
    parser.add_argument('ta_offset', metavar='TA_OFFSET', type=parse_address,
                        help="The breakpoint target offset of OPTEE-TA.")
    parser.add_argument('-v', dest='verbose', action='store_true', help='verbose output.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} 0xe137c78 0x2784".format(_cmdline_)

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["ARM32", "ARM64"])
    def do_invoke(self, args):
        self.dont_repeat()

        if args.verbose:
            info("thread_enter_user_mode @ OPTEE-OS: {:#x}".format(args.thread_enter_user_mode))
            info("breakpoint target offset of TA: {:#x}".format(args.ta_offset))

        thread_enter_user_mode_virt = XSecureMemAddrCommand.phys2virt(args.thread_enter_user_mode, args.verbose)

        for vaddr in thread_enter_user_mode_virt:
            OpteeThreadEnterUserModeBreakpoint(vaddr, args.ta_offset)
            info("Temporarily breakpoint at {:#x}".format(vaddr))
        return


@register_command
class OpteeBgetDumpCommand(GenericCommand):
    """Dump bget allocator of OPTEE-Trusted-App."""
    _cmdline_ = "optee-bget-dump"
    _category_ = "08-c. Qemu-system Cooperation - TrustZone"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('malloc_ctx', metavar='OFFSET_malloc_ctx', type=parse_address,
                        help='The offset of `malloc_ctx` at OPTEE-TA.')
    parser.add_argument('-v', dest='verbose', action='store_true', help='verbose output.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} 0x2a408\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "Simplified heap structure\n"
    _example_ += "+-malloc_ctx-------------------+         +-free-ed chunk----------+\n"
    _example_ += "| bufsize prevfree             |<--+ +-->| bufsize prevfree       |= 0 (if upper chunk is used)  +--> ...\n"
    _example_ += "| bufsize bsize                |   | |   | bufsize bsize          |= the size of this chunk      |\n"
    _example_ += "| struct bfhead *flink         |-----+   | struct bfhead *flink   |------------------------------+\n"
    _example_ += "| struct bfhead *blink         |   +-----| struct bfhead *blink   |\n"
    _example_ += "| (bufsize totalloc)           |         |                        |\n"
    _example_ += "| (long numget)                |         |                        |\n"
    _example_ += "| (long numrel)                |         |                        |\n"
    _example_ += "| (long numpblk)               |         +-used chunk-------------+\n"
    _example_ += "| (long numpget)               |         | bufsize prevfree       |= the size of upper chunk (if upper chunk is free-ed)\n"
    _example_ += "| (long numprel)               |         | bufsize bsize          |= the size of this chunk (negative number)\n"
    _example_ += "| (long numdget)               |         | uchar user_data[bsize] |\n"
    _example_ += "| (long numdrel)               |         |                        |\n"
    _example_ += "| (func_ptr compfcn)           |         |                        |\n"
    _example_ += "| (func_ptr acqfcn)            |         +------------------------+\n"
    _example_ += "| (func_ptr relfcn)            |\n"
    _example_ += "| (bufsize exp_incr)           |\n"
    _example_ += "| (bufsize pool_len)           |\n"
    _example_ += "| struct malloc_pool* pool     |\n"
    _example_ += "| size_t pool_len              |\n"
    _example_ += "| (struct malloc_stats mstats) |\n"
    _example_ += "+------------------------------+"

    def is_readable_virt_memory(self, addr):
        if is_arm32():
            res = get_maps_by_pagewalk("pagewalk -q -S")
            res = sorted(set(res.splitlines()))
            res = list(filter(lambda line: "PL0/RW-" in line, res))
        elif is_arm64():
            res = get_maps_by_pagewalk("pagewalk 1 -q")
            res = sorted(set(res.splitlines()))
            res = list(filter(lambda line: "EL0/RW-" in line, res))
        for line in res:
            vrange, prange, *_ = line.split()
            vstart, vend = [int(x, 16) for x in vrange.split("-")]
            pstart, pend = [int(x, 16) for x in prange.split("-")]
            if vstart <= addr < vend:
                return True
        return False

    def parse_flink(self, head):
        current = head
        flinks = []
        seen = [current]
        while True:
            try:
                prevfree = read_int_from_memory(current + current_arch.ptrsize * 0)
                bsize = read_int_from_memory(current + current_arch.ptrsize * 1)
                flink = read_int_from_memory(current + current_arch.ptrsize * 2)
                blink = read_int_from_memory(current + current_arch.ptrsize * 3)
                next_prevfree = read_int_from_memory(current + bsize)
                next_bsize = read_int_from_memory(current + bsize + current_arch.ptrsize)
            except Exception:
                flinks.append("memory corrupted")
                break
            if flink % 8 or blink % 8 or bsize % 8 or next_prevfree % 8 or next_bsize % 8:
                flinks.append("unaligned corrupted")
                break
            _chunk = {"addr": current, "prevfree": prevfree, "bsize": bsize, "flink": flink, "blink": blink,
                      "next_prevfree": next_prevfree, "next_bsize": next_bsize}
            Chunk = collections.namedtuple("Chunk", _chunk.keys())
            flinks.append(Chunk(*_chunk.values()))
            if flink == head:
                break
            if flink in seen[1:]:
                flinks.append("loop detected")
                break
            seen.append(current)
            current = flink
        return flinks

    def parse_blink(self, head):
        current = head
        blinks = []
        seen = [current]
        while True:
            try:
                prevfree = read_int_from_memory(current + current_arch.ptrsize * 0)
                bsize = read_int_from_memory(current + current_arch.ptrsize * 1)
                flink = read_int_from_memory(current + current_arch.ptrsize * 2)
                blink = read_int_from_memory(current + current_arch.ptrsize * 3)
                next_prevfree = read_int_from_memory(current + bsize)
                next_bsize = read_int_from_memory(current + bsize + current_arch.ptrsize)
            except Exception:
                blinks.append("memory corrupted")
                break
            if flink % 8 or blink % 8 or bsize % 8 or next_prevfree % 8 or next_bsize % 8:
                blinks.append("unaligned corrupted")
                break
            _chunk = {"addr": current, "prevfree": prevfree, "bsize": bsize, "flink": flink, "blink": blink,
                      "next_prevfree": next_prevfree, "next_bsize": next_bsize}
            Chunk = collections.namedtuple("Chunk", _chunk.keys())
            blinks.append(Chunk(*_chunk.values()))
            if blink == head:
                break
            if blink in seen[1:]:
                blinks.append("loop detected")
                break
            seen.append(current)
            current = blink
        return blinks

    def parse_malloc_ctx(self, malloc_ctx_addr):
        _malloc_ctx = {}
        _malloc_ctx["addr"] = current = malloc_ctx_addr

        _malloc_ctx["prevfree"] = read_int_from_memory(current)
        current += current_arch.ptrsize
        _malloc_ctx["bsize"] = read_int_from_memory(current)
        current += current_arch.ptrsize
        _malloc_ctx["flink"] = read_int_from_memory(current)
        _malloc_ctx["flink_list"] = self.parse_flink(_malloc_ctx["flink"])
        current += current_arch.ptrsize
        _malloc_ctx["blink"] = read_int_from_memory(current)
        _malloc_ctx["blink_list"] = self.parse_blink(_malloc_ctx["blink"])
        current += current_arch.ptrsize

        # search pool
        for i in range(14):
            pool_candidate = read_int_from_memory(current)
            current += current_arch.ptrsize
            if self.is_readable_virt_memory(pool_candidate):
                _malloc_ctx["pool"] = pool_candidate
                break
        else:
            err("Not found malloc_ctx->pool")
            return None

        _malloc_ctx["pool_len"] = read_int_from_memory(current)
        current += current_arch.ptrsize

        _malloc_ctx["pool_list"] = []
        for i in range(_malloc_ctx["pool_len"]):
            buf = read_int_from_memory(_malloc_ctx["pool"] + (i * 2) * current_arch.ptrsize)
            size = read_int_from_memory(_malloc_ctx["pool"] + (i * 2 + 1) * current_arch.ptrsize)
            _pool = {"buf": buf, "len": size}
            Pool = collections.namedtuple("Pool", _pool.keys())
            _malloc_ctx["pool_list"].append(Pool(*_pool.values()))

        MallocCtx = collections.namedtuple("MallocCtx", _malloc_ctx.keys())
        return MallocCtx(*_malloc_ctx.values())

    def print_malloc_ctx(self, malloc_ctx):
        gef_print(titlify("malloc_ctx @ {:#x}".format(malloc_ctx.addr)))
        gef_print("prevfree: {:#x}".format(malloc_ctx.prevfree))
        gef_print("bsize:    {:#x}".format(malloc_ctx.bsize))
        gef_print("flink:    {:#x}".format(malloc_ctx.flink))
        for chunk in malloc_ctx.flink_list:
            if isinstance(chunk, str):
                gef_print("  -> {:s}".format(Color.colorify(chunk, "bold red")))
            else:
                chunk_addr = Color.colorify("{:#010x}".format(chunk.addr), "bold yellow")
                fmt = "  -> {:s}: (prevfree:{:#x}  bsize:{:#010x}  flink:{:#010x}  blink:{:#010x}"
                fmt += "  next_prevfree:{:#010x}  next_bsize:{:#010x}({:#010x}))"
                gef_print(fmt.format(chunk_addr, chunk.prevfree, chunk.bsize, chunk.flink, chunk.blink,
                                     chunk.next_prevfree, chunk.next_bsize, (-chunk.next_bsize) & 0xffffffff))
        gef_print("blink:    {:#x}".format(malloc_ctx.blink))
        for chunk in malloc_ctx.blink_list:
            if isinstance(chunk, str):
                gef_print("  -> {:s}".format(Color.colorify(chunk, "bold red")))
            else:
                chunk_addr = Color.colorify("{:#010x}".format(chunk.addr), "bold yellow")
                fmt = "  -> {:s}: (prevfree:{:#x}  bsize:{:#010x}  flink:{:#010x}  blink:{:#010x}"
                fmt += "  next_prevfree:{:#010x}  next_bsize:{:#010x}({:#010x}))"
                gef_print(fmt.format(chunk_addr, chunk.prevfree, chunk.bsize, chunk.flink, chunk.blink,
                                     chunk.next_prevfree, chunk.next_bsize, (-chunk.next_bsize) & 0xffffffff))
        gef_print("pool:     {:#x}".format(malloc_ctx.pool))
        gef_print("pool_len: {:#x}".format(malloc_ctx.pool_len))

        for i in range(malloc_ctx.pool_len):
            pool = malloc_ctx.pool_list[i]
            gef_print("  pool[{:d}]  buf:{:#x}  size:{:#x}".format(i, pool.buf, pool.len))
        return

    def print_chunk_list(self, malloc_ctx):
        for i in range(malloc_ctx.pool_len):
            pool = malloc_ctx.pool_list[i]
            pool_start = pool.buf
            pool_end = pool.buf + pool.len
            gef_print(titlify("pool[{:d}] @ {:#x} - {:#x}".format(i, pool_start, pool_end)))

            chunk = pool_start
            used = Color.colorify("used", "green underline")
            freed = Color.colorify("free", "bold grey")
            seen = []
            while chunk < pool_end:
                if chunk in seen:
                    gef_print(Color.colorify("loop detected", "bold red"))
                    break
                seen.append(chunk)
                try:
                    prevfree = read_int_from_memory(chunk + current_arch.ptrsize * 0)
                    bsize = read_int_from_memory(chunk + current_arch.ptrsize * 1)
                    flink = read_int_from_memory(chunk + current_arch.ptrsize * 2)
                    blink = read_int_from_memory(chunk + current_arch.ptrsize * 3)
                except Exception:
                    gef_print(Color.colorify("unaligned orrupted", "bold red"))
                    break
                chunk_addr = Color.colorify("{:#010x}".format(chunk), "bold yellow")
                bsize_inv = (-bsize) & 0xffffffff
                if bsize_inv < 0x80000000: # used
                    fmt = "{:s} {:s}: prevfree:{:#010x}  bsize:{:#010x}({:#010x})"
                    gef_print(fmt.format(used, chunk_addr, prevfree, bsize, bsize_inv))
                    chunk += bsize_inv
                else: # freed
                    fmt = "{:s} {:s}: prevfree:{:#010x}  bsize:{:#010x}              flink:{:#010x}  blink:{:#010x}"
                    gef_print(fmt.format(freed, chunk_addr, prevfree, bsize, flink, blink))
                    chunk += bsize
                if chunk % 8:
                    gef_print(Color.colorify("unaligned orrupted", "bold red"))
                    break
            return

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["ARM32", "ARM64"])
    def do_invoke(self, args):
        self.dont_repeat()

        if args.verbose:
            info("offset of malloc_ctx: {:#x}".format(args.malloc_ctx))

        ta_address_map = OpteeThreadEnterUserModeBreakpoint.get_ta_loaded_address()
        if ta_address_map is None:
            err("TA address is not found")
            return

        ta_address = ta_address_map[0]
        if args.verbose:
            info("TA loaded address: {:#x}".format(ta_address))

        malloc_ctx_addr = ta_address + args.malloc_ctx
        if args.verbose:
            info("malloc_ctx: {:#x}".format(malloc_ctx_addr))

        malloc_ctx = self.parse_malloc_ctx(malloc_ctx_addr)
        if malloc_ctx is None:
            err("parse failed")
            return

        self.print_malloc_ctx(malloc_ctx)
        self.print_chunk_list(malloc_ctx)
        return


@register_command
class CpuidCommand(GenericCommand):
    """Get cpuid result."""
    _cmdline_ = "cpuid"
    _category_ = "04-a. Register - View"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    _example_ = "{:s}\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "DISABLE `-enable-kvm` option for qemu-system; This command will be aborted if the option is set"

    def get_state(self, code_len):
        d = {}
        d["pc"] = get_register("$pc")
        d["code"] = read_memory(d["pc"], code_len)
        if is_x86_64():
            d["rax"] = get_register("$rax")
            d["rbx"] = get_register("$rbx")
            d["rdx"] = get_register("$rdx")
            d["rcx"] = get_register("$rcx")
        else:
            d["eax"] = get_register("$eax")
            d["ebx"] = get_register("$ebx")
            d["edx"] = get_register("$edx")
            d["ecx"] = get_register("$ecx")
        return d

    def revert_state(self, d):
        write_memory(d["pc"], d["code"], len(d["code"]))
        gdb.execute("set $pc = {:#x}".format(d["pc"]), to_string=True)
        if is_x86_64():
            gdb.execute("set $rax = {:#x}".format(d["rax"]), to_string=True)
            gdb.execute("set $rbx = {:#x}".format(d["rbx"]), to_string=True)
            gdb.execute("set $rdx = {:#x}".format(d["rdx"]), to_string=True)
            gdb.execute("set $rcx = {:#x}".format(d["rcx"]), to_string=True)
        else:
            gdb.execute("set $eax = {:#x}".format(d["eax"]), to_string=True)
            gdb.execute("set $ebx = {:#x}".format(d["ebx"]), to_string=True)
            gdb.execute("set $edx = {:#x}".format(d["edx"]), to_string=True)
            gdb.execute("set $ecx = {:#x}".format(d["ecx"]), to_string=True)
        return

    def close_stdout(self):
        self.stdout = 1
        self.stdout_bak = os.dup(self.stdout)
        f = open("/dev/null")
        os.dup2(f.fileno(), self.stdout)
        f.close()
        return

    def revert_stdout(self):
        os.dup2(self.stdout_bak, self.stdout)
        os.close(self.stdout_bak)
        return

    def execute_cpuid(self, num, subnum=0):
        code = b"\xeb\xfe\x0f\xa2" # inf-loop (to stop another thread); cpuid
        gef_on_stop_unhook(hook_stop_handler)
        d = self.get_state(len(code))
        write_memory(d["pc"], code, len(code))
        if is_x86_64():
            gdb.execute("set $rax = {:#x}".format(num), to_string=True)
            gdb.execute("set $rcx = {:#x}".format(subnum), to_string=True)
        else:
            gdb.execute("set $eax = {:#x}".format(num), to_string=True)
            gdb.execute("set $ecx = {:#x}".format(subnum), to_string=True)
        gdb.execute("set $pc = {:#x}".format(d["pc"] + 2), to_string=True) # skip "\xeb\xfe"
        self.close_stdout()
        gdb.execute("stepi", to_string=True)
        self.revert_stdout()
        eax = get_register("$eax") & 0xffffffff
        ebx = get_register("$ebx") & 0xffffffff
        ecx = get_register("$ecx") & 0xffffffff
        edx = get_register("$edx") & 0xffffffff
        self.revert_state(d)
        gef_on_stop_hook(hook_stop_handler)
        return eax, ebx, ecx, edx

    def show_result(self, id, subid, eax, ebx, ecx, edx):
        if eax == ebx == ecx == edx == 0:
            return

        if subid is None:
            info("cpuid (eax={:#x})".format(id))
        else:
            info("cpuid (eax={:#x}, ecx={:#x})".format(id, subid))
        gef_print(Color.colorify("    eax={:#x}, ebx={:#x}, ecx={:#x}, edx={:#x}".format(eax, ebx, ecx, edx), "bold yellow"))

        def c(reg, shift, mask, msg):
            val = (reg >> shift) & mask
            msg = msg + " (={:#x})".format(val)
            if val:
                return Color.boldify(msg)
            else:
                return msg

        if id == 0:
            vid = (p32(ebx) + p32(edx) + p32(ecx)).decode("utf-8")
            gef_print("    eax: Maximum Input Value for Basic CPUID Information")
            gef_print("    ebx+edx+ecx: Vendor ID (={:s})".format(repr(vid)))
        elif id == 1:
            gef_print("    eax: Version Information")
            gef_print(c(eax,  0, 0xf,        "        EAX  3- 0: Stepping ID"))
            gef_print(c(eax,  4, 0xf,        "        EAX  7- 4: Model Number"))
            gef_print(c(eax,  8, 0xf,        "        EAX 11- 8: Family Code"))
            gef_print(c(eax, 12, 0b11,       "        EAX 13-12: Processor Type"))
            gef_print(c(eax, 14, 0b11,       "        EAX 15-14: Reserved"))
            gef_print(c(eax, 16, 0xf,        "        EAX 19-16: Extended Model"))
            gef_print(c(eax, 20, 0xff,       "        EAX 27-20: Extended Family"))
            gef_print(c(eax, 28, 0xf,        "        EAX 31-28: Reserved"))
            gef_print("    ebx: Additional Information")
            gef_print(c(ebx,  0, 0xff,       "        EBX  7- 0: Brand Index"))
            gef_print(c(ebx,  8, 0xff,       "        EBX 15- 8: CLFLUSH line size"))
            gef_print(c(ebx, 16, 0xff,       "        EBX 23-16: The number of logical processors"))
            gef_print(c(ebx, 24, 0xff,       "        EBX 31-24: Initial APIC ID"))
            gef_print("    edx,ecx: Feature Information")
            gef_print(c(edx,  0, 1,          "        EDX     0: FPU (Floating Point Unit on-chip)"))
            gef_print(c(edx,  1, 1,          "        EDX     1: VME (Virtual 8086 Mode Enhancements)"))
            gef_print(c(edx,  2, 1,          "        EDX     2: DE (Debugging Extensions)"))
            gef_print(c(edx,  3, 1,          "        EDX     3: PSE (Page Size Extension)"))
            gef_print(c(edx,  4, 1,          "        EDX     4: TSC (Time Stamp Counter)"))
            gef_print(c(edx,  5, 1,          "        EDX     5: MSR (Model Specific Registers RDMSR and WRMSR instructions)"))
            gef_print(c(edx,  6, 1,          "        EDX     6: PAE (Physical Address Extension)"))
            gef_print(c(edx,  7, 1,          "        EDX     7: MCE (Machine Check Exception)"))
            gef_print(c(edx,  8, 1,          "        EDX     8: CX8 (CMPXCHG8B instruction)"))
            gef_print(c(edx,  9, 1,          "        EDX     9: APIC (APIC on-chip)"))
            gef_print(c(edx, 10, 1,          "        EDX    10: Reserved"))
            gef_print(c(edx, 11, 1,          "        EDX    11: SEP (SYSENTER and SYSEXIT instructions)"))
            gef_print(c(edx, 12, 1,          "        EDX    12: MTRR (Memory Type Range Registers)"))
            gef_print(c(edx, 13, 1,          "        EDX    13: PGE (Page Global Bit)"))
            gef_print(c(edx, 14, 1,          "        EDX    14: MCA (Machine Check Architecture)"))
            gef_print(c(edx, 15, 1,          "        EDX    15: CMOV (Conditional Move instructions)"))
            gef_print(c(edx, 16, 1,          "        EDX    16: PAT (Page Attribute Table)"))
            gef_print(c(edx, 17, 1,          "        EDX    17: PSE-36 (36-Bit Page Size Extension)"))
            gef_print(c(edx, 18, 1,          "        EDX    18: PSN (Processor Serial Number)"))
            gef_print(c(edx, 19, 1,          "        EDX    19: CLFSH (CLFLUSH instruction)"))
            gef_print(c(edx, 20, 1,          "        EDX    20: Reserved"))
            gef_print(c(edx, 21, 1,          "        EDX    21: DS (Debug Store)"))
            gef_print(c(edx, 22, 1,          "        EDX    22: ACPI (Thermal Monitor and Software Controlled Clock Facilities)"))
            gef_print(c(edx, 23, 1,          "        EDX    23: MMX (Intel MMX technology)"))
            gef_print(c(edx, 24, 1,          "        EDX    24: FXSR (FXSAVE and FXRSTOR instructions)"))
            gef_print(c(edx, 25, 1,          "        EDX    25: SSE (Streaming SIMD Extension)"))
            gef_print(c(edx, 26, 1,          "        EDX    26: SSE2 (STreaming SIMD Extension 2)"))
            gef_print(c(edx, 27, 1,          "        EDX    27: SS (Self Snoop)"))
            gef_print(c(edx, 28, 1,          "        EDX    28: HTT (Max APIC IDs reserved field is Valid)"))
            gef_print(c(edx, 29, 1,          "        EDX    29: TM (Thermal Monitor)"))
            gef_print(c(edx, 30, 1,          "        EDX    30: Reserved"))
            gef_print(c(edx, 31, 1,          "        EDX    31: PBE (Pending Break Enable)"))
            gef_print(c(ecx,  0, 1,          "        ECX     0: SSE3 (Streaming SIMD Extensions 3)"))
            gef_print(c(ecx,  1, 1,          "        ECX     1: PCLMULQDQ (PCLMULQDQ instruction)"))
            gef_print(c(ecx,  2, 1,          "        ECX     2: DTES64 (64-bit DS Area)"))
            gef_print(c(ecx,  3, 1,          "        ECX     3: MONITOR (MONITOR/MWAIT instruction)"))
            gef_print(c(ecx,  4, 1,          "        ECX     4: DS-CPL (CPL Qualified Debug Store)"))
            gef_print(c(ecx,  5, 1,          "        ECX     5: VMX (Intel VT (Virtual Machine eXtensions))"))
            gef_print(c(ecx,  6, 1,          "        ECX     6: SMX (Safer Mode eXtensions)"))
            gef_print(c(ecx,  7, 1,          "        ECX     7: EIST (Enhanced Intel SpeedStep Technology)"))
            gef_print(c(ecx,  8, 1,          "        ECX     8: TM2 (Thermal Monitor 2)"))
            gef_print(c(ecx,  9, 1,          "        ECX     9: SSSE3 (Supplemental Streaming SIMD Extensions 3)"))
            gef_print(c(ecx, 10, 1,          "        ECX    10: CNXT-ID (L1 Context ID)"))
            gef_print(c(ecx, 11, 1,          "        ECX    11: SDBG (IA32_DEBUG_INTERFACE MSR for silicon debug)"))
            gef_print(c(ecx, 12, 1,          "        ECX    12: FMA (FMA extensions using YMM state)"))
            gef_print(c(ecx, 13, 1,          "        ECX    13: CMPXCHG16B (CMPXCHG16B instruction)"))
            gef_print(c(ecx, 14, 1,          "        ECX    14: xTPR (xTPR update control)"))
            gef_print(c(ecx, 15, 1,          "        ECX    15: PDCM (Perfmon and Debug Capability MSR)"))
            gef_print(c(ecx, 16, 1,          "        ECX    16: Reserved"))
            gef_print(c(ecx, 17, 1,          "        ECX    17: PCID (Process-Context IDentifiers)"))
            gef_print(c(ecx, 18, 1,          "        ECX    18: DCA (Direct Cache Access)"))
            gef_print(c(ecx, 19, 1,          "        ECX    19: SSE4_1 (Streaming SIMD Extensions 4.1)"))
            gef_print(c(ecx, 20, 1,          "        ECX    20: SSE4_2 (Streaming SIMD Extensions 4.2)"))
            gef_print(c(ecx, 21, 1,          "        ECX    21: x2APIC"))
            gef_print(c(ecx, 22, 1,          "        ECX    22: MOVBE (MOVBE instruction)"))
            gef_print(c(ecx, 23, 1,          "        ECX    23: POPCNT (POPulation CouNt instruction)"))
            gef_print(c(ecx, 24, 1,          "        ECX    24: TSC-Deadline"))
            gef_print(c(ecx, 25, 1,          "        ECX    25: AESNI (AESNI Instruction)"))
            gef_print(c(ecx, 26, 1,          "        ECX    26: XSAVE (XSAVE instruction)"))
            gef_print(c(ecx, 27, 1,          "        ECX    27: OSXSAVE (OSXSAVE instruction)"))
            gef_print(c(ecx, 28, 1,          "        ECX    28: AVX (Intel Advanced Vector eXtensions)"))
            gef_print(c(ecx, 29, 1,          "        ECX    29: F16C (16-bit Floating-point Conversion instructions)"))
            gef_print(c(ecx, 30, 1,          "        ECX    30: RDRAND (RDRAND instruction)"))
            gef_print(c(ecx, 31, 1,          "        ECX    31: RAZ (Reserved for use by hypervisor to indicate guest status)"))
        elif id == 2:
            gef_print("    Cache and TLB Information")
        elif id == 3:
            gef_print("    eax,ebx: Reserved")
            gef_print("    edx+ecx: Processor Serial Number")
        elif id == 4:
            gef_print("    Information of cache configuration descriptor")
        elif id == 5:
            gef_print("    Information of MONITOR/MWAIT")
        elif id == 6:
            gef_print("    Information of power management")
            gef_print(c(eax,  0, 1,          "        EAX     0: Digital temperature sensor"))
            gef_print(c(eax,  1, 1,          "        EAX     1: Intel Turbo Boost Technology"))
            gef_print(c(eax,  2, 1,          "        EAX     2: ARAT (Always Running APIC Timer)"))
            gef_print(c(eax,  3, 1,          "        EAX     3: Reserved"))
            gef_print(c(eax,  4, 1,          "        EAX     4: Power limit notification controls"))
            gef_print(c(eax,  5, 1,          "        EAX     5: Clock modulation duty cycle extensions"))
            gef_print(c(eax,  6, 1,          "        EAX     6: Package thermal management"))
            gef_print(c(eax,  7, 1,          "        EAX     7: Hardware-managed P-state base support (HWP)"))
            gef_print(c(eax,  8, 1,          "        EAX     8: HWP notification interrupt enable MSR"))
            gef_print(c(eax,  9, 1,          "        EAX     9: HWP activity window MSR"))
            gef_print(c(eax, 10, 1,          "        EAX    10: HWP energy/performance preference MSR"))
            gef_print(c(eax, 11, 1,          "        EAX    11: HWP package level request MSR"))
            gef_print(c(eax, 12, 1,          "        EAX    12: Reserved"))
            gef_print(c(eax, 13, 1,          "        EAX    13: HDC (Hardware Duty Cycle programming)"))
            gef_print(c(eax, 14, 1,          "        EAX    14: Intel Turbo Boost Max Technology 3.0"))
            gef_print(c(eax, 15, 1,          "        EAX    15: HWP Capabilities, Highest Performance change"))
            gef_print(c(eax, 16, 1,          "        EAX    16: HWP PECI override"))
            gef_print(c(eax, 17, 1,          "        EAX    17: Flexible HWP"))
            gef_print(c(eax, 18, 1,          "        EAX    18: Fast access mode for IA32_HWP_REQUEST MSR"))
            gef_print(c(eax, 19, 1,          "        EAX    19: Hardware feedback MSRs"))
            gef_print(c(eax, 20, 1,          "        EAX    20: Ignoring Idle Logical Processor HWP request"))
            gef_print(c(eax, 21, 1,          "        EAX    21: Reserved"))
            gef_print(c(eax, 22, 1,          "        EAX    22: Reserved"))
            gef_print(c(eax, 23, 1,          "        EAX    23: Enhanced hardware feedback MSRs"))
            gef_print(c(eax, 24, 0x7f,       "        EAX 30-24: Reserved"))
            gef_print(c(eax, 31, 1,          "        EAX    31: IP payloads are LIP"))
            gef_print(c(ebx,  0, 0xf,        "        EBX  3- 0: Number of interrupted thresholds of digital temperature sensor"))
            gef_print(c(ebx,  4, 0xfffffff,  "        EBX 31- 4: Reserved"))
            gef_print(c(ecx,  0, 1,          "        ECX     0: Hardware Coordination Feedback Capability (APERF and MPERF)"))
            gef_print(c(ecx,  1, 1,          "        ECX     1: Reserved"))
            gef_print(c(ecx,  2, 1,          "        ECX     2: Reserved"))
            gef_print(c(ecx,  3, 1,          "        ECX     3: Performance-energy bias preference"))
            gef_print(c(ecx,  4, 0xfffffff,  "        ECX 31- 4: Reserved"))
            gef_print(c(edx,  0, 1,          "        EDX     0: Performance feature report"))
            gef_print(c(edx,  1, 1,          "        EDX     1: Energy efficiency capacity report"))
            gef_print(c(edx,  2, 0x3f,       "        EDX  7- 2: Reserved"))
            gef_print(c(edx,  8, 0xf,        "        EDX 11- 8: The size of the hardware feedback interface structure"))
            gef_print(c(edx, 12, 0xf,        "        EDX 15-12: Reserved"))
            gef_print(c(edx, 16, 0xffff,     "        EDX 31-16: Index of rows for the hardware feedback interface structure"))
        elif id == 7 and subid == 0:
            gef_print("    eax: Maximum Input Value for Extended CPUID Information")
            gef_print("    ebx,edx,edx: Extended Feature Information")
            gef_print(c(ebx,  0, 1,          "        EBX     0: FSGSBASE (FSGSBASE instructions)"))
            gef_print(c(ebx,  1, 1,          "        EBX     1: TSC_ADJUST (IA32_TSC_ADJUST MSR supported)"))
            gef_print(c(ebx,  2, 1,          "        EBX     2: SGX (Software Guard Extensions)"))
            gef_print(c(ebx,  3, 1,          "        EBX     3: BMI1 (Bit Manipulation Instructions)"))
            gef_print(c(ebx,  4, 1,          "        EBX     4: HLE (Hardware Lock Elision)"))
            gef_print(c(ebx,  5, 1,          "        EBX     5: AVX2 (Advanced Vector Extensions 2.0)"))
            gef_print(c(ebx,  6, 1,          "        EBX     6: FDP_EXCPTN_ONLY (x87 FPU Data Pointer updated only on x87 Exceptions)"))
            gef_print(c(ebx,  7, 1,          "        EBX     7: SMEP (Supervisor Mode Execution Protection)"))
            gef_print(c(ebx,  8, 1,          "        EBX     8: BMI2 (Bit Manipulation Instructions 2)"))
            gef_print(c(ebx,  9, 1,          "        EBX     9: ERMS (Enhanced REP MOVSB/STOSB)"))
            gef_print(c(ebx, 10, 1,          "        EBX    10: INVPCID (INVPCID instruction)"))
            gef_print(c(ebx, 11, 1,          "        EBX    11: RTM (Restricted Transactional Memor)"))
            gef_print(c(ebx, 12, 1,          "        EBX    12: PQM (Platform QoS Monitoring)"))
            gef_print(c(ebx, 13, 1,          "        EBX    13: x87 FPU CS and DS deprecated"))
            gef_print(c(ebx, 14, 1,          "        EBX    14: MPX (Memory Protection eXtensions)"))
            gef_print(c(ebx, 15, 1,          "        EBX    15: PQE (Platform QoS Enforcement)"))
            gef_print(c(ebx, 16, 1,          "        EBX    16: AVX512F (AVX512 Foundation)"))
            gef_print(c(ebx, 17, 1,          "        EBX    17: AVX512DQ (AVX512 Double/Quadword instructions)"))
            gef_print(c(ebx, 18, 1,          "        EBX    18: RDSEED (RDSEED instruction)"))
            gef_print(c(ebx, 19, 1,          "        EBX    19: ADX (Multi-Precision Add-Carry instruction eXtensions)"))
            gef_print(c(ebx, 20, 1,          "        EBX    20: SMAP (Supervisor Mode Access Prevention)"))
            gef_print(c(ebx, 21, 1,          "        EBX    21: AVX512IFMA (AVX512 Integer FMA instructions)"))
            gef_print(c(ebx, 22, 1,          "        EBX    22: (Intel) PCOMMIT (Persistent Commit instruction)"))
            gef_print(c(ebx, 22, 1,          "        EBX    22: (AMD) RDPID (RDPID instruction and TSC_AUX MSR iupport)"))
            gef_print(c(ebx, 23, 1,          "        EBX    23: CLFLUSHOPT (CLFLUSHOPT instruction)"))
            gef_print(c(ebx, 24, 1,          "        EBX    24: CLWB (Cache Line Write-Back instruction)"))
            gef_print(c(ebx, 25, 1,          "        EBX    25: PT (Intel Processor Trace)"))
            gef_print(c(ebx, 26, 1,          "        EBX    26: AVX512PF (AVX512 Prefetch instructions)"))
            gef_print(c(ebx, 27, 1,          "        EBX    27: AVX512ER (AVX512 Exponent/Reciprocal instructions)"))
            gef_print(c(ebx, 28, 1,          "        EBX    28: AVX512CD (AVX512 Conflict Detection instructions)"))
            gef_print(c(ebx, 29, 1,          "        EBX    29: SHA (SHA-1/SHA-256 instructions)"))
            gef_print(c(ebx, 30, 1,          "        EBX    30: AVX512BW (AVX512 Byte/Word instructions)"))
            gef_print(c(ebx, 31, 1,          "        EBX    31: AVX512VL (AVX512 Vector Length Extensions)"))
            gef_print(c(ecx,  0, 1,          "        ECX     0: PREFETCHWT1 (PREFETCHWT1 instruction)"))
            gef_print(c(ecx,  1, 1,          "        ECX     1: AVX512VBMI (AVX512 Vector Byte Manipulation Instructions)"))
            gef_print(c(ecx,  2, 1,          "        ECX     2: UMIP (User Mode Instruction Prevention)"))
            gef_print(c(ecx,  3, 1,          "        ECX     3: PKU (Protection Keys for User-mode pages)"))
            gef_print(c(ecx,  4, 1,          "        ECX     4: OSPKE (OS has Enabled Protection Keys)"))
            gef_print(c(ecx,  5, 1,          "        ECX     5: WAITPKG (Wait and Pause Enhancements)"))
            gef_print(c(ecx,  6, 1,          "        ECX     6: AVX512VBMI2 (AVX512 Vector Byte Manipulation Instructions 2)"))
            gef_print(c(ecx,  7, 1,          "        ECX     7: CET_SS (CET shadow stack)"))
            gef_print(c(ecx,  8, 1,          "        ECX     8: GFNI (Galois Field NI / Galois Field Affine Transformation)"))
            gef_print(c(ecx,  9, 1,          "        ECX     9: VAES (VEX-encoded AES-NI)"))
            gef_print(c(ecx, 10, 1,          "        ECX    10: VPCL (VEX-encoded PCLMUL)"))
            gef_print(c(ecx, 11, 1,          "        ECX    11: AVX512VNNI (AVX512 Vector Neural Network Instructions)"))
            gef_print(c(ecx, 12, 1,          "        ECX    12: AVX512BITALG (AVX512 Bitwise Algorithms)"))
            gef_print(c(ecx, 13, 1,          "        ECX    13: TME_EN (Total Memory Encryption)"))
            gef_print(c(ecx, 14, 1,          "        ECX    14: AVX512 VPOPCNTDQ"))
            gef_print(c(ecx, 15, 1,          "        ECX    15: Reserved"))
            gef_print(c(ecx, 16, 1,          "        ECX    16: LA57 (5-Level paging)"))
            gef_print(c(ecx, 17, 0x1f,       "        ECX 21-17: MAWAU (MPX Address-Width Adjust for CPL=3)"))
            gef_print(c(ecx, 22, 1,          "        ECX    22: RDPID (Read Processor ID)"))
            gef_print(c(ecx, 23, 1,          "        ECX    23: KL (Key Locker)"))
            gef_print(c(ecx, 24, 1,          "        ECX    24: Reserved"))
            gef_print(c(ecx, 25, 1,          "        ECX    25: CLDEMOTE (Cache Line Demote)"))
            gef_print(c(ecx, 26, 1,          "        ECX    26: Reserved"))
            gef_print(c(ecx, 27, 1,          "        ECX    27: MOVDIRI (32-bit Direct Stores)"))
            gef_print(c(ecx, 28, 1,          "        ECX    28: MOVDIRI64B (64-bit Direct Stores)"))
            gef_print(c(ecx, 29, 1,          "        ECX    29: ENQCMD (ENQueue Stores)"))
            gef_print(c(ecx, 30, 1,          "        ECX    30: SGX_LC (SGX Launch Configuration)"))
            gef_print(c(ecx, 31, 1,          "        ECX    31: PKS (Protection Keys for Supervisor-mode pages)"))
            gef_print(c(edx,  0, 1,          "        EDX     0: Reserved"))
            gef_print(c(edx,  1, 1,          "        EDX     1: Reserved"))
            gef_print(c(edx,  2, 1,          "        EDX     2: AVX512_4VNNIW"))
            gef_print(c(edx,  3, 1,          "        EDX     3: AVX512_4FMAPS"))
            gef_print(c(edx,  4, 1,          "        EDX     4: Fast Short REP MOV"))
            gef_print(c(edx,  5, 1,          "        EDX     5: UINTR (User Interrupts)"))
            gef_print(c(edx,  6, 1,          "        EDX     6: Reserved"))
            gef_print(c(edx,  7, 1,          "        EDX     7: Reserved"))
            gef_print(c(edx,  8, 1,          "        EDX     8: AVX512_VP2INTERSECT"))
            gef_print(c(edx,  9, 1,          "        EDX     9: Reserved"))
            gef_print(c(edx, 10, 1,          "        EDX    10: MD_CLEAR"))
            gef_print(c(edx, 11, 1,          "        EDX    11: Reserved"))
            gef_print(c(edx, 12, 1,          "        EDX    12: Reserved"))
            gef_print(c(edx, 13, 1,          "        EDX    13: TSX force abort MSR"))
            gef_print(c(edx, 14, 1,          "        EDX    14: SERIALIZE"))
            gef_print(c(edx, 15, 1,          "        EDX    15: Hybrid"))
            gef_print(c(edx, 16, 1,          "        EDX    16: TSX suspend load address tracking"))
            gef_print(c(edx, 17, 1,          "        EDX    17: Reserved"))
            gef_print(c(edx, 18, 1,          "        EDX    18: PCONFIG"))
            gef_print(c(edx, 19, 1,          "        EDX    19: Reserved"))
            gef_print(c(edx, 20, 1,          "        EDX    20: CET_IBT (CET Indirect Branch Tracking)"))
            gef_print(c(edx, 21, 1,          "        EDX    21: Reserved"))
            gef_print(c(edx, 22, 1,          "        EDX    22: AMX-BF16 (Tile computation on bfloat16)"))
            gef_print(c(edx, 23, 1,          "        EDX    23: AVX512FP16"))
            gef_print(c(edx, 24, 1,          "        EDX    24: AMX-TILE (Tile architecture)"))
            gef_print(c(edx, 25, 1,          "        EDX    25: AMX-INT8 (Tile computation on 8-bit integers)"))
            gef_print(c(edx, 26, 1,          "        EDX    26: IBRS/IBPB (Indirect Branch Restricted Speculation/Predictor Barrier)"))
            gef_print(c(edx, 27, 1,          "        EDX    27: STIBP (Single Thread Indirect Branch Predictors)"))
            gef_print(c(edx, 28, 1,          "        EDX    28: L1D_FLUSH (L1 Data Cache Flush)"))
            gef_print(c(edx, 29, 1,          "        EDX    29: IA32_ARCH_CAPABILITIES MSR"))
            gef_print(c(edx, 30, 1,          "        EDX    30: IA32_CORE_CAPABILITIES MSR"))
            gef_print(c(edx, 31, 1,          "        EDX    31: SSBD (Speculative Store Bypass Disable)"))
        elif id == 7 and subid != 0:
            gef_print("    ebx,edx,edx: Extended Feature Information")
        elif id == 8:
            gef_print("    Reserved")
        elif id == 9:
            gef_print("    eax: PLATFORM_DCA_CAP MSR")
            gef_print("    ebx,ecx,edx: Reserved")
        elif id == 10:
            gef_print("    DCA parameters")
            gef_print(c(eax,  0, 0xff,       "        EAX  7- 0: Revision"))
            gef_print(c(eax,  8, 0xff,       "        EAX 15- 8: Number of PeMo counters per logical processor"))
            gef_print(c(eax, 16, 0xff,       "        EAX 23-16: Bit width of PeMo counter"))
            gef_print(c(eax, 24, 0xff,       "        EAX 31-24: EBX bit vector length"))
            gef_print(c(ebx,  0, 1,          "        EBX     0: Core cycles event unavailable"))
            gef_print(c(ebx,  1, 1,          "        EBX     1: Instructions retired event unavailable"))
            gef_print(c(ebx,  2, 1,          "        EBX     2: Reference cycles event unavailable"))
            gef_print(c(ebx,  3, 1,          "        EBX     3: Last level cache references event unavailable"))
            gef_print(c(ebx,  4, 1,          "        EBX     4: Last level cache misses event unavailable"))
            gef_print(c(ebx,  5, 1,          "        EBX     5: Branch instructions retired event unavailable"))
            gef_print(c(ebx,  6, 1,          "        EBX     6: Branch mispredicts retired event unavailable"))
            gef_print(c(ebx,  7, 0x1ffffff,  "        EBX 31- 7: Reserved"))
            gef_print(c(ecx,  0, 0xffffffff, "        ECX 31- 0: Reserved"))
            gef_print(c(edx,  0, 0x1f,       "        EDX  4- 0: Number of fixed function PeMo counters"))
            gef_print(c(edx,  5, 0xff,       "        EDX 12- 5: Bit width of fixed function PeMo counter"))
            gef_print(c(edx, 13, 1,          "        EDX    13: Reserved"))
            gef_print(c(edx, 14, 1,          "        EDX    14: Reserved"))
            gef_print(c(edx, 15, 1,          "        EDX    15: AnyThread deprecation"))
            gef_print(c(edx, 16, 0xffff,     "        EDX 31-16: Reserved"))
        elif id == 11:
            gef_print("    Information of topology enumeration")
        elif id == 12:
            gef_print("    Reserved")
        elif id == 13:
            if subid == 0:
                m = "main"
            elif subid == 1:
                m = "sub"
            else:
                m = "XCR0.{:d}".format(subid)
            gef_print("    Information of extended state enumeration ({:s})".format(m))
        elif id in [15, 16]:
            gef_print("    Intel Resource Director Technology (Intel RDT), Cache, Memory Bandwidth Allocation Enumeration")
        elif id == 18:
            gef_print("    Information of Intel SGX")
        elif id == 20:
            gef_print("    Information of Intel Processor Trace Enumeration")
            gef_print(c(ebx,  0, 1,          "        EBX     0: CR3 filtering"))
            gef_print(c(ebx,  1, 1,          "        EBX     1: Configurable PSB, Cycle-Accurate Mode"))
            gef_print(c(ebx,  2, 1,          "        EBX     2: Filtering preserved across warm reset"))
            gef_print(c(ebx,  3, 1,          "        EBX     3: MTC timing packet, suppression of COFI-based packets"))
            gef_print(c(ebx,  4, 1,          "        EBX     4: PTWRITE"))
            gef_print(c(ebx,  5, 1,          "        EBX     5: Power Event Trace"))
            gef_print(c(ebx,  6, 1,          "        EBX     6: PSB and PMI preservation MSRs"))
            gef_print(c(ebx,  7, 0x1ffffff,  "        EBX 31- 7: Reserved"))
            gef_print(c(ecx,  0, 1,          "        ECX     0: ToPA output scheme"))
            gef_print(c(ecx,  1, 1,          "        ECX     1: ToPA tables hold multiple output entries"))
            gef_print(c(ecx,  2, 1,          "        ECX     2: Single-range output scheme"))
            gef_print(c(ecx,  3, 1,          "        ECX     3: Trace Transport output support"))
            gef_print(c(ecx,  4, 0x7ffffff,  "        ECX 30- 4: Reserved"))
            gef_print(c(ecx, 31, 1,          "        ECX    31: IP payloads are LIP"))
        elif id == 21:
            gef_print("    TSC and Nominal Core Crystal Clock")
        elif id == 22:
            gef_print("    Information of CPU frequency")
            gef_print(c(eax,  0, 0xffff,     "        EAX 15- 0: Processor Base Frequency (MHz)"))
            gef_print(c(eax, 16, 0xffff,     "        EAX 31-16: Reserved"))
            gef_print(c(ebx,  0, 0xffff,     "        EBX 15- 0: Maximum Frequency (MHz)"))
            gef_print(c(ebx, 16, 0xffff,     "        EBX 31-16: Reserved"))
            gef_print(c(ecx,  0, 0xffff,     "        ECX 15- 0: Bus (Reference) Frequency (MHz)"))
            gef_print(c(ecx, 16, 0xffff,     "        ECX 31-16: Reserved"))
            gef_print(c(edx,  0, 0xffffffff, "        EDX 31- 0: Reserved"))
        elif id == 23:
            gef_print("    Information of System-On-Chip Vendor Attribute Enumeration")
        elif id == 24:
            gef_print("    Information of Deterministic Address Translation Parameters")
        elif id == 26:
            gef_print("    Information of Hybrid Information Enumeration")
        elif id == 31:
            gef_print("    Information of V2 Extended Topology Enumeration")
        elif id == 0x40000000:
            vid = (p32(ebx) + p32(ecx) + p32(edx)).decode("utf-8")
            gef_print("    eax: Maximum Input Value for Hypervisor Function CPUID Information")
            gef_print("    ebx+ecx+edx: Hypervisor Brand String (={:s})".format(repr(vid)))
        elif id == 0x40000001:
            gef_print("    Hypervisor")
            gef_print(c(eax,  0, 1,          "        EAX     0: Clocksource"))
            gef_print(c(eax,  1, 1,          "        EAX     1: NOP IO Delay"))
            gef_print(c(eax,  2, 1,          "        EAX     2: MMU Op"))
            gef_print(c(eax,  3, 1,          "        EAX     3: Clocksource 2"))
            gef_print(c(eax,  4, 1,          "        EAX     4: Async PF"))
            gef_print(c(eax,  5, 1,          "        EAX     5: Steal Time"))
            gef_print(c(eax,  6, 1,          "        EAX     6: PV EOI"))
            gef_print(c(eax,  7, 1,          "        EAX     7: PV UNHALT"))
            gef_print(c(eax,  8, 1,          "        EAX     8: Reserved"))
            gef_print(c(eax,  9, 1,          "        EAX     9: PV TLB flush"))
            gef_print(c(eax, 10, 1,          "        EAX    10: PV async PF VMEXIT"))
            gef_print(c(eax, 11, 1,          "        EAX    11: PV send IPI"))
            gef_print(c(eax, 12, 1,          "        EAX    12: PV poll control"))
            gef_print(c(eax, 13, 1,          "        EAX    13: PV sched yield"))
            gef_print(c(eax, 14, 1,          "        EAX    14: Async PF INT"))
            gef_print(c(eax, 15, 1,          "        EAX    15: MSI extended destination ID"))
            gef_print(c(eax, 16, 1,          "        EAX    16: Hypercall map GPA range"))
            gef_print(c(eax, 17, 1,          "        EAX    17: Hypercall map GPA range"))
            gef_print(c(eax, 18, 1,          "        EAX    18: Migration control"))
            gef_print(c(eax, 19, 0x3f,       "        EAX 24-19: Reserved"))
            gef_print(c(eax, 25, 1,          "        EAX    25: Clocksource Stable"))
            gef_print(c(eax, 26, 0x3f,       "        EAX 31-26: Reserved"))
            gef_print(c(edx,  0, 1,          "        EDX     0: vCPUs realtime, never preempted"))
            gef_print(c(edx,  1, 0x7fffffff, "        EDX 31- 1: Reserved"))
        elif id == 0x40000003:
            gef_print("    Hypervisor")
            gef_print(c(eax,  0, 1,          "        EAX     0: VP_RUNTIME"))
            gef_print(c(eax,  1, 1,          "        EAX     1: TIME_REF_COUNT"))
            gef_print(c(eax,  2, 1,          "        EAX     2: Basic SynIC MSRs"))
            gef_print(c(eax,  3, 1,          "        EAX     3: Synthetic Timer"))
            gef_print(c(eax,  4, 1,          "        EAX     4: APIC access"))
            gef_print(c(eax,  5, 1,          "        EAX     5: Hypercall MSRs"))
            gef_print(c(eax,  6, 1,          "        EAX     6: VP Index MSR"))
            gef_print(c(eax,  7, 1,          "        EAX     7: System Reset MSR"))
            gef_print(c(eax,  8, 1,          "        EAX     8: Access stats MSRs"))
            gef_print(c(eax,  9, 1,          "        EAX     9: Reference TSC"))
            gef_print(c(eax, 10, 1,          "        EAX    10: Guest Idle MSR"))
            gef_print(c(eax, 11, 1,          "        EAX    11: Timer Frequency MSRs"))
            gef_print(c(eax, 12, 1,          "        EAX    12: Debug MSRs"))
            gef_print(c(eax, 13, 1,          "        EAX    13: Reenlightenment controls"))
            gef_print(c(eax, 14, 0x3ffff,    "        EAX 31-14: Reserved"))
            gef_print(c(ebx,  0, 1,          "        EBX     0: CreatePartitions"))
            gef_print(c(ebx,  1, 1,          "        EBX     1: AccessPartitionId"))
            gef_print(c(ebx,  2, 1,          "        EBX     2: AccessMemoryPool"))
            gef_print(c(ebx,  3, 1,          "        EBX     3: AdjustMemoryBuffers"))
            gef_print(c(ebx,  4, 1,          "        EBX     4: PostMessages"))
            gef_print(c(ebx,  5, 1,          "        EBX     5: SignalEvents"))
            gef_print(c(ebx,  6, 1,          "        EBX     6: CreatePort"))
            gef_print(c(ebx,  7, 1,          "        EBX     7: ConnectPort"))
            gef_print(c(ebx,  8, 1,          "        EBX     8: AccessStats"))
            gef_print(c(ebx,  9, 1,          "        EBX     9: Reserved"))
            gef_print(c(ebx, 10, 1,          "        EBX    10: Reserved"))
            gef_print(c(ebx, 11, 1,          "        EBX    11: Debugging"))
            gef_print(c(ebx, 12, 1,          "        EBX    12: CpuManagement"))
            gef_print(c(ebx, 13, 1,          "        EBX    13: ConfigureProfiler"))
            gef_print(c(ebx, 14, 1,          "        EBX    14: EnableExpandedStackwalking"))
            gef_print(c(ebx, 15, 1,          "        EBX    15: Reserved"))
            gef_print(c(ebx, 16, 1,          "        EBX    16: AccessVSM"))
            gef_print(c(ebx, 17, 1,          "        EBX    17: AccessVpRegisters"))
            gef_print(c(ebx, 18, 1,          "        EBX    18: Reserved"))
            gef_print(c(ebx, 19, 1,          "        EBX    19: Reserved"))
            gef_print(c(ebx, 20, 1,          "        EBX    20: EnableExtendedHypercalls"))
            gef_print(c(ebx, 21, 1,          "        EBX    21: StartVirtualProcessor"))
            gef_print(c(ebx, 22, 0x3ff,      "        EBX 31-22: Reserved"))
            gef_print(c(edx,  0, 1,          "        EDX     0: MWAIT instruction support (deprecated)"))
            gef_print(c(edx,  1, 1,          "        EDX     1: Guest debugging support"))
            gef_print(c(edx,  2, 1,          "        EDX     2: Performance Monitor support"))
            gef_print(c(edx,  3, 1,          "        EDX     3: Physical CPU dynamic partitioning event support"))
            gef_print(c(edx,  4, 1,          "        EDX     4: Hypercall input params via XMM registers"))
            gef_print(c(edx,  5, 1,          "        EDX     5: Virtual guest idle state support"))
            gef_print(c(edx,  6, 1,          "        EDX     6: Hypervisor sleep state support"))
            gef_print(c(edx,  7, 1,          "        EDX     7: NUMA distance query support"))
            gef_print(c(edx,  8, 1,          "        EDX     8: Timer frequency details available"))
            gef_print(c(edx,  9, 1,          "        EDX     9: Synthetic machine check injection support"))
            gef_print(c(edx, 10, 1,          "        EDX    10: Guest crash MSR support"))
            gef_print(c(edx, 11, 1,          "        EDX    11: Debug MSR support"))
            gef_print(c(edx, 12, 1,          "        EDX    12: NPIEP support"))
            gef_print(c(edx, 13, 1,          "        EDX    13: Hypervisor disable support"))
            gef_print(c(edx, 14, 1,          "        EDX    14: Extended GVA ranges for flush virtual address list available"))
            gef_print(c(edx, 15, 1,          "        EDX    15: Hypercall output via XMM registers"))
            gef_print(c(edx, 16, 1,          "        EDX    16: Virtual guest idle state"))
            gef_print(c(edx, 17, 1,          "        EDX    17: Soft interrupt polling mode available"))
            gef_print(c(edx, 18, 1,          "        EDX    18: Hypercall MSR lock available"))
            gef_print(c(edx, 19, 1,          "        EDX    19: Direct synthetic timers support"))
            gef_print(c(edx, 20, 1,          "        EDX    20: PAT register available for VSM"))
            gef_print(c(edx, 21, 1,          "        EDX    21: BNDCFGS register available for VSM"))
            gef_print(c(edx, 22, 1,          "        EDX    22: Reserved"))
            gef_print(c(edx, 23, 1,          "        EDX    23: Synthetic time unhalted timer"))
            gef_print(c(edx, 24, 1,          "        EDX    24: Reserved"))
            gef_print(c(edx, 25, 1,          "        EDX    25: Reserved"))
            gef_print(c(edx, 26, 1,          "        EDX    26: Intel Last Branch Record (LBR) feature"))
            gef_print(c(edx, 27, 1,          "        EDX 31-27: Reserved"))
        elif id == 0x40000004:
            gef_print("    Hypervisor implementation recommendations")
            gef_print(c(eax,  0, 1,          "        EAX     0: Hypercall for address space switches"))
            gef_print(c(eax,  1, 1,          "        EAX     1: Hypercall for local TLB flushes"))
            gef_print(c(eax,  2, 1,          "        EAX     2: Hypercall for remote TLB flushes"))
            gef_print(c(eax,  3, 1,          "        EAX     3: MSRs for accessing APIC registers"))
            gef_print(c(eax,  4, 1,          "        EAX     4: Hypervisor MSR for system RESET"))
            gef_print(c(eax,  5, 1,          "        EAX     5: Relaxed timing"))
            gef_print(c(eax,  6, 1,          "        EAX     6: DMA remapping"))
            gef_print(c(eax,  7, 1,          "        EAX     7: Interrupt remapping"))
            gef_print(c(eax,  8, 1,          "        EAX     8: x2APIC MSRs"))
            gef_print(c(eax,  9, 1,          "        EAX     9: Deprecating AutoEOI"))
            gef_print(c(eax, 10, 1,          "        EAX    10: Hypercall for SyntheticClusterIpi"))
            gef_print(c(eax, 11, 1,          "        EAX    11: Interface ExProcessorMasks"))
            gef_print(c(eax, 12, 1,          "        EAX    12: Nested Hyper-V partition"))
            gef_print(c(eax, 13, 1,          "        EAX    13: INT for MBEC system calls"))
            gef_print(c(eax, 14, 1,          "        EAX    14: Enlightenment VMCS interface"))
            gef_print(c(eax, 15, 1,          "        EAX    15: Synced timeline"))
            gef_print(c(eax, 16, 1,          "        EAX    16: Reserved"))
            gef_print(c(eax, 17, 1,          "        EAX    17: Direct local flush entire"))
            gef_print(c(eax, 18, 1,          "        EAX    18: No architectural core sharing"))
            gef_print(c(eax, 19, 0x1fff,     "        EAX 31-19: Reserved"))
        elif id == 0x40000006:
            gef_print("    Hypervisor hardware features enable")
            gef_print(c(eax,  0, 1,          "        EAX     0: APIC overlay assist"))
            gef_print(c(eax,  1, 1,          "        EAX     1: MSR bitmaps"))
            gef_print(c(eax,  2, 1,          "        EAX     2: Architectural performance counters"))
            gef_print(c(eax,  3, 1,          "        EAX     3: Second-level address translation"))
            gef_print(c(eax,  4, 1,          "        EAX     4: DMA remapping"))
            gef_print(c(eax,  5, 1,          "        EAX     5: Interrupt remapping"))
            gef_print(c(eax,  6, 1,          "        EAX     6: Memory patrol scrubber"))
            gef_print(c(eax,  7, 1,          "        EAX     7: DMA protection"))
            gef_print(c(eax,  8, 1,          "        EAX     8: HPET"))
            gef_print(c(eax,  9, 1,          "        EAX     9: Volatile synthetic timers"))
            gef_print(c(eax, 10, 0x3fffff,   "        EAX 31-10: Reserved"))
        elif id == 0x40000007:
            gef_print("    Hypervisor CPU management features")
            gef_print(c(eax,  0, 1,          "        EAX     0: Start logical processor"))
            gef_print(c(eax,  1, 1,          "        EAX     1: Create root virtual processor"))
            gef_print(c(eax,  2, 1,          "        EAX     2: Performance counter sync"))
            gef_print(c(eax,  3, 0x1fffffff, "        EAX 31- 3: Reserved"))
            gef_print(c(ebx,  0, 1,          "        EBX     0: Processor power management"))
            gef_print(c(ebx,  1, 1,          "        EBX     1: MWAIT idle states"))
            gef_print(c(ebx,  2, 1,          "        EBX     2: Logical processor idling"))
            gef_print(c(ebx,  3, 0x1fffffff, "        EBX 31- 3: Reserved"))
            gef_print(c(ecx,  0, 1,          "        ECX     0: Remap guest uncached"))
            gef_print(c(ecx,  1, 0x7fffffff, "        ECX 31- 1: Reserved"))
        elif id == 0x40000008:
            gef_print("    Hypervisor shared virtual memory (SVM) features")
            gef_print(c(eax,  0, 1,          "        EAX     0: SVM (Shared Virtual Memory)"))
            gef_print(c(eax,  1, 0x7fffffff, "        EAX 31- 1: Reserved"))
        elif id == 0x40000009:
            gef_print("    Nested hypervisor feature indentification")
            gef_print(c(eax,  0, 1,          "        EAX     0: Reserved"))
            gef_print(c(eax,  1, 1,          "        EAX     1: Reserved"))
            gef_print(c(eax,  2, 1,          "        EAX     2: Synthetic Timer"))
            gef_print(c(eax,  3, 1,          "        EAX     3: Reserved"))
            gef_print(c(eax,  4, 1,          "        EAX     4: Interrupt control registers"))
            gef_print(c(eax,  5, 1,          "        EAX     5: Hypercall MSRs"))
            gef_print(c(eax,  6, 1,          "        EAX     6: VP index MSR"))
            gef_print(c(eax,  7, 0x1f,       "        EAX 11- 7: Reserved"))
            gef_print(c(eax, 12, 1,          "        EAX    12: Reenlightenment controls"))
            gef_print(c(eax, 13, 0x7ffff,    "        EAX 31-13: Reserved"))
            gef_print(c(edx,  0, 0xf,        "        EDX  3- 0: Reserved"))
            gef_print(c(eax,  4, 1,          "        EDX     4: Hypercall input params via XMM registers"))
            gef_print(c(edx,  5, 0x3ff,      "        EDX 14- 5: Reserved"))
            gef_print(c(edx, 15, 1,          "        EDX    15: Hypercall output via XMM registers"))
            gef_print(c(edx, 16, 1,          "        EDX    16: Reserved"))
            gef_print(c(edx, 17, 1,          "        EDX    17: Soft interrupt polling mode available"))
            gef_print(c(edx, 18, 0x3fff,     "        EDX 31-18: Reserved"))
        elif id == 0x4000000a:
            gef_print("    Nested hypervisor feature indentification")
            gef_print(c(eax,  0, 0x1ffff,    "        EAX 16- 0: Reserved"))
            gef_print(c(eax, 17, 1,          "        EAX    17: Direct virtual flush hypercalls"))
            gef_print(c(eax, 18, 1,          "        EAX    18: Flush GPA space and list hypercalls"))
            gef_print(c(eax, 19, 1,          "        EAX    19: Enlightened MSR bitmaps"))
            gef_print(c(eax, 20, 1,          "        EAX    20: Combining virtualization exceptions in page fault exception class"))
            gef_print(c(eax, 21, 0x7ff,      "        EAX 31-21: Reserved"))
        elif id == 0x40000010:
            gef_print("    Hypervisor timing information")
            gef_print("    eax: (Virtual) TSC frequency in kHz")
            gef_print("    ebx: (Virtual) Bus (local apic timer) frequency in kHz")
            gef_print("    ecx,edx: Reserved")
        elif id == 0x80000000:
            gef_print("    eax: Maximum Input Value for Extended Function CPUID Information")
            gef_print("    ebx,ecx,edx: Reserved")
        elif id == 0x80000001:
            gef_print("    eax,ebx: Extended Processor Signature")
            gef_print("    edx,ecx: Extended Processor Feature")
            gef_print(c(edx,  0, 1,          "        EDX     0: FPU (Floating Point Unit on-chip)"))
            gef_print(c(edx,  1, 1,          "        EDX     1: VME (Virtual 8086 Mode Enhancements)"))
            gef_print(c(edx,  2, 1,          "        EDX     2: DE (Debugging Extensions)"))
            gef_print(c(edx,  3, 1,          "        EDX     3: PSE (Page Size Extension)"))
            gef_print(c(edx,  4, 1,          "        EDX     4: TSC (Time Stamp Counter)"))
            gef_print(c(edx,  5, 1,          "        EDX     5: MSR (Model Specific Registers RDMSR and WRMSR instructions)"))
            gef_print(c(edx,  6, 1,          "        EDX     6: PAE (Physical Address Extension)"))
            gef_print(c(edx,  7, 1,          "        EDX     7: MCE (Machine Check Exception)"))
            gef_print(c(edx,  8, 1,          "        EDX     8: CX8 (CMPXCHG8B instruction)"))
            gef_print(c(edx,  9, 1,          "        EDX     9: APIC (APIC on-chip)"))
            gef_print(c(edx, 10, 1,          "        EDX    10: Reserved"))
            gef_print(c(edx, 11, 1,          "        EDX    11: (Intel) SEP (SYSENTER and SYSEXIT instructions)"))
            gef_print(c(edx, 11, 1,          "        EDX    11: (AMD) SYSCALL (SYSCALL and SYSRET instructions)"))
            gef_print(c(edx, 12, 1,          "        EDX    12: MTRR (Memory Type Range Registers)"))
            gef_print(c(edx, 13, 1,          "        EDX    13: PGE (Page Global Bit)"))
            gef_print(c(edx, 14, 1,          "        EDX    14: MCA (Machine Check Architecture)"))
            gef_print(c(edx, 15, 1,          "        EDX    15: CMOV (Conditional MOVe instructions)"))
            gef_print(c(edx, 16, 1,          "        EDX    16: PAT (Page Attribute Table)"))
            gef_print(c(edx, 17, 1,          "        EDX    17: PSE-36 (36-Bit Page Size Extension)"))
            gef_print(c(edx, 18, 1,          "        EDX    18: Reserved"))
            gef_print(c(edx, 19, 1,          "        EDX    19: MP (MultiProcessing capable)"))
            gef_print(c(edx, 20, 1,          "        EDX    20: (Intel) XD (No-execute page protection)"))
            gef_print(c(edx, 20, 1,          "        EDX    20: (AMD) NX (No-execute page protection)"))
            gef_print(c(edx, 21, 1,          "        EDX    21: Reserved"))
            gef_print(c(edx, 22, 1,          "        EDX    22: MMX+ (MMX instruction extensions)"))
            gef_print(c(edx, 23, 1,          "        EDX    23: MMX (Intel MMX technology)"))
            gef_print(c(edx, 24, 1,          "        EDX    24: FXSR (FXSAVE and FXRSTOR instructions)"))
            gef_print(c(edx, 25, 1,          "        EDX    25: FFXSR (Fast FXSAVE/FXRSTOR)"))
            gef_print(c(edx, 26, 1,          "        EDX    26: P1GB (1GB Page support)"))
            gef_print(c(edx, 27, 1,          "        EDX    27: RDTSCP (RDTSCP instruction)"))
            gef_print(c(edx, 28, 1,          "        EDX    28: Reserved"))
            gef_print(c(edx, 29, 1,          "        EDX    29: LM (Long Mode (EM64T))"))
            gef_print(c(edx, 30, 1,          "        EDX    30: 3DNow!+ (3DNow! extended)"))
            gef_print(c(edx, 31, 1,          "        EDX    31: 3DNow! (3DNow! instructions)"))
            gef_print(c(ecx,  0, 1,          "        ECX     0: LAHF (LAHF/SAHF supported in 64-bit mode)"))
            gef_print(c(ecx,  1, 1,          "        ECX     1: CMPL (Core Multi-Processing Legacy mode)"))
            gef_print(c(ecx,  2, 1,          "        ECX     2: SVM (Secure Virtual Machine)"))
            gef_print(c(ecx,  3, 1,          "        ECX     3: EAS (Extended APIC Space)"))
            gef_print(c(ecx,  4, 1,          "        ECX     4: AMC8 (AltMovCr8; LOCK MOV CR0 means MOV CR8)"))
            gef_print(c(ecx,  5, 1,          "        ECX     5: ABM (Advanced Bit Manipulation; LZCNT instruction)"))
            gef_print(c(ecx,  6, 1,          "        ECX     6: SSE4A (SSE4A instructions)"))
            gef_print(c(ecx,  7, 1,          "        ECX     7: MASSE (Mis-Aligned SSE Support)"))
            gef_print(c(ecx,  8, 1,          "        ECX     8: PREFETCH (3DNow! PREFETCH/PREFETCHHW instructions)"))
            gef_print(c(ecx,  9, 1,          "        ECX     9: OSVW (OS-Visible Workaround)"))
            gef_print(c(ecx, 10, 1,          "        ECX    10: IBS (Instruction-Based Sampling)"))
            gef_print(c(ecx, 11, 1,          "        ECX    11: XOP (eXtended OPeration)"))
            gef_print(c(ecx, 12, 1,          "        ECX    12: SKINIT (SKINIT/STGI instructions)"))
            gef_print(c(ecx, 13, 1,          "        ECX    13: WDT (WatchDog Timer)"))
            gef_print(c(ecx, 14, 1,          "        ECX    14: Reserved"))
            gef_print(c(ecx, 15, 1,          "        ECX    15: LWP (Light Weight Profiling)"))
            gef_print(c(ecx, 16, 1,          "        ECX    16: FMA4 (4-operands FMA instructions)"))
            gef_print(c(ecx, 17, 1,          "        ECX    17: TCE (Translation Cache Extension)"))
            gef_print(c(ecx, 18, 1,          "        ECX    18: Reserved"))
            gef_print(c(ecx, 19, 1,          "        ECX    19: MSR (Node ID MSR"))
            gef_print(c(ecx, 20, 1,          "        ECX    20: Reserved"))
            gef_print(c(ecx, 21, 1,          "        ECX    21: TBM (Trailing Bit Manipulation instructions)"))
            gef_print(c(ecx, 22, 1,          "        ECX    22: TOPOEXT (TOPology EXTensions)"))
            gef_print(c(ecx, 23, 1,          "        ECX    23: PERFCTR_CORE (CORE PERFormance CounTeR extensions)"))
            gef_print(c(ecx, 24, 1,          "        ECX    24: PERFCTR_NB (NB PERFormance CounTeR extensions"))
            gef_print(c(ecx, 25, 1,          "        ECX    25: Streaming performance monitor architecture"))
            gef_print(c(ecx, 26, 1,          "        ECX    26: DBX (Data breakpoint eXtensions)"))
            gef_print(c(ecx, 27, 1,          "        ECX    27: PERFTSC (PERFormance Time Stamp Counter)"))
            gef_print(c(ecx, 28, 1,          "        ECX    28: PERFCTR_L2 (L2 PERFormance CounTeR extensions)"))
            gef_print(c(ecx, 29, 1,          "        ECX    29: MONITORX/MWAITX instructions"))
            gef_print(c(ecx, 30, 1,          "        ECX    30: Address mask extension for instruction breakpoint"))
            gef_print(c(ecx, 31, 1,          "        ECX    31: Reserved"))
        elif id in [0x80000002, 0x80000003, 0x80000004]:
            vid = (p32(eax) + p32(ebx) + p32(ecx) + p32(edx)).decode("utf-8")
            gef_print("    eax+ebx+ecx+edx: Processor Brand String (={:s})".format(repr(vid)))
        elif id == 0x80000005:
            gef_print("    L1 Cache Information")
            gef_print("    eax: 4/2 MB L1 TLB configuration descriptor")
            gef_print("    ebx: 4 KB L1 TLB configuration descriptor")
            gef_print("    ecx: data L1 cache configuration descriptor")
            gef_print("    edx: code L1 cache configuration descriptor")
        elif id == 0x80000006:
            gef_print("    L2/L3 Cache Information")
            gef_print("    eax: 4/2 MB L2 TLB configuration descriptor")
            gef_print("    ebx: 4 KB L2 TLB configuration descriptor")
            gef_print("    ecx: unified L2 cache configuration descriptor")
            gef_print("    edx: unified L3 cache configuration descriptor")
        elif id == 0x80000007:
            gef_print("    ebx: RAS Capabilities")
            gef_print(c(ebx,  0, 1,          "        EBX     0: MCA overflow recovery"))
            gef_print(c(ebx,  1, 1,          "        EBX     1: Software uncorrectable error containment and recovery"))
            gef_print(c(ebx,  2, 1,          "        EBX     2: HWA (HardWare Assert)"))
            gef_print(c(ebx,  3, 1,          "        EBX     3: Scalable MCA"))
            gef_print(c(ebx,  4, 1,          "        EBX     4: PFEH (Platform First Error Handling)"))
            gef_print(c(ebx,  5, 0x7ffffff,  "        EBX 31- 5: Reserved"))
            gef_print("    edx: Advanced Power Management information")
            gef_print(c(edx,  0, 1,          "        EDX     0: TS (Temperature Sensor)"))
            gef_print(c(edx,  1, 1,          "        EDX     1: FID (Frequency ID control)"))
            gef_print(c(edx,  2, 1,          "        EDX     2: VID (Voltage ID control)"))
            gef_print(c(edx,  3, 1,          "        EDX     3: TTP (Thermal Trip)"))
            gef_print(c(edx,  4, 1,          "        EDX     4: TM (Thermal Monitoring)"))
            gef_print(c(edx,  5, 1,          "        EDX     5: STC (Software Thermal Control)"))
            gef_print(c(edx,  6, 1,          "        EDX     6: MUL (100MHz Multiplier steps)"))
            gef_print(c(edx,  7, 1,          "        EDX     7: HWPS (HardWare P-State control)"))
            gef_print(c(edx,  8, 1,          "        EDX     8: ITSC (Invariant TSC)"))
            gef_print(c(edx,  9, 1,          "        EDX     9: Core performance boost"))
            gef_print(c(edx, 10, 1,          "        EDX    10: Read-only effective frequency interface"))
            gef_print(c(edx, 11, 1,          "        EDX    11: Processor feedback interface"))
            gef_print(c(edx, 12, 1,          "        EDX    12: Core power reporting"))
            gef_print(c(edx, 13, 1,          "        EDX    13: Connected standby"))
            gef_print(c(edx, 14, 1,          "        EDX    14: RAPL (Running Average Power Limit)"))
            gef_print(c(edx, 15, 0x1ffff,    "        EAX 31-15: Reserved"))
        elif id == 0x80000008:
            gef_print("    eax: Extended Address Length Information")
            gef_print(c(eax,  0, 0xff,       "        EAX  7- 0: Physical address length"))
            gef_print(c(eax,  8, 0xff,       "        EAX 15- 8: Linear address length"))
            gef_print(c(eax, 16, 0xff,       "        EAX 23-16: Guest physical address length"))
            gef_print(c(eax, 24, 0xff,       "        EAX 31-24: Reserved"))
            gef_print("    ebx: Extended Feature Extensions ID")
            gef_print(c(ebx,  0, 1,          "        EBX     0: CLZERO (CLZERO instruction)"))
            gef_print(c(ebx,  1, 1,          "        EBX     1: IRPerf (Instructions Retired count support)"))
            gef_print(c(ebx,  2, 1,          "        EBX     2: XSAVE always saves/restores error pointers"))
            gef_print(c(ebx,  3, 1,          "        EBX     3: INVLPGB and TLBSYNC instruction"))
            gef_print(c(ebx,  4, 1,          "        EBX     4: RDPRU (RDPRU instruction)"))
            gef_print(c(ebx,  5, 1,          "        EBX     5: Reserved"))
            gef_print(c(ebx,  6, 1,          "        EBX     6: MBE (Memory Bandwidth Enforcement)"))
            gef_print(c(ebx,  7, 1,          "        EBX     7: Reserved"))
            gef_print(c(ebx,  8, 1,          "        EBX     8: MCOMMIT (MCOMMIT instruction)"))
            gef_print(c(ebx,  9, 1,          "        EBX     9: WBNOINVD (Write Back and do NOt INValiDate cache)"))
            gef_print(c(ebx, 10, 1,          "        EBX    10: LBR extensions"))
            gef_print(c(ebx, 11, 1,          "        EBX    11: Reserved"))
            gef_print(c(ebx, 12, 1,          "        EBX    12: IBPB (Indirect Branch Prediction Barrier)"))
            gef_print(c(ebx, 13, 1,          "        EBX    13: WBINVD (Write Back and INValiDate cache)"))
            gef_print(c(ebx, 14, 1,          "        EBX    14: IBRS (Indirect Branch Restricted Speculation)"))
            gef_print(c(ebx, 15, 1,          "        EBX    15: STIBP (Single Thread Indirect Branch Predictor)"))
            gef_print(c(ebx, 16, 1,          "        EBX    16: Reserved"))
            gef_print(c(ebx, 17, 1,          "        EBX    17: STIBP always on"))
            gef_print(c(ebx, 18, 1,          "        EBX    18: IBRS preferred over software solution"))
            gef_print(c(ebx, 19, 1,          "        EBX    19: IBRS provides Same Mode Protection"))
            gef_print(c(ebx, 20, 1,          "        EBX    20: EFER.LMLSE is unsupported"))
            gef_print(c(ebx, 21, 1,          "        EBX    21: INVLPGB for guest nested translations"))
            gef_print(c(ebx, 22, 1,          "        EBX    22: Reserved"))
            gef_print(c(ebx, 23, 1,          "        EBX    23: PPIN (Protected Processor Inventory Number)"))
            gef_print(c(ebx, 24, 1,          "        EBX    24: SSBD (Speculative Store Bypass Disable)"))
            gef_print(c(ebx, 25, 1,          "        EBX    25: VIRT_SPEC_CTL"))
            gef_print(c(ebx, 26, 1,          "        EBX    26: SSBD no longer needed"))
            gef_print(c(ebx, 27, 1,          "        EBX    27: CPPC (Collaborative Processor Performance Control)"))
            gef_print(c(ebx, 28, 1,          "        EBX    28: PSFD (Predictive Store Forward Disable)"))
            gef_print(c(ebx, 29, 1,          "        EBX    29: Reserved"))
            gef_print(c(ebx, 30, 1,          "        EBX    30: Reserved"))
            gef_print(c(ebx, 31, 1,          "        EBX    31: Reserved"))
            gef_print("    ecx: Extended Core Information")
            gef_print(c(ecx,  0, 0xff,       "        ECX  7- 0: Number of cores per (number of dies-1)"))
            gef_print(c(ecx,  8, 0xf,        "        ECX 11- 8: Reserved"))
            gef_print(c(ecx, 12, 0xf,        "        ECX 15-12: Number of LSBs in APIC ID that indicate core ID"))
            gef_print(c(ecx, 16, 0xffff,     "        ECX 31-16: Reserved"))
        elif id == 0x8000000a:
            gef_print("    SVM Revision and Feature Identification")
            gef_print(c(edx,  0, 1,          "        EDX     0: Nested paging"))
            gef_print(c(edx,  1, 1,          "        EDX     1: LBR virtualization"))
            gef_print(c(edx,  2, 1,          "        EDX     2: SVM lock"))
            gef_print(c(edx,  3, 1,          "        EDX     3: NRIP save"))
            gef_print(c(edx,  4, 1,          "        EDX     4: MSR-based TSC rate control"))
            gef_print(c(edx,  5, 1,          "        EDX     5: VMCB clean bits"))
            gef_print(c(edx,  6, 1,          "        EDX     6: Flush by ASID"))
            gef_print(c(edx,  7, 1,          "        EDX     7: Decode assists"))
            gef_print(c(edx,  8, 1,          "        EDX     8: Reserved"))
            gef_print(c(edx,  9, 1,          "        EDX     9: Reserved"))
            gef_print(c(edx, 10, 1,          "        EDX    10: Pause intercept filter"))
            gef_print(c(edx, 11, 1,          "        EDX    11: Encrypted micro-code patch"))
            gef_print(c(edx, 12, 1,          "        EDX    12: PAUSE filter threshold"))
            gef_print(c(edx, 13, 1,          "        EDX    13: AMD virtual interrupt controller"))
            gef_print(c(edx, 14, 1,          "        EDX    14: Reserved"))
            gef_print(c(edx, 15, 1,          "        EDX    15: Virtualized VMLOAD/VMSAVE"))
            gef_print(c(edx, 16, 1,          "        EDX    16: Virtualized GIF"))
            gef_print(c(edx, 17, 1,          "        EDX    17: GMET (Guest Mode Execution Trap"))
            gef_print(c(edx, 18, 1,          "        EDX    18: Reserved"))
            gef_print(c(edx, 19, 1,          "        EDX    19: SVM supervisor shadow stack restrictions"))
            gef_print(c(edx, 20, 1,          "        EDX    20: SPEC_CTRL virtualization"))
            gef_print(c(edx, 21, 1,          "        EDX    21: Reserved"))
            gef_print(c(edx, 22, 1,          "        EDX    22: Reserved"))
            gef_print(c(edx, 23, 1,          "        EDX    23: Host MCE override"))
            gef_print(c(edx, 24, 1,          "        EDX    24: INVLPGB/TLBSYNC hypervisor enable"))
            gef_print(c(edx, 25, 0x7f,       "        EDX 31-25: Reserved"))
        elif id == 0x80000019:
            gef_print("    TLB Configuration Descriptors")
        elif id == 0x8000001a:
            gef_print("    Performance Optimization Identifiers")
            gef_print(c(eax,  0, 1,          "        EAX     0: FP128 (128-bit SSE full-width pipelines)"))
            gef_print(c(eax,  1, 1,          "        EAX     1: MOVU (Efficient MOVU SSE instructions)"))
            gef_print(c(eax,  2, 1,          "        EAX     2: FP256 (256-bit AVX full-width pipelines)"))
            gef_print(c(eax,  3, 0x1fffffff, "        EAX 31- 3: Reserved"))
        elif id == 0x8000001b:
            gef_print("    Instruction Based Sampling Identifiers")
            gef_print(c(eax,  0, 1,          "        EAX     0: IBSFFV (IBS Feature Flags Valid)"))
            gef_print(c(eax,  1, 1,          "        EAX     1: FetchSam (IBS Fetch Sampling)"))
            gef_print(c(eax,  2, 1,          "        EAX     2: OpSam (IBS Execution Sampling)"))
            gef_print(c(eax,  3, 1,          "        EAX     3: RdWrOpCnt (Read/write of Op Counter)"))
            gef_print(c(eax,  4, 1,          "        EAX     4: OpCnt (Op Counting mode)"))
            gef_print(c(eax,  5, 1,          "        EAX     5: BrnTrgt (Branch Target address reporting)"))
            gef_print(c(eax,  6, 1,          "        EAX     6: OpCntExt (IBS op cur/max count extended by 7 bits)"))
            gef_print(c(eax,  7, 1,          "        EAX     7: RipInvalidChk (IBS RIP invalid indication)"))
            gef_print(c(eax,  8, 1,          "        EAX     8: OpBrnFuse (IBS fused Branch micro-op indication)"))
            gef_print(c(eax,  9, 1,          "        EAX     9: IbsFetchCtlExtd (IBS Fetch Control Extended MSR)"))
            gef_print(c(eax, 10, 1,          "        EAX    10: IbsOpData4 (IBS Op Data 4 MSR)"))
            gef_print(c(eax, 11, 0x1fffff,   "        EAX 31-11: Reserved"))
        elif id == 0x8fffffff:
            vid = (p32(eax) + p32(ebx) + p32(ecx) + p32(edx)).decode("utf-8")
            gef_print("    eax+ebx+ecx+edx: Easter egg (={:s})".format(repr(vid)))
        elif id == 0xc0000000:
            gef_print("    eax: Maximum Input Value for Extended Function CPUID Information")
            gef_print("    ebx,ecx,edx: Reserved")
        elif id == 0xc0000001:
            gef_print("    Centaur features")
            gef_print(c(edx,  0, 1,          "        EDX     0: AIS (Alternate Instruction Set available)"))
            gef_print(c(edx,  1, 1,          "        EDX     1: AIS_EN (Alternate Instruction Set ENabled)"))
            gef_print(c(edx,  2, 1,          "        EDX     2: RNG (Random Number Generator available)"))
            gef_print(c(edx,  3, 1,          "        EDX     3: RNG_EN (Random Number Generator ENabled)"))
            gef_print(c(edx,  4, 1,          "        EDX     4: LH (LongHaul MSR 0000_110Ah)"))
            gef_print(c(edx,  5, 1,          "        EDX     5: FEMMS"))
            gef_print(c(edx,  6, 1,          "        EDX     6: ACE (Advanced Cryptography Engine available)"))
            gef_print(c(edx,  7, 1,          "        EDX     7: ACE_EN (Advanced Cryptography Engine Enabled)"))
            gef_print(c(edx,  8, 1,          "        EDX     8: ACE2 (Montgomery Multiplier and Hash Engine available)"))
            gef_print(c(edx,  9, 1,          "        EDX     9: ACE2_EN (Montgomery Multiplier and Hash Engine Enabled)"))
            gef_print(c(edx, 10, 1,          "        EDX    10: PHE (Padlock Hash Engine available)"))
            gef_print(c(edx, 11, 1,          "        EDX    11: PHE_EN (Padlock Hash Engine ENabled)"))
            gef_print(c(edx, 12, 1,          "        EDX    12: PMM (Padlock Montgomery Multiplier available)"))
            gef_print(c(edx, 13, 1,          "        EDX    13: PMM_EN (Padlock Montgomery Multiplier ENabled)"))
            gef_print(c(edx, 14, 0x3ffff,    "        EAX 31-14: Reserved"))
        return

    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            argv.remove("-h")
            self.usage()
            return

        # Basic Information
        eax, _, _, _ = self.execute_cpuid(0)
        valid_max_cpuid = min(eax, 0x20)

        for id in range(valid_max_cpuid + 1):
            if id == 4:
                for subid in range(3):
                    eax, ebx, ecx, edx = self.execute_cpuid(id, subid)
                    self.show_result(id, subid, eax, ebx, ecx, edx)
            elif id == 7:
                eax, _, _, _ = self.execute_cpuid(id, 0)
                for subid in range(eax + 1):
                    eax, ebx, ecx, edx = self.execute_cpuid(id, subid)
                    self.show_result(id, subid, eax, ebx, ecx, edx)
            elif id == 13:
                for subid in range(63):
                    eax, ebx, ecx, edx = self.execute_cpuid(id, subid)
                    self.show_result(id, subid, eax, ebx, ecx, edx)
            elif id in [16, 18, 19, 20, 23, 24, 26, 31]:
                eax, ebx, ecx, edx = self.execute_cpuid(id, 0)
                self.show_result(id, 0, eax, ebx, ecx, edx)
            else:
                eax, ebx, ecx, edx = self.execute_cpuid(id)
                self.show_result(id, None, eax, ebx, ecx, edx)

        # Hypervisor Information
        valid_max_cpuid, _, _, _ = self.execute_cpuid(0x40000000)
        for id in range(0x40000000, valid_max_cpuid + 1):
            eax, ebx, ecx, edx = self.execute_cpuid(id)
            self.show_result(id, None, eax, ebx, ecx, edx)

        # Extended Information
        valid_max_cpuid, _, _, _ = self.execute_cpuid(0x80000000)
        for id in range(0x80000000, valid_max_cpuid + 1):
            eax, ebx, ecx, edx = self.execute_cpuid(id)
            self.show_result(id, None, eax, ebx, ecx, edx)
        for id in [0x8fffffff]:
            eax, ebx, ecx, edx = self.execute_cpuid(id)
            self.show_result(id, None, eax, ebx, ecx, edx)

        # Transmeta Specific Information
        valid_max_cpuid, _, _, _ = self.execute_cpuid(0x80860000)
        for id in range(0x80860000, valid_max_cpuid + 1):
            eax, ebx, ecx, edx = self.execute_cpuid(id)
            self.show_result(id, None, eax, ebx, ecx, edx)

        # Centaur(VIA) Specific Information
        valid_max_cpuid, _, _, _ = self.execute_cpuid(0xc0000000)
        for id in range(0xc0000000, valid_max_cpuid + 1):
            eax, ebx, ecx, edx = self.execute_cpuid(id)
            self.show_result(id, None, eax, ebx, ecx, edx)
        return


@register_command
class MsrCommand(GenericCommand):
    """Get MSR via kernel."""
    _cmdline_ = "msr"
    _category_ = "04-a. Register - View"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-l', dest='filter', nargs='*', help='list up known MSR values.')
    group.add_argument('msr_target', metavar='MSR_VALUE|MSR_NAME', nargs='?', help='the msr value/name you want to know real value.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} 0xc0000080              # rcx value\n".format(_cmdline_)
    _example_ += "{:s} MSR_EFER                # another valid format\n".format(_cmdline_)
    _example_ += "{:s} -l                      # list up known MSR const values\n".format(_cmdline_)
    _example_ += "{:s} -l MSR_EFER MSR_GS_BASE # show specified MSR const value\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "DISABLE `-enable-kvm` option for qemu-system; This command will be aborted if the option is set"

    msr_table = [
        ["MSR_EFER",                         0xc0000080, "Extended feature register"],
        ["MSR_STAR",                         0xc0000081, "Legacy mode SYSCALL target"],
        ["MSR_LSTAR",                        0xc0000082, "Long mode SYSCALL target"],
        ["MSR_CSTAR",                        0xc0000083, "Compat mode SYSCALL target"],
        ["MSR_SYSCALL_MASK",                 0xc0000084, "EFLAGS mask for syscall"],
        ["MSR_FS_BASE",                      0xc0000100, "64bit FS base"],
        ["MSR_GS_BASE",                      0xc0000101, "64bit GS base"],
        ["MSR_KERNEL_GS_BASE",               0xc0000102, "SwapGS GS shadow"],
        ["MSR_TSC_AUX",                      0xc0000103, "Auxiliary TSC"],
        ["MSR_TEST_CTRL",                    0x00000033, ""],
        ["MSR_IA32_SPEC_CTRL",               0x00000048, "Speculation Control"],
        ["MSR_IA32_PRED_CMD",                0x00000049, "Prediction Command"],
        ["MSR_PPIN_CTL",                     0x0000004e, ""],
        ["MSR_PPIN",                         0x0000004f, ""],
        ["MSR_IA32_PERFCTR",                 0x000000c1, ""],
        ["MSR_IA32_PERFCTR",                 0x000000c2, ""],
        ["MSR_FSB_FREQ",                     0x000000cd, ""],
        ["MSR_PLATFORM_INFO",                0x000000ce, ""],
        ["MSR_IA32_CORE_CAPS",               0x000000cf, ""],
        ["MSR_IA32_UMWAIT_CONTROL",          0x000000e1, ""],
        ["MSR_PKG_CST_CONFIG_CONTROL",       0x000000e2, ""],
        ["MSR_MTRRcap",                      0x000000fe, ""],
        ["MSR_IA32_ARCH_CAPABILITIES",       0x0000010a, ""],
        ["MSR_IA32_FLUSH_CMD",               0x0000010b, ""],
        ["MSR_IA32_BBL_CR_CTL",              0x00000119, ""],
        ["MSR_IA32_BBL_CR_CTL3",             0x0000011e, ""],
        ["MSR_IA32_TSX_CTRL",                0x00000122, ""],
        ["MSR_IA32_MCU_OPT_CTRL",            0x00000123, ""],
        ["MSR_IA32_SYSENTER_CS",             0x00000174, ""],
        ["MSR_IA32_SYSENTER_ESP",            0x00000175, ""],
        ["MSR_IA32_SYSENTER_EIP",            0x00000176, ""],
        ["MSR_IA32_MCG_CAP",                 0x00000179, ""],
        ["MSR_IA32_MCG_STATUS",              0x0000017a, ""],
        ["MSR_IA32_MCG_CTL",                 0x0000017b, ""],
        ["MSR_IA32_MCG_EXT_CTL",             0x000004d0, ""],
        ["MSR_OFFCORE_RSP_0",                0x000001a6, ""],
        ["MSR_OFFCORE_RSP_1",                0x000001a7, ""],
        ["MSR_TURBO_RATIO_LIMIT",            0x000001ad, ""],
        ["MSR_TURBO_RATIO_LIMIT1",           0x000001ae, ""],
        ["MSR_TURBO_RATIO_LIMIT2",           0x000001af, ""],
        ["MSR_LBR_SELECT",                   0x000001c8, ""],
        ["MSR_LBR_TOS",                      0x000001c9, ""],
        ["MSR_IA32_POWER_CTL",               0x000001fc, ""],
        ["MSR_LBR_NHM_FROM",                 0x00000680, ""],
        ["MSR_LBR_NHM_TO",                   0x000006c0, ""],
        ["MSR_LBR_CORE_FROM",                0x00000040, ""],
        ["MSR_LBR_CORE_TO",                  0x00000060, ""],
        ["MSR_LBR_INFO_0",                   0x00000dc0, ""],
        ["MSR_LBR_INFO_1",                   0x00000dc1, ""],
        ["MSR_LBR_INFO_2",                   0x00000dc2, ""],
        ["MSR_LBR_INFO_3",                   0x00000dc3, ""],
        ["MSR_LBR_INFO_4",                   0x00000dc4, ""],
        ["MSR_LBR_INFO_5",                   0x00000dc5, ""],
        ["MSR_LBR_INFO_6",                   0x00000dc6, ""],
        ["MSR_LBR_INFO_7",                   0x00000dc7, ""],
        ["MSR_LBR_INFO_8",                   0x00000dc8, ""],
        ["MSR_LBR_INFO_9",                   0x00000dc9, ""],
        ["MSR_LBR_INFO_10",                  0x00000dca, ""],
        ["MSR_LBR_INFO_11",                  0x00000dcb, ""],
        ["MSR_LBR_INFO_12",                  0x00000dcc, ""],
        ["MSR_LBR_INFO_13",                  0x00000dcd, ""],
        ["MSR_LBR_INFO_14",                  0x00000dce, ""],
        ["MSR_LBR_INFO_15",                  0x00000dcf, ""],
        ["MSR_LBR_INFO_16",                  0x00000dd0, ""],
        ["MSR_LBR_INFO_17",                  0x00000dd1, ""],
        ["MSR_LBR_INFO_18",                  0x00000dd2, ""],
        ["MSR_LBR_INFO_19",                  0x00000dd3, ""],
        ["MSR_LBR_INFO_20",                  0x00000dd4, ""],
        ["MSR_LBR_INFO_21",                  0x00000dd5, ""],
        ["MSR_LBR_INFO_22",                  0x00000dd6, ""],
        ["MSR_LBR_INFO_23",                  0x00000dd7, ""],
        ["MSR_LBR_INFO_24",                  0x00000dd8, ""],
        ["MSR_LBR_INFO_25",                  0x00000dd9, ""],
        ["MSR_LBR_INFO_26",                  0x00000dda, ""],
        ["MSR_LBR_INFO_27",                  0x00000ddb, ""],
        ["MSR_LBR_INFO_28",                  0x00000ddc, ""],
        ["MSR_LBR_INFO_29",                  0x00000ddd, ""],
        ["MSR_LBR_INFO_30",                  0x00000dde, ""],
        ["MSR_LBR_INFO_31",                  0x00000ddf, ""],
        ["MSR_ARCH_LBR_CTL",                 0x000014ce, ""],
        ["MSR_ARCH_LBR_DEPTH",               0x000014cf, ""],
        ["MSR_ARCH_LBR_FROM_0",              0x00001500, ""],
        ["MSR_ARCH_LBR_TO_0",                0x00001600, ""],
        ["MSR_ARCH_LBR_INFO_0",              0x00001200, ""],
        ["MSR_IA32_PEBS_ENABLE",             0x000003f1, ""],
        ["MSR_PEBS_DATA_CFG",                0x000003f2, ""],
        ["MSR_IA32_DS_AREA",                 0x00000600, ""],
        ["MSR_IA32_PERF_CAPABILITIES",       0x00000345, ""],
        ["MSR_PEBS_LD_LAT_THRESHOLD",        0x000003f6, ""],
        ["MSR_IA32_RTIT_CTL",                0x00000570, ""],
        ["MSR_IA32_RTIT_STATUS",             0x00000571, ""],
        ["MSR_IA32_RTIT_ADDR0_A",            0x00000580, ""],
        ["MSR_IA32_RTIT_ADDR0_B",            0x00000581, ""],
        ["MSR_IA32_RTIT_ADDR1_A",            0x00000582, ""],
        ["MSR_IA32_RTIT_ADDR1_B",            0x00000583, ""],
        ["MSR_IA32_RTIT_ADDR2_A",            0x00000584, ""],
        ["MSR_IA32_RTIT_ADDR2_B",            0x00000585, ""],
        ["MSR_IA32_RTIT_ADDR3_A",            0x00000586, ""],
        ["MSR_IA32_RTIT_ADDR3_B",            0x00000587, ""],
        ["MSR_IA32_RTIT_CR3_MATCH",          0x00000572, ""],
        ["MSR_IA32_RTIT_OUTPUT_BASE",        0x00000560, ""],
        ["MSR_IA32_RTIT_OUTPUT_MASK",        0x00000561, ""],
        ["MSR_MTRRfix64K_00000",             0x00000250, ""],
        ["MSR_MTRRfix16K_80000",             0x00000258, ""],
        ["MSR_MTRRfix16K_A0000",             0x00000259, ""],
        ["MSR_MTRRfix4K_C0000",              0x00000268, ""],
        ["MSR_MTRRfix4K_C8000",              0x00000269, ""],
        ["MSR_MTRRfix4K_D0000",              0x0000026a, ""],
        ["MSR_MTRRfix4K_D8000",              0x0000026b, ""],
        ["MSR_MTRRfix4K_E0000",              0x0000026c, ""],
        ["MSR_MTRRfix4K_E8000",              0x0000026d, ""],
        ["MSR_MTRRfix4K_F0000",              0x0000026e, ""],
        ["MSR_MTRRfix4K_F8000",              0x0000026f, ""],
        ["MSR_MTRRdefType",                  0x000002ff, ""],
        ["MSR_IA32_CR_PAT",                  0x00000277, ""],
        ["MSR_IA32_DEBUGCTLMSR",             0x000001d9, ""],
        ["MSR_IA32_LASTBRANCHFROMIP",        0x000001db, ""],
        ["MSR_IA32_LASTBRANCHTOIP",          0x000001dc, ""],
        ["MSR_IA32_LASTINTFROMIP",           0x000001dd, ""],
        ["MSR_IA32_LASTINTTOIP",             0x000001de, ""],
        ["MSR_PEBS_FRONTEND",                0x000003f7, ""],
        ["MSR_IA32_MC0_CTL",                 0x00000400, ""],
        ["MSR_IA32_MC0_STATUS",              0x00000401, ""],
        ["MSR_IA32_MC0_ADDR",                0x00000402, ""],
        ["MSR_IA32_MC0_MISC",                0x00000403, ""],
        ["MSR_PKG_C3_RESIDENCY",             0x000003f8, ""],
        ["MSR_PKG_C6_RESIDENCY",             0x000003f9, ""],
        ["MSR_ATOM_PKG_C6_RESIDENCY",        0x000003fa, ""],
        ["MSR_PKG_C7_RESIDENCY",             0x000003fa, ""],
        ["MSR_CORE_C3_RESIDENCY",            0x000003fc, ""],
        ["MSR_CORE_C6_RESIDENCY",            0x000003fd, ""],
        ["MSR_CORE_C7_RESIDENCY",            0x000003fe, ""],
        ["MSR_KNL_CORE_C6_RESIDENCY",        0x000003ff, ""],
        ["MSR_PKG_C2_RESIDENCY",             0x0000060d, ""],
        ["MSR_PKG_C8_RESIDENCY",             0x00000630, ""],
        ["MSR_PKG_C9_RESIDENCY",             0x00000631, ""],
        ["MSR_PKG_C10_RESIDENCY",            0x00000632, ""],
        ["MSR_PKGC3_IRTL",                   0x0000060a, ""],
        ["MSR_PKGC6_IRTL",                   0x0000060b, ""],
        ["MSR_PKGC7_IRTL",                   0x0000060c, ""],
        ["MSR_PKGC8_IRTL",                   0x00000633, ""],
        ["MSR_PKGC9_IRTL",                   0x00000634, ""],
        ["MSR_PKGC10_IRTL",                  0x00000635, ""],
        ["MSR_RAPL_POWER_UNIT",              0x00000606, ""],
        ["MSR_PKG_POWER_LIMIT",              0x00000610, ""],
        ["MSR_PKG_ENERGY_STATUS",            0x00000611, ""],
        ["MSR_PKG_PERF_STATUS",              0x00000613, ""],
        ["MSR_PKG_POWER_INFO",               0x00000614, ""],
        ["MSR_DRAM_POWER_LIMIT",             0x00000618, ""],
        ["MSR_DRAM_ENERGY_STATUS",           0x00000619, ""],
        ["MSR_DRAM_PERF_STATUS",             0x0000061b, ""],
        ["MSR_DRAM_POWER_INFO",              0x0000061c, ""],
        ["MSR_PP0_POWER_LIMIT",              0x00000638, ""],
        ["MSR_PP0_ENERGY_STATUS",            0x00000639, ""],
        ["MSR_PP0_POLICY",                   0x0000063a, ""],
        ["MSR_PP0_PERF_STATUS",              0x0000063b, ""],
        ["MSR_PP1_POWER_LIMIT",              0x00000640, ""],
        ["MSR_PP1_ENERGY_STATUS",            0x00000641, ""],
        ["MSR_PP1_POLICY",                   0x00000642, ""],
        ["MSR_AMD_PKG_ENERGY_STATUS",        0xc001029b, ""],
        ["MSR_AMD_RAPL_POWER_UNIT",          0xc0010299, ""],
        ["MSR_CONFIG_TDP_NOMINAL",           0x00000648, ""],
        ["MSR_CONFIG_TDP_LEVEL_1",           0x00000649, ""],
        ["MSR_CONFIG_TDP_LEVEL_2",           0x0000064a, ""],
        ["MSR_CONFIG_TDP_CONTROL",           0x0000064b, ""],
        ["MSR_TURBO_ACTIVATION_RATIO",       0x0000064c, ""],
        ["MSR_PLATFORM_ENERGY_STATUS",       0x0000064d, ""],
        ["MSR_PKG_WEIGHTED_CORE_C0_RES",     0x00000658, ""],
        ["MSR_PKG_ANY_CORE_C0_RES",          0x00000659, ""],
        ["MSR_PKG_ANY_GFXE_C0_RES",          0x0000065a, ""],
        ["MSR_PKG_BOTH_CORE_GFXE_C0_RES",    0x0000065b, ""],
        ["MSR_CORE_C1_RES",                  0x00000660, ""],
        ["MSR_MODULE_C6_RES_MS",             0x00000664, ""],
        ["MSR_CC6_DEMOTION_POLICY_CONFIG",   0x00000668, ""],
        ["MSR_MC6_DEMOTION_POLICY_CONFIG",   0x00000669, ""],
        ["MSR_ATOM_CORE_RATIOS",             0x0000066a, ""],
        ["MSR_ATOM_CORE_VIDS",               0x0000066b, ""],
        ["MSR_ATOM_CORE_TURBO_RATIOS",       0x0000066c, ""],
        ["MSR_ATOM_CORE_TURBO_VIDS",         0x0000066d, ""],
        ["MSR_CORE_PERF_LIMIT_REASONS",      0x00000690, ""],
        ["MSR_GFX_PERF_LIMIT_REASONS",       0x000006b0, ""],
        ["MSR_RING_PERF_LIMIT_REASONS",      0x000006b1, ""],
        ["MSR_PPERF",                        0x0000064e, ""],
        ["MSR_PERF_LIMIT_REASONS",           0x0000064f, ""],
        ["MSR_PM_ENABLE",                    0x00000770, ""],
        ["MSR_HWP_CAPABILITIES",             0x00000771, ""],
        ["MSR_HWP_REQUEST_PKG",              0x00000772, ""],
        ["MSR_HWP_INTERRUPT",                0x00000773, ""],
        ["MSR_HWP_REQUEST",                  0x00000774, ""],
        ["MSR_HWP_STATUS",                   0x00000777, ""],
        ["MSR_AMD64_MC0_MASK",               0xc0010044, ""],
        ["MSR_IA32_MC0_CTL2",                0x00000280, ""],
        ["MSR_P6_PERFCTR0",                  0x000000c1, ""],
        ["MSR_P6_PERFCTR1",                  0x000000c2, ""],
        ["MSR_P6_EVNTSEL0",                  0x00000186, ""],
        ["MSR_P6_EVNTSEL1",                  0x00000187, ""],
        ["MSR_KNC_PERFCTR0",                 0x00000020, ""],
        ["MSR_KNC_PERFCTR1",                 0x00000021, ""],
        ["MSR_KNC_EVNTSEL0",                 0x00000028, ""],
        ["MSR_KNC_EVNTSEL1",                 0x00000029, ""],
        ["MSR_IA32_PMC0",                    0x000004c1, ""],
        ["MSR_RELOAD_PMC0",                  0x000014c1, ""],
        ["MSR_RELOAD_FIXED_CTR0",            0x00001309, ""],
        ["MSR_AMD64_PATCH_LEVEL",            0x0000008b, ""],
        ["MSR_AMD64_TSC_RATIO",              0xc0000104, ""],
        ["MSR_AMD64_NB_CFG",                 0xc001001f, ""],
        ["MSR_AMD64_PATCH_LOADER",           0xc0010020, ""],
        ["MSR_AMD_PERF_CTL",                 0xc0010062, ""],
        ["MSR_AMD_PERF_STATUS",              0xc0010063, ""],
        ["MSR_AMD_PSTATE_DEF_BASE",          0xc0010064, ""],
        ["MSR_AMD64_OSVW_ID_LENGTH",         0xc0010140, ""],
        ["MSR_AMD64_OSVW_STATUS",            0xc0010141, ""],
        ["MSR_AMD_PPIN_CTL",                 0xc00102f0, ""],
        ["MSR_AMD_PPIN",                     0xc00102f1, ""],
        ["MSR_AMD64_CPUID_FN_1",             0xc0011004, ""],
        ["MSR_AMD64_LS_CFG",                 0xc0011020, ""],
        ["MSR_AMD64_DC_CFG",                 0xc0011022, ""],
        ["MSR_AMD64_BU_CFG2",                0xc001102a, ""],
        ["MSR_AMD64_IBSFETCHCTL",            0xc0011030, ""],
        ["MSR_AMD64_IBSFETCHLINAD",          0xc0011031, ""],
        ["MSR_AMD64_IBSFETCHPHYSAD",         0xc0011032, ""],
        ["MSR_AMD64_IBSOPCTL",               0xc0011033, ""],
        ["MSR_AMD64_IBSOPRIP",               0xc0011034, ""],
        ["MSR_AMD64_IBSOPDATA",              0xc0011035, ""],
        ["MSR_AMD64_IBSOPDATA2",             0xc0011036, ""],
        ["MSR_AMD64_IBSOPDATA3",             0xc0011037, ""],
        ["MSR_AMD64_IBSDCLINAD",             0xc0011038, ""],
        ["MSR_AMD64_IBSDCPHYSAD",            0xc0011039, ""],
        ["MSR_AMD64_IBSCTL",                 0xc001103a, ""],
        ["MSR_AMD64_IBSBRTARGET",            0xc001103b, ""],
        ["MSR_AMD64_IBSOPDATA4",             0xc001103d, ""],
        ["MSR_AMD64_SEV",                    0xc0010131, ""],
        ["MSR_AMD64_VIRT_SPEC_CTRL",         0xc001011f, ""],
        ["MSR_F17H_IRPERF",                  0xc00000e9, ""],
        ["MSR_F16H_L2I_PERF_CTL",            0xc0010230, ""],
        ["MSR_F16H_L2I_PERF_CTR",            0xc0010231, ""],
        ["MSR_F16H_DR1_ADDR_MASK",           0xc0011019, ""],
        ["MSR_F16H_DR2_ADDR_MASK",           0xc001101a, ""],
        ["MSR_F16H_DR3_ADDR_MASK",           0xc001101b, ""],
        ["MSR_F16H_DR0_ADDR_MASK",           0xc0011027, ""],
        ["MSR_F15H_CU_PWR_ACCUMULATOR",      0xc001007a, ""],
        ["MSR_F15H_CU_MAX_PWR_ACCUMULATOR",  0xc001007b, ""],
        ["MSR_F15H_PERF_CTL0",               0xc0010200, ""],
        ["MSR_F15H_PERF_CTL1",               0xc0010202, ""],
        ["MSR_F15H_PERF_CTL2",               0xc0010204, ""],
        ["MSR_F15H_PERF_CTL3",               0xc0010206, ""],
        ["MSR_F15H_PERF_CTL4",               0xc0010208, ""],
        ["MSR_F15H_PERF_CTL5",               0xc001020a, ""],
        ["MSR_F15H_PERF_CTR0",               0xc0010201, ""],
        ["MSR_F15H_PERF_CTR1",               0xc0010203, ""],
        ["MSR_F15H_PERF_CTR2",               0xc0010205, ""],
        ["MSR_F15H_PERF_CTR3",               0xc0010207, ""],
        ["MSR_F15H_PERF_CTR4",               0xc0010209, ""],
        ["MSR_F15H_PERF_CTR5",               0xc001020b, ""],
        ["MSR_F15H_NB_PERF_CTL",             0xc0010240, ""],
        ["MSR_F15H_NB_PERF_CTR",             0xc0010241, ""],
        ["MSR_F15H_PTSC",                    0xc0010280, ""],
        ["MSR_F15H_IC_CFG",                  0xc0011021, ""],
        ["MSR_F15H_EX_CFG",                  0xc001102c, ""],
        ["MSR_FAM10H_MMIO_CONF_BASE",        0xc0010058, ""],
        ["MSR_FAM10H_NODE_ID",               0xc001100c, ""],
        ["MSR_F10H_DECFG",                   0xc0011029, ""],
        ["MSR_K8_TOP_MEM1",                  0xc001001a, ""],
        ["MSR_K8_TOP_MEM2",                  0xc001001d, ""],
        ["MSR_K8_SYSCFG",                    0xc0010010, ""],
        ["MSR_K8_INT_PENDING_MSG",           0xc0010055, ""],
        ["MSR_K8_TSEG_ADDR",                 0xc0010112, ""],
        ["MSR_K8_TSEG_MASK",                 0xc0010113, ""],
        ["MSR_K7_EVNTSEL0",                  0xc0010000, ""],
        ["MSR_K7_PERFCTR0",                  0xc0010004, ""],
        ["MSR_K7_EVNTSEL1",                  0xc0010001, ""],
        ["MSR_K7_PERFCTR1",                  0xc0010005, ""],
        ["MSR_K7_EVNTSEL2",                  0xc0010002, ""],
        ["MSR_K7_PERFCTR2",                  0xc0010006, ""],
        ["MSR_K7_EVNTSEL3",                  0xc0010003, ""],
        ["MSR_K7_PERFCTR3",                  0xc0010007, ""],
        ["MSR_K7_CLK_CTL",                   0xc001001b, ""],
        ["MSR_K7_HWCR",                      0xc0010015, ""],
        ["MSR_K7_FID_VID_CTL",               0xc0010041, ""],
        ["MSR_K7_FID_VID_STATUS",            0xc0010042, ""],
        ["MSR_K6_WHCR",                      0xc0000082, ""],
        ["MSR_K6_UWCCR",                     0xc0000085, ""],
        ["MSR_K6_EPMR",                      0xc0000086, ""],
        ["MSR_K6_PSOR",                      0xc0000087, ""],
        ["MSR_K6_PFIR",                      0xc0000088, ""],
        ["MSR_IDT_FCR1",                     0x00000107, ""],
        ["MSR_IDT_FCR2",                     0x00000108, ""],
        ["MSR_IDT_FCR3",                     0x00000109, ""],
        ["MSR_IDT_FCR4",                     0x0000010a, ""],
        ["MSR_IDT_MCR0",                     0x00000110, ""],
        ["MSR_IDT_MCR1",                     0x00000111, ""],
        ["MSR_IDT_MCR2",                     0x00000112, ""],
        ["MSR_IDT_MCR3",                     0x00000113, ""],
        ["MSR_IDT_MCR4",                     0x00000114, ""],
        ["MSR_IDT_MCR5",                     0x00000115, ""],
        ["MSR_IDT_MCR6",                     0x00000116, ""],
        ["MSR_IDT_MCR7",                     0x00000117, ""],
        ["MSR_IDT_MCR_CTRL",                 0x00000120, ""],
        ["MSR_VIA_FCR",                      0x00001107, ""],
        ["MSR_VIA_LONGHAUL",                 0x0000110a, ""],
        ["MSR_VIA_RNG",                      0x0000110b, ""],
        ["MSR_VIA_BCR2",                     0x00001147, ""],
        ["MSR_TMTA_LONGRUN_CTRL",            0x80868010, ""],
        ["MSR_TMTA_LONGRUN_FLAGS",           0x80868011, ""],
        ["MSR_TMTA_LRTI_READOUT",            0x80868018, ""],
        ["MSR_TMTA_LRTI_VOLT_MHZ",           0x8086801a, ""],
        ["MSR_IA32_P5_MC_ADDR",              0x00000000, ""],
        ["MSR_IA32_P5_MC_TYPE",              0x00000001, ""],
        ["MSR_IA32_TSC",                     0x00000010, ""],
        ["MSR_IA32_PLATFORM_ID",             0x00000017, ""],
        ["MSR_IA32_EBL_CR_POWERON",          0x0000002a, ""],
        ["MSR_EBC_FREQUENCY_ID",             0x0000002c, ""],
        ["MSR_SMI_COUNT",                    0x00000034, ""],
        ["MSR_IA32_FEAT_CTL",                0x0000003a, ""],
        ["MSR_IA32_TSC_ADJUST",              0x0000003b, ""],
        ["MSR_IA32_BNDCFGS",                 0x00000d90, ""],
        ["MSR_IA32_BNDCFGS_RSVD",            0x00000ffc, ""],
        ["MSR_IA32_XSS",                     0x00000da0, ""],
        ["MSR_IA32_APICBASE",                0x0000001b, ""],
        ["MSR_IA32_TSCDEADLINE",             0x000006e0, ""],
        ["MSR_IA32_UCODE_WRITE",             0x00000079, ""],
        ["MSR_IA32_UCODE_REV",               0x0000008b, ""],
        ["MSR_IA32_SMM_MONITOR_CTL",         0x0000009b, ""],
        ["MSR_IA32_SMBASE",                  0x0000009e, ""],
        ["MSR_IA32_PERF_STATUS",             0x00000198, ""],
        ["MSR_IA32_PERF_CTL",                0x00000199, ""],
        ["MSR_IA32_MPERF",                   0x000000e7, ""],
        ["MSR_IA32_APERF",                   0x000000e8, ""],
        ["MSR_IA32_THERM_CONTROL",           0x0000019a, ""],
        ["MSR_IA32_THERM_INTERRUPT",         0x0000019b, ""],
        ["MSR_IA32_THERM_STATUS",            0x0000019c, ""],
        ["MSR_THERM2_CTL",                   0x0000019d, ""],
        ["MSR_IA32_MISC_ENABLE",             0x000001a0, ""],
        ["MSR_IA32_TEMPERATURE_TARGET",      0x000001a2, ""],
        ["MSR_MISC_FEATURE_CONTROL",         0x000001a4, ""],
        ["MSR_MISC_PWR_MGMT",                0x000001aa, ""],
        ["MSR_IA32_ENERGY_PERF_BIAS",        0x000001b0, ""],
        ["MSR_IA32_PACKAGE_THERM_STATUS",    0x000001b1, ""],
        ["MSR_IA32_PACKAGE_THERM_INTERRUPT", 0x000001b2, ""],
        ["MSR_MISC_FEATURES_ENABLES",        0x00000140, ""],
        ["MSR_IA32_TSC_DEADLINE",            0x000006e0, ""],
        ["MSR_TSX_FORCE_ABORT",              0x0000010f, ""],
        ["MSR_IA32_MCG_EAX",                 0x00000180, ""],
        ["MSR_IA32_MCG_EBX",                 0x00000181, ""],
        ["MSR_IA32_MCG_ECX",                 0x00000182, ""],
        ["MSR_IA32_MCG_EDX",                 0x00000183, ""],
        ["MSR_IA32_MCG_ESI",                 0x00000184, ""],
        ["MSR_IA32_MCG_EDI",                 0x00000185, ""],
        ["MSR_IA32_MCG_EBP",                 0x00000186, ""],
        ["MSR_IA32_MCG_ESP",                 0x00000187, ""],
        ["MSR_IA32_MCG_EFLAGS",              0x00000188, ""],
        ["MSR_IA32_MCG_EIP",                 0x00000189, ""],
        ["MSR_IA32_MCG_RESERVED",            0x0000018a, ""],
        ["MSR_P4_BPU_PERFCTR0",              0x00000300, ""],
        ["MSR_P4_BPU_PERFCTR1",              0x00000301, ""],
        ["MSR_P4_BPU_PERFCTR2",              0x00000302, ""],
        ["MSR_P4_BPU_PERFCTR3",              0x00000303, ""],
        ["MSR_P4_MS_PERFCTR0",               0x00000304, ""],
        ["MSR_P4_MS_PERFCTR1",               0x00000305, ""],
        ["MSR_P4_MS_PERFCTR2",               0x00000306, ""],
        ["MSR_P4_MS_PERFCTR3",               0x00000307, ""],
        ["MSR_P4_FLAME_PERFCTR0",            0x00000308, ""],
        ["MSR_P4_FLAME_PERFCTR1",            0x00000309, ""],
        ["MSR_P4_FLAME_PERFCTR2",            0x0000030a, ""],
        ["MSR_P4_FLAME_PERFCTR3",            0x0000030b, ""],
        ["MSR_P4_IQ_PERFCTR0",               0x0000030c, ""],
        ["MSR_P4_IQ_PERFCTR1",               0x0000030d, ""],
        ["MSR_P4_IQ_PERFCTR2",               0x0000030e, ""],
        ["MSR_P4_IQ_PERFCTR3",               0x0000030f, ""],
        ["MSR_P4_IQ_PERFCTR4",               0x00000310, ""],
        ["MSR_P4_IQ_PERFCTR5",               0x00000311, ""],
        ["MSR_P4_BPU_CCCR0",                 0x00000360, ""],
        ["MSR_P4_BPU_CCCR1",                 0x00000361, ""],
        ["MSR_P4_BPU_CCCR2",                 0x00000362, ""],
        ["MSR_P4_BPU_CCCR3",                 0x00000363, ""],
        ["MSR_P4_MS_CCCR0",                  0x00000364, ""],
        ["MSR_P4_MS_CCCR1",                  0x00000365, ""],
        ["MSR_P4_MS_CCCR2",                  0x00000366, ""],
        ["MSR_P4_MS_CCCR3",                  0x00000367, ""],
        ["MSR_P4_FLAME_CCCR0",               0x00000368, ""],
        ["MSR_P4_FLAME_CCCR1",               0x00000369, ""],
        ["MSR_P4_FLAME_CCCR2",               0x0000036a, ""],
        ["MSR_P4_FLAME_CCCR3",               0x0000036b, ""],
        ["MSR_P4_IQ_CCCR0",                  0x0000036c, ""],
        ["MSR_P4_IQ_CCCR1",                  0x0000036d, ""],
        ["MSR_P4_IQ_CCCR2",                  0x0000036e, ""],
        ["MSR_P4_IQ_CCCR3",                  0x0000036f, ""],
        ["MSR_P4_IQ_CCCR4",                  0x00000370, ""],
        ["MSR_P4_IQ_CCCR5",                  0x00000371, ""],
        ["MSR_P4_ALF_ESCR0",                 0x000003ca, ""],
        ["MSR_P4_ALF_ESCR1",                 0x000003cb, ""],
        ["MSR_P4_BPU_ESCR0",                 0x000003b2, ""],
        ["MSR_P4_BPU_ESCR1",                 0x000003b3, ""],
        ["MSR_P4_BSU_ESCR0",                 0x000003a0, ""],
        ["MSR_P4_BSU_ESCR1",                 0x000003a1, ""],
        ["MSR_P4_CRU_ESCR0",                 0x000003b8, ""],
        ["MSR_P4_CRU_ESCR1",                 0x000003b9, ""],
        ["MSR_P4_CRU_ESCR2",                 0x000003cc, ""],
        ["MSR_P4_CRU_ESCR3",                 0x000003cd, ""],
        ["MSR_P4_CRU_ESCR4",                 0x000003e0, ""],
        ["MSR_P4_CRU_ESCR5",                 0x000003e1, ""],
        ["MSR_P4_DAC_ESCR0",                 0x000003a8, ""],
        ["MSR_P4_DAC_ESCR1",                 0x000003a9, ""],
        ["MSR_P4_FIRM_ESCR0",                0x000003a4, ""],
        ["MSR_P4_FIRM_ESCR1",                0x000003a5, ""],
        ["MSR_P4_FLAME_ESCR0",               0x000003a6, ""],
        ["MSR_P4_FLAME_ESCR1",               0x000003a7, ""],
        ["MSR_P4_FSB_ESCR0",                 0x000003a2, ""],
        ["MSR_P4_FSB_ESCR1",                 0x000003a3, ""],
        ["MSR_P4_IQ_ESCR0",                  0x000003ba, ""],
        ["MSR_P4_IQ_ESCR1",                  0x000003bb, ""],
        ["MSR_P4_IS_ESCR0",                  0x000003b4, ""],
        ["MSR_P4_IS_ESCR1",                  0x000003b5, ""],
        ["MSR_P4_ITLB_ESCR0",                0x000003b6, ""],
        ["MSR_P4_ITLB_ESCR1",                0x000003b7, ""],
        ["MSR_P4_IX_ESCR0",                  0x000003c8, ""],
        ["MSR_P4_IX_ESCR1",                  0x000003c9, ""],
        ["MSR_P4_MOB_ESCR0",                 0x000003aa, ""],
        ["MSR_P4_MOB_ESCR1",                 0x000003ab, ""],
        ["MSR_P4_MS_ESCR0",                  0x000003c0, ""],
        ["MSR_P4_MS_ESCR1",                  0x000003c1, ""],
        ["MSR_P4_PMH_ESCR0",                 0x000003ac, ""],
        ["MSR_P4_PMH_ESCR1",                 0x000003ad, ""],
        ["MSR_P4_RAT_ESCR0",                 0x000003bc, ""],
        ["MSR_P4_RAT_ESCR1",                 0x000003bd, ""],
        ["MSR_P4_SAAT_ESCR0",                0x000003ae, ""],
        ["MSR_P4_SAAT_ESCR1",                0x000003af, ""],
        ["MSR_P4_SSU_ESCR0",                 0x000003be, ""],
        ["MSR_P4_SSU_ESCR1",                 0x000003bf, ""],
        ["MSR_P4_TBPU_ESCR0",                0x000003c2, ""],
        ["MSR_P4_TBPU_ESCR1",                0x000003c3, ""],
        ["MSR_P4_TC_ESCR0",                  0x000003c4, ""],
        ["MSR_P4_TC_ESCR1",                  0x000003c5, ""],
        ["MSR_P4_U2L_ESCR0",                 0x000003b0, ""],
        ["MSR_P4_U2L_ESCR1",                 0x000003b1, ""],
        ["MSR_P4_PEBS_MATRIX_VERT",          0x000003f2, ""],
        ["MSR_CORE_PERF_FIXED_CTR0",         0x00000309, ""],
        ["MSR_CORE_PERF_FIXED_CTR1",         0x0000030a, ""],
        ["MSR_CORE_PERF_FIXED_CTR2",         0x0000030b, ""],
        ["MSR_CORE_PERF_FIXED_CTR_CTRL",     0x0000038d, ""],
        ["MSR_CORE_PERF_GLOBAL_STATUS",      0x0000038e, ""],
        ["MSR_CORE_PERF_GLOBAL_CTRL",        0x0000038f, ""],
        ["MSR_CORE_PERF_GLOBAL_OVF_CTRL",    0x00000390, ""],
        ["MSR_GEODE_BUSCONT_CONF0",          0x00001900, ""],
        ["MSR_IA32_VMX_BASIC",               0x00000480, ""],
        ["MSR_IA32_VMX_PINBASED_CTLS",       0x00000481, ""],
        ["MSR_IA32_VMX_PROCBASED_CTLS",      0x00000482, ""],
        ["MSR_IA32_VMX_EXIT_CTLS",           0x00000483, ""],
        ["MSR_IA32_VMX_ENTRY_CTLS",          0x00000484, ""],
        ["MSR_IA32_VMX_MISC",                0x00000485, ""],
        ["MSR_IA32_VMX_CR0_FIXED0",          0x00000486, ""],
        ["MSR_IA32_VMX_CR0_FIXED1",          0x00000487, ""],
        ["MSR_IA32_VMX_CR4_FIXED0",          0x00000488, ""],
        ["MSR_IA32_VMX_CR4_FIXED1",          0x00000489, ""],
        ["MSR_IA32_VMX_VMCS_ENUM",           0x0000048a, ""],
        ["MSR_IA32_VMX_PROCBASED_CTLS2",     0x0000048b, ""],
        ["MSR_IA32_VMX_EPT_VPID_CAP",        0x0000048c, ""],
        ["MSR_IA32_VMX_TRUE_PINBASED_CTLS",  0x0000048d, ""],
        ["MSR_IA32_VMX_TRUE_PROCBASED_CTLS", 0x0000048e, ""],
        ["MSR_IA32_VMX_TRUE_EXIT_CTLS",      0x0000048f, ""],
        ["MSR_IA32_VMX_TRUE_ENTRY_CTLS",     0x00000490, ""],
        ["MSR_IA32_VMX_VMFUNC",              0x00000491, ""],
        ["MSR_VM_CR",                        0xc0010114, ""],
        ["MSR_VM_IGNNE",                     0xc0010115, ""],
        ["MSR_VM_HSAVE_PA",                  0xc0010117, ""],
    ]

    def lookup_name2val(self, target_name):
        for name, val, desc in self.msr_table:
            if name == target_name:
                return val
        return None

    def lookup_val2name(self, target_val):
        for name, val, desc in self.msr_table:
            if val == target_val:
                return name
        return "Unknown"

    def print_const_table(self, filt):
        gef_print(titlify("MSR table"))
        fmt = "{:60s}: {:20s} : {:s}"
        legend = ["Name", "Value", "Description"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for name, val, desc in self.msr_table:
            name = f"{name} ({val:#010x})"
            if filt == []:
                val = self.read_msr_core(val)
                gef_print("{:60s}: {:#020x} : {:s}".format(name, val, desc))
                continue
            for f in filt:
                if f in name:
                    val = self.read_msr_core(val)
                    gef_print("{:60s}: {:#020x} : {:s}".format(name, val, desc))
        return

    def bits_split(self, x, bits=64):
        # 0xaaaabbbb -> 0xaaaa_bbbb
        out = ""
        for i in range(bits):
            if x & (1 << i):
                out = "1" + out
            else:
                out = "0" + out
            if i % 4 == 3:
                out = "_" + out
        while out.startswith("_0000"):
            out = out[5:]
        return "0b" + out[1:]

    def get_state(self, code_len):
        d = {}
        d["pc"] = get_register("$pc")
        d["code"] = read_memory(d["pc"], code_len)
        if is_x86_64():
            d["rax"] = get_register("$rax")
            d["rdx"] = get_register("$rdx")
            d["rcx"] = get_register("$rcx")
        else:
            d["eax"] = get_register("$eax")
            d["edx"] = get_register("$edx")
            d["ecx"] = get_register("$ecx")
        return d

    def revert_state(self, d):
        write_memory(d["pc"], d["code"], len(d["code"]))
        gdb.execute("set $pc = {:#x}".format(d["pc"]), to_string=True)
        if is_x86_64():
            gdb.execute("set $rax = {:#x}".format(d["rax"]), to_string=True)
            gdb.execute("set $rdx = {:#x}".format(d["rdx"]), to_string=True)
            gdb.execute("set $rcx = {:#x}".format(d["rcx"]), to_string=True)
        else:
            gdb.execute("set $eax = {:#x}".format(d["eax"]), to_string=True)
            gdb.execute("set $edx = {:#x}".format(d["edx"]), to_string=True)
            gdb.execute("set $ecx = {:#x}".format(d["ecx"]), to_string=True)
        return

    def close_stdout(self):
        self.stdout = 1
        self.stdout_bak = os.dup(self.stdout)
        f = open("/dev/null")
        os.dup2(f.fileno(), self.stdout)
        f.close()
        return

    def revert_stdout(self):
        os.dup2(self.stdout_bak, self.stdout)
        os.close(self.stdout_bak)
        return

    def read_msr_core(self, num):
        code = b"\xeb\xfe\x0f\x32" # inf-loop (to stop another thread); rdmsr
        gef_on_stop_unhook(hook_stop_handler)
        d = self.get_state(len(code))
        write_memory(d["pc"], code, len(code))
        if is_x86_64():
            gdb.execute("set $rcx = {:#x}".format(num), to_string=True)
        else:
            gdb.execute("set $ecx = {:#x}".format(num), to_string=True)
        gdb.execute("set $pc = {:#x}".format(d["pc"] + 2), to_string=True) # skip "\xeb\xfe"
        self.close_stdout()
        gdb.execute("stepi", to_string=True)
        self.revert_stdout()
        eax = get_register("$eax")
        edx = get_register("$edx")
        self.revert_state(d)
        gef_on_stop_hook(hook_stop_handler)
        return ((edx << 32) | eax) & 0xffffffffffffffff

    def read_msr(self, num):
        val = self.read_msr_core(num)
        name = self.lookup_val2name(num)
        gef_print("{:s} ({:#x}): {:#x} (={:s})".format(name, num, val, self.bits_split(val)))
        return

    @parse_args
    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, args):
        self.dont_repeat()

        if args.msr_target == None:
            self.print_const_table(args.filter)
            return

        ring = get_register("$cs") & 0b11
        if ring != 0:
            err("Ring 0 is needed")
            return

        # search const table
        num = self.lookup_name2val(args.msr_target)
        if num is None:
            try:
                num = int(args.msr_target, 16)
            except Exception as e:
                self.usage()
                return
        self.read_msr(num)
        return


class PrintBitInfo:
    """Printing various bit informations of the register"""

    def __init__(self, name, register_bit, description, bit_info):
        self.name = name
        self.register_bit = register_bit
        self.description = description
        self.bit_info = bit_info
        return

    def bits_split(self, x):
        # split by 4bits. ex: 0bXXYYYY -> 0b00XX_YYYY
        out = ""
        for i in range(self.register_bit):
            if x & (1 << i):
                out = "1" + out
            else:
                out = "0" + out
            if i % 4 == 3:
                out = "_" + out
        return "0b" + out[1:]

    def print_value(self, regval, split=True):
        regname = Color.colorify(self.name, "bold red")
        if split:
            value_str = Color.colorify("{:#x} (={:s})".format(regval, self.bits_split(regval)), "bold yellow")
            gef_print("{:s} = {:s}".format(regname, value_str))
        else:
            value_str = Color.colorify("{:#x}".format(regval), "bold yellow")
            gef_print("{:s} = {:s}".format(regname, value_str))
        return

    def print_description(self):
        if self.description:
            gef_print(self.description)
        return

    def print_bitinfo(self, regval):
        # search max width for bit range string
        bit_range_strs = []
        for info in self.bit_info:
            bits, sym, sdesc, ldesc = info
            if isinstance(bits, int):
                bit_range_strs.append("") # length = 0
            elif isinstance(bits, list):
                bit_range_str = []
                tmp = []
                for b in sorted(bits, reverse=True):
                    if tmp == [] or tmp[-1] - 1 == b:
                        tmp.append(b) # bits are contiguous
                        continue
                    else:
                        # bits are not contiguous (scattered), create format string
                        if len(tmp) == 1:
                            bit_range_str.append("{:d}".format(tmp[0]))
                        else:
                            bit_range_str.append("{:d}-{:d}".format(tmp[0], tmp[-1]))
                        # then restart
                        tmp = [b]
                # add remain
                if tmp:
                    if len(tmp) == 1:
                        bit_range_str.append("{:d}".format(tmp[0]))
                    else:
                        bit_range_str.append("{:d}-{:d}".format(tmp[0], tmp[-1]))
                # join
                bit_range_strs.append(','.join(bit_range_str))
            else:
                raise
        max_width_bits = max(list(map(len, bit_range_strs)) + [2]) # 2 is default

        # search max width for sym
        max_width_sym = 0
        for info in self.bit_info:
            bits, sym, sdesc, ldesc = info
            if sym:
                max_width_sym = max(max_width_sym, len(sym))

        # search max width for val
        max_width_val = 0
        for info in self.bit_info:
            bits, sym, sdesc, ldesc = info
            if isinstance(bits, int):
                val = (regval & (1 << bits)) >> bits
            elif isinstance(bits, list):
                val = 0
                for j, x in enumerate(bits):
                    val |= (regval & (1 << x)) >> (x - j)
            else:
                raise
            max_width_val = max(max_width_val, len("{:#x}".format(val)))

        # search max width for sdesc
        max_width_sdesc = 0
        for info in self.bit_info:
            bits, sym, sdesc, ldesc = info
            if sdesc:
                max_width_sdesc = max(max_width_sdesc, len(sdesc))

        # print using each width
        for i, info in enumerate(self.bit_info):
            bits, sym, sdesc, ldesc = info
            if isinstance(bits, int):
                b = "{:d}".format(bits)
                val = (regval & (1 << bits)) >> bits
            elif isinstance(bits, list):
                b = bit_range_strs[i]
                val = 0
                for j, x in enumerate(bits):
                    val |= (regval & (1 << x)) >> (x - j)
            else:
                raise

            if val:
                colored_val = Color.colorify(f"{val:>#{max_width_val}x}", "bold")
            else:
                colored_val = f"{val:>#{max_width_val}x}"
            if sym is not None and sdesc is not None:
                gef_print(f"bit{b:>{max_width_bits}s}: {colored_val:s} [{sym:{max_width_sym}s}: {sdesc:{max_width_sdesc}s}]: {ldesc}")
            else:
                gef_print(f"bit{b:>{max_width_bits}s}: {colored_val:s}: {ldesc}")
        return

    def print(self, regval, split=True):
        self.print_value(regval, split)
        self.print_description()
        self.print_bitinfo(regval)
        return



@register_command
class QemuRegistersCommand(GenericCommand):
    """Get regisers via qemu-monitor."""
    _cmdline_ = "qreg"
    _category_ = "08-a. Qemu-system Cooperation - General"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-v', dest='verbose', action='store_true', help='also display detailed bit information.')
    _syntax_ = parser.format_help()

    def qregisters_x86_x64(self):
        res = gdb.execute("monitor info registers", to_string=True)
        red = lambda x: Color.colorify(x, "bold red")
        yellow = lambda x: Color.colorify(x, "bold yellow")

        # CR0
        gef_print(titlify("CR0 (Control Register 0)"))
        desc = "It contains system control flags that control operating mode and states of the processor"
        bit_info = [
            [31, "PG", "Paging", "If 1, enable paging and use CR3 register, else disable paging"],
            [30, "CD", "Cache disable", "If 1, disable the memory cache globally"],
            [29, "NW", "Not-write through", "If 1, disable write-through caching globally"],
            [18, "AM", "Alignment mask", "If 1, alignment check enabled when EFLAGS.AC==1 and Ring-3"],
            [16, "WP", "Write protect", "If 1, the CPU can't write to read-only pages when Ring-0"],
            [5, "NE", "Numeric error", "If 1, enable internal x87 FPU error reporting, else enables PC style x87 error detection"],
            [4, "ET", "Extension type", "x64: always 1. i386: if 1, x87 DX math coprosessor instructions is supported"],
            [3, "TS", "Task switched", "If 1, allow the saving x87 task context upon a task switch only after x87 instruction used"],
            [2, "EM", "Emulation", "If 1, no x87 FPU present, else x87 FPU present"],
            [1, "MP", "Monitor co-processor", "If 1, WAIT/FWAIT instructions generate #NM exception when CR0.TS"],
            [0, "PE", "Protected mode enable", "If 1, system is in protected mode, else system is in real mode"],
        ]
        cr0 = int(re.search(r"CR0=(\S+)", res).group(1), 16)
        PrintBitInfo("CR0", 32, desc, bit_info).print(cr0)

        # CR1
        gef_print(titlify("CR1 (Control Register 1)"))
        gef_print("Reserved")

        # CR2
        gef_print(titlify("CR2 (Control Register 2)"))
        desc = "When page fault, the address attempted to access is stored (PFLA: Page Fault Linear Address)"
        cr2 = int(re.search(r"CR2=(\S+)", res).group(1), 16)
        PrintBitInfo("CR2", 64 if is_x86_64() else 32, desc, bit_info=[]).print(cr2, split=False)

        # CR3
        gef_print(titlify("CR3 (Control Register 3)"))
        desc = "It contains the physical address of the base of the paging-structure hierarchy and two flags"
        bit_info = [
            [list(range(12, 32)), None, None, "Base of page directory base, typically it points to PML4T if 4-level paging"],
            [list(range(0, 12)), None, None, "Process context identifier when CR4.PCIDE=1"],
            [4, "PCD", "Page-level Cache Disable", "If 1, disable Page-Directory itself caching when CR4.PCIDE=0"],
            [3, "PWT", "Page-level Write-Through", "If 1, enable write through Page-Directory itself caching when CR4.PCIDE=0"],
        ]
        cr3 = int(re.search(r"CR3=(\S+)", res).group(1), 16)
        PrintBitInfo("CR3", 64 if is_x86_64() else 32, desc, bit_info).print(cr3)

        # CR4
        gef_print(titlify("CR4 (Control Register 4)"))
        desc = "It contains flags that enable some architectural extensions, and indicate OS or executive support for specific processor capabilities"
        bit_info = [
            [24, "PKS", "Enable protection keys for supervisor-mode pages", "If 1, enables PKS"],
            [23, "CET", "Control-flow Enforcement Technology", "If 1, enables CET"],
            [22, "PKE", "Protection Key Enable", "If 1, enables PKE"],
            [21, "SMAP", "Supervisor Mode Access Protection Enable", "If 1, access of data in a higher ring generates a fault"],
            [20, "SMEP", "Supervisor Mode Execution Protection Enable", "If 1, execution of code in a higher ring generates a fault"],
            [18, "OSXSAVE", "Enable XSAVE and Processor Extended States", "If 1, enable XSAVE/XSAVEC/XSAVEOPT/XSAVES/XRSTOR/XRSTORS/XSETBV/XGETBV"],
            [17, "PCIDE", "PCID Enable", "If 1, enables process-context identifiers (PCIDs)"],
            [15, "FSGSBASE", "FSGSBASE Enable", "If 1, enable RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE"],
            [14, "SMXE", "Safer Mode Extensions Enable", "If 1, enable Trusted Execution Technology (TXT)"],
            [13, "VMXE", "Virtual Machine Extensions Enable", "If 1, enable Intel VT-x x86 virtualization"],
            [12, "LA57", "57bit linear addresses", "If 1, enables 5-Level Paging"],
            [11, "UMIP", "User-Mode Instruction Prevention", "If 1, SGDT/SIDT/SLDT/SMSW/STR instructions can only be executed in ring0"],
            [10, "OSXMMEXCPT", "OS support for Unmasked SIMD FP Exceptions", "If 1, enables unmasked SSE exceptions"],
            [9, "OSFXSR", "OS support for FXSAVE/FXRSTOR", "If 1, enables SSE instructions and fast FPU save & restore"],
            [8, "PCE", "Performance-Monitoring Counter enable", "If 1, RDPMC instruction can be executed at any privilege level"],
            [7, "PGE", "Page Global Enabled", "If 1, address translations (PDE or PTE records) may be shared between address spaces"],
            [6, "MCE", "Machine Check Exception", "If 1, enables machine check interrupts to occur"],
            [5, "PAE", "Physical Address Extension", "If 1, changes page table layout to translate 32bit virtaddr into 36bit physaddr"],
            [4, "PSE", "Page Size Extension", "If 1, page size is 4MB, else 4KB, this bit is ignored when PAE or x86-64 long mode"],
            [3, "DE", "Debugging Extensions", "If 1, enables debug register based breaks on I/O space access"],
            [2, "TSD", "Time Stamp Disable", "If 1, RDTSC instruction can only be executed in ring0"],
            [1, "PVI", "Protected-mode Virtual Interrupts", "If 1, enables support for the virtual interrupt flag (VIF) in protected mode"],
            [0, "VME", "Virtual 8086 Mode Extensions", "If 1, enables support for the virtual interrupt flag (VIF) in virtual-8086 mode"],
        ]
        cr4 = int(re.search(r"CR4=(\S+)", res).group(1), 16)
        PrintBitInfo("CR4", 64 if is_x86_64() else 32, desc, bit_info).print(cr4)

        # DR0-DR3
        gef_print(titlify("DR0-DR3 (Debug Address Register 0-3)"))
        desc = "Contain linear addresses of up to 4 hardware breakpoints. If paging is enabled, they are translated to physical addresses"
        dr0 = int(re.search(r"DR0=(\S+)", res).group(1), 16)
        dr1 = int(re.search(r"DR1=(\S+)", res).group(1), 16)
        dr2 = int(re.search(r"DR2=(\S+)", res).group(1), 16)
        dr3 = int(re.search(r"DR3=(\S+)", res).group(1), 16)
        PrintBitInfo("DR0", 64 if is_x86_64() else 32, None, bit_info=[]).print(dr0, split=False)
        PrintBitInfo("DR1", 64 if is_x86_64() else 32, None, bit_info=[]).print(dr1, split=False)
        PrintBitInfo("DR2", 64 if is_x86_64() else 32, None, bit_info=[]).print(dr2, split=False)
        PrintBitInfo("DR3", 64 if is_x86_64() else 32, desc, bit_info=[]).print(dr3, split=False)

        # DR4-DR5
        gef_print(titlify("DR4-DR5 (Debug Register 4-5)"))
        gef_print("Reserved")

        # DR6
        gef_print(titlify("DR6 (Debug Status Register 6)"))
        desc = "It permits the debugger to determine which debug conditions have occurred"
        bit_info = [
            [16, "RTM", "restricted transactional memory", "If 0, the debug exception or breakpoint exception occured inside an RTM region"],
            [15, "BT", "task switch", "If 1, the debug instruction resulted from a task switch where TSS.T of target task was set"],
            [14, "BS", "single step", "If 1, the debug exception was triggered by the single-step execution mode (enabled with EFLAGS.TF)"],
            [13, "BD", "debug register access detected", "If 1, the next instruction accesses one of the debug registers"],
            [3, "B3", "breakpoint condition detected", "If 1, breakpoint condition was met when a debug exception for DR3"],
            [2, "B2", "breakpoint condition detected", "If 1, breakpoint condition was met when a debug exception for DR2"],
            [1, "B1", "breakpoint condition detected", "If 1, breakpoint condition was met when a debug exception for DR1"],
            [0, "B0", "breakpoint condition detected", "If 1, breakpoint condition was met when a debug exception for DR0"],
        ]
        dr6 = int(re.search(r"DR6=(\S+)", res).group(1), 16)
        PrintBitInfo("DR6", 32, desc, bit_info).print(dr6)

        # DR7
        gef_print(titlify("DR7 (Debug Control Register 7)"))
        desc = "A local breakpoint bit deactivates on hardware task switches, while a global does not"
        bit_info = [
            [[30, 31], "LEN3", "Size of DR3 breakpoint", ""],
            [[28, 29], "R/W3", "Breakpoint conditions for DR3", ""],
            [[26, 27], "LEN2", "Size of DR2 breakpoint", ""],
            [[24, 25], "R/W2", "Breakpoint conditions for DR2", ""],
            [[22, 23], "LEN1", "Size of DR1 breakpoint", ""],
            [[20, 21], "R/W1", "Breakpoint conditions for DR1", ""],
            [[18, 19], "LEN0", "Size of DR0 breakpoint", ""],
            [[16, 17], "R/W0", "Breakpoint conditions for DR0", ""],
            [13, "GD", "General Detect enable", ""],
            [11, "RTM", "Restricted Transactional Memory", ""],
            [9, "GE", "Global Exact breakpoint", ""],
            [8, "LE", "Local Exact breakpoint", ""],
            [7, "G3", "Global DR3 breakpoint", ""],
            [6, "L3", "Local DR3 breakpoint", ""],
            [5, "G2", "Global DR2 breakpoint", ""],
            [4, "L2", "Local DR2 breakpoint", ""],
            [3, "G1", "Global DR1 breakpoint", ""],
            [2, "L1", "Local DR1 breakpoint", ""],
            [1, "G0", "Global DR0 breakpoint", ""],
            [0, "L0", "Local DR0 breakpoint", ""],
        ]
        dr7 = int(re.search(r"DR7=(\S+)", res).group(1), 16)
        PrintBitInfo("DR7", 64 if is_x86_64() else 32, desc, bit_info).print(dr7)

        # EFER
        gef_print(titlify("EFER (Extended Feature Enable Register; MSR_EFER:0xc0000080)"))
        efer = int(re.search(r"EFER=(\S+)", res).group(1), 16)
        bit_info = [
            [15, "TCE", "Translation Cache Extension", ""],
            [14, "FFXSR", "Fast FXSAVE/FXRSTOR", ""],
            [13, "LMSLE", "Long Mode Segment Limit Enable", ""],
            [12, "SVME", "Secure Virtual Machine Enable", ""],
            [11, "NXE", "No-Execute Enable", ""],
            [10, "LMA", "Long Mode Active", ""],
            [8, "LME", "Long Mode Enable", ""],
            [4, "L2D", "L2 Cache Disable", "AMD K6 only"],
            [3, "GEWBED", "Global EWBE# Disable", "AMD K6 only"],
            [2, "SEWBED", "Speculative EWBE# Disable", "AMD K6 only"],
            [1, "DPE", "Data Prefetch Enable", "AMD K6 only"],
            [0, "SCE", "System Call Extensions", ""],
        ]
        PrintBitInfo("EFER", 64 if is_x86_64() else 32, None, bit_info).print(efer)

        # TR
        gef_print(titlify("TR (Task Register)"))
        tr = re.search(r"TR\s*=\s*(\S+) (\S+) (\S+) (\S+)", res)
        trseg, base, limit, attr = [int(tr.group(i), 16) for i in range(1, 5)]
        gef_print("{:s} = {:s}".format(red("TR"), yellow("{:#x}".format(trseg))))
        regv = Color.boldify("{:#x} (rpl:{:d},ti:{:d},index:{:d})".format(trseg, trseg & 0b11, (trseg >> 2) & 1, trseg >> 3))
        gef_print("seg: {:s}: segment selector for TSS (Task State Segment)".format(regv))
        gef_print("  base : {:s}: starting address of TSS".format(Color.boldify("{:#x}".format(base))))
        limit_c = Color.boldify("{:#x}".format(limit))
        gef_print("  limit: {:s}: segment limit or fixed value(=__KERNEL_TSS_LIMIT x64:0x206f/x86:0x206b)".format(limit_c))
        gef_print("  attr : {:s}: attribute".format(Color.boldify("{:#x}".format(attr))))

        # GDTR
        gef_print(titlify("GDTR (Global Descriptor Table Register)"))
        gdtr = re.search(r"GDT\s*=\s*(\S+) (\S+)", res)
        base, limit = [int(gdtr.group(i), 16) for i in range(1, 3)]
        gef_print("{:s} = {:s}:{:s}".format(red("GDTR"), yellow("{:#x}".format(base)), yellow("{:#x}".format(limit))))
        gef_print("base : {:s}: starting address of GDT (Global Descriptor Table)".format(Color.boldify("{:#x}".format(base))))
        gef_print("limit: {:s}: (size of GDT) - 1".format(Color.boldify("{:#x}".format(limit))))
        info("GDT entry")
        regs = GdtInfoCommand.get_segreg_list()
        legend = GdtInfoCommand.segval2str_legend()
        gef_print(Color.colorify(legend, get_gef_setting("theme.table_heading")))
        gdtinfo = read_memory(base, limit + 1)
        # https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/segment.h
        if is_x86_64():
            segname_info = [
                "NULL",
                "KERNEL_32_CS",
                "KERNEL_CS",
                "KERNEL_DS",
                "DEFAULT_USER32_CS",
                "DEFAULT_USER_DS",
                "DEFAULT_USER_CS",
                "",
                "TSS-part1",
                "TSS-part2",
                "LDT-part1",
                "LDT-part2",
                "TLS_#1",
                "TLS_#2",
                "TLS_#3",
                "CPUNODE",
            ]
        else:
            segname_info = [
                "NULL",
                "RESERVED",
                "RESERVED",
                "RESERVED",
                "UNUSED",
                "UNUSED",
                "TLS_#1",
                "TLS_#2",
                "TLS_#3",
                "RESERVED",
                "RESERVED",
                "RESERVED",
                "KERNEL_CS",
                "KERNEL_DS",
                "DEFAULT_USER_CS",
                "DEFAULT_USER_DS",
                "TSS",
                "LDT",
                "PNPBIOS_CS32",
                "PNPBIOS_CS16",
                "PNPBIOS_DS",
                "PNPBIOS_TS1",
                "PNPBIOS_TS2",
                "APMBIOS_BASE",
                "APMBIOS",
                "APMBIOS",
                "ESPFIX_SS",
                "PERCPU",
                "STACK_CANARY",
                "UNUSED",
                "UNUSED",
                "DOUBLEFAULT_TSS",
            ]
        sliced = list(map(u64, [gdtinfo[i:i + 8] for i in range(0, len(gdtinfo), 8)]))
        registers_color = get_gef_setting("theme.dereference_register_value")
        for i, b in enumerate(sliced):
            reglist = ', '.join(regs.get(i, []))
            if reglist:
                reglist = LEFT_ARROW + reglist
            if is_x86_64() and i == (trseg >> 3): # for TSS
                s = GdtInfoCommand.segval2str(b, value_only=True)
                prev = b
                reglist = reglist + ", tr" if reglist else LEFT_ARROW + "TR"
            elif is_x86_64() and i == (trseg >> 3) + 1: # for TSS
                s = GdtInfoCommand.segval2str([prev, b])
            elif is_x86_32() and i == (trseg >> 3): # for TSS
                s = GdtInfoCommand.segval2str(b)
                reglist = reglist + ", tr" if reglist else LEFT_ARROW + "TR"
            else:
                s = GdtInfoCommand.segval2str(b)
            gef_print("[{:02d}] {:20s}: {:s} {:s}".format(i, segname_info[i], s, Color.colorify(reglist, registers_color)))
        info("for more info, use `gdtinfo -v` command, it prints legend of GDT entry")

        # IDTR
        gef_print(titlify("IDTR (Interrupt Descriptor Table Register)"))
        idtr = re.search(r"IDT\s*=\s*(\S+) (\S+)", res)
        base, limit = [int(idtr.group(i), 16) for i in range(1, 3)]
        gef_print("{:s} = {:s}:{:s}".format(red("IDTR"), yellow("{:#x}".format(base)), yellow("{:#x}".format(limit))))
        gef_print("base : {:s}: starting address of IDT (Interrupt Descriptor Table)".format(Color.boldify("{:#x}".format(base))))
        gef_print("limit: {:s}: (size of IDT) - 1".format(Color.boldify("{:#x}".format(limit))))

        info("for more info, use `int -v` command, it prints every current IDT entry".format(Color.boldify("EXAMPLE")))

        # LDTR
        gef_print(titlify("LDTR (Local Descriptor Table Register)"))
        ldtr = re.search(r"LDT\s*=\s*(\S+) (\S+) (\S+) (\S+)", res)
        seg, base, limit, attr = [int(ldtr.group(i), 16) for i in range(1, 5)]
        gef_print("{:s} = {:s}".format(red("LDTR"), yellow("{:#x}".format(seg))))
        regv = Color.boldify("{:#x} (rpl:{:d},ti:{:d},index:{:d})".format(seg, seg & 0b11, (seg >> 2) & 1, seg >> 3))
        gef_print("seg: {:s}: segment selector for LDT (Local Descriptor Table)".format(regv))
        gef_print("  base : {:s}: starting address of LDT".format(Color.boldify("{:#x}".format(base))))
        gef_print("  limit: {:s}: segment limit".format(Color.boldify("{:#x}".format(limit))))
        gef_print("  attr : {:s}: attribute".format(Color.boldify("{:#x}".format(attr))))
        return

    def qregisters(self):
        res = gdb.execute("monitor info registers", to_string=True)
        gef_print(titlify("info register"))
        for line in res.splitlines():
            gef_print(line)

        if is_x86():
            if not self.add_info:
                info("use `-v` for print Additional info")
            else:
                info("Additional info")
                self.qregisters_x86_x64()
        return

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()
        self.add_info = args.verbose
        self.qregisters()
        return


@functools.lru_cache(maxsize=None)
def get_maps_arm64_optee_secure_memory(verbose=False):
    # heuristic search of qemu-system memory
    sm_base, sm_size = XSecureMemAddrCommand.get_secure_memory_base_and_size(verbose)
    if sm_base is None or sm_size is None:
        err("Not found memory tree of secure memory (see monitor info mtree -f)")
        return None
    sm = XSecureMemAddrCommand.get_secure_memory_qemu_map(sm_base, sm_size, verbose)
    if sm is None:
        err("Not found secure memory maps")
        return None
    data = XSecureMemAddrCommand.read_secure_memory(sm, 0x0, sm.size, verbose)
    data_list = slice_unpack(data, 8)

    """
    enum teecore_memtypes {
        MEM_AREA_END = 0,
        MEM_AREA_TEE_RAM,
        MEM_AREA_TEE_RAM_RX,
        MEM_AREA_TEE_RAM_RO,
        MEM_AREA_TEE_RAM_RW,
        MEM_AREA_INIT_RAM_RO,
        MEM_AREA_INIT_RAM_RX,
        MEM_AREA_NEX_RAM_RO,
        MEM_AREA_NEX_RAM_RW,
        MEM_AREA_TEE_COHERENT,
        MEM_AREA_TEE_ASAN,
        MEM_AREA_IDENTITY_MAP_RX,
        MEM_AREA_TA_RAM,
        MEM_AREA_NSEC_SHM,
        MEM_AREA_RAM_NSEC,
        MEM_AREA_RAM_SEC,
        MEM_AREA_IO_NSEC,
        MEM_AREA_IO_SEC,
        MEM_AREA_EXT_DT,
        MEM_AREA_RES_VASPACE,
        MEM_AREA_SHM_VASPACE,
        MEM_AREA_TS_VASPACE,
        MEM_AREA_PAGER_VASPACE,
        MEM_AREA_SDP_MEM,
        MEM_AREA_DDR_OVERALL,
        MEM_AREA_SEC_RAM_OVERALL,
        MEM_AREA_MAXTYPE
    };
    struct tee_mmap_region {
        unsigned int type; /* enum teecore_memtypes */
        unsigned int region_size;
        paddr_t pa;
        vaddr_t va;
        size_t size;
        uint32_t attr; /* TEE_MATTR_* above */
    };
    """
    maps = []
    old_i = -1
    for i in range(len(data_list) - 4):
        type = data_list[i] & 0xffffffff
        if 26 < type: # enum teecore_memtypes
            continue
        region_size = (data_list[i] >> 32) & 0xffffffff
        if region_size & 0xfff or region_size < 0x1000 or 0xfffff000 < region_size:
            continue
        pa, va, size, attr = data_list[i + 1:i + 5]
        if pa & 0xfff or 0xfffff000 < pa:
            continue
        if va & 0xfff or 0xfffff000 < va:
            continue
        if size & 0xfff or size < 0x1000 or 0xfffff000 < size:
            continue
        if len(maps) > 0 and old_i + 5 != i: # Judging continuity
            continue
        maps.append([va, va + size, pa, pa + size])
        old_i = i
    if verbose:
        fmt = "{:33s}  {:33s}  {:12s}"
        legend = ["Virtual address start-end", "Physical address start-end", "Total size"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for va_start, va_end, pa_start, pa_end in maps:
            fmt = "{:016x}-{:016x}  {:016x}-{:016x}  {:<#12x}"
            gef_print(fmt.format(va_start, va_end, pa_start, pa_end, va_end - va_start))
    return maps


@functools.lru_cache(maxsize=None)
def get_maps_by_pagewalk(command):
    # for lru cache
    return gdb.execute(command, to_string=True)


@register_command
class V2PCommand(GenericCommand):
    """Transfer from virtual address to physical address."""
    _cmdline_ = "v2p"
    _category_ = "08-a. Qemu-system Cooperation - General"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    group = parser.add_mutually_exclusive_group()
    group.add_argument('-S', dest='force_secure', action='store_true',
                       help='ARMv7: use TTBRn_ELm_S for parsing start register. ARMv8: heuristic search the memory of qemu-system.')
    group.add_argument('-s', dest='force_normal', action='store_true',
                       help='ARMv7/v8: use TTBRn_ELm for parsing start register.')
    parser.add_argument('address', metavar='ADDRESS', type=parse_address, help='the address of data you want to translate.')
    parser.add_argument('-v', dest='verbose', action='store_true', help='verbose output.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} 0xa31dd000\n".format(_cmdline_)
    _example_ += "{:s} 0xa31dd000 -S".format(_cmdline_)

    @staticmethod
    def get_maps(FORCE_PREFIX_S, verbose=False):
        if is_arm64():
            if FORCE_PREFIX_S is True:
                return get_maps_arm64_optee_secure_memory(verbose) # already parsed
            else:
                res = get_maps_by_pagewalk("pagewalk 1 -q --no-merge")
        else:
            if FORCE_PREFIX_S is None:
                res = get_maps_by_pagewalk("pagewalk -q --no-merge")
            elif FORCE_PREFIX_S is True:
                res = get_maps_by_pagewalk("pagewalk -q --no-merge -S")
            elif FORCE_PREFIX_S is False:
                res = get_maps_by_pagewalk("pagewalk -q --no-merge -s")
        res = sorted(set(res.splitlines()))
        res = list(filter(lambda line: line.endswith("]"), res))
        res = list(filter(lambda line: "[+]" not in line, res))
        maps = []
        for line in res:
            vrange, prange, *_ = line.split()
            vstart, vend = [int(x, 16) for x in vrange.split("-")]
            pstart, pend = [int(x, 16) for x in prange.split("-")]
            maps.append((vstart, vend, pstart, pend))
        if maps == []:
            if is_x86():
                warn("Make sure you are in ring0 (=kernel mode)")
            elif is_arm32():
                warn("Make sure you are in supervisor mode (=kernel mode)")
                warn("Make sure qemu 3.x or higher")
            elif is_arm64():
                warn("Make sure you are in EL1 (=kernel mode)")
                warn("Make sure qemu 3.x or higher")
            return None
        return maps

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, args):
        self.dont_repeat()

        FORCE_PREFIX_S = None
        if is_arm32() or is_arm64():
            if args.force_normal:
                FORCE_PREFIX_S = False
            elif args.force_secure:
                FORCE_PREFIX_S = True

        maps = self.get_maps(FORCE_PREFIX_S)
        if maps is None:
            return
        for vstart, vend, pstart, pend in maps:
            if vstart <= args.address < vend:
                offset = args.address - vstart
                paddr = pstart + offset
                gef_print("Virt: {:#x} -> Phys: {:#x}".format(args.address, paddr))
        return


@register_command
class P2VCommand(GenericCommand):
    """Transfer from physical address to virtual address."""
    _cmdline_ = "p2v"
    _category_ = "08-a. Qemu-system Cooperation - General"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    group = parser.add_mutually_exclusive_group()
    group.add_argument('-S', dest='force_secure', action='store_true',
                       help='ARMv7: use TTBRn_ELm_S for parsing start register. ARMv8: heuristic search the memory of qemu-system.')
    group.add_argument('-s', dest='force_normal', action='store_true',
                       help='ARMv7/v8: use TTBRn_ELm for parsing start register.')
    parser.add_argument('address', metavar='ADDRESS', type=parse_address, help='the address of data you want to translate.')
    parser.add_argument('-v', dest='verbose', action='store_true', help='verbose output.')
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, args):
        self.dont_repeat()

        FORCE_PREFIX_S = None
        if is_arm32() or is_arm64():
            if args.force_normal:
                FORCE_PREFIX_S = False
            elif args.force_secure:
                FORCE_PREFIX_S = True

        maps = V2PCommand.get_maps(FORCE_PREFIX_S)
        if maps is None:
            return
        count = 0
        for vstart, vend, pstart, pend in maps:
            if pstart <= args.address < pend:
                offset = args.address - pstart
                vaddr = vstart + offset
                if count < 10:
                    gef_print("Phys: {:#x} -> Virt: {:#x}".format(args.address, vaddr))
                count += 1
        if count:
            gef_print("Total {:d} results are found".format(count))
        else:
            gef_print("Not mapped as virt")
        return


@register_command
class PagewalkCommand(GenericCommand):
    """Get physical memory info via qemu-monitor. Currently, x64, x86, arm and arm64 are supported."""
    _cmdline_ = "pagewalk"
    _category_ = "08-a. Qemu-system Cooperation - General"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    subparsers = parser.add_subparsers(title='command')
    subparsers.add_parser('x64')
    subparsers.add_parser('x86')
    subparsers.add_parser('arm')
    subparsers.add_parser('arm64')
    _syntax_ = parser.format_help()

    def __init__(self, *args, **kwargs):
        prefix = kwargs.get("prefix", True)
        super().__init__(prefix=prefix)
        return

    def read_physmem_cache(self, paddr, size):
        key = "{:#x}_{:d}".format(paddr, size)
        if key in self.cache:
            return self.cache[key]
        out = read_physmem(paddr, size)
        self.cache[key] = out
        return out

    def gef_print(self, msg):
        if self.use_pager:
            self.out.append(msg)
        gef_print(msg)
        return

    def quiet_info(self, msg):
        if not self.quiet:
            msg = "{} {}".format(Color.colorify("[+]", "bold blue"), msg)
            self.gef_print(msg)
        return

    def quiet_gef_print(self, msg):
        if not self.quiet:
            self.gef_print(msg)
        return

    # merge pages that points same phys page
    # for example, there are 16 pages,
    #    virt: 0xffffffff11107000  -> phys:0xabcd000
    #    virt: 0xffffffff11117000  -> phys;0xabcd000
    #    virt: 0xffffffff11127000  -> phys;0xabcd000
    #    ...
    #    virt: 0xffffffff111d7000  -> phys;0xabcd000
    #    virt: 0xffffffff111e7000  -> phys;0xabcd000
    #    virt: 0xffffffff111f7000  -> phys;0xabcd000
    # they will be merged by "*". type is changed from int to string.
    #    virt:"0xffffffff111*7000" -> phys:0xabcd000
    def merge1(self):
        # group entries that refer to the same phys page
        tmp = {}
        for entry in self.mappings: # [virt_addr, phys_addr, page_size, page_count, flags]
            va, other = entry[0], tuple(entry[1:])
            if other not in tmp:
                tmp[other] = []
            tmp[other].append("{:016x}".format(va))

        # merge if possible
        merged_mappings = []
        for other, va_array in tmp.items():
            queue = va_array
            # extract
            dic = {}
            for q in queue:
                for i in range(16):
                    dst = dic
                    src = dic
                    for j in range(i + 1):
                        src = src.get(q[j], {})
                        if j > 0:
                            dst = dst.get(q[j - 1], {})
                    dst[q[i]] = src

            # merge
            def recursive_merge(d):
                if d == {}:
                    return [""]
                out = []
                if len(d) == 16:
                    tmp = list(d.values())
                    if tmp.count(tmp[0]) == 16:
                        for vv in recursive_merge(tmp[0]):
                            out.append("*" + vv)
                        return out
                for k, v in d.items():
                    for vv in recursive_merge(v):
                        out.append(k + vv)
                return out

            for d in recursive_merge(dic):
                merged_mappings.append([d] + list(other))

        # done
        self.mappings = sorted(merged_mappings)
        return

    # merge consecutive pages
    def merge2(self):
        merged_mappings = []
        prev = None
        for now in self.mappings: # [virt_addr_string, phys_addr, page_size, page_count, flags]

            # specific case
            if "*" in now[0]:
                if prev:
                    merged_mappings += [prev]
                merged_mappings += [now]
                prev = None
                continue

            # first loop case
            if prev is None:
                prev = now
                continue

            now_va = int(now[0], 16) if isinstance(now[0], str) else now[0]
            prev_va = int(prev[0], 16) if isinstance(prev[0], str) else prev[0]
            now_pa = int(now[1], 16) if isinstance(now[1], str) else now[1]
            prev_pa = int(prev[1], 16) if isinstance(prev[1], str) else prev[1]
            now_size = now[2]
            prev_size = prev[2]
            #now_cnt = now[3] # unused
            prev_cnt = prev[3]
            now_flags = now[4]
            prev_flags = prev[4]

            # check consecutiveness
            if self.simple:
                if prev_va + prev_size == now_va: # va consecutiveness
                    if prev_flags == now_flags: # flags equivalence
                        # ok, they are consecutive (at least virt_addr)
                        prev[2] += now[2]
                        # For simple mode, page_size is ignored.
                        # so we use entry[2] as total_size instead of page_size.
                        continue
            else:
                if prev_va + prev_size * prev_cnt == now_va: # va consecutiveness
                    if prev_pa + prev_size * prev_cnt == now_pa: # pa consecutiveness
                        if prev_size == now_size: # page_size equivalence
                            if prev_flags == now_flags: # flags equivalence
                                # ok, they are consecutive
                                prev[3] += 1 # prev_page_cnt update
                                continue

            merged_mappings += [prev]
            prev = now

        if prev:
            merged_mappings += [prev]

        self.mappings = merged_mappings
        return

    def vrange_filter(self):
        filtered_mappings = []
        for mapping in self.mappings:
            va, _, size, cnt = mapping[:4]
            if isinstance(va, str) and "*" in va:
                start = int(va.replace("*", "0"), 16)
                end = int(va.replace("*", "f"), 16)
                for addr in self.vrange:
                    if start <= addr < end + size * cnt:
                        filtered_mappings.append(mapping)
                        break
            else:
                if isinstance(va, str):
                    va = int(va, 16)
                for addr in self.vrange:
                    if va <= addr < va + size * cnt:
                        filtered_mappings.append(mapping)
                        break
        self.mappings = sorted(filtered_mappings)
        return

    def prange_filter(self):
        filtered_mappings = []
        for mapping in self.mappings:
            _, pa, size, cnt = mapping[:4]
            if isinstance(pa, str):
                pa = int(pa, 16)
            for addr in self.prange:
                if pa <= addr < pa + size * cnt:
                    filtered_mappings.append(mapping)
                    break
        self.mappings = sorted(filtered_mappings)
        return

    def format_legend(self):
        fmt = "{:33s}  {:33s}  {:12s} {:11s} {:6s} {:s}"
        legend = ["Virtual address start-end", "Physical address start-end", "Total size", "Page size", "Count", "Flags"]
        return fmt.format(*legend)

    def format_entry(self, entry):
        va, pa, size, cnt, flags = entry
        if isinstance(va, str) and "*" in va:
            vend = "{:016x}".format(int(va.replace("*", "0"), 16) + size * cnt)
            for pos in [x.span() for x in re.finditer(r'\*', va)]:
                vend = vend[:pos[0]] + "*" + vend[pos[1]:]
            pend = pa + size * cnt
            if self.simple:
                fmt = "{:16s}-{:16s}  {:33s}  {:<#12x} {:<11s} {:<6s} [{:s}]"
                text = fmt.format(va, vend, "-", size, "-", "-", flags)
            else:
                fmt = "{:16s}-{:16s}  {:016x}-{:016x}  {:<#12x} {:<#11x} {:<6d} [{:s}]"
                text = fmt.format(va, vend, pa, pend, size * cnt, size, cnt, flags)
        else:
            if isinstance(va, str):
                va = int(va, 16)
            vend = va + size * cnt
            pend = pa + size * cnt
            if self.simple:
                fmt = "{:016x}-{:016x}  {:33s}  {:<#12x} {:<11s} {:<6s} [{:s}]"
                text = fmt.format(va, vend, "-", size, "-", "-", flags)
            else:
                fmt = "{:016x}-{:016x}  {:016x}-{:016x}  {:<#12x} {:<#11x} {:<6d} [{:s}]"
                text = fmt.format(va, vend, pa, pend, size * cnt, size, cnt, flags)
        return text

    def print_page(self):
        if len(self.mappings) == 0:
            warn("No virtual mappings found")
            return

        self.mappings = sorted(self.mappings)

        # merging
        if self.no_merge:
            pass
        else:
            self.merge1()
            self.quiet_info("PT Entry (merged similar pages that refer the same physpage): {:d}".format(len(self.mappings)))
            self.merge2()
            self.quiet_info("PT Entry (merged consecutive pages): {:d}".format(len(self.mappings)))

        # filter by virtual address range
        if self.vrange != []:
            self.vrange_filter()
            self.quiet_info("PT Entry (filtered by virtual address range): {:d}".format(len(self.mappings)))

        # filter by physical address range
        if self.prange != []:
            self.prange_filter()
            self.quiet_info("PT Entry (filtered by physical address range): {:d}".format(len(self.mappings)))

        # create output
        lines = []
        for entry_info in self.mappings:
            line = self.format_entry(entry_info)
            lines.append(line)

        # filter by keyword
        if self.filter != []:
            filtered_lines = []
            for line in lines:
                for filt in self.filter:
                    if re.search(filt, line):
                        filtered_lines.append(line)
                        break
            lines = filtered_lines
            self.quiet_info("PT Entry (filtered by keyword): {:d}".format(len(lines)))

        # sort by phys
        if self.sort_by_phys:
            lines = sorted(lines, key=lambda x: x.split()[1])

        # check how many result
        if lines == []:
            warn("Nothing to display")
            return

        # print
        if self.use_pager:
            self.out.append(titlify("Memory map"))
            self.out.append(Color.colorify(self.format_legend(), get_gef_setting("theme.table_heading")))
            self.out.extend(lines)
        else:
            out = self.out.copy()
            out.append(titlify("Memory map"))
            out.append(Color.colorify(self.format_legend(), get_gef_setting("theme.table_heading")))
            out.extend(lines)
            gef_print('\n'.join(out))
        return

    def is_not_trace_target(self, va_start, va_end):
        if self.trace == []:
            return False
        for tr in self.trace:
            if va_start <= tr and tr < va_end:
                return False
        return True

    def is_not_filter_target(self, line):
        if self.filter == []:
            return False
        for filt in self.filter:
            if re.search(filt, line):
                return False
        return True

    # Need not @parse_args because argparse can't stop interpreting options for pagewalk sub-command.
    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, argv):
        self.dont_repeat()
        if is_x86_32():
            gdb.execute("pagewalk x86 {}".format(' '.join(argv)))
        elif is_x86_64():
            gdb.execute("pagewalk x64 {}".format(' '.join(argv)))
        elif is_arm32():
            gdb.execute("pagewalk arm {}".format(' '.join(argv)))
        elif is_arm64():
            gdb.execute("pagewalk arm64 {}".format(' '.join(argv)))
        return


@register_command
class PagewalkX64Command(PagewalkCommand):
    """Dump pagetable for x64/x86 using qemu-monitor."""
    _cmdline_ = "pagewalk x64"
    _category_ = "08-a. Qemu-system Cooperation - General"
    _aliases_ = ["pagewalk x86"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-q', dest='quiet', action='store_true', help='show result only.')
    parser.add_argument('-v', '--print-each_level', action='store_true', help='show all level pagetables.')
    parser.add_argument('--no-merge', action='store_true', help='do not merge similar/consecutive address.')
    parser.add_argument('--sort-by-phys', action='store_true', help='sort by physical address.')
    parser.add_argument('--simple', action='store_true', help='merge with ignoring physical address consecutivness.')
    parser.add_argument('--filter', metavar='REGEX', default=[], action='append', help='filter by REGEX pattern.')
    parser.add_argument('--vrange', metavar='VADDR', default=[], action='append', type=lambda x: int(x, 16),
                        help='filter by map included specified virtual address.')
    parser.add_argument('--prange', metavar='PADDR', default=[], action='append', type=lambda x: int(x, 16),
                        help='filter by map included specified physical address.')
    parser.add_argument('--trace', metavar='VADDR', default=[], action='append', type=lambda x: int(x, 16),
                        help='show all level pagetables only associated specified address.')
    parser.add_argument('-p', '--use-pager', action='store_true', help='use pager (less).')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(prefix=False)
        return

    def format_flags(self, flag_info):
        flags = []
        if "NO_RW" in flag_info and "XD" in flag_info:
            flags += ["R--"]
        elif "NO_RW" in flag_info and "XD" not in flag_info:
            flags += ["R-X"]
        elif "NO_RW" not in flag_info and "XD" in flag_info:
            flags += ["RW-"]
        elif "NO_RW" not in flag_info and "XD" not in flag_info:
            flags += ["RWX"]
        if "NO_US" in flag_info:
            flags += ["KERN"]
        else:
            flags += ["USER"]
        if "A" in flag_info:
            flags += ["ACCESSED"]
        if "D" in flag_info:
            flags += ["DIRTY"]
        if "G" in flag_info:
            flags += ["GLOBAL"]
        return ' '.join(flags)

    def pagewalk_PML5T(self):
        self.quiet_gef_print(titlify("PML5E: Page Map Level 5 Entry"))
        PML5E = []
        COUNT = 0
        for va_base, table_base, parent_flags in self.TABLES:
            entries = self.read_physmem_cache(table_base, 2 ** self.bits["PML5T_BITS"] * self.bits["ENTRY_SIZE"])
            entries = slice_unpack(entries, self.bits["ENTRY_SIZE"])
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 1) == 0:
                    continue

                # calc virtual address
                b = self.bits["PML4T_BITS"] + self.bits["PDPT_BITS"] + self.bits["PDT_BITS"] + self.bits["PT_BITS"] + self.bits["OFFSET"]
                sign_ext = 0xfe00000000000000 if ((i >> (self.bits["PML5T_BITS"] - 1)) & 1) else 0
                new_va = va_base + (sign_ext | (i << b))
                new_va_end = new_va + (1 << b)

                # calc flags
                flags = parent_flags.copy()
                print(hex(entry))
                if ((entry >> 1) & 1) == 0:
                    flags.append("NO_RW")
                if ((entry >> 2) & 1) == 0:
                    flags.append("NO_US")
                if ((entry >> 5) & 1) == 1:
                    flags.append("A")
                if ((entry >> 63) & 1) == 1:
                    flags.append("XD")

                # calc next table (drop the flag bits)
                next_level_table = entry & 0x000ffffffffff000

                # make entry
                PML5E.append([new_va, next_level_table, flags])
                entry_type = "TABLE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(new_va, new_va_end):
                        continue
                    addr = table_base + i * self.bits["ENTRY_SIZE"]
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    self.gef_print(line)

        self.quiet_info("Number of entries: {:d}".format(COUNT))
        self.quiet_info("PML5 Entry: {:d}".format(len(PML5E)))
        self.quiet_info("Invalid entries: {:d}".format(COUNT - len(PML5E)))
        self.TABLES = PML5E
        return

    def pagewalk_PML4T(self):
        self.quiet_gef_print(titlify("PML4E: Page Map Level 4 Entry"))
        PML4E = []
        COUNT = 0
        for va_base, table_base, parent_flags in self.TABLES:
            entries = self.read_physmem_cache(table_base, 2 ** self.bits["PML4T_BITS"] * self.bits["ENTRY_SIZE"])
            entries = slice_unpack(entries, self.bits["ENTRY_SIZE"])
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 1) == 0:
                    continue

                # calc virtual address
                b = self.bits["PDPT_BITS"] + self.bits["PDT_BITS"] + self.bits["PT_BITS"] + self.bits["OFFSET"]
                if "PML5T_BITS" in self.bits:
                    new_va = va_base + (i << b)
                    new_va_end = new_va + (1 << b)
                else:
                    sign_ext = 0xffff000000000000 if ((i >> (self.bits["PML4T_BITS"] - 1)) & 1) else 0
                    new_va = va_base + (sign_ext | (i << b))
                    new_va_end = new_va + (1 << b)

                # calc flags
                flags = parent_flags.copy()
                if ((entry >> 1) & 1) == 0:
                    flags.append("NO_RW")
                if ((entry >> 2) & 1) == 0:
                    flags.append("NO_US")
                if ((entry >> 5) & 1) == 1:
                    flags.append("A")
                if ((entry >> 63) & 1) == 1:
                    flags.append("XD")

                # calc next table (drop the flag bits)
                next_level_table = entry & 0x000ffffffffff000

                # make entry
                PML4E.append([new_va, next_level_table, flags])
                entry_type = "TABLE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(new_va, new_va_end):
                        continue
                    addr = table_base + i * self.bits["ENTRY_SIZE"]
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    self.gef_print(line)

        self.quiet_info("Number of entries: {:d}".format(COUNT))
        self.quiet_info("PML4 Entry: {:d}".format(len(PML4E)))
        self.quiet_info("Invalid entries: {:d}".format(COUNT - len(PML4E)))
        self.TABLES = PML4E
        return

    def pagewalk_PDPT(self):
        self.quiet_gef_print(titlify("PDPE: Page Directory Pointer Entry"))

        def is_set_PS(entry):
            return ((entry >> 7) & 1) == 1

        PDPTE = []
        PTE = []
        COUNT = 0
        for va_base, table_base, parent_flags in self.TABLES:
            entries = self.read_physmem_cache(table_base, 2 ** self.bits["PDPT_BITS"] * self.bits["ENTRY_SIZE"])
            entries = slice_unpack(entries, self.bits["ENTRY_SIZE"])
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 1) == 0:
                    continue

                # calc virtual address
                new_va = va_base + (i << (self.bits["PDT_BITS"] + self.bits["PT_BITS"] + self.bits["OFFSET"]))
                new_va_end = new_va + (1 << (self.bits["PDT_BITS"] + self.bits["PT_BITS"] + self.bits["OFFSET"]))

                # calc flags
                flags = parent_flags.copy()
                if is_x86_64():
                    if ((entry >> 1) & 1) == 0:
                        flags.append("NO_RW")
                    if ((entry >> 2) & 1) == 0:
                        flags.append("NO_US")
                    if ((entry >> 5) & 1) == 1:
                        flags.append("A")
                    if is_set_PS(entry) and ((entry >> 6) & 1) == 1:
                        flags.append("D")
                    if is_set_PS(entry) and ((entry >> 8) & 1) == 1:
                        flags.append("G")
                    if ((entry >> 63) & 1) == 1:
                        flags.append("XD")
                else: # x86_32 and PAE
                    pass

                # calc next table (drop the flag bits)
                if is_x86_64() and is_set_PS(entry):
                    next_level_table = entry & 0x000fffffffffe000
                else:
                    next_level_table = entry & 0x000ffffffffff000

                # make entry
                if is_set_PS(entry):
                    virt_addr = new_va
                    phys_addr = next_level_table
                    page_size = 1 * 1024 * 1024 * 1024
                    page_count = 1
                    PTE.append([virt_addr, phys_addr, page_size, page_count, self.format_flags(flags)])
                    entry_type = "1GB-PAGE"
                else:
                    PDPTE.append([new_va, next_level_table, flags])
                    entry_type = "TABLE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(new_va, new_va_end):
                        continue
                    addr = table_base + i * self.bits["ENTRY_SIZE"]
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    self.gef_print(line)

        self.quiet_info("Number of entries: {:d}".format(COUNT))
        self.quiet_info("PDPT Entry: {:d}".format(len(PDPTE)))
        self.quiet_info("PT Entry (1GB): {:d}".format(len(PTE)))
        self.quiet_info("Invalid entries: {:d}".format(COUNT - len(PDPTE) - len(PTE)))
        self.TABLES = PDPTE
        self.PTE += PTE
        return

    def pagewalk_PDT(self):
        self.quiet_gef_print(titlify("PDE: Page Directory Entry"))

        def is_set_PS(entry):
            return ((entry >> 7) & 1) == 1

        PDE = []
        PTE = []
        COUNT = 0
        for va_base, table_base, parent_flags in self.TABLES:
            entries = self.read_physmem_cache(table_base, 2 ** self.bits["PDT_BITS"] * self.bits["ENTRY_SIZE"])
            entries = slice_unpack(entries, self.bits["ENTRY_SIZE"])
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 1) == 0:
                    continue

                # calc virtual address
                new_va = va_base + (i << (self.bits["PT_BITS"] + self.bits["OFFSET"]))
                new_va_end = new_va + (1 << (self.bits["PT_BITS"] + self.bits["OFFSET"]))

                # calc flags
                flags = parent_flags.copy()
                if ((entry >> 1) & 1) == 0:
                    flags.append("NO_RW")
                if ((entry >> 2) & 1) == 0:
                    flags.append("NO_US")
                if ((entry >> 5) & 1) == 1:
                    flags.append("A")
                if is_set_PS(entry) and ((entry >> 6) & 1) == 1:
                    flags.append("D")
                if is_set_PS(entry) and ((entry >> 8) & 1) == 1:
                    flags.append("G")
                if self.PAE and ((entry >> 63) & 1) == 1:
                    flags.append("XD")

                # calc next table (drop the flag bits)
                if is_x86_64() and is_set_PS(entry):
                    next_level_table = entry & 0x000fffffffffe000
                elif is_x86_32() and is_set_PS(entry):
                    high = (entry >> 13) & 0xf
                    low = (entry >> 22) & 0x3ff
                    next_level_table = (high << 10) | low
                else:
                    next_level_table = entry & 0x000ffffffffff000

                # make entry
                if is_set_PS(entry):
                    virt_addr = new_va
                    phys_addr = next_level_table
                    if self.PAE:
                        page_size = 2 * 1024 * 1024
                        entry_type = "2MB-PAGE"
                    else:
                        page_size = 4 * 1024 * 1024
                        entry_type = "4MB-PAGE"
                    page_count = 1
                    PTE.append([virt_addr, phys_addr, page_size, page_count, self.format_flags(flags)])
                else:
                    PDE.append([new_va, next_level_table, flags])
                    entry_type = "TABLE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(new_va, new_va_end):
                        continue
                    addr = table_base + i * self.bits["ENTRY_SIZE"]
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    self.gef_print(line)

        self.quiet_info("Number of entries: {:d}".format(COUNT))
        self.quiet_info("PD Entry: {:d}".format(len(PDE)))
        self.quiet_info("PT Entry ({:d}MB): {:d}".format(2 if self.PAE else 4, len(PTE)))
        self.quiet_info("Invalid entries: {:d}".format(COUNT - len(PDE) - len(PTE)))
        self.TABLES = PDE
        self.PTE += PTE
        return

    def pagewalk_PT(self):
        self.quiet_gef_print(titlify("PTE: Page Table Entry"))
        PTE = []
        COUNT = 0
        for va_base, table_base, parent_flags in self.TABLES:
            entries = self.read_physmem_cache(table_base, 2 ** self.bits["PT_BITS"] * self.bits["ENTRY_SIZE"])
            entries = slice_unpack(entries, self.bits["ENTRY_SIZE"])
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 1) == 0:
                    continue

                # calc virtual address
                virt_addr = va_base + (i << self.bits["OFFSET"])
                virt_addr_end = virt_addr + (1 << self.bits["OFFSET"])

                # calc flags
                flags = parent_flags.copy()
                if ((entry >> 1) & 1) == 0:
                    flags.append("NO_RW")
                if ((entry >> 2) & 1) == 0:
                    flags.append("NO_US")
                if ((entry >> 5) & 1) == 1:
                    flags.append("A")
                if ((entry >> 6) & 1) == 1:
                    flags.append("D")
                if ((entry >> 8) & 1) == 1:
                    flags.append("G")
                if self.PAE and ((entry >> 63) & 1) == 1:
                    flags.append("XD")

                # calc physical addr (drop the flag bits)
                phys_addr = entry & 0x000ffffffffff000

                # make entry
                page_size = 4 * 1024
                page_count = 1
                PTE.append([virt_addr, phys_addr, page_size, page_count, self.format_flags(flags)])
                entry_type = "4KB-PAGE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(virt_addr, virt_addr_end):
                        continue
                    addr = table_base + i * self.bits["ENTRY_SIZE"]
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, virt_addr, virt_addr_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    self.gef_print(line)

        self.quiet_info("Number of entries: {:d}".format(COUNT))
        self.quiet_info("PT Entry (4KB): {:d}".format(len(PTE)))
        self.quiet_info("Invalid entries: {:d}".format(COUNT - len(PTE)))
        self.PTE += PTE
        return

    def pagewalk(self):
        # `info tlb` on qemu-monitor returns pagetable without intermediate pagetable information.
        # for printing it, we will pagewalk manually.
        res = gdb.execute("monitor info registers", to_string=True)
        cr3 = int(re.search(r"CR3=(\S+)", res).group(1), 16)
        cr4 = int(re.search(r"CR4=(\S+)", res).group(1), 16)
        self.quiet_info("cr3: {:#018x}".format(cr3))
        self.quiet_info("cr4: {:#018x}".format(cr4))

        # virtual address base
        va_base = 0

        # pagewalk base is from CR3 register
        if is_x86_64(): # 64bit
            pagewalk_base = (cr3 >> 12) << 12
        elif ((cr4 >> 5) & 1) == 1: # 32bit PAE
            pagewalk_base = (cr3 >> 5) << 5
        else: # 32bit non-PAE
            pagewalk_base = (cr3 >> 12) << 12

        # we ignore PWT and PCD flags.
        flags = []

        # do pagewalk
        self.PTE = []
        self.TABLES = [(va_base, pagewalk_base, flags)]
        if is_x86_64():
            if (cr4 >> 12) & 1: # PML5T check
                # 64bit 5-level(4KB): 9,9,9,9,9,12
                # 64bit 5-level(2MB): 9,9,9,9,0,21
                # 64bit 5-level(1GB): 9,9,9,0,0,30
                self.quiet_info("64-bit 5 level page table")
                self.bits = {
                    "ENTRY_SIZE": 8,
                    "PML5T_BITS": 9, "PML4T_BITS": 9, "PDPT_BITS": 9, "PDT_BITS": 9, "PT_BITS": 9, "OFFSET": 12,
                }
                self.PAE = True
                self.pagewalk_PML5T()
                self.pagewalk_PML4T()
                self.pagewalk_PDPT()
                self.pagewalk_PDT()
                self.pagewalk_PT()
            else:
                # 64bit 4-level(4KB): 9,9,9,9,12
                # 64bit 4-level(2MB): 9,9,9,0,21
                # 64bit 4-level(1GB): 9,9,0,0,30
                self.quiet_info("64-bit 4 level page table")
                self.bits = {
                    "ENTRY_SIZE": 8,
                    "PML4T_BITS": 9, "PDPT_BITS": 9, "PDT_BITS": 9, "PT_BITS": 9, "OFFSET": 12,
                }
                self.PAE = True
                self.pagewalk_PML4T()
                self.pagewalk_PDPT()
                self.pagewalk_PDT()
                self.pagewalk_PT()
        elif is_x86_32():
            if (cr4 >> 5) & 1: # PAE check
                # 32bit PAE(4KB): 2,9,9,12 (PTE Size: 64bit)
                # 32bit PAE(2MB): 2,9,0,21 (PTE Size: 64bit)
                self.quiet_info("32-bit {:s} page table".format(Color.boldify("PAE")))
                self.bits = {
                    "ENTRY_SIZE": 8,
                    "PDPT_BITS": 2, "PDT_BITS": 9, "PT_BITS": 9, "OFFSET": 12,
                }
                self.PAE = True
                self.pagewalk_PDPT()
                self.pagewalk_PDT()
                self.pagewalk_PT()
            else:
                # 32bit(4KB): 10,10,12
                # 32bit(4MB): 10,0,22
                self.quiet_info("32-bit Non-PAE page table")
                self.bits = {
                    "ENTRY_SIZE": 4,
                    "PDT_BITS": 10, "PT_BITS": 10, "OFFSET": 12,
                }
                self.PAE = False
                self.pagewalk_PDT()
                self.pagewalk_PT()
        else:
            err("Unsupported")
            return

        self.quiet_gef_print(titlify("Total"))
        self.quiet_info("PT Entry (Total): {:d}".format(len(self.PTE)))
        self.mappings = self.PTE
        self.print_page()
        return

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, args):
        self.dont_repeat()

        self.quiet = args.quiet
        self.print_each_level = args.print_each_level
        self.no_merge = args.no_merge
        self.sort_by_phys = args.sort_by_phys
        self.simple = args.simple
        self.filter = args.filter
        self.vrange = args.vrange
        self.prange = args.prange
        self.trace = args.trace
        if self.trace:
            self.vrange.extend(self.trace) # also set --vrange
            self.print_each_level = True # overwrite
        self.use_pager = args.use_pager
        self.cache = {}

        self.mappings = None
        self.out = []
        self.pagewalk()
        self.cache = {}

        if self.out:
            gef_print('\n'.join(self.out), less=self.use_pager)
        return


@register_command
class PagewalkArmCommand(PagewalkCommand):
    """Dump pagetable for ARM (Cortex-A only) using qemu-monitor. PL2 pagewalk is unsupported"""

    _cmdline_ = "pagewalk arm"
    _category_ = "08-a. Qemu-system Cooperation - General"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-q', dest='quiet', action='store_true', help='show result only.')
    group = parser.add_mutually_exclusive_group()
    group.add_argument('-S', dest='force_secure', action='store_true', help='use TTBRn_ELm_S for parsing start register.')
    group.add_argument('-s', dest='force_normal', action='store_true', help='use TTBRn_ELm for parsing start register.')
    parser.add_argument('-v', '--print-each_level', action='store_true', help='show all level pagetables.')
    parser.add_argument('--no-merge', action='store_true', help='do not merge similar/consecutive address.')
    parser.add_argument('--sort-by-phys', action='store_true', help='sort by physical address.')
    parser.add_argument('--simple', action='store_true', help='merge with ignoring physical address consecutivness.')
    parser.add_argument('--filter', metavar='REGEX', default=[], action='append', help='filter by REGEX pattern.')
    parser.add_argument('--vrange', metavar='VADDR', default=[], action='append', type=lambda x: int(x, 16),
                        help='filter by map included specified virtual address.')
    parser.add_argument('--prange', metavar='PADDR', default=[], action='append', type=lambda x: int(x, 16),
                        help='filter by map included specified physical address.')
    parser.add_argument('--trace', metavar='VADDR', default=[], action='append', type=lambda x: int(x, 16),
                        help='show all level pagetables only associated specified address.')
    parser.add_argument('-p', '--use-pager', action='store_true', help='use pager (less).')
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(prefix=False)
        return

    def format_flags_short(self, flag_info):
        flags = []

        XN = "XN" in flag_info
        PXN = "PXN" in flag_info
        PXN &= self.PXN

        # AP[2:0] access permissions model
        if "AP=000" in flag_info:
            if XN is False and PXN is False:
                flags += ['PL0/---', "PL1/---"] #
            elif XN is False and PXN is True:
                flags += ['PL0/---', "PL1/---"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/---', "PL1/---"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/---', "PL1/---"] # XN, PXN
        elif "AP=001" in flag_info:
            if XN is False and PXN is False:
                flags += ['PL0/---', "PL1/RWX"] #
            elif XN is False and PXN is True:
                flags += ['PL0/---', "PL1/RW-"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/---', "PL1/RW-"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/---', "PL1/RW-"] # XN, PXN
        elif "AP=010" in flag_info:
            if XN is False and PXN is False:
                flags += ['PL0/R-X', "PL1/RWX"] #
            elif XN is False and PXN is True:
                flags += ['PL0/R-X', "PL1/RW-"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/R--', "PL1/RW-"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/R--', "PL1/RW-"] # XN, PXN
        elif "AP=011" in flag_info:
            if XN is False and PXN is False:
                flags += ['PL0/RWX', "PL1/RWX"] #
            elif XN is False and PXN is True:
                flags += ['PL0/RWX', "PL1/RW-"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/RW-', "PL1/RW-"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/RW-', "PL1/RW-"] # XN, PXN
        elif "AP=100" in flag_info:
            flags += ['PL0/???', "PL1/???"] # undefined (reserved)
        elif "AP=101" in flag_info:
            if XN is False and PXN is False:
                flags += ['PL0/---', "PL1/R-X"] #
            elif XN is False and PXN is True:
                flags += ['PL0/---', "PL1/R--"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/---', "PL1/R--"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/---', "PL1/R--"] # XN, PXN
        elif "AP=110" in flag_info: # deprecated
            if XN is False and PXN is False:
                flags += ['PL0/R-X', "PL1/R-X"] #
            elif XN is False and PXN is True:
                flags += ['PL0/R-X', "PL1/R--"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/R--', "PL1/R--"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/R--', "PL1/R--"] # XN, PXN
        elif "AP=111" in flag_info:
            if XN is False and PXN is False:
                flags += ['PL0/R-X', "PL1/R-X"] #
            elif XN is False and PXN is True:
                flags += ['PL0/R-X', "PL1/R--"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/R--', "PL1/R--"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/R--', "PL1/R--"] # XN, PXN
        # AP[2:1] access permissions model
        elif "AP=00" in flag_info:
            if XN is False and PXN is False:
                flags += ['PL0/---', "PL1/RWX"] #
            elif XN is False and PXN is True:
                flags += ['PL0/---', "PL1/RW-"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/---', "PL1/RW-"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/---', "PL1/RW-"] # XN, PXN
        elif "AP=01" in flag_info:
            if XN is False and PXN is False:
                flags += ['PL0/RWX', "PL1/RWX"] #
            elif XN is False and PXN is True:
                flags += ['PL0/RWX', "PL1/RW-"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/RW-', "PL1/RW-"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/RW-', "PL1/RW-"] # XN, PXN
        elif "AP=10" in flag_info:
            if XN is False and PXN is False:
                flags += ['PL0/---', "PL1/R-X"] #
            elif XN is False and PXN is True:
                flags += ['PL0/---', "PL1/R--"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/---', "PL1/R--"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/---', "PL1/R--"] # XN, PXN
        elif "AP=11" in flag_info:
            if XN is False and PXN is False:
                flags += ['PL0/R-X', "PL1/R-X"] #
            elif XN is False and PXN is True:
                flags += ['PL0/R-X', "PL1/R--"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/R--', "PL1/R--"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/R--', "PL1/R--"] # XN, PXN

        if "NS" in flag_info:
            flags += ['NS']
        # short description has no `AF` bit
        if "nG" not in flag_info:
            flags += ["GLOBAL"]
        return ' '.join(flags)

    def format_flags_long(self, flag_info):
        flags = []

        # AP/APTable parsing
        if "AP=00" in flag_info:
            disable_write_access = 0
            enable_unpriv_access = 0
        elif "AP=01" in flag_info:
            disable_write_access = 0
            enable_unpriv_access = 1
        elif "AP=10" in flag_info:
            disable_write_access = 1
            enable_unpriv_access = 0
        elif "AP=11" in flag_info:
            disable_write_access = 1
            enable_unpriv_access = 1
        if "APTable2=00" in flag_info:
            pass
        elif "APTable2=01" in flag_info:
            enable_unpriv_access &= 0
        elif "APTable2=10" in flag_info:
            disable_write_access |= 1
        elif "APTable2=11" in flag_info:
            disable_write_access |= 1
            enable_unpriv_access &= 0
        if "APTable1=00" in flag_info:
            pass
        elif "APTable1=01" in flag_info:
            enable_unpriv_access &= 0
        elif "APTable1=10" in flag_info:
            disable_write_access |= 1
        elif "APTable1=11" in flag_info:
            disable_write_access |= 1
            enable_unpriv_access &= 0
        AP = (disable_write_access << 1) | enable_unpriv_access

        # XN/XNTable, PXN/PXNTable, NS/NSTable parsing
        XN = "XN" in flag_info
        XN |= "XNTable2" in flag_info
        XN |= "XNTable1" in flag_info
        PXN = "PXN" in flag_info
        PXN |= "PXNTable2" in flag_info
        PXN |= "PXNTable1" in flag_info
        PXN &= self.PXN
        NS = "NS" in flag_info
        NS |= "NSTable2" in flag_info
        NS |= "NSTable1" in flag_info

        # AP[2:1] access permissions model
        if AP == 0b00:
            if XN is False and PXN is False:
                flags += ['PL0/---', "PL1/RWX"] #
            elif XN is False and PXN is True:
                flags += ['PL0/---', "PL1/RW-"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/---', "PL1/RW-"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/---', "PL1/RW-"] # XN, PXN
        elif AP == 0b01:
            if XN is False and PXN is False:
                flags += ['PL0/RWX', "PL1/RWX"] #
            elif XN is False and PXN is True:
                flags += ['PL0/RWX', "PL1/RW-"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/RW-', "PL1/RW-"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/RW-', "PL1/RW-"] # XN, PXN
        elif AP == 0b10:
            if XN is False and PXN is False:
                flags += ['PL0/---', "PL1/R-X"] #
            elif XN is False and PXN is True:
                flags += ['PL0/---', "PL1/R--"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/---', "PL1/R--"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/---', "PL1/R--"] # XN, PXN
        elif AP == 0b11:
            if XN is False and PXN is False:
                flags += ['PL0/R-X', "PL1/R-X"] #
            elif XN is False and PXN is True:
                flags += ['PL0/R-X', "PL1/R--"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/R--', "PL1/R--"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/R--', "PL1/R--"] # XN, PXN

        if NS:
            flags += ['NS']
        if "AF" in flag_info:
            flags += ['ACCESSED']
        if "nG" not in flag_info:
            flags += ["GLOBAL"]
        return ' '.join(flags)

    def do_pagewalk_short(self, table_base, va_base=0):
        self.mappings = []

        def has_next_level(entry):
            return (entry & 0b11) == 0b01

        def is_section(entry):
            return (entry & 0b11) in [0b10, 0b11] and ((entry >> 18) & 1) == 0

        def is_super_section(entry):
            return (entry & 0b11) in [0b10, 0b11] and ((entry >> 18) & 1) == 1

        def is_large_page(entry):
            return (entry & 0b11) == 0b01

        def is_small_page(entry):
            return (entry & 0b11) in [0b10, 0b11]

        # 1st level parse
        self.quiet_gef_print(titlify("LEVEL 1"))
        LEVEL1 = []
        SECTION = []
        SUPER_SECTION = []
        COUNT = 0
        entries = self.read_physmem_cache(table_base, 4 * (2 ** (12 - self.N)))
        entries = slice_unpack(entries, 4)
        COUNT += len(entries)
        for i, entry in enumerate(entries):
            # present flag
            if (entry & 0b11) == 0b00:
                continue

            # calc virtual address
            new_va = va_base + (i << 20)
            new_va_end = new_va + (1 << 20)

            # calc flags
            flags = []
            if has_next_level(entry):
                if ((entry >> 2) & 1) == 1:
                    flags.append("PXN")
                if ((entry >> 3) & 1) == 1:
                    flags.append("NS")
                flags.append("domain={:#x}".format((entry >> 5) & 0b1111))
            elif is_section(entry):
                if ((entry >> 0) & 1) == 1:
                    flags.append("PXN")
                if ((entry >> 2) & 1) == 1:
                    flags.append("B")
                if ((entry >> 3) & 1) == 1:
                    flags.append("C")
                if ((entry >> 4) & 1) == 1:
                    flags.append("XN")
                flags.append("domain={:#x}".format((entry >> 5) & 0b1111))
                ap = (((entry >> 15) & 1) << 2) + ((entry >> 10) & 0b11)
                if self.AFE: # AP[2:1] access permissions model
                    flags.append("AP={:02b}".format(ap >> 1))
                else: # AP[2:0] access permissions model
                    flags.append("AP={:03b}".format(ap))
                flags.append("TEX={:#x}".format((entry >> 12) & 0b111))
                if ((entry >> 16) & 1) == 1:
                    flags.append("S")
                if ((entry >> 17) & 1) == 1:
                    flags.append("nG")
                if ((entry >> 19) & 1) == 1:
                    flags.append("NS")
            elif is_super_section(entry):
                if ((entry >> 0) & 1) == 1:
                    flags.append("PXN")
                if ((entry >> 2) & 1) == 1:
                    flags.append("B")
                if ((entry >> 3) & 1) == 1:
                    flags.append("C")
                if ((entry >> 4) & 1) == 1:
                    flags.append("XN")
                ap = (((entry >> 15) & 1) << 2) + ((entry >> 10) & 0b11)
                if self.AFE: # AP[2:1] access permissions model
                    flags.append("AP={:02b}".format(ap >> 1))
                else: # AP[2:0] access permissions model
                    flags.append("AP={:03b}".format(ap))
                flags.append("TEX={:#x}".format((entry >> 12) & 0b111))
                if ((entry >> 16) & 1) == 1:
                    flags.append("S")
                if ((entry >> 17) & 1) == 1:
                    flags.append("nG")
                if ((entry >> 19) & 1) == 1:
                    flags.append("NS")

            # calc next table (drop the flag bits)
            if has_next_level(entry):
                next_level_table = entry & 0xfffffc00
            elif is_section(entry):
                next_level_table = entry & 0xfff00000
            elif is_super_section(entry):
                next_level_table = entry & 0xff000000         # PA[31:24]
                next_level_table += (entry & 0x00f0000) << 12 # PA[35:32]
                next_level_table += (entry & 0x00001e0) << 31 # PA[39:36]

            # make entry
            if has_next_level(entry):
                LEVEL1.append([new_va, next_level_table, flags])
                entry_type = "TABLE"
            elif is_section(entry):
                virt_addr = new_va
                phys_addr = next_level_table
                page_size = 1 * 1024 * 1024
                page_count = 1
                SECTION.append([virt_addr, phys_addr, page_size, page_count, self.format_flags_short(flags)])
                entry_type = "SECTION"
            elif is_super_section(entry):
                virt_addr = new_va
                phys_addr = next_level_table
                page_size = 16 * 1024 * 1024
                page_count = 1
                SUPER_SECTION.append([virt_addr, phys_addr, page_size, page_count, self.format_flags_short(flags)])
                entry_type = "SUPER_SECTION"

            # dump
            if self.print_each_level:
                if self.is_not_trace_target(new_va, new_va_end):
                    continue
                addr = table_base + i * 4
                fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                if self.is_not_filter_target(line):
                    continue
                self.gef_print(line)

        self.quiet_info("Number of entries: {:d}".format(COUNT))
        self.quiet_info("Level 1 Entry: {:d}".format(len(LEVEL1)))
        self.quiet_info("PT Entry (supersection; 16MB): {:d}".format(len(SUPER_SECTION)))
        self.quiet_info("PT Entry (section; 1MB): {:d}".format(len(SECTION)))
        self.quiet_info("Invalid entries: {:d}".format(COUNT - len(LEVEL1) - len(SUPER_SECTION) - len(SECTION)))
        self.mappings += SECTION + SUPER_SECTION

        # 2nd level parse
        self.quiet_gef_print(titlify("LEVEL 2"))
        LARGE = []
        SMALL = []
        COUNT = 0
        for va_base, table_base, parent_flags in LEVEL1:
            entries = self.read_physmem_cache(table_base, 4 * (2 ** 8))
            entries = slice_unpack(entries, 4)
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 0b11) == 0b00:
                    continue

                # calc virtual address
                virt_addr = va_base + (i << 12)
                virt_addr_end = virt_addr + (1 << 12)

                # calc flags
                flags = parent_flags.copy()
                if is_large_page(entry):
                    if ((entry >> 2) & 1) == 1:
                        flags.append("B")
                    if ((entry >> 3) & 1) == 1:
                        flags.append("C")
                    ap = (((entry >> 9) & 1) << 2) + ((entry >> 4) & 0b11)
                    if self.AFE: # AP[2:1] access permissions model
                        flags.append("AP={:02b}".format(ap >> 1))
                    else: # AP[2:0] access permissions model
                        flags.append("AP={:03b}".format(ap))
                    if ((entry >> 10) & 1) == 1:
                        flags.append("S")
                    if ((entry >> 11) & 1) == 1:
                        flags.append("nG")
                    flags.append("TEX={:#x}".format((entry >> 12) & 0b111))
                    if ((entry >> 15) & 1) == 1:
                        flags.append("XN")
                elif is_small_page(entry):
                    if ((entry >> 0) & 1) == 1:
                        flags.append("XN")
                    if ((entry >> 2) & 1) == 1:
                        flags.append("B")
                    if ((entry >> 3) & 1) == 1:
                        flags.append("C")
                    ap = (((entry >> 9) & 1) << 2) + ((entry >> 4) & 0b11)
                    if self.AFE: # AP[2:1] access permissions model
                        flags.append("AP={:02b}".format(ap >> 1))
                    else: # AP[2:0] access permissions model
                        flags.append("AP={:03b}".format(ap))
                    flags.append("TEX={:#x}".format((entry >> 6) & 0b111))
                    if ((entry >> 10) & 1) == 1:
                        flags.append("S")
                    if ((entry >> 11) & 1) == 1:
                        flags.append("nG")

                # calc physical addr (drop the flag bits)
                if is_large_page(entry):
                    phys_addr = entry & 0xffff0000
                elif is_small_page(entry):
                    phys_addr = entry & 0xfffff000

                # make entry
                if is_large_page(entry):
                    page_size = 64 * 1024
                    page_count = 1
                    LARGE.append([virt_addr, phys_addr, page_size, page_count, self.format_flags_short(flags)])
                    entry_type = "LARGE"
                elif is_small_page(entry):
                    page_size = 4 * 1024
                    page_count = 1
                    SMALL.append([virt_addr, phys_addr, page_size, page_count, self.format_flags_short(flags)])
                    entry_type = "SMALL"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(virt_addr, virt_addr_end):
                        continue
                    addr = table_base + i * 4
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, virt_addr, virt_addr_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    self.gef_print(line)

        self.quiet_info("Number of entries: {:d}".format(COUNT))
        self.quiet_info("PT Entry (large; 64KB): {:d}".format(len(LARGE)))
        self.quiet_info("PT Entry (small; 4KB): {:d}".format(len(SMALL)))
        self.quiet_info("Invalid entries: {:d}".format(COUNT - len(LARGE) - len(SMALL)))
        self.mappings += LARGE + SMALL

        self.quiet_gef_print(titlify("Total"))
        self.quiet_info("PT Entry (Total): {:d}".format(len(self.mappings)))
        self.mappings = sorted(self.mappings)
        return

    def do_pagewalk_long(self, table_base, va_base=0):
        self.mappings = []

        def has_next_level(entry):
            return (entry & 0b11) == 0b11

        def is_1GB_page(entry):
            return (entry & 0b11) == 0b01

        def is_2MB_page(entry):
            return (entry & 0b11) == 0b01

        self.quiet_gef_print(titlify("LEVEL 1"))
        if self.N < 2:
            # 1st level parse
            LEVEL1 = []
            GB = []
            COUNT = 0
            entries = self.read_physmem_cache(table_base, 8 * (2 ** 2))
            entries = slice_unpack(entries, 8)
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 1) == 0:
                    continue

                # calc virtual address
                new_va = va_base | (i << 30)
                new_va_end = new_va + (1 << 30)

                # calc flags
                flags = []
                if has_next_level(entry):
                    if ((entry >> 59) & 1) == 1:
                        flags.append("PXNTable1")
                    if ((entry >> 60) & 1) == 1:
                        flags.append("XNTable1")
                    flags.append("APTable1={:02b}".format((entry >> 61) & 0b11))
                    if ((entry >> 63) & 1) == 1:
                        flags.append("NSTable1")
                elif is_1GB_page(entry):
                    flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                    if ((entry >> 5) & 1) == 1:
                        flags.append("NS")
                    flags.append("AP={:02b}".format((entry >> 6) & 0b11))
                    flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                    if ((entry >> 10) & 1) == 1:
                        flags.append("AF")
                    if ((entry >> 11) & 1) == 1:
                        flags.append("nG")
                    if ((entry >> 52) & 1) == 1:
                        flags.append("Contiguous")
                    if ((entry >> 53) & 1) == 1:
                        flags.append("PXN")
                    if ((entry >> 54) & 1) == 1:
                        flags.append("XN")

                # calc next table (drop the flag bits)
                if has_next_level(entry):
                    next_level_table = entry & 0x000000fffffff000
                elif is_1GB_page(entry):
                    next_level_table = entry & 0x000000ffc0000000

                # make entry
                if has_next_level(entry):
                    LEVEL1.append([new_va, next_level_table, flags])
                    entry_type = "TABLE"
                elif is_1GB_page(entry):
                    virt_addr = new_va
                    phys_addr = next_level_table
                    page_size = 1 * 1024 * 1024 * 1024
                    page_count = 1
                    GB.append([virt_addr, phys_addr, page_size, page_count, self.format_flags_long(flags)])
                    entry_type = "1GB-PAGE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(new_va, new_va_end):
                        continue
                    addr = table_base + i * 8
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    self.gef_print(line)

            self.quiet_info("Number of entries: {:d}".format(COUNT))
            self.quiet_info("Level 1 Entry: {:d}".format(len(LEVEL1)))
            self.quiet_info("PT Entry (1GB): {:d}".format(len(GB)))
            self.quiet_info("Invalid entries: {:d}".format(COUNT - len(LEVEL1) - len(GB)))
            self.mappings += GB
        else:
            self.quiet_info("LEVEL 1 is skipped")
            flags = []
            LEVEL1 = [[va_base, table_base, flags]]

        # 2nd level parse
        self.quiet_gef_print(titlify("LEVEL 2"))
        LEVEL2 = []
        MB = []
        COUNT = 0
        for va_base, table_base, parent_flags in LEVEL1:
            entries = self.read_physmem_cache(table_base, 8 * (2 ** 9))
            entries = slice_unpack(entries, 8)
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 1) == 0:
                    continue

                # calc virtual address
                new_va = va_base | (i << 21)
                new_va_end = new_va + (1 << 21)

                # calc flags
                flags = parent_flags.copy()
                if has_next_level(entry):
                    if ((entry >> 59) & 1) == 1:
                        flags.append("PXNTable2")
                    if ((entry >> 60) & 1) == 1:
                        flags.append("XNTable2")
                    flags.append("APTable2={:02b}".format((entry >> 61) & 0b11))
                    if ((entry >> 63) & 1) == 1:
                        flags.append("NSTable2")
                elif is_2MB_page(entry):
                    flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                    if ((entry >> 5) & 1) == 1:
                        flags.append("NS")
                    flags.append("AP={:02b}".format((entry >> 6) & 0b11))
                    flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                    if ((entry >> 10) & 1) == 1:
                        flags.append("AF")
                    if ((entry >> 11) & 1) == 1:
                        flags.append("nG")
                    if ((entry >> 52) & 1) == 1:
                        flags.append("Contiguous")
                    if ((entry >> 53) & 1) == 1:
                        flags.append("PXN")
                    if ((entry >> 54) & 1) == 1:
                        flags.append("XN")

                # calc next table (drop the flag bits)
                if has_next_level(entry):
                    next_level_table = entry & 0x000000fffffff000
                elif is_2MB_page(entry):
                    next_level_table = entry & 0x000000ffffe00000

                # make entry
                if has_next_level(entry):
                    LEVEL2.append([new_va, next_level_table, flags])
                    entry_type = "TABLE"
                elif is_2MB_page(entry):
                    virt_addr = new_va
                    phys_addr = next_level_table
                    page_size = 2 * 1024 * 1024
                    page_count = 1
                    MB.append([virt_addr, phys_addr, page_size, page_count, self.format_flags_long(flags)])
                    entry_type = "2MB-PAGE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(new_va, new_va_end):
                        continue
                    addr = table_base + i * 8
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    self.gef_print(line)

        self.quiet_info("Number of entries: {:d}".format(COUNT))
        self.quiet_info("Level 2 Entry: {:d}".format(len(LEVEL2)))
        self.quiet_info("PT Entry (2MB): {:d}".format(len(MB)))
        self.quiet_info("Invalid entries: {:d}".format(COUNT - len(LEVEL2) - len(MB)))
        self.mappings += MB

        # 3rd level parse
        self.quiet_gef_print(titlify("LEVEL 3"))
        KB = []
        COUNT = 0
        for va_base, table_base, parent_flags in LEVEL2:
            entries = self.read_physmem_cache(table_base, 8 * (2 ** 9))
            entries = slice_unpack(entries, 8)
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 0b11) != 0b11:
                    continue

                # calc virtual address
                virt_addr = va_base | (i << 12)
                virt_addr_end = virt_addr + (1 << 12)

                # calc flags
                flags = parent_flags.copy()
                flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                if ((entry >> 5) & 1) == 1:
                    flags.append("NS")
                flags.append("AP={:02b}".format((entry >> 6) & 0b11))
                flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                if ((entry >> 10) & 1) == 1:
                    flags.append("AF")
                if ((entry >> 11) & 1) == 1:
                    flags.append("nG")
                if ((entry >> 52) & 1) == 1:
                    flags.append("Contiguous")
                if ((entry >> 53) & 1) == 1:
                    flags.append("PXN")
                if ((entry >> 54) & 1) == 1:
                    flags.append("XN")

                # calc physical addr (drop the flag bits)
                phys_addr = entry & 0x000000fffffff000

                # make entry
                page_size = 4 * 1024
                page_count = 1
                KB.append([virt_addr, phys_addr, page_size, page_count, self.format_flags_long(flags)])
                entry_type = "1KB-PAGE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(virt_addr, virt_addr_end):
                        continue
                    addr = table_base + i * 8
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, virt_addr, virt_addr_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    self.gef_print(line)

        self.quiet_info("Number of entries: {:d}".format(COUNT))
        self.quiet_info("PT Entry (4KB): {:d}".format(len(KB)))
        self.quiet_info("Invalid entries: {:d}".format(COUNT - len(KB)))
        self.mappings += KB

        self.quiet_gef_print(titlify("Total"))
        self.quiet_info("PT Entry (Total): {:d}".format(len(self.mappings)))
        self.mappings = sorted(self.mappings)
        return

    def pagewalk_short(self):
        self.gef_print(titlify("$TTBR0_EL1{}".format(self.suffix)))

        TTBR0_EL1 = get_register('$TTBR0_EL1{}'.format(self.suffix))
        if TTBR0_EL1 is None:
            err('$TTBR0_EL1{} is not found'.format(self.suffix))
            return

        TTBR1_EL1 = get_register('$TTBR1_EL1{}'.format(self.suffix))
        if TTBR1_EL1 is None:
            err('$TTBR1_EL1{} is not found'.format(self.suffix))
            return

        TTBCR = get_register('$TTBCR{}'.format(self.suffix))
        if TTBCR is None:
            err('$TTBCR{} is not found'.format(self.suffix))
            return

        # pagewalk TTBR0_EL1
        self.N = TTBCR & 0b111
        ml = 14 - self.N
        pl0_base = ((TTBR0_EL1 & ((1 << 32) - 1)) >> ml) << ml
        self.quiet_info("$TTBR0_EL1{}: {:#x}".format(self.suffix, TTBR0_EL1))
        self.quiet_info("$TTBCR{}: {:#x}".format(self.suffix, TTBCR))
        self.quiet_info("PL0 base: {:#x}".format(pl0_base))
        self.do_pagewalk_short(pl0_base)
        self.print_page()

        # pagewalk TTBR1_EL1
        self.gef_print(titlify("$TTBR1_EL1{}".format(self.suffix)))
        if self.suffix:
            pl1_vabase = 0 # I don't know why, but vabase of PL1 seems to be 0x0 when using TTBR1_EL1_S.
        else:
            pl1_vabase = {
                0: None, 1: 0x80000000, 2: 0x40000000, 3: 0x20000000,
                4: 0x10000000, 5: 0x08000000, 6: 0x04000000, 7: 0x02000000
            }[self.N]
        pl1_base = ((TTBR1_EL1 & ((1 << 32) - 1)) >> ml) << ml
        self.N = 0 # Whenever TTBCR.N is nonzero, the size of the translation table addressed by TTBR1 is 16KB (N=0).
        if pl1_vabase is not None:
            self.quiet_info("$TTBR1_EL1{}: {:#x}".format(self.suffix, TTBR1_EL1))
            self.quiet_info("$TTBCR{}: {:#x}".format(self.suffix, TTBCR))
            self.quiet_info("PL1 base: {:#x}".format(pl1_base))
            self.quiet_info("PL1 va_base: {:#x}".format(pl1_vabase))
            self.do_pagewalk_short(pl1_base, pl1_vabase)
            self.print_page()
        else:
            self.quiet_info("$TTBR1_EL1{} is unused".format(self.suffix))
        return

    def pagewalk_long(self):
        self.gef_print(titlify("$TTBR0_EL1{}".format(self.suffix)))

        TTBR0_EL1 = get_register('$TTBR0_EL1{}'.format(self.suffix))
        if TTBR0_EL1 is None:
            err('$TTBR0_EL1{} is not found'.format(self.suffix))
            return

        TTBR1_EL1 = get_register('$TTBR1_EL1{}'.format(self.suffix))
        if TTBR1_EL1 is None:
            err('$TTBR1_EL1{} is not found'.format(self.suffix))
            return

        TTBCR = get_register('$TTBCR{}'.format(self.suffix))
        if TTBCR is None:
            err('$TTBCR{} is not found'.format(self.suffix))
            return

        # pagewalk TTBR0_EL1
        T0SZ = TTBCR & 0b111
        T1SZ = (TTBCR >> 16) & 0b111
        self.N = T0SZ
        pl0_base = TTBR0_EL1 & ((1 << 40) - 1)
        self.quiet_info("$TTBR0_EL1{}: {:#x}".format(self.suffix, TTBR0_EL1))
        self.quiet_info("$TTBCR{}: {:#x}".format(self.suffix, TTBCR))
        self.quiet_info("PL0 base: {:#x}".format(pl0_base))
        self.do_pagewalk_long(pl0_base)
        self.print_page()

        # pagewalk TTBR1_EL1
        self.gef_print(titlify("$TTBR1_EL1{}".format(self.suffix)))
        if T0SZ != 0 or T1SZ != 0:
            self.N = T1SZ
            pl1_base = TTBR1_EL1 & ((1 << 40) - 1)
            if T1SZ == 0:
                pl1_vabase = 2 ** (32 - T0SZ)
            else:
                pl1_vabase = (2 ** 32) - (2 ** (32 - T1SZ))
            self.quiet_info("$TTBR1_EL1{}: {:#x}".format(self.suffix, TTBR1_EL1))
            self.quiet_info("PL1 base: {:#x}".format(pl1_base))
            self.quiet_info("PL1 va_base: {:#x}".format(pl1_vabase))
            self.do_pagewalk_long(pl1_base, pl1_vabase)
            self.print_page()
        else:
            self.quiet_info("$TTBR1_EL1{} is unused".format(self.suffix))
        return

    def pagewalk(self):
        res = gdb.execute("info registers", to_string=True)
        if "TTBR" not in res:
            err("Not found system registers. Check qemu version (at least: 3.x~, recommend: 5.x~).")
            return

        # check Secure mode
        if self.FORCE_PREFIX_S is None:
            # auto detect
            SCR = get_register('$SCR_S')
            if SCR is None:
                SCR = get_register('$SCR')
            if SCR is not None:
                self.SECURE = (SCR & 0x1) == 0 # NS bit
            else:
                self.SECURE = False
            self.suffix = "_S" if self.SECURE else ""
        elif self.FORCE_PREFIX_S is True:
            # use "_S"
            SCR = get_register('$SCR_S')
            if SCR is not None:
                self.SECURE = (SCR & 0x1) == 0 # NS bit
            else:
                self.SECURE = False
            self.suffix = "_S"
        elif self.FORCE_PREFIX_S is False:
            # do not use "_S"
            SCR = get_register('$SCR')
            if SCR is not None:
                self.SECURE = (SCR & 0x1) == 0 # NS bit
            else:
                self.SECURE = False
            self.suffix = ""
        self.quiet_info("Secure world: {}".format(self.SECURE))

        # check AFE
        SCTLR = get_register('$SCTLR{}'.format(self.suffix))
        if SCTLR is not None:
            self.AFE = ((SCTLR >> 29) & 0x1) == 1
        else:
            self.AFE = False

        # check enabled LPAE
        TTBCR = get_register('$TTBCR{}'.format(self.suffix))
        if TTBCR is not None:
            self.LPAE = ((TTBCR >> 31) & 0x1) == 1
            self.PTE_SIZE = 8 if self.LPAE else 4
        else:
            self.LPAE = False

        # check PXN supported
        ID_MMFR0 = get_register('$ID_MMFR0{}'.format(self.suffix))
        if ID_MMFR0 is not None:
            self.PXN = ((ID_MMFR0 >> 2) & 0x1) == 1
        else:
            self.PXN = False

        if self.PXN:
            self.quiet_info("{:s} is supported".format(Color.boldify("PXN")))
        else:
            self.quiet_info("PXN is unsupported")
        self.quiet_info("PAN is unimplemented on all ARMv7")

        # pagewalk
        if self.LPAE:
            self.quiet_info("{:s} is enabled (using long description)".format(Color.boldify("LPAE")))
            self.pagewalk_long()
        else:
            self.quiet_info("LPAE is disabled (using short description)")
            self.pagewalk_short()
        return

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["ARM32"])
    def do_invoke(self, args):
        self.dont_repeat()

        self.FORCE_PREFIX_S = None
        if args.force_secure:
            self.FORCE_PREFIX_S = True
        elif args.force_normal:
            self.FORCE_PREFIX_S = False

        self.quiet = args.quiet
        self.print_each_level = args.print_each_level
        self.no_merge = args.no_merge
        self.sort_by_phys = args.sort_by_phys
        self.simple = args.simple
        self.filter = args.filter
        self.vrange = args.vrange
        self.prange = args.prange
        self.trace = args.trace
        if self.trace:
            self.vrange.extend(self.trace) # also set --vrange
            self.print_each_level = True # overwrite
        self.use_pager = args.use_pager
        self.cache = {}

        self.mappings = None
        self.out = []
        self.pagewalk()
        self.cache = {}

        if self.out:
            gef_print('\n'.join(self.out), less=self.use_pager)
        return


@register_command
class PagewalkArm64Command(PagewalkCommand):
    """Dump pagetable for ARM64 using qemu-monitor (for ARMv8.7)."""
    _cmdline_ = "pagewalk arm64"
    _category_ = "08-a. Qemu-system Cooperation - General"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-q', dest='quiet', action='store_true', help='show result only.')
    parser.add_argument("target_el", metavar='TARGET_EL', nargs='?', type=int, help='target EL. (default: current EL)')
    parser.add_argument('-v', '--print-each_level', action='store_true', help='show all level pagetables.')
    parser.add_argument('--no-merge', action='store_true', help='do not merge similar/consecutive address.')
    parser.add_argument('--sort-by-phys', action='store_true', help='sort by physical address.')
    parser.add_argument('--simple', action='store_true', help='merge with ignoring physical address consecutivness.')
    parser.add_argument('--filter', metavar='REGEX', default=[], action='append', help='filter by REGEX pattern.')
    parser.add_argument('--vrange', metavar='VADDR', default=[], action='append', type=lambda x: int(x, 16),
                        help='filter by map included specified virtual address.')
    parser.add_argument('--prange', metavar='PADDR', default=[], action='append', type=lambda x: int(x, 16),
                        help='filter by map included specified physical address.')
    parser.add_argument('--trace', metavar='VADDR', default=[], action='append', type=lambda x: int(x, 16),
                        help='show all level pagetables only associated specified address.')
    parser.add_argument('-p', '--use-pager', action='store_true', help='use pager (less).')
    _syntax_ = parser.format_help()

    # If you want to dump the secure world memory map, you need to break in the secure world.
    # This is because unlike ARMv7, TTBR0_EL1_S and TTBR1_EL1_S do not exist.
    # It is difficult to know the correct value of the secure world's system registers while in the normal world,
    # as the secure monitor saves all system registers to memory when the world changes.

    def __init__(self):
        super().__init__(prefix=False)
        return

    def read_mem_wrapper(self, addr, size=8):
        """
        When pagewalking EL0/EL1 of the guest OS, gdb pagewalks the physical memory according to $TTBR0_ELx.
        However, even if you try to read the physical memory, access to the address will fail
        because it is actually an intermediate physical memory.
        Therefore, in order to perform a pagewalk of EL0/EL1, EL2 mapping information is required.
        This function is for reading from physical memory with that in mind.
        """

        if self.EL3_M and self.TargetEL == 3:
            return read_memory(addr, size)

        # translate via EL2 mappings
        if self.EL2_VM and self.TargetEL == 1 and self.el2_mappings:
            def search_pa(addr):
                for entry_info in self.el2_mappings:
                    va, entry, sz, cnt, flags = entry_info
                    if isinstance(va, str):
                        va = int(va, 16)
                    pa = entry & 0x0000fffffffff000
                    if va <= addr < va + sz:
                        offset = addr - va
                        return pa + offset, sz - offset
                else: # not found
                    raise
            out = b""
            while size > 0:
                paddr, available_sz = search_pa(addr)
                out += self.read_physmem_cache(paddr, min([size, available_sz]))
                size -= min(size, available_sz)
            return out

        # direct physmem read
        else:
            return self.read_physmem_cache(addr, size)

    def format_flags_stage2(self, flag_info):
        flags = []

        XN1 = "XN1" in flag_info
        XN0 = "XN0" in flag_info
        if "S2AP=00" in flag_info:
            if XN1 is False and XN0 is False:
                flags += ['EL0/---', 'EL1/---']
            elif XN1 is False and XN0 is True:
                flags += ['EL0/---', 'EL1/---']
            elif XN1 is True and XN0 is False:
                flags += ['EL0/---', 'EL1/---']
            elif XN1 is True and XN0 is True:
                flags += ['EL0/---', 'EL1/---']
        elif "S2AP=01" in flag_info:
            if XN1 is False and XN0 is False:
                flags += ['EL0/R-X', 'EL1/R-X']
            elif XN1 is False and XN0 is True:
                flags += ['EL0/R-X', 'EL1/R--']
            elif XN1 is True and XN0 is False:
                flags += ['EL0/R--', 'EL1/R--']
            elif XN1 is True and XN0 is True:
                flags += ['EL0/R--', 'EL1/R-X']
        elif "S2AP=10" in flag_info:
            if XN1 is False and XN0 is False:
                flags += ['EL0/-W-', 'EL1/-W-']
            elif XN1 is False and XN0 is True:
                flags += ['EL0/-W-', 'EL1/-W-']
            elif XN1 is True and XN0 is False:
                flags += ['EL0/-W-', 'EL1/-W-']
            elif XN1 is True and XN0 is True:
                flags += ['EL0/-W-', 'EL1/-W-']
        elif "S2AP=11" in flag_info:
            if XN1 is False and XN0 is False:
                flags += ['EL0/RWX', 'EL1/RWX']
            elif XN1 is False and XN0 is True:
                flags += ['EL0/RWX', 'EL1/RW-']
            elif XN1 is True and XN0 is False:
                flags += ['EL0/RW-', 'EL1/RW-']
            elif XN1 is True and XN0 is True:
                flags += ['EL0/RW-', 'EL1/RWX']
        if "AF" in flag_info:
            flags += ['ACCESSED']
        if "DBM" in flag_info:
            flags += ['DIRTY']
        # stage2 has no `nG` bit
        return ' '.join(flags)

    def format_flags(self, flag_info):
        flags = []

        # AP/APTable parsing
        if "AP=00" in flag_info:
            disable_write_access = 0
            enable_unpriv_access = 0
        elif "AP=01" in flag_info:
            disable_write_access = 0
            enable_unpriv_access = 1
        elif "AP=10" in flag_info:
            disable_write_access = 1
            enable_unpriv_access = 0
        elif "AP=11" in flag_info:
            disable_write_access = 1
            enable_unpriv_access = 1
        if "APTable2=00" in flag_info:
            pass
        elif "APTable2=01" in flag_info:
            enable_unpriv_access &= 0
        elif "APTable2=10" in flag_info:
            disable_write_access |= 1
        elif "APTable2=11" in flag_info:
            disable_write_access |= 1
            enable_unpriv_access &= 0
        if "APTable1=00" in flag_info:
            pass
        elif "APTable1=01" in flag_info:
            enable_unpriv_access &= 0
        elif "APTable1=10" in flag_info:
            disable_write_access |= 1
        elif "APTable1=11" in flag_info:
            disable_write_access |= 1
            enable_unpriv_access &= 0
        if "APTable0=00" in flag_info:
            pass
        elif "APTable0=01" in flag_info:
            enable_unpriv_access &= 0
        elif "APTable0=10" in flag_info:
            disable_write_access |= 1
        elif "APTable0=11" in flag_info:
            disable_write_access |= 1
            enable_unpriv_access &= 0
        if "APTable-1=00" in flag_info:
            pass
        elif "APTable-1=01" in flag_info:
            enable_unpriv_access &= 0
        elif "APTable-1=10" in flag_info:
            disable_write_access |= 1
        elif "APTable-1=11" in flag_info:
            disable_write_access |= 1
            enable_unpriv_access &= 0

        # UXN/UXNTable, XN/XNTable, PXN/PXNTable, NS/NSTable parsing
        UXN = "UXN" in flag_info
        UXN |= "UXNTable2" in flag_info
        UXN |= "UXNTable1" in flag_info
        UXN |= "UXNTable0" in flag_info
        UXN |= "UXNTable-1" in flag_info
        XN = "XN" in flag_info
        XN |= "XNTable2" in flag_info
        XN |= "XNTable1" in flag_info
        XN |= "XNTable0" in flag_info
        XN |= "XNTable-1" in flag_info
        PXN = "PXN" in flag_info
        PXN |= "PXNTable2" in flag_info
        PXN |= "PXNTable1" in flag_info
        PXN |= "PXNTable0" in flag_info
        PXN |= "PXNTable-1" in flag_info
        NS = "NS" in flag_info
        NS |= "NSTable2" in flag_info
        NS |= "NSTable1" in flag_info
        NS |= "NSTable0" in flag_info
        NS |= "NSTable-1" in flag_info

        if self.TargetEL == 1:
            # always support 2VA ranges
            if UXN is False and PXN is False:
                if disable_write_access == 0 and enable_unpriv_access == 0:
                    if not self.EL1_WXN:
                        flags += ['EL0/--X', 'EL1/RWX']
                    else:
                        flags += ['EL0/--X', 'EL1/RW-']
                elif disable_write_access == 0 and enable_unpriv_access == 1:
                    if not self.EL1_WXN:
                        flags += ['EL0/RWX', 'EL1/RW-']
                    else:
                        flags += ['EL0/RW-', 'EL1/RW-']
                elif disable_write_access == 1 and enable_unpriv_access == 0:
                    flags += ['EL0/--X', 'EL1/R-X']
                elif disable_write_access == 1 and enable_unpriv_access == 1:
                    flags += ['EL0/R-X', 'EL1/R-X']
            elif UXN is False and PXN is True:
                if disable_write_access == 0 and enable_unpriv_access == 0:
                    flags += ['EL0/--X', 'EL1/RW-']
                elif disable_write_access == 0 and enable_unpriv_access == 1:
                    if not self.EL1_WXN:
                        flags += ['EL0/RWX', 'EL1/RW-']
                    else:
                        flags += ['EL0/RW-', 'EL1/RW-']
                elif disable_write_access == 1 and enable_unpriv_access == 0:
                    flags += ['EL0/--X', 'EL1/R--']
                elif disable_write_access == 1 and enable_unpriv_access == 1:
                    flags += ['EL0/R-X', 'EL1/R--']
            elif UXN is True and PXN is False:
                if disable_write_access == 0 and enable_unpriv_access == 0:
                    if not self.EL1_WXN:
                        flags += ['EL0/---', 'EL1/RWX']
                    else:
                        flags += ['EL0/---', 'EL1/RW-']
                elif disable_write_access == 0 and enable_unpriv_access == 1:
                    flags += ['EL0/RW-', 'EL1/RW-']
                elif disable_write_access == 1 and enable_unpriv_access == 0:
                    flags += ['EL0/---', 'EL1/R-X']
                elif disable_write_access == 1 and enable_unpriv_access == 1:
                    flags += ['EL0/R--', 'EL1/R-X']
            elif UXN is True and PXN is True:
                if disable_write_access == 0 and enable_unpriv_access == 0:
                    flags += ['EL0/---', 'EL1/RW-']
                elif disable_write_access == 0 and enable_unpriv_access == 1:
                    flags += ['EL0/RW-', 'EL1/RW-']
                elif disable_write_access == 1 and enable_unpriv_access == 0:
                    flags += ['EL0/---', 'EL1/R--']
                elif disable_write_access == 1 and enable_unpriv_access == 1:
                    flags += ['EL0/R--', 'EL1/R--']
        elif self.TargetEL == 2:
            if self.EL2_M20:
                # support 2VA ranges if HCR_EL2.{TGE,E2H} == {1,1}
                if UXN is False and PXN is False:
                    if disable_write_access == 0 and enable_unpriv_access == 0:
                        if not self.EL2_WXN:
                            flags += ['EL0/--X', 'EL2/RWX']
                        else:
                            flags += ['EL0/--X', 'EL2/RW-']
                    elif disable_write_access == 0 and enable_unpriv_access == 1:
                        if not self.EL2_WXN:
                            flags += ['EL0/RWX', 'EL2/RW-']
                        else:
                            flags += ['EL0/RW-', 'EL2/RW-']
                    elif disable_write_access == 1 and enable_unpriv_access == 0:
                        flags += ['EL0/--X', 'EL2/R-X']
                    elif disable_write_access == 1 and enable_unpriv_access == 1:
                        flags += ['EL0/R-X', 'EL2/R-X']
                elif UXN is False and PXN is True:
                    if disable_write_access == 0 and enable_unpriv_access == 0:
                        flags += ['EL0/--X', 'EL2/RW-']
                    elif disable_write_access == 0 and enable_unpriv_access == 1:
                        if not self.EL2_WXN:
                            flags += ['EL0/RWX', 'EL2/RW-']
                        else:
                            flags += ['EL0/RW-', 'EL2/RW-']
                    elif disable_write_access == 1 and enable_unpriv_access == 0:
                        flags += ['EL0/--X', 'EL2/R--']
                    elif disable_write_access == 1 and enable_unpriv_access == 1:
                        flags += ['EL0/R-X', 'EL2/R--']
                elif UXN is True and PXN is False:
                    if disable_write_access == 0 and enable_unpriv_access == 0:
                        if not self.EL2_WXN:
                            flags += ['EL0/---', 'EL2/RWX']
                        else:
                            flags += ['EL0/---', 'EL2/RW-']
                    elif disable_write_access == 0 and enable_unpriv_access == 1:
                        flags += ['EL0/RW-', 'EL2/RW-']
                    elif disable_write_access == 1 and enable_unpriv_access == 0:
                        flags += ['EL0/---', 'EL2/R-X']
                    elif disable_write_access == 1 and enable_unpriv_access == 1:
                        flags += ['EL0/R--', 'EL2/R-X']
                elif UXN is True and PXN is True:
                    if disable_write_access == 0 and enable_unpriv_access == 0:
                        flags += ['EL0/---', 'EL2/RW-']
                    elif disable_write_access == 0 and enable_unpriv_access == 1:
                        flags += ['EL0/RW-', 'EL2/RW-']
                    elif disable_write_access == 1 and enable_unpriv_access == 0:
                        flags += ['EL0/---', 'EL2/R--']
                    elif disable_write_access == 1 and enable_unpriv_access == 1:
                        flags += ['EL0/R--', 'EL2/R--']
            else:
                # not support 2VA ranges if HCR_EL2.{TGE,E2H} != {1,1}
                if XN is False:
                    if disable_write_access == 0:
                        if not self.EL2_WXN:
                            flags += ['EL2/RWX']
                        else:
                            flags += ['EL2/RW-']
                    elif disable_write_access == 1:
                        flags += ['EL2/R-X']
                elif XN is True:
                    if disable_write_access == 0:
                        flags += ['EL2/RW-']
                    elif disable_write_access == 1:
                        flags += ['EL2/R--']
        elif self.TargetEL == 3:
            if XN is False:
                if disable_write_access == 0:
                    if not self.EL3_WXN:
                        flags += ['EL3/RWX']
                    else:
                        flags += ['EL3/RW-']
                elif disable_write_access == 1:
                    flags += ['EL3/R-X']
            elif XN is True:
                if disable_write_access == 0:
                    flags += ['EL3/RW-']
                elif disable_write_access == 1:
                    flags += ['EL3/R--']
        if NS:
            flags += ['NS']
        if "AF" in flag_info:
            flags += ['ACCESSED']
        if "DBM" in flag_info:
            flags += ['DIRTY']
        if "nG" not in flag_info:
            flags += ["GLOBAL"]
        return ' '.join(flags)

    """
     Stage1                   |     Stage2
    -------------------------------------------------------
    +----------------------+  |   +----------------------+
    | Guest OS table       | -|-> | Virtualization table |
    +----------------------+  |   +----------------------+
      TTBR0_EL1, TTBR1_EL1    |     VTTBR0_EL2
                              |
    +----------------------+  |
    | Hypervisor table     |  |
    +----------------------+  |
      TTBR0_EL2, TTBR1_EL2    |
                              |
    +----------------------+  |
    | Secure monitor table |  |
    +----------------------+  |
      TTBR0_EL3               |
                              |


      TargetEL=1              |    TargetEL=2              |    TargetEL=3
    ---------------------------------------------------------------------------------
    +----------------------+  |  +----------------------+  |  +----------------------+
    | Guest OS table       |  |  | Virtualization table |  |  | Secure monitor table |
    +----------------------+  |  +----------------------+  |  +----------------------+
      TTBR0_EL1, TTBR1_EL1    |    VTTBR0_EL2              |    TTBR0_EL3
                              |                            |
                              |  +----------------------+  |
                              |  | Hypervisor table     |  |
                              |  +----------------------+  |
                              |    TTBR0_EL2, TTBR1_EL2    |
                              |                            |
    """
    def parse_bit_range(self, granule_bits, region_bits):
        IA_LVA_MAX = 52 if self.FEAT_LVA else 48
        if granule_bits == 12: # 4KB granule
            self.LEVELM1_BIT_RANGE = [48, min(IA_LVA_MAX, region_bits)] if region_bits > 48 else None # no block descriptor
            self.LEVEL0_BIT_RANGE = [39, min(48, region_bits)] if region_bits > 39 else None          # 512GB
            self.LEVEL1_BIT_RANGE = [30, min(39, region_bits)] if region_bits > 30 else None          # 1GB
            self.LEVEL2_BIT_RANGE = [21, min(30, region_bits)] if region_bits > 21 else None          # 2MB
            self.LEVEL3_BIT_RANGE = [12, min(21, region_bits)] if region_bits > 12 else None          # 4KB
            self.OFFSET_BIT_RANGE = [0, 12]
        elif granule_bits == 14: # 16KB granule
            self.LEVELM1_BIT_RANGE = None
            self.LEVEL0_BIT_RANGE = [47, min(IA_LVA_MAX, region_bits)] if region_bits > 47 else None  # no block descriptor
            self.LEVEL1_BIT_RANGE = [36, min(47, region_bits)] if region_bits > 36 else None          # 64GB
            self.LEVEL2_BIT_RANGE = [25, min(36, region_bits)] if region_bits > 25 else None          # 32MB
            self.LEVEL3_BIT_RANGE = [14, min(25, region_bits)] if region_bits > 14 else None          # 16KB
            self.OFFSET_BIT_RANGE = [0, 14]
        elif granule_bits == 16: # 64KB granule
            self.LEVELM1_BIT_RANGE = None
            self.LEVEL0_BIT_RANGE = None
            self.LEVEL1_BIT_RANGE = [42, min(IA_LVA_MAX, region_bits)] if region_bits > 42 else None  # 4TB
            self.LEVEL2_BIT_RANGE = [29, min(42, region_bits)] if region_bits > 29 else None          # 512MB
            self.LEVEL3_BIT_RANGE = [16, min(29, region_bits)] if region_bits > 16 else None          # 64KB
            self.OFFSET_BIT_RANGE = [0, 16]
        else:
            if not self.silent:
                err("Unsupported granule_bits")
            return

        if not self.silent:
            self.quiet_info("granule_bits: {:d}".format(granule_bits))
            self.quiet_info("LEVELM1_BIT_RANGE: " + str(self.LEVELM1_BIT_RANGE))
            self.quiet_info("LEVEL0_BIT_RANGE: " + str(self.LEVEL0_BIT_RANGE))
            self.quiet_info("LEVEL1_BIT_RANGE: " + str(self.LEVEL1_BIT_RANGE))
            self.quiet_info("LEVEL2_BIT_RANGE: " + str(self.LEVEL2_BIT_RANGE))
            self.quiet_info("LEVEL3_BIT_RANGE: " + str(self.LEVEL3_BIT_RANGE))
            self.quiet_info("OFFSET_BIT_RANGE: " + str(self.OFFSET_BIT_RANGE))
        return

    def do_pagewalk(self, table_base, granule_bits, region_start, start_level=0, is_stage2=False, is_2VAranges=False):
        # table_base: The start address of pagewalk
        # granule_bits: One of [12, 14, 16]; It specifies how to separate the bits used for address translation.
        # region_start: The base address of translated address
        # start_level: Only used at stage2. In stage2, the starting level will fluctuate
        # is_stage2: Affects how the bitfield of each entry is interpreted
        self.mappings = []

        is_4k_granule = granule_bits == 12
        is_16k_granule = granule_bits == 14
        is_64k_granule = granule_bits == 16

        def get_entries_per_table(BIT_RANGE):
            entries_per_table = 2 ** (BIT_RANGE[1] - BIT_RANGE[0])
            if not self.silent:
                self.quiet_info("Entries per table: {:d}".format(entries_per_table))
            return entries_per_table

        def has_next_level(entry): # for Level0, 1, 2 but not Level3
            return (entry & 0b11) == 0b11

        flags = []
        TABLE_BASE = [[region_start, table_base, flags]]

        # level -1 parse for 4KB granule
        if not self.silent:
            self.quiet_gef_print(titlify("LEVEL -1"))
        if self.LEVELM1_BIT_RANGE is not None and start_level == -1:
            entries_per_table = get_entries_per_table(self.LEVELM1_BIT_RANGE)
            LEVELM1 = []
            COUNT = 0
            for va_base, table_base, parent_flags in TABLE_BASE:
                entries = self.read_mem_wrapper(table_base, 8 * entries_per_table)
                entries = slice_unpack(entries, 8)
                COUNT += len(entries)
                for i, entry in enumerate(entries):
                    # present flag
                    if entry & 1 == 0:
                        continue

                    # calc virtual address
                    new_va = va_base + (i << self.LEVELM1_BIT_RANGE[0])
                    new_va_end = new_va + (1 << self.LEVELM1_BIT_RANGE[0])

                    # calc flags
                    flags = parent_flags.copy()
                    if has_next_level(entry):
                        if is_stage2:
                            pass
                        elif is_2VAranges:
                            if ((entry >> 59) & 1) == 1:
                                flags.append("PXNTable-1")
                            if ((entry >> 60) & 1) == 1:
                                flags.append("UXNTable-1")
                            flags.append("APTable-1={:02b}".format((entry >> 61) & 0b11))
                            if ((entry >> 63) & 1) == 1:
                                flags.append("NSTable-1")
                        else:
                            if ((entry >> 60) & 1) == 1:
                                flags.append("XNTable-1") # Use XNTable, not UXNTable # PXNTable is undefined
                            flags.append("APTable-1={:02b}".format((entry >> 61) & 0b11 & 0b10)) # APTable[0] must be 0
                            if ((entry >> 63) & 1) == 1:
                                flags.append("NSTable-1")
                    else:
                        # In ARMv8.7, level -1 has no block descriptors
                        raise

                    # calc next table / output phys addr (drop the flag bits)
                    if has_next_level(entry):
                        next_level_table = (entry & 0x0003fffffffff000) | (((entry >> 8) & 0b11) << 50)
                    else:
                        # In ARMv8.7, level -1 has no block descriptors
                        raise

                    # make entry
                    if has_next_level(entry):
                        LEVELM1.append([new_va, next_level_table, flags])
                        entry_type = "TABLE"
                    else:
                        # In ARMv8.7, level -1 has no block descriptors
                        raise

                    # dump
                    if self.print_each_level:
                        if self.is_not_trace_target(new_va, new_va_end):
                            continue
                        addr = table_base + i * 8
                        fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                        line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                        if self.is_not_filter_target(line):
                            continue
                        self.gef_print(line)

            if not self.silent:
                self.quiet_info("Number of entries: {:d}".format(COUNT))
                self.quiet_info("Level -1 Entry: {:d}".format(len(LEVELM1)))
                self.quiet_info("Invalid entries: {:d}".format(COUNT - len(LEVELM1)))
            self.mappings += []
        else:
            if not self.silent:
                self.quiet_info("LEVEL -1 is skipped")
            LEVELM1 = TABLE_BASE

        # level 0 parse for 4KB/16KB granule
        if not self.silent:
            self.quiet_gef_print(titlify("LEVEL 0"))
        if self.LEVEL0_BIT_RANGE is not None and start_level <= 0:
            entries_per_table = get_entries_per_table(self.LEVEL0_BIT_RANGE)
            LEVEL0 = []
            GB512 = []
            COUNT = 0
            for va_base, table_base, parent_flags in LEVELM1:
                entries = self.read_mem_wrapper(table_base, 8 * entries_per_table)
                entries = slice_unpack(entries, 8)
                COUNT += len(entries)
                for i, entry in enumerate(entries):
                    # present flag
                    if entry & 1 == 0:
                        continue

                    # calc virtual address
                    new_va = va_base + (i << self.LEVEL0_BIT_RANGE[0])
                    new_va_end = new_va + (1 << self.LEVEL0_BIT_RANGE[0])

                    # calc flags
                    flags = parent_flags.copy()
                    if has_next_level(entry):
                        if is_stage2:
                            pass
                        elif is_2VAranges:
                            if ((entry >> 59) & 1) == 1:
                                flags.append("PXNTable0")
                            if ((entry >> 60) & 1) == 1:
                                flags.append("UXNTable0")
                            flags.append("APTable0={:02b}".format((entry >> 61) & 0b11))
                            if ((entry >> 63) & 1) == 1:
                                flags.append("NSTable0")
                        else:
                            if ((entry >> 60) & 1) == 1:
                                flags.append("XNTable0") # Use XNTable, not UXNTable # PXNTable is undefined
                            flags.append("APTable0={:02b}".format((entry >> 61) & 0b11 & 0b10)) # APTable[0] must be 0
                            if ((entry >> 63) & 1) == 1:
                                flags.append("NSTable0")
                    else:
                        if is_stage2:
                            flags.append("MemAttr={:#x}".format((entry >> 2) & 0b1111))
                            flags.append("S2AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            flags.append("XN={:02b}".format((entry >> 53) & 0b11)) # Use XN, not UXN
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        elif is_2VAranges:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1:
                                flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 11) & 1) == 1:
                                flags.append("nG")
                            if ((entry >> 16) & 1) == 1:
                                flags.append("nT")
                            if ((entry >> 50) & 1) == 1:
                                flags.append("GP")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            if ((entry >> 53) & 1) == 1:
                                flags.append("PXN")
                            if ((entry >> 54) & 1) == 1:
                                flags.append("UXN")
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        else:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1:
                                flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11 & 0b10)) # AP[0] must be 0
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 11) & 1) == 1:
                                flags.append("nG")
                            if ((entry >> 16) & 1) == 1:
                                flags.append("nT")
                            if ((entry >> 50) & 1) == 1:
                                flags.append("GP")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            if ((entry >> 54) & 1) == 1:
                                flags.append("XN") # Use XN, not UXN # PXN is undefined
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))

                    # calc next table / output phys addr (drop the flag bits)
                    if has_next_level(entry):
                        if self.FEAT_LPA:
                            next_level_table = (entry & 0x0003fffffffff000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            next_level_table = entry & 0x0000fffffffff000
                    else:
                        if self.FEAT_LPA:
                            phys_addr = (entry & 0x0003fffffffe0000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            # In ARMv8.7, level 0 + no-FEAT_LPA has no block descriptors
                            raise

                    # make entry
                    if has_next_level(entry):
                        LEVEL0.append([new_va, next_level_table, flags])
                        entry_type = "TABLE"
                    else:
                        virt_addr = new_va
                        page_count = 1
                        flag_string = self.format_flags_stage2(flags) if is_stage2 else self.format_flags(flags)
                        if is_4k_granule:
                            page_size = 512 * 1024 * 1024 * 1024
                            GB512.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                            entry_type = "512GB-PAGE"
                        else:
                            raise

                    # dump
                    if self.print_each_level:
                        if self.is_not_trace_target(new_va, new_va_end):
                            continue
                        addr = table_base + i * 8
                        fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                        line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                        if self.is_not_filter_target(line):
                            continue
                        self.gef_print(line)

            if not self.silent:
                self.quiet_info("Number of entries: {:d}".format(COUNT))
                self.quiet_info("Level 0 Entry: {:d}".format(len(LEVEL0)))
                self.quiet_info("PT Entry (512GB): {:d}".format(len(GB512)))
                self.quiet_info("Invalid entries: {:d}".format(COUNT - len(LEVEL0) - len(GB512)))
            self.mappings += GB512
        else:
            if not self.silent:
                self.quiet_info("LEVEL 0 is skipped")
            LEVEL0 = TABLE_BASE

        # level 1 parse for 4KB/16KB/64KB granule
        if not self.silent:
            self.quiet_gef_print(titlify("LEVEL 1"))
        if self.LEVEL1_BIT_RANGE is not None and start_level <= 1:
            entries_per_table = get_entries_per_table(self.LEVEL1_BIT_RANGE)
            LEVEL1 = []
            GB1 = []
            TB4 = []
            GB64 = []
            COUNT = 0
            for va_base, table_base, parent_flags in LEVEL0:
                entries = self.read_mem_wrapper(table_base, 8 * entries_per_table)
                entries = slice_unpack(entries, 8)
                COUNT += len(entries)
                for i, entry in enumerate(entries):
                    # present flag
                    if entry & 1 == 0:
                        continue

                    # calc virtual address
                    new_va = va_base + (i << self.LEVEL1_BIT_RANGE[0])
                    new_va_end = new_va + (1 << self.LEVEL1_BIT_RANGE[0])

                    # calc flags
                    flags = parent_flags.copy()
                    if has_next_level(entry):
                        if is_stage2:
                            pass
                        elif is_2VAranges:
                            if ((entry >> 59) & 1) == 1:
                                flags.append("PXNTable1")
                            if ((entry >> 60) & 1) == 1:
                                flags.append("UXNTable1")
                            flags.append("APTable1={:02b}".format((entry >> 61) & 0b11))
                            if ((entry >> 63) & 1) == 1:
                                flags.append("NSTable1")
                        else:
                            if ((entry >> 60) & 1) == 1:
                                flags.append("XNTable1") # Use XNTable, not UXNTable # PXNTable is undefined
                            flags.append("APTable1={:02b}".format((entry >> 61) & 0b11 & 0b10)) # APTable[0] must be 0
                            if ((entry >> 63) & 1) == 1:
                                flags.append("NSTable1")
                    else:
                        if is_stage2:
                            flags.append("MemAttr={:#x}".format((entry >> 2) & 0b1111))
                            flags.append("S2AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            flags.append("XN={:02b}".format((entry >> 53) & 0b11)) # Use XN, not UXN
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        elif is_2VAranges:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1:
                                flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 11) & 1) == 1:
                                flags.append("nG")
                            if ((entry >> 16) & 1) == 1:
                                flags.append("nT")
                            if ((entry >> 50) & 1) == 1:
                                flags.append("GP")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            if ((entry >> 53) & 1) == 1:
                                flags.append("PXN")
                            if ((entry >> 54) & 1) == 1:
                                flags.append("UXN")
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        else:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1:
                                flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11 & 0b10)) # AP[0] must be 0
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 11) & 1) == 1:
                                flags.append("nG")
                            if ((entry >> 16) & 1) == 1:
                                flags.append("nT")
                            if ((entry >> 50) & 1) == 1:
                                flags.append("GP")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            if ((entry >> 54) & 1) == 1:
                                flags.append("XN") # Use XN, not UXN # PXN is undefined
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))

                    # calc next table / output phys addr (drop the flag bits)
                    if has_next_level(entry):
                        if self.FEAT_LPA:
                            if is_64k_granule:
                                next_level_table = (entry & 0x0000ffffffff0000) | (((entry >> 12) & 0b1111) << 48)
                            else:
                                next_level_table = (entry & 0x0003fffffffff000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            next_level_table = entry & 0x0000fffffffff000
                    else:
                        if self.FEAT_LPA:
                            if is_64k_granule:
                                phys_addr = (entry & 0x0000fffffffe0000) | (((entry >> 12) & 0b1111) << 48)
                            else:
                                phys_addr = (entry & 0x0003fffffffe0000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            phys_addr = entry & 0x0000fffffffe0000

                    # make entry
                    if has_next_level(entry):
                        LEVEL1.append([new_va, next_level_table, flags])
                        entry_type = "TABLE"
                    else:
                        virt_addr = new_va
                        page_count = 1
                        flag_string = self.format_flags_stage2(flags) if is_stage2 else self.format_flags(flags)
                        if is_64k_granule:
                            page_size = 4 * 1024 * 1024 * 1024 * 1024
                            TB4.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                            entry_type = "4TB-PAGE"
                        elif is_4k_granule:
                            page_size = 1 * 1024 * 1024 * 1024
                            GB1.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                            entry_type = "1GB-PAGE"
                        elif is_16k_granule:
                            page_size = 64 * 1024 * 1024 * 1024
                            GB64.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                            entry_type = "64GB-PAGE"

                    # dump
                    if self.print_each_level:
                        if self.is_not_trace_target(new_va, new_va_end):
                            continue
                        addr = table_base + i * 8
                        fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                        line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                        if self.is_not_filter_target(line):
                            continue
                        self.gef_print(line)

            if not self.silent:
                self.quiet_info("Number of entries: {:d}".format(COUNT))
                self.quiet_info("Level 1 Entry: {:d}".format(len(LEVEL1)))
                self.quiet_info("PT Entry (1GB): {:d}".format(len(GB1)))
                self.quiet_info("PT Entry (64GB): {:d}".format(len(GB64)))
                self.quiet_info("PT Entry (4TB): {:d}".format(len(TB4)))
                self.quiet_info("Invalid entries: {:d}".format(COUNT - len(LEVEL1) - len(GB1) - len(GB64) - len(TB4)))
            self.mappings += GB1 + GB64 + TB4
        else:
            if not self.silent:
                self.quiet_info("LEVEL 1 is skipped")
            LEVEL1 = LEVEL0

        # level 2 parse for 4KB/16KB/64KB granule
        if not self.silent:
            self.quiet_gef_print(titlify("LEVEL 2"))
        if self.LEVEL2_BIT_RANGE is not None and start_level <= 2:
            entries_per_table = get_entries_per_table(self.LEVEL2_BIT_RANGE)
            LEVEL2 = []
            MB2 = []
            MB32 = []
            MB512 = []
            COUNT = 0
            for va_base, table_base, parent_flags in LEVEL1:
                entries = self.read_mem_wrapper(table_base, 8 * entries_per_table)
                entries = slice_unpack(entries, 8)
                COUNT += len(entries)
                for i, entry in enumerate(entries):
                    # present flag
                    if entry & 1 == 0:
                        continue

                    # calc virtual address
                    new_va = va_base + (i << self.LEVEL2_BIT_RANGE[0])
                    new_va_end = new_va + (1 << self.LEVEL2_BIT_RANGE[0])

                    # calc flags
                    flags = parent_flags.copy()
                    if has_next_level(entry):
                        if is_stage2:
                            pass
                        elif is_2VAranges:
                            if ((entry >> 59) & 1) == 1:
                                flags.append("PXNTable2")
                            if ((entry >> 60) & 1) == 1:
                                flags.append("UXNTable2")
                            flags.append("APTable2={:02b}".format((entry >> 61) & 0b11))
                            if ((entry >> 63) & 1) == 1:
                                flags.append("NSTable2")
                        else:
                            if ((entry >> 60) & 1) == 1:
                                flags.append("XNTable2") # Use XNTable, not UXNTable # PXNTable is undefined
                            flags.append("APTable2={:02b}".format((entry >> 61) & 0b11 & 0b10)) # APTable[0] must be 0
                            if ((entry >> 63) & 1) == 1:
                                flags.append("NSTable2")
                    else:
                        if is_stage2:
                            flags.append("MemAttr={:#x}".format((entry >> 2) & 0b1111))
                            flags.append("S2AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            flags.append("XN={:02b}".format((entry >> 53) & 0b11)) # Use XN, not UXN
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        elif is_2VAranges:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1:
                                flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 11) & 1) == 1:
                                flags.append("nG")
                            if ((entry >> 16) & 1) == 1:
                                flags.append("nT")
                            if ((entry >> 50) & 1) == 1:
                                flags.append("GP")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            if ((entry >> 53) & 1) == 1:
                                flags.append("PXN")
                            if ((entry >> 54) & 1) == 1:
                                flags.append("UXN")
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        else:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1:
                                flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11 & 0b10)) # AP[0] must be 0
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 11) & 1) == 1:
                                flags.append("nG")
                            if ((entry >> 16) & 1) == 1:
                                flags.append("nT")
                            if ((entry >> 50) & 1) == 1:
                                flags.append("GP")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            if ((entry >> 54) & 1) == 1:
                                flags.append("XN") # Use XN, not UXN # PXN is undefined
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))

                    # calc next table / output phys addr (drop the flag bits)
                    if has_next_level(entry):
                        if self.FEAT_LPA:
                            if is_64k_granule:
                                next_level_table = (entry & 0x0000ffffffff0000) | (((entry >> 12) & 0b1111) << 48)
                            else:
                                next_level_table = (entry & 0x0003fffffffff000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            next_level_table = entry & 0x0000fffffffff000
                    else:
                        if self.FEAT_LPA:
                            if is_64k_granule:
                                phys_addr = (entry & 0x0000fffffffe0000) | (((entry >> 12) & 0b1111) << 48)
                            else:
                                phys_addr = (entry & 0x0003fffffffe0000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            phys_addr = entry & 0x0000fffffffe0000

                    # make entry
                    if has_next_level(entry):
                        LEVEL2.append([new_va, next_level_table, flags])
                        entry_type = "TABLE"
                    else:
                        virt_addr = new_va
                        page_count = 1
                        flag_string = self.format_flags_stage2(flags) if is_stage2 else self.format_flags(flags)
                        if is_64k_granule:
                            page_size = 512 * 1024 * 1024
                            MB512.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                            entry_type = "512MB-PAGE"
                        elif is_16k_granule:
                            page_size = 32 * 1024 * 1024
                            MB32.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                            entry_type = "32MB-PAGE"
                        elif is_4k_granule:
                            page_size = 2 * 1024 * 1024
                            MB2.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                            entry_type = "2MB-PAGE"

                    # dump
                    if self.print_each_level:
                        if self.is_not_trace_target(new_va, new_va_end):
                            continue
                        addr = table_base + i * 8
                        fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                        line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                        if self.is_not_filter_target(line):
                            continue
                        self.gef_print(line)

            if not self.silent:
                self.quiet_info("Number of entries: {:d}".format(COUNT))
                self.quiet_info("Level 2 Entry: {:d}".format(len(LEVEL2)))
                self.quiet_info("PT Entry (2MB): {:d}".format(len(MB2)))
                self.quiet_info("PT Entry (32MB): {:d}".format(len(MB32)))
                self.quiet_info("PT Entry (512MB): {:d}".format(len(MB512)))
                self.quiet_info("Invalid entries: {:d}".format(COUNT - len(LEVEL2) - len(MB2) - len(MB32) - len(MB512)))
            self.mappings += MB2 + MB32 + MB512
        else:
            if not self.silent:
                self.quiet_info("LEVEL 2 is skipped")
            LEVEL2 = LEVEL1

        # level 3 parse for 4KB/16KB/64KB granule
        if not self.silent:
            self.quiet_gef_print(titlify("LEVEL 3"))
        if self.LEVEL3_BIT_RANGE is not None and start_level <= 3:
            entries_per_table = get_entries_per_table(self.LEVEL3_BIT_RANGE)
            KB4 = []
            KB16 = []
            KB64 = []
            COUNT = 0
            for va_base, table_base, parent_flags in LEVEL2:
                entries = self.read_mem_wrapper(table_base, 8 * entries_per_table)
                entries = slice_unpack(entries, 8)
                COUNT += len(entries)
                for i, entry in enumerate(entries):
                    # present flag
                    if entry & 1 == 0:
                        continue

                    # calc virtual address
                    virt_addr = va_base + (i << self.LEVEL3_BIT_RANGE[0])
                    virt_addr_end = virt_addr + (1 << self.LEVEL3_BIT_RANGE[0])

                    # calc flags
                    flags = parent_flags.copy()
                    if (entry & 0b11) == 0b11:
                        if is_stage2:
                            flags.append("MemAttr={:#x}".format((entry >> 2) & 0b1111))
                            flags.append("S2AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            flags.append("XN={:02b}".format((entry >> 53) & 0b11)) # Use XN, not UXN
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        elif is_2VAranges:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1:
                                flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 11) & 1) == 1:
                                flags.append("nG")
                            if ((entry >> 16) & 1) == 1:
                                flags.append("nT")
                            if ((entry >> 50) & 1) == 1:
                                flags.append("GP")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            if ((entry >> 53) & 1) == 1:
                                flags.append("PXN")
                            if ((entry >> 54) & 1) == 1:
                                flags.append("UXN")
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        else:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1:
                                flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11 & 0b10)) # AP[0] must be 0
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 11) & 1) == 1:
                                flags.append("nG")
                            if ((entry >> 16) & 1) == 1:
                                flags.append("nT")
                            if ((entry >> 50) & 1) == 1:
                                flags.append("GP")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            if ((entry >> 54) & 1) == 1:
                                flags.append("XN") # Use XN, not UXN # PXN is undefined
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                    else:
                        # In ARMv8.7, level 3 has no table descriptors
                        raise

                    # calc next table / output phys addr (drop the flag bits)
                    if is_4k_granule:
                        if self.FEAT_LPA:
                            phys_addr = (entry & 0x0003fffffffff000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            phys_addr = entry & 0x0000fffffffff000
                    elif is_16k_granule:
                        if self.FEAT_LPA:
                            phys_addr = (entry & 0x0003ffffffffc000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            phys_addr = entry & 0x0000ffffffffc000
                    elif is_64k_granule:
                        if self.FEAT_LPA:
                            phys_addr = (entry & 0x0000ffffffff0000) | (((entry >> 12) & 0b1111) << 48)
                        else:
                            phys_addr = entry & 0x0000ffffffff0000

                    # make entry
                    page_count = 1
                    flag_string = self.format_flags_stage2(flags) if is_stage2 else self.format_flags(flags)
                    if is_64k_granule:
                        page_size = 64 * 1024
                        KB64.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                        entry_type = "64KB-PAGE"
                    elif is_16k_granule:
                        page_size = 16 * 1024
                        KB16.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                        entry_type = "16KB-PAGE"
                    elif is_4k_granule:
                        page_size = 4 * 1024
                        KB4.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                        entry_type = "4KB-PAGE"

                    # dump
                    if self.print_each_level:
                        if self.is_not_trace_target(virt_addr, virt_addr_end):
                            continue
                        addr = table_base + i * 8
                        fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                        line = fmt.format(addr, entry, virt_addr, virt_addr_end, entry_type, ' '.join(flags))
                        if self.is_not_filter_target(line):
                            continue
                        self.gef_print(line)

            if not self.silent:
                self.quiet_info("Number of entries: {:d}".format(COUNT))
                self.quiet_info("PT Entry (4KB): {:d}".format(len(KB4)))
                self.quiet_info("PT Entry (16KB): {:d}".format(len(KB16)))
                self.quiet_info("PT Entry (64KB): {:d}".format(len(KB64)))
                self.quiet_info("Invalid entries: {:d}".format(COUNT - len(KB4) - len(KB16) - len(KB64)))
            self.mappings += KB4 + KB16 + KB64
        else:
            if not self.silent:
                self.quiet_info("LEVEL 3 is skipped")

        # Finalize
        if not self.silent:
            self.quiet_gef_print(titlify("Total"))
            self.quiet_info("PT Entry (Total): {:d}".format(len(self.mappings)))
        self.mappings = sorted(self.mappings)
        return

    def switch_el(self):
        self.SAVED_CPSR = 0
        CPSR = get_register('$cpsr') & 0xffffffff
        CurrentEL = int((CPSR >> 2) & 0b11)
        # change EL
        try:
            if self.TargetEL < 1 or self.TargetEL > 3:
                err("Invalid argument (ELx>=1 && ELx<=3)")
                return
            if self.TargetEL != CurrentEL:
                self.SAVED_CPSR = CPSR
                CPSR = CPSR & ~(0b11 << 2) # clear EL
                CPSR |= self.TargetEL << 2 # set desired EL
                gdb.parse_and_eval('$cpsr = 0x%08x' % CPSR)
                self.quiet_info('Moving to EL%d' % (self.TargetEL))
        except ValueError:
            err("Invalid argument (ELx integer required)")
            return
        except gdb.error:
            err("Maybe unsupported to change to EL%d" % (self.TargetEL))
            return
        # reload CPSR
        CPSR = get_register('$cpsr') & 0xffffffff
        CurrentEL = int((CPSR >> 2) & 0b11)
        self.quiet_info('CPSR: EL%d' % (CurrentEL))
        return True

    def revert_el(self):
        if self.SAVED_CPSR:
            gdb.parse_and_eval('$cpsr = 0x%08x' % self.SAVED_CPSR)
            SavedEL = (self.SAVED_CPSR >> 2) & 0b11
            self.quiet_info('Moving back to EL%d' % (SavedEL))
        return

    def pagewalk_TTBR0_EL1(self):
        self.gef_print(titlify("$TTBR0_EL1"))

        TTBR0_EL1 = get_register('$TTBR0_EL1')
        TCR_EL1 = get_register('$TCR_EL1')
        if TTBR0_EL1 == 0:
            warn("Maybe unused TTBR0_EL1")
            return

        IPS = (TCR_EL1 >> 32) & 0b111
        TG0 = (TCR_EL1 >> 14) & 0b11
        T0SZ = TCR_EL1 & 0b111111
        try:
            granule_bits = {0b00: 12, 0b01: 16, 0b10: 14}[TG0]
        except Exception:
            err("Unsupported $TCR_EL1.TG0")
            return
        region_start = 0
        region_end = region_start + (2 ** (64 - T0SZ))
        region_bits = int(math.log2(region_end - region_start))
        page_size = 2 ** (granule_bits - 10)
        intermediate_pa_size = 32 + (IPS * 4)

        if IPS == 0b110:
            if self.FEAT_LPA:
                translation_base_addr = (TTBR0_EL1 & 0xffffffffffc0) | (((TTBR0_EL1 >> 2) & 0b1111) << 48)
            else:
                err("Unsupported FEAT_LPA and IPS pair")
                return
        else:
            translation_base_addr = TTBR0_EL1 & 0xfffffffffffe

        self.quiet_info('$TTBR0_EL1: {:#x}'.format(TTBR0_EL1))
        self.quiet_info('$TCR_EL1: {:#x}'.format(TCR_EL1))
        self.quiet_info('Intermediate Physical Address Size: {:d} bits'.format(intermediate_pa_size))
        self.quiet_info('EL1 User Region: {:#018x} - {:#018x} ({:d} bits)'.format(region_start, region_end - 1, region_bits))
        self.quiet_info('EL1 User Page Size: {:d}KB (per page)'.format(page_size))

        self.parse_bit_range(granule_bits, region_bits)
        self.do_pagewalk(translation_base_addr, granule_bits, region_start, is_2VAranges=True)
        self.print_page()
        return

    def pagewalk_TTBR1_EL1(self):
        self.gef_print(titlify("$TTBR1_EL1"))

        TTBR1_EL1 = get_register('$TTBR1_EL1')
        TCR_EL1 = get_register('$TCR_EL1')
        if TTBR1_EL1 == 0:
            warn("Maybe unused TTBR1_EL1")
            return

        IPS = (TCR_EL1 >> 32) & 0b111
        TG1 = (TCR_EL1 >> 30) & 0b11
        T1SZ = (TCR_EL1 >> 16) & 0b111111
        try:
            granule_bits = {0b01: 14, 0b10: 12, 0b11: 16}[TG1]
        except Exception:
            err("Unsupported $TCR_EL1.TG1")
            return
        region_end = 2 ** 64
        region_start = region_end - (2 ** (64 - T1SZ))
        region_bits = int(math.log2(region_end - region_start))
        page_size = 2 ** (granule_bits - 10)
        intermediate_pa_size = 32 + (IPS * 4)

        if IPS == 0b110:
            if self.FEAT_LPA:
                translation_base_addr = (TTBR1_EL1 & 0xffffffffffc0) | (((TTBR1_EL1 >> 2) & 0b1111) << 48)
            else:
                err("Unsupported FEAT_LPA and IPS pair")
                return
        else:
            translation_base_addr = TTBR1_EL1 & 0xfffffffffffe

        self.quiet_info('$TTBR1_EL1: {:#x}'.format(TTBR1_EL1))
        self.quiet_info('$TCR_EL1: {:#x}'.format(TCR_EL1))
        self.quiet_info('Intermediate Physical Address Size: {:d} bits'.format(intermediate_pa_size))
        self.quiet_info('EL1 Kernel Region: {:#018x} - {:#018x} ({:d} bits)'.format(region_start, region_end - 1, region_bits))
        self.quiet_info('EL1 Kernel Page Size: {:d}KB (per page)'.format(page_size))

        self.parse_bit_range(granule_bits, region_bits)
        self.do_pagewalk(translation_base_addr, granule_bits, region_start, is_2VAranges=True)
        self.print_page()
        return

    def pagewalk_VTTBR_EL2(self):
        if not self.silent:
            self.gef_print(titlify("$VTTBR_EL2"))

        VTTBR_EL2 = get_register('$VTTBR_EL2')
        VTCR_EL2 = get_register('$VTCR_EL2')
        if VTTBR_EL2 == 0:
            if not self.silent:
                warn("Maybe unused VTTBR_EL2")
            return

        SL2 = (VTCR_EL2 >> 33) & 0b1
        PS = (VTCR_EL2 >> 16) & 0b11
        TG0 = (VTCR_EL2 >> 14) & 0b11
        SL0 = (VTCR_EL2 >> 6) & 0b11
        T0SZ = VTCR_EL2 & 0b111111
        try:
            granule_bits = {0b00: 12, 0b01: 16, 0b10: 14}[TG0]
        except Exception:
            if not self.silent:
                err("Unsupported $VTCR_EL2.TG0")
            return
        region_start = 0
        region_end = region_start + (2 ** (64 - T0SZ))
        region_bits = int(math.log2(region_end - region_start))
        page_size = 2 ** (granule_bits - 10)
        pa_size = 32 + (PS * 4)

        if self.FEAT_TTST:
            if SL0 == 0b00:
                if TG0 == 0b00:
                    if self.FEAT_LPA2 and SL2 == 1:
                        stage2_start_level = -1
                    else:
                        stage2_start_level = 2
                else:
                    stage2_start_level = 3
            elif SL0 == 0b01:
                if TG0 == 0b00:
                    if self.FEAT_LPA2 and SL2 == 1:
                        if not self.silent:
                            err("Unsupported stage2 start level")
                        return
                    else:
                        stage2_start_level = 1
                else:
                    stage2_start_level = 2
            elif SL0 == 0b10:
                if TG0 == 0b00:
                    if self.FEAT_LPA2 and SL2 == 1:
                        if not self.silent:
                            err("Unsupported stage2 start level")
                        return
                    else:
                        stage2_start_level = 0
                else:
                    stage2_start_level = 1
            elif SL0 == 0b11:
                if TG0 == 0b00:
                    if self.FEAT_LPA2 and SL2 == 1:
                        if not self.silent:
                            err("Unsupported stage2 start level")
                        return
                    else:
                        stage2_start_level = 3
                else:
                    stage2_start_level = 0
        else:
            if SL0 == 0b00:
                if TG0 == 0b00:
                    stage2_start_level = 2
                else:
                    stage2_start_level = 3
            elif SL0 == 0b01:
                if TG0 == 0b00:
                    stage2_start_level = 1
                else:
                    stage2_start_level = 2
            elif SL0 == 0b10:
                if TG0 == 0b00:
                    stage2_start_level = 0
                else:
                    stage2_start_level = 1
            else:
                if not self.silent:
                    err("Unsupported stage2 start level")
                return

        if PS == 0b110:
            if self.FEAT_LPA:
                translation_base_addr = (VTTBR_EL2 & 0xffffffffffc0) | (((VTTBR_EL2 >> 2) & 0b1111) << 48)
            else:
                if not self.silent:
                    err("Unsupported FEAT_LPA and PS pair")
                return
        else:
            translation_base_addr = VTTBR_EL2 & 0xfffffffffffe

        if not self.silent:
            self.quiet_info('$VTTBR_EL2: {:#x}'.format(VTTBR_EL2))
            self.quiet_info('$VTCR_EL2: {:#x}'.format(VTCR_EL2))
            self.quiet_info('Physical Address Size: {:d} bits'.format(pa_size))
            self.quiet_info('EL2 Starting Level: {:d}'.format(SL0))
            self.quiet_info('EL2 Region: {:#018x} - {:#018x} ({:d} bits)'.format(region_start, region_end - 1, region_bits))
            self.quiet_info('EL2 Page Size: {:d}KB (per page)'.format(page_size))

        self.parse_bit_range(granule_bits, region_bits)
        self.do_pagewalk(translation_base_addr, granule_bits, region_start, start_level=stage2_start_level, is_stage2=True)
        if not self.silent:
            self.print_page()
        return

    def pagewalk_TTBR0_EL2(self):
        self.gef_print(titlify("$TTBR0_EL2"))

        TTBR0_EL2 = get_register('$TTBR0_EL2')
        TCR_EL2 = get_register('$TCR_EL2')
        if TTBR0_EL2 == 0:
            warn("Maybe unused TTBR0_EL2")
            return

        if self.EL2_E2H:
            IPS = (TCR_EL2 >> 32) & 0b111
        else:
            PS = (TCR_EL2 >> 16) & 0b111
        TG0 = (TCR_EL2 >> 14) & 0b11
        T0SZ = TCR_EL2 & 0b111111
        try:
            granule_bits = {0b00: 12, 0b01: 16, 0b10: 14}[TG0]
        except Exception:
            err("Unsupported $TCR_EL2.TG0")
            return
        region_start = 0
        region_end = region_start + (2 ** (64 - T0SZ))
        region_bits = int(math.log2(region_end - region_start))
        page_size = 2 ** (granule_bits - 10)
        if self.EL2_E2H:
            intermediate_pa_size = 32 + (IPS * 4)
        else:
            pa_size = 32 + (PS * 4)

        if not self.EL2_E2H and PS == 0b110:
            if self.FEAT_LPA:
                translation_base_addr = (TTBR0_EL2 & 0xffffffffffc0) | (((TTBR0_EL2 >> 2) & 0b1111) << 48)
            else:
                err("Unsupported FEAT_LPA and PS pair")
                return
        elif self.EL2_E2H and IPS == 0b110:
            if self.FEAT_LPA:
                translation_base_addr = (TTBR0_EL2 & 0xffffffffffc0) | (((TTBR0_EL2 >> 2) & 0b1111) << 48)
            else:
                err("Unsupported FEAT_LPA and IPS pair")
                return
        else:
            translation_base_addr = TTBR0_EL2 & 0xfffffffffffe

        self.quiet_info('$TTBR0_EL2: {:#x}'.format(TTBR0_EL2))
        self.quiet_info('$TCR_EL2: {:#x}'.format(TCR_EL2))
        if self.EL2_E2H:
            self.quiet_info('Intermediate Physical Address Size: {:d} bits'.format(intermediate_pa_size))
        else:
            self.quiet_info('Physical Address Size: {:d} bits'.format(pa_size))
        if self.EL2_M20:
            self.quiet_info('EL2 User Region: {:#018x} - {:#018x} ({:d} bits)'.format(region_start, region_end - 1, region_bits))
            self.quiet_info('EL2 USer Page Size: {:d}KB (per page)'.format(page_size))
        else:
            self.quiet_info('EL2 Region: {:#018x} - {:#018x} ({:d} bits)'.format(region_start, region_end - 1, region_bits))
            self.quiet_info('EL2 Page Size: {:d}KB (per page)'.format(page_size))

        self.parse_bit_range(granule_bits, region_bits)
        self.do_pagewalk(translation_base_addr, granule_bits, region_start, is_2VAranges=self.EL2_M20)
        self.print_page()
        return

    def pagewalk_TTBR1_EL2(self):
        self.gef_print(titlify("$TTBR1_EL2"))

        TTBR1_EL2 = get_register('$TTBR1_EL2')
        TCR_EL2 = get_register('$TCR_EL2')
        if TTBR1_EL2 == 0:
            warn("Maybe unused TTBR1_EL2")
            return

        IPS = (TCR_EL2 >> 32) & 0b111
        TG1 = (TCR_EL2 >> 30) & 0b11
        T1SZ = (TCR_EL2 >> 16) & 0b111111
        try:
            granule_bits = {0b01: 14, 0b10: 12, 0b11: 16}[TG1]
        except Exception:
            err("Unsupported $TCR_EL2.TG1")
            return
        region_end = 2 ** 64
        region_start = region_end - (2 ** (64 - T1SZ))
        region_bits = int(math.log2(region_end - region_start))
        page_size = 2 ** (granule_bits - 10)
        intermediate_pa_size = 32 + (IPS * 4)

        if IPS == 0b110:
            if self.FEAT_LPA:
                translation_base_addr = (TTBR1_EL2 & 0xffffffffffc0) | (((TTBR1_EL2 >> 2) & 0b1111) << 48)
            else:
                err("Unsupported FEAT_LPA and IPS pair")
                return
        else:
            translation_base_addr = TTBR1_EL2 & 0xfffffffffffe

        self.quiet_info('$TTBR1_EL2: {:#x}'.format(TTBR1_EL2))
        self.quiet_info('$TCR_EL2: {:#x}'.format(TCR_EL2))
        self.quiet_info('Intermediate Physical Address Size: {:d} bits'.format(intermediate_pa_size))
        self.quiet_info('EL2 Kernel Region: {:#018x} - {:#018x} ({:d} bits)'.format(region_start, region_end - 1, region_bits))
        self.quiet_info('EL2 Kernel Page Size: {:d}KB (per page)'.format(page_size))

        self.parse_bit_range(granule_bits, region_bits)
        self.do_pagewalk(translation_base_addr, granule_bits, region_start, is_2VAranges=self.EL2_M20)
        self.print_page()
        return

    def pagewalk_TTBR0_EL3(self):
        self.gef_print(titlify("$TTBR0_EL3"))

        TTBR0_EL3 = get_register('$TTBR0_EL3')
        TCR_EL3 = get_register('$TCR_EL3')
        if TTBR0_EL3 == 0:
            warn("Maybe unused TTBR0_EL3")
            return

        PS = (TCR_EL3 >> 16) & 0b111
        TG0 = (TCR_EL3 >> 14) & 0b11
        T0SZ = TCR_EL3 & 0b111111
        try:
            granule_bits = {0b00: 12, 0b01: 16, 0b10: 14}[TG0]
        except Exception:
            err("Unsupported $TCR_EL3.TG0")
            return
        region_start = 0
        region_end = region_start + (2 ** (64 - T0SZ))
        region_bits = int(math.log2(region_end - region_start))
        page_size = 2 ** (granule_bits - 10)
        pa_size = 32 + (PS * 4)

        if PS == 0b110:
            if self.FEAT_LPA:
                translation_base_addr = (TTBR0_EL3 & 0xffffffffffc0) | (((TTBR0_EL3 >> 2) & 0b1111) << 48)
            else:
                err("Unsupported FEAT_LPA and PS pair")
                return
        else:
            translation_base_addr = TTBR0_EL3 & 0xfffffffffffe

        self.quiet_info('$TTBR0_EL3: {:#x}'.format(TTBR0_EL3))
        self.quiet_info('$TCR_EL3: {:#x}'.format(TCR_EL3))
        self.quiet_info('Physical Address Size: {:d} bits'.format(pa_size))
        self.quiet_info('EL3 Region: {:#018x} - {:#018x} ({:d} bits)'.format(region_start, region_end - 1, region_bits))
        self.quiet_info('EL3 Page Size: {:d}KB (per page)'.format(page_size))

        self.parse_bit_range(granule_bits, region_bits)
        self.do_pagewalk(translation_base_addr, granule_bits, region_start)
        self.print_page()
        return

    def pagewalk_init(self):
        res = gdb.execute("info registers", to_string=True)
        if "TTBR" not in res:
            err("Not found system registers. Check qemu version (at least: 3.x~, recommend: 5.x~).")
            return

        SCTLR_EL1 = get_register('$SCTLR_EL1')
        if SCTLR_EL1 is None:
            SCTLR_EL1 = get_register('$SCTLR')
        if SCTLR_EL1 is not None:
            self.EL1_M = (SCTLR_EL1 & 1) == 1
            self.EL1_WXN = ((SCTLR_EL1 >> 19) & 1) == 1
        else:
            self.EL1_M = False
            self.EL1_WXN = False

        HCR_EL2 = get_register('$HCR_EL2')
        if HCR_EL2 is not None:
            self.EL2_TGE = ((HCR_EL2 >> 27) & 1) == 1
            self.EL2_E2H = ((HCR_EL2 >> 34) & 1) == 1
            self.EL2_M20 = self.EL2_TGE and self.EL2_E2H
            self.EL2_VM = (HCR_EL2 & 1) == 1
        else:
            self.EL2_TGE = False
            self.EL2_E2H = False
            self.EL2_M20 = False
            self.EL2_VM = False

        SCTLR_EL2 = get_register('$SCTLR_EL2')
        if SCTLR_EL2 is not None:
            self.EL2_M = (SCTLR_EL2 & 1) == 1
            self.EL2_WXN = ((SCTLR_EL2 >> 19) & 1) == 1
        else:
            self.EL2_M = False
            self.EL2_WXN = False

        SCTLR_EL3 = get_register('$SCTLR_EL3')
        if SCTLR_EL3 is not None:
            self.EL3_M = (SCTLR_EL3 & 1) == 1
            self.EL3_WXN = ((SCTLR_EL3 >> 19) & 1) == 1
        else:
            self.EL3_M = False
            self.EL3_WXN = False

        ID_AA64MMFR0_EL1 = get_register('$ID_AA64MMFR0_EL1')
        if ID_AA64MMFR0_EL1 is not None:
            TGran4_2 = (ID_AA64MMFR0_EL1 >> 40) & 0b1111
            TGran16_2 = (ID_AA64MMFR0_EL1 >> 32) & 0b1111
            TGran4 = (ID_AA64MMFR0_EL1 >> 28) & 0b1111
            TGran16 = (ID_AA64MMFR0_EL1 >> 20) & 0b1111
            self.FEAT_LPA2 = (TGran4_2 == 0b0011) or (TGran16_2 == 0b0011) or (TGran4 == 0b0001) or (TGran16 == 0b0010)
            self.FEAT_LPA = (ID_AA64MMFR0_EL1 & 0b1111) == 0b0110
        else:
            self.FEAT_LPA2 = False
            self.FEAT_LPA = False

        ID_AA64MMFR1_EL1 = get_register('$ID_AA64MMFR1_EL1')
        if ID_AA64MMFR1_EL1 is not None:
            self.FEAT_PAN = ((ID_AA64MMFR1_EL1 >> 20) & 0b1111) != 0b0000
        else:
            self.FEAT_PAN = False
        self.quiet_info("{:s} is supported on all ARMv8".format(Color.boldify("PXN")))
        if self.FEAT_PAN:
            self.quiet_info("{:s} is supported".format(Color.boldify("PAN")))
        else:
            self.quiet_info("PAN is unsupported")

        ID_AA64MMFR2_EL1 = get_register('$ID_AA64MMFR2_EL1')
        if ID_AA64MMFR2_EL1 is not None:
            self.FEAT_TTST = ((ID_AA64MMFR2_EL1 >> 28) & 0b1111) == 0b0001
            self.FEAT_LVA = ((ID_AA64MMFR2_EL1 >> 16) & 0b1111) == 0b0001
        else:
            self.FEAT_TTST = False
            self.FEAT_LVA = False

        return

    def pagewalk(self):
        # parse system registers
        self.pagewalk_init()

        # TODO implementation for VSTTBR_EL2, VSTCR_EL2 pattern

        # do pagewalk
        if self.TargetEL < 1 or 3 < self.TargetEL:
            warn('No paging in EL{:d}'.format(self.TargetEL))
            return
        if self.TargetEL == 1 and self.EL1_M:
            if self.EL2_VM:
                # el2_mapping is needed because read_mem() uses PA, but not IPA
                self.silent = True
                self.pagewalk_VTTBR_EL2()
                if self.mappings:
                    self.el2_mappings = self.mappings
                self.silent = False
            self.pagewalk_TTBR0_EL1()
            self.pagewalk_TTBR1_EL1()
        if self.TargetEL == 1 and not self.EL1_M:
            self.quiet_info("EL1/0 translation is unused")
        if self.TargetEL == 2 and self.EL2_VM:
            self.pagewalk_VTTBR_EL2()
        if self.TargetEL == 2 and not self.EL2_VM:
            self.quiet_info("EL2(as stage2) translation is unused")
        if self.TargetEL == 2 and self.EL2_M:
            self.pagewalk_TTBR0_EL2()
            if self.EL2_M20:
                self.pagewalk_TTBR1_EL2()
        if self.TargetEL == 2 and self.EL2_VM:
            self.quiet_info("EL2(as stage1) translation is unused")
        if self.TargetEL == 3 and self.EL3_M:
            if not self.switch_el():
                return
            self.pagewalk_TTBR0_EL3()
            self.revert_el()
        if self.TargetEL == 3 and not self.EL3_M:
            self.quiet_info("EL3 translation is unused")
        return

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["ARM64"])
    def do_invoke(self, args):
        self.dont_repeat()

        if args.target_el is None:
            CPSR = get_register('$cpsr')
            self.TargetEL = (CPSR >> 2) & 0b11
        else:
            self.TargetEL = args.target_el

        self.quiet = args.quiet
        self.print_each_level = args.print_each_level
        self.no_merge = args.no_merge
        self.sort_by_phys = args.sort_by_phys
        self.simple = args.simple
        self.filter = args.filter
        self.vrange = args.vrange
        self.prange = args.prange
        self.trace = args.trace
        if self.trace:
            self.vrange.extend(self.trace) # also set --vrange
            self.print_each_level = True # overwrite
        self.use_pager = args.use_pager
        self.cache = {}

        self.silent = False
        self.mappings = None
        self.el2_mappings = None
        self.out = []
        self.pagewalk()
        self.cache = {}

        if self.out:
            gef_print('\n'.join(self.out), less=self.use_pager)
        return


@register_command
class SwitchELCommand(GenericCommand):
    """Switch EL (Exception Level) on ARM64 architecture."""
    _cmdline_ = "switch-el"
    _category_ = "08-a. Qemu-system Cooperation - General"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument("target_el", metavar='TARGET_EL', nargs='?', type=int, help='Exception Level to change to.')
    _syntax_ = parser.format_help()

    def switch_el(self):
        # current EL
        CPSR = get_register('$cpsr') & 0xffffffff
        CurrentEL = (CPSR >> 2) & 0b11

        # check argv
        if self.target_el is None:
            info('$cpsr = 0x%x (EL%d)' % (CPSR, CurrentEL))
            return

        # check target EL
        try:
            if self.target_el < 0 or self.target_el > 3:
                err("Invalid argument (ELx>=0 && ELx<=3)")
                return
        except ValueError:
            err("Invalid argument (ELx integer required)")
            return

        # change CPSR
        if self.target_el != CurrentEL:
            CPSR = CPSR & ~(0b11 << 2) # clear EL
            CPSR |= self.target_el << 2 # set desired EL
            gdb.parse_and_eval('$cpsr = 0x%08x' % CPSR)
            info('Moving to EL%d' % (self.target_el))
        else:
            info('Already at EL%d' % (self.target_el))

        # reprint CPSR
        CPSR = int(gdb.parse_and_eval('$cpsr')) & 0xffffffff
        CurrentEL = (CPSR >> 2) & 0b11
        info('$cpsr = 0x%x (EL%d)' % (CPSR, CurrentEL))
        return

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["ARM64"])
    def do_invoke(self, args):
        self.dont_repeat()
        self.target_el = args.target_el
        self.switch_el()
        return


@register_command
class ExecNextCommand(GenericCommand):
    """Execute until next address. This command is used for rep prefix."""
    _cmdline_ = "exec-next"
    _category_ = "01-d. Debugging Support - Execution"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        if is_arm32() or is_arm64():
            next_addr = gdb_get_nth_next_instruction_address(current_arch.pc, 1)
        else:
            next_addr = gdb_get_nth_next_instruction_address(current_arch.pc, 2)
        # `until` command has a bug(?) because sometimes fail. we use `tbreak` and `continue` instead of `until`.
        gdb.Breakpoint("*{:#x}".format(next_addr), gdb.BP_BREAKPOINT, internal=True, temporary=True)
        gdb.execute("c") # use c wrapper
        return


@register_command
class ExecUntilCommand(GenericCommand):
    """Execute until next call/jmp/syscall/ret/mem-access/specified-keyword instruction."""
    _cmdline_ = "exec-until"
    _category_ = "01-d. Debugging Support - Execution"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    subparsers = parser.add_subparsers(title='command', required=True)
    subparsers.add_parser('call')
    subparsers.add_parser('jmp')
    subparsers.add_parser('syscall')
    subparsers.add_parser('ret')
    subparsers.add_parser('all-branch')
    subparsers.add_parser('indirect-branch')
    subparsers.add_parser('memaccess')
    subparsers.add_parser('keyword')
    subparsers.add_parser('cond')
    _syntax_ = parser.format_help()

    _example_ = "{:s} call                                # execute until call instruction\n".format(_cmdline_)
    _example_ += "{:s} jmp                                 # execute until jmp instruction\n".format(_cmdline_)
    _example_ += "{:s} syscall                             # execute until syscall instruction\n".format(_cmdline_)
    _example_ += "{:s} ret                                 # execute until ret instruction\n".format(_cmdline_)
    _example_ += "{:s} all-branch                          # execute until call/jmp/ret instruction\n".format(_cmdline_)
    _example_ += "{:s} indirect-branch                     # execute until indirect branch instruction (x86/x64 only)\n".format(_cmdline_)
    _example_ += "{:s} memaccess                           # execute until '[' is included by the instruction\n".format(_cmdline_)
    _example_ += '{:s} keyword "call +r[ab]x"              # execute until specified keyword (regex)\n'.format(_cmdline_)
    _example_ += '{:s} cond "$rax==0xdead && $rbx==0xcafe" # execute until specified condition is filled'.format(_cmdline_)

    def __init__(self, *args, **kwargs):
        prefix = kwargs.get("prefix", True)
        super().__init__(prefix=prefix)
        self.mode = None
        return

    def close_stdout_stderr(self):
        self.stdout = 1
        self.stdout_bak = os.dup(self.stdout)
        f = open("/dev/null")
        os.dup2(f.fileno(), self.stdout)
        f.close()

        self.stderr = 2
        self.stderr_bak = os.dup(self.stderr)
        f = open("/dev/null")
        os.dup2(f.fileno(), self.stderr)
        f.close()
        return

    def revert_stdout_stderr(self):
        os.dup2(self.stdout_bak, self.stdout)
        os.close(self.stdout_bak)
        os.dup2(self.stderr_bak, self.stderr)
        os.close(self.stderr_bak)
        return

    def force_write_stdout(self, msg):
        open("/proc/self/fd/0", "wb").write(msg)
        return

    def is_target_insn(self, insn):
        if self.mode == "call":
            return current_arch.is_call(insn)
        elif self.mode == "jmp":
            return current_arch.is_jump(insn)
        elif self.mode == "indirect-branch":
            if current_arch.is_call(insn) or current_arch.is_jump(insn):
                if "[" in str(insn):
                    return True
                for reg in current_arch.gpr_registers:
                    if reg.replace("$", "") in str(insn):
                        return True
            return False
        elif self.mode == "syscall":
            return current_arch.is_syscall(insn)
        elif self.mode == "ret":
            return current_arch.is_ret(insn)
        if self.mode == "all-branch":
            return current_arch.is_call(insn) or current_arch.is_jump(insn) or current_arch.is_ret(insn)
        elif self.mode == "memaccess":
            return "[" in str(insn)
        elif self.mode == "keyword":
            for k in self.keyword:
                if re.search(k, str(insn)):
                    return True
            return False
        elif self.mode == "cond":
            try:
                v = gdb.parse_and_eval(self.condition)
            except gdb.error:
                return False
            if v not in [0x0, 0x1]:
                self.err = "condition result should be True or False"
                return True
            if v:
                return True
        return False

    def get_breakpoint_list(self):
        lines = gdb.execute("info breakpoints", to_string=True).splitlines()
        if lines[0] == 'No breakpoints or watchpoints.':
            return []

        enable_idx = lines[0].index("Enb")
        addr_idx = lines[0].index("Address")

        bp_list = []
        for line in lines[1:]:
            try:
                if line[0] == "\t":
                    continue
                enable = line[enable_idx]
                addr = int(line[addr_idx:].split()[0], 16)
                if enable == 'y':
                    bp_list.append(addr)
            except Exception:
                pass
        # breakpoint with condition is unsupported
        return bp_list

    def exec_next(self):
        bp_list = self.get_breakpoint_list()
        gef_on_stop_unhook(hook_stop_handler)
        self.close_stdout_stderr()
        self.err = None

        prev_addr = -1
        try:
            count = 0
            while True:
                # progress
                if not self.print_insn and count % 100 == 0:
                    self.force_write_stdout([b"\r|", b"\r/", b"\r-", b"\r\\"][count // 100 % 4])

                # backup
                prev_prev_addr = prev_addr
                prev_addr = current_arch.pc

                # execute 1 instruction
                insn = gef_current_instruction(current_arch.pc)
                if self.skip_lib and "@plt>" in str(insn):
                    gdb.execute("ni") # use ni wrapper
                else:
                    gdb.execute("si") # use si wrapper

                # check breakpoint
                insn = gef_current_instruction(current_arch.pc)
                if current_arch.pc in bp_list:
                    break

                # $pc is not changed
                if prev_prev_addr == prev_addr == current_arch.pc: # for faster, repeat insn is skip
                    # infinity self loop
                    if current_arch.is_call(insn) or current_arch.is_jump(insn) or current_arch.is_ret(insn):
                        self.err = "Detected infinity loop prev_addr"
                        break
                    # maybe rep prefix
                    gdb.execute("exec-next")
                    # recheck
                    if prev_prev_addr == prev_addr == current_arch.pc:
                        self.err = "Detected infinity loop prev_addr"
                        break
                    insn = gef_current_instruction(current_arch.pc)

                if self.print_insn:
                    self.force_write_stdout((str(insn) + "\n").encode())

                # found and break
                if self.is_target_insn(insn):
                    if not self.print_insn:
                        self.force_write_stdout(b"\r \r")
                    break

                count += 1

        except KeyboardInterrupt:
            pass

        except Exception:
            if is_alive():
                exc_type, exc_value, exc_traceback = sys.exc_info()
                self.err = exc_value
            else:
                pass

        finally:
            self.revert_stdout_stderr() # anytime needed
            gef_on_stop_hook(hook_stop_handler) # anytime needed
            if self.err:
                err(self.err)
            else:
                gdb.execute("context")
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        if self.mode is None:
            self.usage()
            return
        self.print_insn = args.print_insn
        self.skip_lib = args.skip_lib
        self.exec_next()
        return


@register_command
class ExecUntilCallCommand(ExecUntilCommand):
    """Execute until next call instruction."""
    _cmdline_ = "exec-until call"
    _category_ = "Debugging Support"
    _aliases_ = ["next-call"]
    _repeat_ = True

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--print-insn', action='store_true', help='print each instruction during execution.')
    parser.add_argument('--skip-lib', action='store_true', help='uses `nexti` instead of `stepi` if instruction is `call xxx@plt`.')
    _syntax_ = parser.format_help()
    _example_ = None

    def __init__(self):
        gdb.execute("ni")
        super().__init__(prefix=False)
        self.mode = "call"
        return


@register_command
class ExecUntilJumpCommand(ExecUntilCommand):
    """Execute until next jmp instruction."""
    _cmdline_ = "exec-until jmp"
    _category_ = "Debugging Support"
    _aliases_ = ["next-jmp"]
    _repeat_ = True

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--print-insn', action='store_true', help='print each instruction during execution.')
    parser.add_argument('--skip-lib', action='store_true', help='uses `nexti` instead of `stepi` if instruction is `call xxx@plt`.')
    _syntax_ = parser.format_help()
    _example_ = None

    def __init__(self):
        super().__init__(prefix=False)
        self.mode = "jmp"
        return


@register_command
class ExecUntilIndirectBranchCommand(ExecUntilCommand):
    """Execute until next indirect call/jmp instruction (x86/x64 only)."""
    _cmdline_ = "exec-until indirect-branch"
    _category_ = "Debugging Support"
    _aliases_ = ["next-indirect-branch"]
    _repeat_ = True

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--print-insn', action='store_true', help='print each instruction during execution.')
    parser.add_argument('--skip-lib', action='store_true', help='uses `nexti` instead of `stepi` if instruction is `call xxx@plt`.')
    _syntax_ = parser.format_help()
    _example_ = None

    def __init__(self):
        super().__init__(prefix=False)
        self.mode = "indirect-branch"
        return

    @parse_args
    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, args):
        self.print_insn = args.print_insn
        self.skip_lib = args.skip_lib
        self.exec_next()
        return


@register_command
class ExecUntilAllBranchCommand(ExecUntilCommand):
    """Execute until next call/jump/ret instruction."""
    _cmdline_ = "exec-until all-branch"
    _category_ = "Debugging Support"
    _aliases_ = ["next-all-branch"]
    _repeat_ = True

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--print-insn', action='store_true', help='print each instruction during execution.')
    parser.add_argument('--skip-lib', action='store_true', help='uses `nexti` instead of `stepi` if instruction is `call xxx@plt`.')
    _syntax_ = parser.format_help()
    _example_ = None

    def __init__(self):
        super().__init__(prefix=False)
        self.mode = "all-branch"
        return


@register_command
class ExecUntilSyscallCommand(ExecUntilCommand):
    """Execute until next syscall instruction."""
    _cmdline_ = "exec-until syscall"
    _category_ = "Debugging Support"
    _aliases_ = ["next-syscall"]
    _repeat_ = True

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--print-insn', action='store_true', help='print each instruction during execution.')
    parser.add_argument('--skip-lib', action='store_true', help='uses `nexti` instead of `stepi` if instruction is `call xxx@plt`.')
    _syntax_ = parser.format_help()
    _example_ = None

    def __init__(self):
        super().__init__(prefix=False)
        self.mode = "syscall"
        return


@register_command
class ExecUntilRetCommand(ExecUntilCommand):
    """Execute until next ret instruction."""
    _cmdline_ = "exec-until ret"
    _category_ = "Debugging Support"
    _aliases_ = ["next-ret"]
    _repeat_ = True

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--print-insn', action='store_true', help='print each instruction during execution.')
    parser.add_argument('--skip-lib', action='store_true', help='uses `nexti` instead of `stepi` if instruction is `call xxx@plt`.')
    _syntax_ = parser.format_help()
    _example_ = None

    def __init__(self):
        super().__init__(prefix=False)
        self.mode = "ret"
        return


@register_command
class ExecUntilMemaccessCommand(ExecUntilCommand):
    """Execute until next mem-access instruction."""
    _cmdline_ = "exec-until memaccess"
    _category_ = "Debugging Support"
    _aliases_ = ["next-mem"]
    _repeat_ = True

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--print-insn', action='store_true', help='print each instruction during execution.')
    parser.add_argument('--skip-lib', action='store_true', help='uses `nexti` instead of `stepi` if instruction is `call xxx@plt`.')
    _syntax_ = parser.format_help()
    _example_ = None

    def __init__(self):
        super().__init__(prefix=False)
        self.mode = "memaccess"
        return


@register_command
class ExecUntilKeywordReCommand(ExecUntilCommand):
    """Execute until specified keyword instruction."""
    _cmdline_ = "exec-until keyword"
    _category_ = "Debugging Support"
    _aliases_ = ["next-keyword"]
    _repeat_ = True

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--print-insn', action='store_true', help='print each instruction during execution.')
    parser.add_argument('--skip-lib', action='store_true', help='uses `nexti` instead of `stepi` if instruction is `call xxx@plt`.')
    parser.add_argument('keyword', metavar='KEYWORD', nargs='+', help='filter by specified regex keyword.')
    _syntax_ = parser.format_help()

    _example_ = '{:s} "call +r[ab]x"                                      # execute until specified keyword\n'.format(_cmdline_)
    _example_ += '{:s} "(push|pop) +(r[a-d]x|r[ds]i|r[sb]p|r[89]|r1[0-5])" # another exsample\n'.format(_cmdline_)
    _example_ += '{:s} "mov +rax, QWORD PTR \\\\["                           # another exsample (need double escape if use)'.format(_cmdline_)

    def __init__(self):
        super().__init__(prefix=False)
        self.mode = "keyword"
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.print_insn = args.print_insn
        self.skip_lib = args.skip_lib
        self.keyword = args.keyword
        self.exec_next()
        return


@register_command
class ExecUntilCondCommand(ExecUntilCommand):
    """Execute until specified condition is filled."""
    _cmdline_ = "exec-until cond"
    _category_ = "Debugging Support"
    _aliases_ = ["next-cond"]
    _repeat_ = True

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('--print-insn', action='store_true', help='print each instruction during execution.')
    parser.add_argument('--skip-lib', action='store_true', help='uses `nexti` instead of `stepi` if instruction is `call xxx@plt`.')
    parser.add_argument('condition', metavar='CONDITION', help='filter by codition.')
    _syntax_ = parser.format_help()

    _example_ = '{:s} "$rax==0xdead && $rbx==0xcafe"     # execute until specified condition is filled\n'.format(_cmdline_)
    _example_ += '{:s} "$rax==0x123 && *(long*)$rbx==0x4" # multiple condition and memory access is supported\n'.format(_cmdline_)
    _example_ += '{:s} "$ALL_REG==0x1234"                 # compare with all registers. ex: `($rax==0x1234 || $rbx==0x1234 || ...)`\n'.format(_cmdline_)

    def __init__(self):
        super().__init__(prefix=False)
        self.mode = "cond"
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.print_insn = args.print_insn
        self.skip_lib = args.skip_lib

        condition = args.condition
        if re.search(r"[^><!=]=[^=]", condition):
            err("Should not use `=` since it will be replace register/memory value. Use `==`.")
            return

        match = re.search(r"\$ALL_REG==(\w+)", condition)
        if match:
            value = match.groups()[0]
            replace_cond = []
            if hasattr(current_arch, "gpr_registers"):
                regs = current_arch.gpr_registers
            else:
                regs = current_arch.all_registers
                if hasattr(current_arch, "flag_register"):
                    if current_arch.flag_register in regs:
                        regs.remove(current_arch.flag_register)
            for regname in regs:
                replace_cond.append("{:s}=={:s}".format(regname, value))
            replace_string = "(" + "||".join(replace_cond) + ")"
            condition = re.sub(r"\$ALL_REG==(\w+)", replace_string, condition)

        info("Condition: {:s}".format(condition))
        self.condition = condition
        self.exec_next()
        return


class CallUsermodehelperSetupBreakpoint(gdb.Breakpoint):
    """Create a breakpoint to print argv information at call_usermodehelper_setup."""
    def __init__(self, loc):
        super().__init__("*{:#x}".format(loc), gdb.BP_BREAKPOINT, internal=False)
        return

    def stop(self):
        ptr1, addr1 = current_arch.get_ith_parameter(0)
        ptr2, addr2 = current_arch.get_ith_parameter(1)
        path = read_cstring_from_memory(addr1)
        argv = []
        while True:
            string_addr = read_int_from_memory(addr2)
            if string_addr == 0:
                break
            string = read_cstring_from_memory(string_addr)
            argv.append("'{:s}'".format(string))
            addr2 += current_arch.ptrsize
        gef_print("{:s}: {:#x} -> '{:s}'".format(ptr1, addr1, path))
        gef_print("{:s}: {:#x} -> [{:s}]".format(ptr2, addr2, ','.join(argv)))
        return False # continue


@register_command
class UsermodehelperHunterCommand(GenericCommand):
    """Collects and displays information that is executed by call_usermodehelper_setup."""
    _cmdline_ = "usermodehelper-hunter"
    _category_ = "08-b. Qemu-system Cooperation - Linux"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        info("Resolving the function addresses")
        addr = get_ksymaddr("call_usermodehelper_setup")
        if addr is None:
            err("Not found call_usermodehelper_setup")
            return
        CallUsermodehelperSetupBreakpoint(addr)
        info("Do `continue`. If failed, try `vmlinux-to-elf-apply`")
        return


class ThunkBreakpoint(gdb.Breakpoint):
    """Create a breakpoint to print caller address for thunk function."""
    def __init__(self, loc, sym, reg, maps):
        super().__init__("*{:#x}".format(loc), gdb.BP_BREAKPOINT, internal=False)
        self.loc = loc
        self.sym = sym
        self.reg = reg
        self.maps = maps
        self.seen = []
        return

    def search_perm(self, target):
        for m in self.maps:
            addr, size, perm = m
            if addr <= target < addr + size:
                return perm.lower()
        return "?"

    def stop(self):
        try:
            return_address = gdb.selected_frame().older().pc()
            caller_address = gdb_get_nth_previous_instruction_address(return_address, 1)
            target_address = get_register(self.reg)
        except Exception:
            return False # continue

        # duplicate, check
        if (caller_address, target_address) in self.seen:
            return False # continue
        else:
            self.seen.append((caller_address, target_address))

        # get caller address, symbol
        caller_symbol = get_symbol_string(caller_address, nosymbol_string=" <NO_SYMBOL>")

        # get callee address, symbol
        target_symbol = get_symbol_string(target_address, nosymbol_string=" <NO_SYMBOL>")

        # print information
        if caller_address is None:
            fmt = "{:s}{:s} -> {:#x} <{:s}> -> {:#x}{:s}"
            msg = fmt.format("???(unknown)", caller_symbol, self.loc, self.sym, target_address, target_symbol)
        else:
            fmt = "{:#x}{:s} -> {:#x} <{:s}> -> {:#x}{:s}"
            msg = fmt.format(caller_address, caller_symbol, self.loc, self.sym, target_address, target_symbol)
        info(msg)

        # print preferred register condition
        pattern = [0] + [(x + 1) * y for x, y in itertools.product(range(0x100), [1, -1])] # [0, 1, -1, 2, -2, ...]
        for reg in current_arch.gpr_registers:
            reg_value = get_register(reg)
            for i in pattern:
                slide = current_arch.ptrsize * i
                reg_value_slided = reg_value + slide
                try:
                    mem_value = read_int_from_memory(reg_value_slided)
                except Exception:
                    continue
                if mem_value == target_address:
                    perm = self.search_perm(reg_value_slided)
                    reg_value_slided_symbol = get_symbol_string(reg_value_slided, nosymbol_string=" <NO_SYMBOL>")
                    mem_value_symbol = get_symbol_string(mem_value, nosymbol_string=" <NO_SYMBOL>")
                    fmt = "    {:s}{:+#x}: {:#x}{:s} [{:s}]  ->  {:#x}{:s}"
                    info(fmt.format(reg, slide, reg_value_slided, reg_value_slided_symbol, perm, mem_value, mem_value_symbol))
                    break
        return False # continue


@register_command
class ThunkHunterCommand(GenericCommand):
    """Collects and displays the thunk addresses that are called automatically. (x64/x86 only)"""
    _cmdline_ = "thunk-hunter"
    _category_ = "08-b. Qemu-system Cooperation - Linux"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, args):
        self.dont_repeat()

        info("Wait for memory scan")
        maps = KernelbaseCommand.get_maps() # [vaddr, size, perm]
        info("Resolving thunk function addresses")
        for reg in current_arch.gpr_registers:
            if reg in ["$esp", "$rsp", "$eip", "$rip"]:
                continue
            sym = "__x86_indirect_thunk_{}".format(reg.replace("$", ""))
            addr = get_ksymaddr(sym)
            if addr is None:
                continue
            gef_print(sym + ": ", end="")
            ThunkBreakpoint(addr, sym, reg, maps)
        info("Do `continue`. If NO_SYMBOL is in the result, try `vmlinux-to-elf-apply`")
        return


@register_command
class UefiOvmfInfoCommand(GenericCommand):
    """Print UEFI OVMF info."""
    # https://github.com/tianocore/tianocore.github.io/wiki/OVMF-Boot-Overview
    # https://github.com/tianocore/edk2/blob/master/OvmfPkg/Sec/SecMain.c
    # https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Core/Pei/PeiMain/PeiMain.c
    # https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Core/Dxe/DxeMain/DxeMain.c
    # https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Universal/BdsDxe/BdsEntry.c
    # https://uefi.org/sites/default/files/resources/UEFI_Spec_2_8_final.pdf
    _cmdline_ = "uefi-ovmf-info"
    _category_ = "08-d. Qemu-system Cooperation - Bootloader"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    def check_crc32(self, addr):
        try:
            crccheck = __import__("crccheck")
        except ImportError:
            msg = "Missing `crccheck` package for Python, install with: `pip install crccheck`."
            raise ImportWarning(msg)

        size = u32(read_memory(addr + 0xc, 0x4))
        if size <= 0 or size > 0x1000:
            return False
        crc = u64(read_memory(addr + 0x10, 0x8))
        if crc == 0:
            return False
        data = read_memory(addr, 0x10)
        data += p64(0x0) # crc is zero when calculate
        data += read_memory(addr + 0x18, size - 0x18)
        calculated_crc = crccheck.crc.Crc32().calc(data)
        return calculated_crc == crc

    def read_structure(self, addr, structure):
        d = {}
        d["__addr"] = addr
        for size, name in structure:
            unpack = u32 if size == 4 else u64
            d[name] = unpack(read_memory(addr, size))
            addr += size
        return d

    def get_gPs(self):
        result = gdb.execute("search-pattern 'PEI SERV' --disable-utf16", to_string=True) # EFI_TABLE_HEADER.Signature
        result = filter(lambda x: "->" in x, result.splitlines())
        result = [int(x.split()[0], 16) for x in result]
        for addr in result[::-1]: # Higher address seems more likely
            return addr
        return None

    def read_gPs(self):
        addr = self.get_gPs()
        if addr is None:
            return None
        structure = [
            [8, "Hdr.Signature"],
            [4, "Hdr.Revision"],
            [4, "Hdr.HeaderSize"],
            [4, "Hdr.CRC32"],
            [4, "Hdr.Reserved"],
            [8, "InstallPpi"],
            [8, "ReInstallPpi"],
            [8, "LocatePpi"],
            [8, "NotifyPpi"],
            [8, "GetBootMode"],
            [8, "SetBootMode"],
            [8, "GetHobList"],
            [8, "CreateHob"],
            [8, "FfsFindNextVolume"],
            [8, "FfsFindNextFile"],
            [8, "FfsFindSectionData"],
            [8, "InstallPeiMemory"],
            [8, "AllocatePages"],
            [8, "AllocatePool"],
            [8, "CopyMem"],
            [8, "SetMem"],
            [8, "ReportStatusCode"],
            [8, "ResetSystem"],
            [8, "CpuIo"],
            [8, "PciCfg"],
            [8, "FfsFindFileByName"],
            [8, "FfsGetFileInfo"],
            [8, "FfsGetVolumeInfo"],
            [8, "RegisterForShadow"],
            [8, "FindSectionData3"],
            [8, "FfsGetFileInfo2"],
            [8, "ResetSystem2"],
            [8, "FreePages"],
        ]
        return self.read_structure(addr, structure)

    def dump_gPs(self):
        self.gPs = self.read_gPs()
        if self.gPs is None:
            err("gPs is not found")
            return
        info("gPs: {:#x}".format(self.gPs["__addr"]))
        for k, v in self.gPs.items():
            if k.startswith("__"):
                continue
            gef_print("  {:40s}{:#x}".format(k + ":", v))
        return

    def get_mBootServices(self):
        result = gdb.execute("search-pattern BOOTSERV --disable-utf16", to_string=True) # EFI_TABLE_HEADER.Signature
        result = filter(lambda x: "->" in x, result.splitlines())
        result = [int(x.split()[0], 16) for x in result]
        for addr in result[::-1]: # Higher address seems more likely
            if self.check_crc32(addr):
                return addr
        return None

    def read_mBootServices(self):
        addr = self.get_mBootServices()
        if addr is None:
            return None
        structure = [
            [8, "Hdr.Signature"],
            [4, "Hdr.Revision"],
            [4, "Hdr.HeaderSize"],
            [4, "Hdr.CRC32"],
            [4, "Hdr.Reserved"],
            [8, "RaiseTPL"],
            [8, "RestoreTPL"],
            [8, "AllocatePages"],
            [8, "FreePages"],
            [8, "GetMemoryMap"],
            [8, "AllocatePool"],
            [8, "FreePool"],
            [8, "CreateEvent"],
            [8, "SetTimer"],
            [8, "WaitForEvent"],
            [8, "SignalEvent"],
            [8, "CloseEvent"],
            [8, "CheckEvent"],
            [8, "InstallProtocolInterface"],
            [8, "ReinstallProtocolInterface"],
            [8, "UninstallProtocolInterface"],
            [8, "HandleProtocol"],
            [8, "Reserved"],
            [8, "RegisterProtocolNotify"],
            [8, "LocateHandle"],
            [8, "LocateDevicePath"],
            [8, "InstallConfigurationTable"],
            [8, "LoadImage"],
            [8, "StartImage"],
            [8, "Exit"],
            [8, "UnloadImage"],
            [8, "ExitBootServices"],
            [8, "GetNextMonotonicCount"],
            [8, "Stall"],
            [8, "SetWatchdogTimer"],
            [8, "ConnectController"],
            [8, "DisconnectController"],
            [8, "OpenProtocol"],
            [8, "CloseProtocol"],
            [8, "OpenProtocolInformation"],
            [8, "ProtocolsPerHandle"],
            [8, "LocateHandleBuffer"],
            [8, "LocateProtocol"],
            [8, "InstallMultipleProtocolInterfaces"],
            [8, "UninstallMultipleProtocolInterfaces"],
            [8, "CalculateCrc32"],
            [8, "CopyMem"],
            [8, "SetMem"],
            [8, "CreateEventEx"],
        ]
        return self.read_structure(addr, structure)

    def dump_mBootServices(self):
        self.mBootServices = self.read_mBootServices()
        if self.mBootServices is None:
            err("mBootServices is not found")
            return
        info("mBootServices: {:#x}".format(self.mBootServices["__addr"]))
        for k, v in self.mBootServices.items():
            if k.startswith("__"):
                continue
            gef_print("  {:40s}{:#x}".format(k + ":", v))
        return

    def get_mDxeServices(self):
        # fastpath maybe mDxeServices is next to mBootServices
        if self.mBootServices:
            addr = self.mBootServices["__addr"] + self.mBootServices["Hdr.HeaderSize"]
            while addr % 0x10:
                addr += 1
            if read_memory(addr, 8) == b"DXE_SERV" and self.check_crc32(addr):
                return addr

        # slowpath
        result = gdb.execute("search-pattern DXE_SERV --disable-utf16", to_string=True) # EFI_TABLE_HEADER.Signature
        result = filter(lambda x: "->" in x, result.splitlines())
        result = [int(x.split()[0], 16) for x in result]
        for addr in result[::-1]: # Higher address seems more likely
            if self.check_crc32(addr):
                return addr
        return None

    def read_mDxeServices(self):
        addr = self.get_mDxeServices()
        if addr is None:
            return None
        structure = [
            [8, "Hdr.Signature"],
            [4, "Hdr.Revision"],
            [4, "Hdr.HeaderSize"],
            [4, "Hdr.CRC32"],
            [4, "Hdr.Reserved"],
            [8, "AddMemorySpace"],
            [8, "AllocateMemorySpace"],
            [8, "FreeMemorySpace"],
            [8, "RemoveMemorySpace"],
            [8, "GetMemorySpaceDescriptor"],
            [8, "SetMemorySpaceAttributes"],
            [8, "GetMemorySpaceMap"],
            [8, "AddIoSpace"],
            [8, "AllocateIoSpace"],
            [8, "FreeIoSpace"],
            [8, "RemoveIoSpace"],
            [8, "GetIoSpaceDescriptor"],
            [8, "GetIoSpaceMap"],
            [8, "Dispatch"],
            [8, "Schedule"],
            [8, "Trust"],
            [8, "ProcessFirmwareVolume"],
            [8, "SetMemorySpaceCapabilities"],
        ]
        return self.read_structure(addr, structure)

    def dump_mDxeServices(self):
        self.mDxeServices = self.read_mDxeServices()
        if self.mDxeServices is None:
            err("mDxeServices is not found")
            return
        info("mDxeServices: {:#x}".format(self.mDxeServices["__addr"]))
        for k, v in self.mDxeServices.items():
            if k.startswith("__"):
                continue
            gef_print("  {:40s}{:#x}".format(k + ":", v))
        return

    def get_mEfiSystemTable(self):
        result = gdb.execute("search-pattern 'IBI SYST' --disable-utf16", to_string=True) # EFI_TABLE_HEADER.Signature
        result = filter(lambda x: "->" in x, result.splitlines())
        result = [int(x.split()[0], 16) for x in result]
        for addr in result[::-1]: # Higher address seems more likely
            if self.check_crc32(addr):
                return addr
        return None

    def read_mEfiSystemTable(self):
        addr = self.get_mEfiSystemTable()
        if addr is None:
            return None
        structure = [
            [8, "Hdr.Signature"],
            [4, "Hdr.Revision"],
            [4, "Hdr.HeaderSize"],
            [4, "Hdr.CRC32"],
            [4, "Hdr.Reserved"],
            [8, "FirmwareVendor"],
            [8, "FirmwareRevision"],
            [8, "ConsoleInHandle"],
            [8, "ConIn"],
            [8, "ConsoleOutHandle"],
            [8, "ConOut"],
            [8, "StandardErrorHandle"],
            [8, "StdErr"],
            [8, "RuntimeServices"],
            [8, "BootServices"],
            [8, "NumberOfConfigurationTableEntries"],
            [8, "ConfigurationTable"],
        ]
        return self.read_structure(addr, structure)

    def dump_mEfiSystemTable(self):
        self.mEfiSystemTable = self.read_mEfiSystemTable()
        if self.mEfiSystemTable is None:
            err("*gDxeCoreST(=mEfiSystemTable) is not found")
            return
        info("*gDxeCoreST(=mEfiSystemTable): {:#x}".format(self.mEfiSystemTable["__addr"]))
        for k, v in self.mEfiSystemTable.items():
            if k.startswith("__"):
                continue
            gef_print("  {:40s}{:#x}".format(k + ":", v))
        return

    def get_mEfiRuntimeServicesTable(self):
        result = gdb.execute("search-pattern RUNTSERV --disable-utf16", to_string=True) # EFI_TABLE_HEADER.Signature
        result = filter(lambda x: "->" in x, result.splitlines())
        result = [int(x.split()[0], 16) for x in result]
        for addr in result[::-1]: # Higher address seems more likely
            if self.check_crc32(addr):
                return addr
        return None

    def read_mEfiRuntimeServicesTable(self):
        addr = self.get_mEfiRuntimeServicesTable()
        if addr is None:
            return None
        structure = [
            [8, "Hdr.Signature"],
            [4, "Hdr.Revision"],
            [4, "Hdr.HeaderSize"],
            [4, "Hdr.CRC32"],
            [4, "Hdr.Reserved"],
            [8, "GetTime"],
            [8, "SetTime"],
            [8, "GetWakeupTime"],
            [8, "SetWakeupTime"],
            [8, "SetVirtualAddressMap"],
            [8, "ConvertPointer"],
            [8, "GetVariable"],
            [8, "GetNextVariableName"],
            [8, "SetVariable"],
            [8, "GetNextHighMonotonicCount"],
            [8, "ResetSystem"],
            [8, "UpdateCapsule"],
            [8, "QueryCapsuleCapabilities"],
            [8, "QueryVariableInfo"],
        ]
        return self.read_structure(addr, structure)

    def dump_mEfiRuntimeServicesTable(self):
        self.mEfiRuntimeServicesTable = self.read_mEfiRuntimeServicesTable()
        if self.mEfiRuntimeServicesTable is None:
            err("*gDxeCoreRT(=mEfiRuntimeServicesTable) is not found")
            return
        info("*gDxeCoreRT(=mEfiRuntimeServicesTable): {:#x}".format(self.mEfiRuntimeServicesTable["__addr"]))
        for k, v in self.mEfiRuntimeServicesTable.items():
            if k.startswith("__"):
                continue
            gef_print("  {:40s}{:#x}".format(k + ":", v))
        return

    def get_gMemoryMap(self):
        # gMemoryMap is just above mDxeServices
        if not self.mDxeServices:
            return None
        addr = self.mDxeServices["__addr"]
        while addr % 0x10:
            addr -= 1
        while self.mDxeServices["__addr"] - 0x1000 < addr:
            try:
                a = u64(read_memory(addr, 8))
                b = u64(read_memory(a + 8, 8))
                asig = u64(read_memory(a - 8, 8))
                c = u64(read_memory(addr + 8, 8))
                d = u64(read_memory(c, 8))
                csig = u64(read_memory(c - 8, 8))
                if addr == b == d and asig == csig == u32(b"mmap"):
                    return addr
            except Exception:
                pass
            addr -= 0x10
        return None

    def read_gMemoryMap(self):
        addr = self.get_gMemoryMap()
        if addr is None:
            return None
        structure = [
            [8, "ForwardLink"],
            [8, "BackLink"],
        ]
        return self.read_structure(addr, structure)

    def read_Entry(self, addr):
        structure = [
            [8, "Signature"],
            [8, "Link.ForwardLink"],
            [8, "Link.BackLink"],
            [4, "FromPages"], # with pad
            [4, "Type"],
            [8, "Start"],
            [8, "End"],
            [8, "VirtualStart"],
            [8, "Attribute"],
        ]
        offset_of_link = 8
        return self.read_structure(addr - offset_of_link, structure)

    def dump_memory_map(self):
        self.gMemoryMap = self.read_gMemoryMap()
        if self.gMemoryMap is None:
            err("gMemoryMap is not found")
            return
        info("gMemoryMap: {:#x}".format(self.gMemoryMap["__addr"]))

        type_names = [
            "EfiReservedMemoryType",
            "EfiLoaderCode",
            "EfiLoaderData",
            "EfiBootServicesCode",
            "EfiBootServicesData",
            "EfiRuntimeServicesCode",
            "EfiRuntimeServicesData",
            "EfiConventionalMemory",
            "EfiUnusableMemory",
            "EfiACPIReclaimMemory",
            "EfiACPIMemoryNVS",
            "EfiMemoryMappedIO",
            "EfiMemoryMappedIOPortSpace",
            "EfiPalCode",
            "EfiPersistentMemory",
            "EfiMaxMemoryType",
        ]

        att_list = {
            0x1: "UC",
            0x2: "WC",
            0x4: "WT",
            0x8: "WB",
            0x10: "UCE",
            0x1000: "WP",
            0x2000: "RP",
            0x4000: "XP",
            0x8000: "NV",
            0x10000: "MORE_RELIABLE",
            0x20000: "RO",
            0x40000: "SPM",
            0x80000: "CPU_CRYPTO",
            0x8000000000000000: "RUNTIME"
        }

        def att2str(att):
            string = []
            for k, v in att_list.items():
                if k & att:
                    string.append(v)
            return ",".join(string)

        fmt = "{:21s} {:10s} {:10s} {:30s} {:s}"
        legend = ["Paddr Start-End", "Vaddr", "Size", "Type:TypeName", "Attribute"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))

        current = self.gMemoryMap["ForwardLink"]
        while current != self.gMemoryMap["__addr"]:
            entry = self.read_Entry(current)

            paddr_s = entry["Start"]
            paddr_e = entry["End"] + 1
            vaddr = entry["VirtualStart"]
            size = paddr_e - paddr_s
            typ = entry["Type"]
            memtype = type_names[entry["Type"]]
            att = entry["Attribute"]
            att_s = att2str(att)
            fmt = "{:#010x}-{:#010x} {:#010x} {:#010x} {:#x}:{:26s} {:#x}:[{:s}]"
            gef_print(fmt.format(paddr_s, paddr_e, vaddr, size, typ, memtype, att, att_s))

            if entry["Signature"] != u32(b"mmap"):
                gef_print("Signature does not match. Corrupted?")
                break
            current = entry["Link.ForwardLink"]

        gef_print("Legend for attribute")
        gef_print("UC: It supports being configured as Un-Cacheable")
        gef_print("WC: It supports being configured as Write-Combining")
        gef_print("WT: It supports being configured as Write-Through")
        gef_print("WB: It supports being configured as Write-Back")
        gef_print("UCE: It supports being configured as Un-Cacheable and Exportable")
        gef_print("WP: It supports being configured as Write-Protected")
        gef_print("RP: It supports being configured as Read-Protected")
        gef_print("XP: It supports being configured as eXecute-Protected")
        gef_print("NV: It refers to persistent memory(Non-Volatile-Memory)")
        gef_print("MORE_RELIABLE: it has higher reliability than other")
        gef_print("RO: It supports being configured as Read-Only")
        gef_print("SP: Specific-Purpose memory")
        gef_print("CPU_CRYPTO: Encrypted and protected by CPU function")
        gef_print("RUNTIME: It will be mapped by OS when SetVirtualAddressMap() is called")
        return

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, args):
        self.dont_repeat()
        info("This command is very slow. Wait a few tens of seconds")
        gef_print(titlify("SEC (Security) phase variables"))
        gef_print("Unimplemented")
        gef_print(titlify("PEI (Pre EFI Initialization) phase variables"))
        self.dump_gPs()
        gef_print(titlify("DXE (Driver Exectuion Environment) phase variables"))
        self.dump_mBootServices()
        self.dump_mDxeServices()
        self.dump_mEfiSystemTable()
        self.dump_mEfiRuntimeServicesTable()
        gef_print(titlify("Memory map for UEFI"))
        self.dump_memory_map()
        gef_print(titlify("BDS (Boot Device Selection) phase variables"))
        gef_print("gBS: See `mBootServices` in the DXE phase")
        gef_print("gST: See `mEfiSystemTable` in the DXE phase")
        gef_print("gRT: See `mEfiRuntimeServicesTable` in the DXE phase")
        return


@register_command
class AddSymbolTemporaryCommand(GenericCommand):
    """Add symbol from command temporarily."""
    _cmdline_ = "add-symbol-temporary"
    _category_ = "01-g. Debugging Support - Other"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('function_name', metavar='FUNCTION_NAME', help='new symbol you want to add.')
    parser.add_argument('function_addr', metavar='ADDRESS', type=parse_address, help="new symbol's address you want to add.")
    _syntax_ = parser.format_help()

    @staticmethod
    def add_symbol_temp(function_info):
        try:
            gcc = which("gcc")
            objcopy = which("objcopy")
        except FileNotFoundError as e:
            err("{}".format(e))
            return

        cache = {}

        def create_blank_elf(text_base):
            if cache:
                open(cache["fname"], "wb").write(cache["data"])
                return cache["fname"]
            # create light ELF
            fd, fname = tempfile.mkstemp(dir=GEF_TEMP_DIR, suffix=".c")
            os.fdopen(fd, "w").write("int main() {}")
            os.system(f"{gcc} '{fname}' -no-pie -o '{fname}.debug'")
            os.unlink(f"{fname}")
            # delete unneeded section for faster
            os.system(f"{objcopy} --only-keep-debug '{fname}.debug'")
            os.system(f"{objcopy} --strip-all '{fname}.debug'")
            elf = get_elf_headers(f"{fname}.debug")
            for s in elf.shdrs:
                section_name = s.sh_name
                if section_name == "": # null, skip
                    continue
                if section_name == ".text": # .text is needed, don't remove
                    continue
                if section_name == ".interp": # broken if removed
                    continue
                if section_name == ".rela.dyn": # cannot removed
                    continue
                if section_name == ".dynamic": # cannot removed
                    continue
                if section_name == ".bss": # broken if removed
                    continue
                os.system(f"{objcopy} --remove-section='{section_name}' '{fname}.debug' 2>/dev/null")
            cache["fname"] = fname + ".debug"
            cache["data"] = open(cache["fname"], "rb").read()
            return cache["fname"]

        def apply_symbol(fname, cmd_string_arr, text_base):
            cmd_string = ' '.join(cmd_string_arr)
            os.system(f"{objcopy} {cmd_string} '{fname}'")
            gdb.execute(f"add-symbol-file {fname} {text_base:#x}", to_string=True)
            os.unlink(fname)
            return

        info("{:d} entries will be added".format(len(function_info)))

        if is_64bit():
            text_base = 0xffff000000000000
        else:
            text_base = 0x80000000

        cmd_string_arr = []
        fname = create_blank_elf(text_base)
        for i, (fn, fa, typ) in enumerate(function_info):
            # debug print
            if i > 1 and i % 10000 == 0:
                info("{:d} entries were processed".format(i))

            if typ in ["T", "t", "W", None]:
                type_flag = "function"
            else:
                type_flag = "object"
            if typ and typ in "abcdefghijklmnopqrstuvwxyz":
                global_flag = "local"
            else:
                global_flag = "global"

            if fa < text_base:
                # lower address needs not relative, use absolute
                cmd_string_arr.append(f"--add-symbol '{fn}'={fa:#x},{global_flag},{type_flag}")
            else:
                # higher address needs relative
                relative_addr = fa - text_base
                cmd_string_arr.append(f"--add-symbol '{fn}'=.text:{relative_addr:#x},{global_flag},{type_flag}")

            if i > 1 and i % 1000 == 0:
                # too long, so let's commit
                apply_symbol(fname, cmd_string_arr, text_base)
                # re-init
                fname = create_blank_elf(text_base)
                cmd_string_arr = []

        # commit remain
        if cmd_string_arr:
            apply_symbol(fname, cmd_string_arr, text_base)

        info("{:d} entries were processed".format(i + 1))
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        if is_32bit() and args.function_addr > 0xffffffff:
            err("function address must be 0xffffffff or less")
            return
        if is_64bit() and args.function_addr > 0xffffffffffffffff:
            err("function address must be 0xffffffffffffffff or less")
            return

        function_info = []
        typ = None
        function_info.append((args.function_name, args.function_addr, typ))
        self.add_symbol_temp(function_info)
        return


@register_command
class KsymaddrRemoteApplyCommand(GenericCommand):
    """Apply symbol from kallsyms in memory."""
    _cmdline_ = "ksymaddr-remote-apply"
    _category_ = "08-b. Qemu-system Cooperation - Linux"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        info("Wait for memory scan")
        res = gdb.execute("ksymaddr-remote --print-all", to_string=True)
        function_info = []
        for entry in res.splitlines():
            r = re.findall(r"(0x\w+) (\w) (\w+)", entry)
            if not r:
                continue
            addr = int(r[0][0], 16)
            typ = r[0][1]
            func_name = r[0][2]
            if addr == 0:
                continue
            function_info.append((func_name, addr, typ))
        if len(function_info) > 0:
            AddSymbolTemporaryCommand.add_symbol_temp(function_info)
            info("Done. Try `p FUNCTION_NAME`")
        return


@register_command
class WalkLinkListCommand(GenericCommand):
    """Walk the link list."""
    _cmdline_ = "walk-link-list"
    _category_ = "03-a. Memory - Search"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-o', dest='next_offset', type=parse_address, default=0,
                        help="offset of the next(or prev) poiter in the target structure.")
    parser.add_argument('address', metavar='ADDRESS', type=parse_address, help="start address you want to walk.")
    _syntax_ = parser.format_help()

    _example_ = "{:s} 0xffff9c60800597e0      # walk list_head.next\n".format(_cmdline_)
    _example_ += "{:s} -o 8 0xffff9c60800597e0 # walk list_head.prev".format(_cmdline_)

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def walk_link_list(self, head, offset):
        current = head
        seen = [current]
        idx = 1
        while True:
            try:
                flink = read_int_from_memory(current + offset)
            except Exception:
                err("memory corrupted")
                return
            gef_print("[{:d}]   -> {:#x}".format(idx, flink))
            if flink == 0:
                break
            if flink == head:
                break
            if flink in seen[1:]:
                err("loop detected")
                break
            seen.append(current)
            current = flink
            idx += 1
        return

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()
        info("head address: {:#x}".format(args.address))
        info("next pointer offset: {:#x}".format(args.next_offset))
        self.walk_link_list(args.address, args.next_offset)
        return


@register_command
class PeekPointersCommand(GenericCommand):
    """Find pointers belonging to other memory regions.."""
    _cmdline_ = "peek-pointers"
    _category_ = "03-a. Memory - Search"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('address', metavar='ADDRESS', type=parse_address, help="search start address.")
    parser.add_argument('name', metavar='NAME', nargs='?', help="what area to search. (default: all area)")
    parser.add_argument('-n', '--no-pager', action='store_true', help='do not use less.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} 0x00007ffffffde000          # begin address of stack region\n".format(_cmdline_)
    _example_ += "{:s} 0x00007ffffffde000 vdso     # grep by `vdso` area".format(_cmdline_)

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()

        addr = lookup_address(args.address)
        if (addr.value % gef_getpagesize()):
            err("address must be aligned to a page")
            return
        if addr.section is None:
            err("{:#x} does not exist".format(addr.value))
            return

        vmmap = get_process_maps()

        if args.name:
            section_name = args.name
            if section_name == "stack":
                sections = [(s.path, s.page_start, s.page_end) for s in vmmap if s.path == "[stack]"]
            elif section_name == "heap":
                sections = [(s.path, s.page_start, s.page_end) for s in vmmap if s.path == "[heap]"]
            else:
                sections = [(s.path, s.page_start, s.page_end) for s in vmmap if section_name in s.path]
        else:
            sections = [(s.path, s.page_start, s.page_end) for s in vmmap]

        data = read_memory(addr.section.page_start, addr.section.size)
        data = slice_unpack(data, current_arch.ptrsize)

        out = []
        for off, addr_value in enumerate(data):
            addr_v = lookup_address(addr_value)
            if not addr_v:
                continue

            for i, section in enumerate(sections):
                name, start_addr, end_addr = section
                if not (start_addr <= addr_value < end_addr):
                    continue
                sym = gdb_get_location_from_symbol(addr_value)
                sym = "<{:s}+{:04x}>".format(*sym) if sym else ''
                if name.startswith("/"):
                    name = os.path.basename(name)
                elif len(name) == 0:
                    name = get_filename()
                addr_pos = addr.value + off * current_arch.ptrsize
                perm = addr_v.section.permission
                perm_s = str(perm)

                line_color = ""
                if name == "[stack]":
                    line_color = get_gef_setting("theme.address_stack")
                elif name == "[heap]":
                    line_color = get_gef_setting("theme.address_heap")
                elif perm.value & Permission.READ and perm.value & Permission.EXECUTE:
                    line_color = get_gef_setting("theme.address_code")

                search_area = "Found at {:#x}".format(addr_pos)
                found_area = "{:#x} {:s} ('{:s}', perm: {:s})".format(addr_value, sym, name, perm_s)
                found_area = Color.colorify(found_area, line_color)
                out.append("{:s} {:s}".format(search_area, found_area))
                break

        gef_print('\n'.join(out), less=not args.no_pager)
        return


@register_command
class CurrentFrameStackCommand(GenericCommand):
    """Show the entire stack of the current frame."""
    _cmdline_ = "current-stack-frame"
    _category_ = "02-d. Process Information - Trivial Information"
    _aliases_ = ["stack", "full-stack"]

    parser = argparse.ArgumentParser(prog=_cmdline_)
    _syntax_ = parser.format_help()

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        ptrsize = current_arch.ptrsize
        try:
            frame = gdb.selected_frame()
        except Exception:
            # For unknown reasons, gdb.selected_frame() may cause an error (often occurs during kernel startup).
            err("Faild to get frame information")
            return

        if not frame.older():
            reason_str = gdb.frame_stop_reason_string(frame.unwind_stop_reason())
            warn("Cannot determine frame boundary, reason: {:s}".format(reason_str))
            return

        saved_ip = frame.older().pc()
        stack_hi = int(frame.older().read_register("sp"))
        stack_lo = int(frame.read_register("sp"))
        should_stack_grow_down = get_gef_setting("context.grow_stack_down") is True
        results = []

        for offset, address in enumerate(range(stack_lo, stack_hi, ptrsize)):
            pprint_str = DereferenceCommand.pprint_dereferenced(stack_lo, offset)
            if dereference(address) == saved_ip:
                pprint_str += " " + Color.colorify("($savedip)", attrs="gray underline")
            results.append(pprint_str)

        if should_stack_grow_down:
            results.reverse()
            gef_print(titlify("Stack top (higher address)"))
        else:
            gef_print(titlify("Stack top (lower address)"))

        for res in results:
            gef_print(res)

        if should_stack_grow_down:
            gef_print(titlify("Stack bottom (lower address)"))
        else:
            gef_print(titlify("Stack bottom (higher address)"))
        return


@register_command
class XRefTelescopeCommand(SearchPatternCommand):
    """Recursively search for cross-references to a pattern in memory."""
    _cmdline_ = "xref-telescope"
    _category_ = "03-a. Memory - Search"
    _aliases_ = []

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('pattern', metavar='PATTERN', help="search pattern.")
    parser.add_argument('depth', metavar='DEPTH', nargs='?', type=int, default=3,
                        help="max recursive depth. (default: %(default)s)")
    parser.add_argument('-n', '--no-pager', action='store_true', help='do not use less.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} AAAAAAAA\n".format(_cmdline_)
    _example_ += "{:s} 0x555555554000 15".format(_cmdline_)

    def xref_telescope(self, pattern, depth, tree_heading):
        """Recursively search a pattern within the whole userland memory."""
        if depth <= 0:
            return

        if is_hex(pattern):
            if get_endian() == Elf.BIG_ENDIAN:
                pattern = "".join(["\\x" + pattern[i:i + 2] for i in range(2, len(pattern), 2)])
            else:
                pattern = "".join(["\\x" + pattern[i:i + 2] for i in range(len(pattern) - 2, 0, -2)])

        locs = []
        for section in get_process_maps():
            if not section.permission & Permission.READ:
                continue
            if section.path == "[vvar]":
                continue

            start = section.page_start
            end = section.page_end

            locs += self.search_pattern_by_address(pattern, start, end)
        if tree_heading == "":
            self.out.append(" .")
        for i, loc in enumerate(locs):
            addr_loc_start = lookup_address(loc[0])
            path = addr_loc_start.section.path
            perm = addr_loc_start.section.permission
            if i == len(locs) - 1:
                tree_suffix_pre = " +--"
                tree_suffix_post = "    "
            else:
                tree_suffix_pre = " +--"
                tree_suffix_post = " |  "

            fmt = '{} {:#x} {} {} "{}"'
            msg = fmt.format(tree_heading + tree_suffix_pre, loc[0], Color.blueify(path), perm, Color.pinkify(loc[2]))
            self.out.append(msg)
            self.xref_telescope(hex(loc[0]), depth - 1, tree_heading + tree_suffix_post)
        return

    @parse_args
    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, args):
        self.dont_repeat()
        self.out = []
        self.out.append("Recursively searching '{:s}' in memory".format(Color.yellowify(args.pattern)))
        self.xref_telescope(args.pattern, args.depth, "")
        gef_print('\n'.join(self.out), less=not args.no_pager)
        return


@register_command
class BytearrayCommand(GenericCommand):
    """Generate a bytearray to be compared with possible badchars (ported from mona.py)."""
    _cmdline_ = "bytearray"
    _category_ = "09-c. Misc - Generation"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('-b', dest='badchars', default=[], action='append', help='characters to exclude.')
    parser.add_argument('-d', dest='dump', action='store_true', help='dump to /tmp/gef/bytearray.{txt,bin}.')
    _syntax_ = parser.format_help()

    _example_ = "{:s} -b 414243 -b 51-53 -b 61..63".format(_cmdline_)

    def expand_hex(self, x):
        """4142..45 -> 4142434445"""
        if ".." not in x:
            return x

        if len(x) < 6:
            return False

        if "..." in x:
            return False

        while ".." in x:
            pos = x.find("..")
            if pos % 2 != 0:
                return False

            if pos < 2 or len(x) - 4 < pos:
                return False

            xa, xb = int(x[pos - 2:pos], 16), int(x[pos + 2:pos + 4], 16)
            if xa >= xb:
                return False
            middle = ''.join("{:02x}".format(c) for c in range(xa, xb))
            x = x[:pos - 2] + middle + x[pos + 2:]
        return x

    @parse_args
    def do_invoke(self, args):
        self.dont_repeat()

        excluded = set()
        for b in args.badchars:
            b = b.lower().replace("-", "..")

            if not re.match(r"[0-9a-f]+", b):
                err("{:s} is not valid hex (not match `[0-9a-f]+`)".format(b))
                return

            if (len(b) % 2) != 0:
                err("{:s} is not valid hex (odd length)".format(b))
                return

            eb = self.expand_hex(b)
            if eb is False:
                err("{:s} is not valid hex (failed to expand `..`)".format(b))
                return

            excluded |= set([int(c, 16) for c in slicer(eb, 2)])

        info("Generating table, excluding {:d} bad chars...".format(len(excluded)))

        included = set(range(0, 256)) - excluded
        included = sorted(list(included))

        if len(included) == 0:
            info("Nothing to dump")
            return

        info("Dumping table.")
        outt_arr = []
        outb_arr = []
        for c in included:
            outt_arr.append("\\x{:02x}".format(c))
            outb_arr.append(bytes([c]))

        bytesperline = 32
        outt = ""
        for s in slicer(outt_arr, bytesperline):
            outt += '"{:s}"\n'.format("".join(s))
        outb = b"".join(outb_arr)

        gef_print(outt.rstrip())

        if args.dump:
            arrayfile = os.path.join(GEF_TEMP_DIR, "bytearray.txt")
            open(arrayfile, "w").write(outt)
            info("Done, wrote {:d} bytes to file {:s}".format(len(outt_arr), arrayfile))
            binfilename = os.path.join(GEF_TEMP_DIR, "bytearray.bin")
            open(binfilename, "wb").write(outb)
            info("Binary output saved in {:s}".format(binfilename))
        return


@register_command
class BincompareCommand(GenericCommand):
    """Compare an binary file with the memory position looking for badchars."""
    _cmdline_ = "bincompare"
    _category_ = "03-d. Memory - Calculation"

    parser = argparse.ArgumentParser(prog=_cmdline_)
    parser.add_argument('filename', metavar='FILENAME', help="specifies the binary file to be compared")
    parser.add_argument('address', metavar='ADDRESS', type=parse_address, help="sepecifies the memory address.")
    parser.add_argument('size', metavar='SIZE', nargs='?', type=parse_address, help="sepecifies the size.")
    parser.add_argument('--file-offset', type=parse_address, help="sepecifies the file offset.")
    _syntax_ = parser.format_help()

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_FILENAME)
        return

    @parse_args
    @only_if_gdb_running
    def do_invoke(self, args):
        self.dont_repeat()

        # file_data
        if not os.path.isfile(args.filename):
            err("Especified file '{:s}' not exists".format(args.filename))
            return
        file_data = open(args.filename, "rb").read()
        if args.file_offset:
            file_data = file_data[args.file_offset:]
        file_size = len(file_data)

        # size
        if args.size is None:
            size = file_size
        else:
            if args.size > file_size:
                err("file size is too short")
                return
            size = args.size
            file_data = file_data[:size]

        if size == 0:
            err("comparing size is 0, nothing to do.")
            return

        # memory_data
        try:
            memory_data = read_memory(args.address, size)
        except gdb.MemoryError:
            err("Cannot reach memory {:#x}".format(args.address))
            return

        self.compare(file_data, memory_data)
        return

    def compare(self, file_data, memory_data):
        result_table = []
        badchars = ""
        cnt = 0
        corrupted = -1
        for eachByte in file_data:
            hexchar = "{:02x}".format(eachByte)
            if cnt > len(memory_data):
                result_table.append((hexchar, "--"))
                corrupted = -1
            elif eachByte == memory_data[cnt]:
                result_table.append((hexchar, "  "))
                corrupted = -1
            else:
                result_table.append((hexchar, "{:02x}".format(memory_data[cnt])))
                if len(badchars) == 0:
                    badchars = hexchar
                else:
                    badchars += ", " + hexchar
                if corrupted == -1:
                    corrupted = cnt
            cnt += 1

        line = 0

        info("Comparison result:")
        gef_print("    +-----------------------------------------------+")
        for line in range(0, len(result_table), 16):
            pdata1 = []
            pdata2 = []
            for i in range(line, line + 16):
                if i < len(result_table):
                    pdata1.append(result_table[i][0])
                    pdata2.append(result_table[i][1])

            self.print_line("{:02x}".format(line), pdata1, "file")
            self.print_line("  ", pdata2, "memory")

        gef_print("    +-----------------------------------------------+")
        gef_print("")

        if corrupted > -1:
            info("Corruption after {:d} bytes".format(corrupted))

        if badchars == "":
            info("No badchars found!")
        else:
            info("Badchars found: {:s}".format(badchars))
        return

    def print_line(self, prefix, data, label):
        line = []
        for d in data:
            line.append(d)
        r = 16 - len(line)
        for i in range(0, r):
            line.append("--")

        fmt = " {:s} |{:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s}| {:s}"
        gef_print(fmt.format(prefix, *line, label))
        return


class GenericFunction(gdb.Function):
    """This is an abstract class for invoking convenience functions, should not be instantiated."""
    __metaclass__ = abc.ABCMeta

    @abc.abstractproperty
    def _function_(self):
        return

    @property
    def _syntax_(self):
        return "${}([offset])".format(self._function_)

    def __init__(self):
        super().__init__(self._function_)
        return

    def invoke(self, *args):
        if not is_alive():
            raise gdb.GdbError("No debugging session active")
        return int(self.do_invoke(args))

    def arg_to_long(self, args, index, default=0):
        try:
            addr = args[index]
            return int(addr) if addr.address is None else int(addr.address)
        except IndexError:
            return default

    @abc.abstractmethod
    def do_invoke(self, args):
        return


@register_command
class GefFunctionsCommand(GenericCommand):
    """List the convenience functions provided by GEF."""
    _cmdline_ = "functions"
    _syntax_ = _cmdline_
    _category_ = "99. GEF Maintenance Command"

    def __init__(self):
        super().__init__()
        self.docs = []
        self.setup()
        return

    def setup(self):
        global __gef__
        for function in __gef__.loaded_functions:
            self.add_function_to_doc(function)
        self.__doc__ = "\n".join(sorted(self.docs))
        return

    def add_function_to_doc(self, function):
        """Add function to documentation."""
        doc = getattr(function, "__doc__", "").lstrip()
        doc = "\n                         ".join(doc.split("\n"))
        syntax = getattr(function, "_syntax_", "").lstrip()
        msg = "{syntax:<25s} -- {help:s}".format(syntax=syntax, help=Color.greenify(doc))
        self.docs.append(msg)
        return

    def do_invoke(self, argv):
        self.dont_repeat()
        gef_print(titlify("GEF - Convenience Functions"))
        gef_print("These functions can be used as arguments to other "
                  "commands to dynamically calculate values, eg: {:s}\n"
                  .format(Color.colorify("deref $_heap(0x20)", "yellow")))
        gef_print(self.__doc__)
        return

class GefCommand(gdb.Command):
    """GEF main command: view all new commands by typing `gef`."""
    _cmdline_ = "gef"
    _syntax_ = "{:s} (missing|config|save|restore|set|run)".format(_cmdline_)
    _category_ = "99. GEF Maintenance Command"

    def __init__(self):
        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_NONE, True)
        set_gef_setting("gef.follow_child", True, bool, "Automatically set GDB to follow child when forking")
        set_gef_setting("gef.readline_compat", False, bool, "Workaround for readline SOH/ETX issue (SEGV)")
        set_gef_setting("gef.debug", True, bool, "Enable debug mode for gef")
        set_gef_setting("gef.autosave_breakpoints_file", "", str, "Automatically save and restore breakpoints")
        set_gef_setting("gef.extra_plugins_dir", "", str, "Autoload additional GEF commands from external directory")
        set_gef_setting("gef.disable_color", False, bool, "Disable all colors in GEF")
        set_gef_setting("gef.tempdir", GEF_TEMP_DIR, str, "Directory to use for temporary/cache content")
        self.loaded_commands = []
        self.loaded_functions = []
        self.missing_commands = {}
        return

    def setup(self):
        self.load(initial=True)
        # loading GEF sub-commands
        self.doc = GefHelpCommand(self.loaded_commands)
        self.cfg = GefConfigCommand(self.loaded_command_names)
        GefSaveCommand()
        GefRestoreCommand()
        GefMissingCommand()
        GefSetCommand()
        GefRunCommand()

        # load the saved settings
        gdb.execute("gef restore")

        # restore the autosave/autoreload breakpoints policy (if any)
        self.__reload_auto_breakpoints()

        # load plugins from `extra_plugins_dir`
        if self.__load_extra_plugins() > 0:
            # if here, at least one extra plugin was loaded, so we need to restore
            # the settings once more
            gdb.execute("gef restore quiet")
        return

    def __reload_auto_breakpoints(self):
        bkp_fname = __config__.get("gef.autosave_breakpoints_file", None)
        bkp_fname = bkp_fname[0] if bkp_fname else None
        if bkp_fname:
            # restore if existing
            if os.access(bkp_fname, os.R_OK):
                gdb.execute("source {:s}".format(bkp_fname))

            # add hook for autosave breakpoints on quit command
            source = [
                "define hook-quit",
                " save breakpoints {:s}".format(bkp_fname),
                "end",
            ]
            gef_execute_gdb_script("\n".join(source) + "\n")
        return

    def __load_extra_plugins(self):
        nb_added = -1
        try:
            nb_inital = len(self.loaded_commands)
            directories = get_gef_setting("gef.extra_plugins_dir")
            if directories:
                for directory in directories.split(";"):
                    directory = os.path.realpath(os.path.expanduser(directory))
                    if os.path.isdir(directory):
                        sys.path.append(directory)
                        for fname in os.listdir(directory):
                            if not fname.endswith(".py"):
                                continue
                            fpath = "{:s}/{:s}".format(directory, fname)
                            if os.path.isfile(fpath):
                                gdb.execute("source {:s}".format(fpath))
            nb_added = len(self.loaded_commands) - nb_inital
            if nb_added > 0:
                ok("{:s} extra commands added from '{:s}'".format(Color.colorify(nb_added, "bold green"),
                                                                  Color.colorify(directories, "bold blue")))
        except gdb.error as e:
            err("failed: {}".format(str(e)))
        return nb_added

    @property
    def loaded_command_names(self):
        return [x[0] for x in self.loaded_commands]

    def invoke(self, args, from_tty):
        self.dont_repeat()
        gdb.execute("gef help")
        return

    def load(self, initial=False):
        """Load all the commands and functions defined by GEF into GDB."""
        nb_missing = 0
        self.commands = [(x._cmdline_, x) for x in __commands__]

        # load all of the functions
        for function_class_name in __functions__:
            self.loaded_functions.append(function_class_name())

        def is_loaded(x):
            return any(filter(lambda u: x == u[0], self.loaded_commands))

        time_elapsed = []
        for cmd, class_name in self.commands:
            if is_loaded(cmd):
                continue

            try:
                start_time_real = time.perf_counter()
                start_time_proc = time.process_time()
                self.loaded_commands.append((cmd, class_name, class_name()))
                end_time_real = time.perf_counter()
                end_time_proc = time.process_time()
                time_elapsed.append((cmd, end_time_real - start_time_real, end_time_proc - start_time_proc))

                repeat = False
                if hasattr(class_name, "_repeat_"):
                    repeat = getattr(class_name, "_repeat_")

                if hasattr(class_name, "_aliases_"):
                    aliases = getattr(class_name, "_aliases_")
                    for alias in aliases:
                        GefAlias(alias, cmd, repeat=repeat)

            except Exception as reason:
                self.missing_commands[cmd] = reason
                nb_missing += 1

        if False: # debug print
            print(titlify("Top 10 commands that took the longest to load"))
            for cmd, real, cpu in sorted(time_elapsed, key=lambda x: x[1], reverse=True)[:10]:
                print("{:30s} Real:{:.10f} s, CPU:{:.10f} s".format(cmd, real, cpu))

        # sort by command name
        self.loaded_commands = sorted(self.loaded_commands, key=lambda x: x[1]._cmdline_)

        if initial:
            gef_print("{:s} for {:s} ready, type `{:s}' to start, `{:s}' to configure".format(
                Color.greenify("GEF"),
                get_os(),
                Color.colorify("gef", "underline yellow"),
                Color.colorify("gef config", "underline pink")
            ))

            ver = "{:d}.{:d}".format(sys.version_info.major, sys.version_info.minor)
            nb_cmds = len(self.loaded_commands)
            gef_print("{:s} commands loaded for GDB {:s} using Python engine {:s}".format(
                Color.colorify(nb_cmds, "bold green"),
                Color.colorify(gdb.VERSION, "bold yellow"),
                Color.colorify(ver, "bold red")
            ))

            if nb_missing:
                warn("{:s} command{} could not be loaded, run `{:s}` to know why.".format(
                    Color.colorify(nb_missing, "bold red"),
                    "s" if nb_missing > 1 else "",
                    Color.colorify("gef missing", "underline pink")
                ))
        return


class GefHelpCommand(gdb.Command):
    """GEF help sub-command."""
    _cmdline_ = "gef help"
    _syntax_ = _cmdline_
    _category_ = "99. GEF Maintenance Command"

    def __init__(self, commands, *args, **kwargs):
        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_NONE, False)
        self.docs = []
        self.generate_help(commands)
        self.refresh()
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()
        gef_print(titlify("GEF - GDB Enhanced Features"))
        gef_print(self.__doc__)
        return

    def generate_help(self, commands):
        """Generate builtin commands documentation."""
        for command in commands:
            self.add_command_to_doc(command)
        return

    def add_command_to_doc(self, command):
        """Add command to GEF documentation."""
        cmd, class_name, _ = command
        if " " in cmd:
            # do not print subcommands in gef help
            return
        doc = getattr(class_name, "__doc__", "").lstrip()
        doc = "\n                         ".join(doc.split("\n"))
        if hasattr(class_name, "_aliases_") and class_name._aliases_ != []:
            aliases = " (alias: {:s})".format(", ".join(class_name._aliases_))
        else:
            aliases = ""
        msg = "  {cmd:<23s} -- {help:s}{aliases:s}".format(cmd=cmd, help=Color.greenify(doc), aliases=aliases)
        category = class_name._category_ if hasattr(class_name, "_category_") else "Uncategorized"

        self.docs.append([category, msg])
        return

    def refresh(self):
        """Refresh the documentation."""
        newdoc = ""
        old_category = None
        for category, msg in sorted(self.docs):
            if old_category is None or old_category.split("-")[0] != category.split("-")[0] and "." in category:
                newdoc += titlify(category.split(". ")[1].split(" - ")[0]) + "\n"
            if old_category != category:
                newdoc += "[{:s}]\n".format(Color.colorify(category, "bold yellow"))
            old_category = category
            newdoc += msg + "\n"
        self.__doc__ = newdoc.rstrip()
        return


class GefConfigCommand(gdb.Command):
    """GEF configuration sub-command
    This command will help set/view GEF settings for the current debugging session.
    It is possible to make those changes permanent by running `gef save` (refer
    to this command help), and/or restore previously saved settings by running
    `gef restore` (refer help)."""
    _cmdline_ = "gef config"
    _syntax_ = "{:s} [setting_name] [setting_value]".format(_cmdline_)
    _category_ = "99. GEF Maintenance Command"

    def __init__(self, loaded_commands, *args, **kwargs):
        super().__init__(self._cmdline_, gdb.COMMAND_NONE, prefix=False)
        self.loaded_commands = loaded_commands
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()
        argv = gdb.string_to_argv(args)
        argc = len(argv)

        if not (0 <= argc <= 2):
            err("Invalid number of arguments")
            return

        if argc == 0:
            gef_print(titlify("GEF configuration settings"))
            self.print_settings()
            return

        if argc == 1:
            prefix = argv[0]
            names = list(filter(lambda x: x.startswith(prefix), __config__.keys()))
            if names:
                if len(names) == 1:
                    gef_print(titlify("GEF configuration setting: {:s}".format(names[0])))
                    self.print_setting(names[0], verbose=True)
                else:
                    gef_print(titlify("GEF configuration settings matching '{:s}'".format(argv[0])))
                    for name in names:
                        self.print_setting(name)
            return

        self.set_setting(argc, argv)
        return

    def print_setting(self, plugin_name, verbose=False):
        res = __config__.get(plugin_name)
        string_color = get_gef_setting("theme.dereference_string")
        misc_color = get_gef_setting("theme.dereference_base_address")

        if not res:
            return

        _value, _type, _desc = res
        _setting = Color.colorify(plugin_name, "green")
        _type = _type.__name__
        if _type == "str":
            _value = '"{:s}"'.format(Color.colorify(_value, string_color))
        else:
            _value = Color.colorify(_value, misc_color)

        gef_print("{:s} ({:s}) = {:s}".format(_setting, _type, _value))

        if verbose:
            gef_print(Color.colorify("\nDescription:", "bold underline"))
            gef_print("\t{:s}".format(_desc))
        return

    def print_settings(self):
        for x in sorted(__config__):
            self.print_setting(x)
        return

    def set_setting(self, argc, argv):
        global __gef__
        if "." not in argv[0]:
            err("Invalid command format")
            return

        loaded_commands = [x[0].replace(" ", "-") for x in __gef__.loaded_commands] + ["gef"]
        plugin_name = argv[0].split(".", 1)[0]
        if plugin_name not in loaded_commands:
            err("Unknown plugin '{:s}'".format(plugin_name))
            return

        _type = __config__.get(argv[0], [None, None, None])[1]
        if _type is None:
            err("Failed to get '{:s}' config setting".format(argv[0],))
            return

        try:
            if _type == bool:
                _newval = True if argv[1].upper() in ("TRUE", "T", "1") else False
            else:
                _newval = _type(argv[1])

        except Exception:
            err("{} expects type '{}'".format(argv[0], _type.__name__))
            return

        reset_gef_caches()
        __config__[argv[0]][0] = _newval
        get_gef_setting.cache_clear()
        return

    def complete(self, text, word):
        settings = sorted(__config__)

        if text == "":
            # no prefix: example: `gef config TAB`
            return [s for s in settings if word in s]

        if "." not in text:
            # if looking for possible prefix
            return [s for s in settings if s.startswith(text.strip())]

        # finally, look for possible values for given prefix
        return [s.split(".", 1)[1] for s in settings if s.startswith(text.strip())]


class GefSaveCommand(gdb.Command):
    """GEF save sub-command.
    Saves the current configuration of GEF to disk (by default in file '~/.gef.rc')."""
    _cmdline_ = "gef save"
    _syntax_ = _cmdline_
    _category_ = "99. GEF Maintenance Command"

    def __init__(self, *args, **kwargs):
        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_NONE, False)
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()
        cfg = configparser.RawConfigParser()
        old_sect = None

        # save the configuration
        for key in sorted(__config__):
            sect, optname = key.split(".", 1)
            value = __config__.get(key, None)
            value = value[0] if value else None

            if old_sect != sect:
                cfg.add_section(sect)
                old_sect = sect

            cfg.set(sect, optname, value)

        # save the aliases
        cfg.add_section("aliases")
        for alias in __aliases__:
            cfg.set("aliases", alias._alias, alias._command)

        with open(GEF_RC, "w") as fd:
            cfg.write(fd)

        ok("Configuration saved to '{:s}'".format(GEF_RC))
        return


class GefRestoreCommand(gdb.Command):
    """GEF restore sub-command.
    Loads settings from file '~/.gef.rc' and apply them to the configuration of GEF."""
    _cmdline_ = "gef restore"
    _syntax_ = _cmdline_
    _category_ = "99. GEF Maintenance Command"

    def __init__(self, *args, **kwargs):
        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_NONE, False)
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()
        if not os.access(GEF_RC, os.R_OK):
            return

        quiet = args.lower() == "quiet"
        cfg = configparser.ConfigParser()
        cfg.read(GEF_RC)

        for section in cfg.sections():
            if section == "aliases":
                # load the aliases
                for key in cfg.options(section):
                    try:
                        GefAlias(key, cfg.get(section, key))
                    except Exception:
                        pass
                continue

            # load the other options
            for optname in cfg.options(section):
                try:
                    key = "{:s}.{:s}".format(section, optname)
                    _type = __config__.get(key)[1]
                    new_value = cfg.get(section, optname)
                    if _type == bool:
                        new_value = True if new_value == "True" else False
                    else:
                        new_value = _type(new_value)
                    __config__[key][0] = new_value
                except Exception:
                    pass

        # ensure that the temporary directory always exists
        gef_makedirs(__config__["gef.tempdir"][0])

        if not quiet:
            ok("Configuration from '{:s}' restored".format(Color.colorify(GEF_RC, "bold blue")))
        return


class GefMissingCommand(gdb.Command):
    """GEF missing sub-command.
    Display the GEF commands that could not be loaded, along with the reason of why
    they could not be loaded."""
    _cmdline_ = "gef missing"
    _syntax_ = _cmdline_
    _category_ = "99. GEF Maintenance Command"

    def __init__(self, *args, **kwargs):
        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_NONE, False)
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()
        missing_commands = __gef__.missing_commands.keys()
        if not missing_commands:
            ok("No missing command")
            return
        for missing_command in missing_commands:
            reason = __gef__.missing_commands[missing_command]
            warn("Command `{}` is missing, reason {} {}".format(missing_command, RIGHT_ARROW, reason))
        return


class GefSetCommand(gdb.Command):
    """Override GDB set commands with the context from GEF."""
    _cmdline_ = "gef set"
    _syntax_ = "{:s} [GDB_SET_ARGUMENTS]".format(_cmdline_)
    _category_ = "99. GEF Maintenance Command"

    def __init__(self, *args, **kwargs):
        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_SYMBOL, False)
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()
        args = args.split()
        cmd = ["set", args[0]]
        for p in args[1:]:
            if p.startswith("$_gef"):
                c = gdb.parse_and_eval(p)
                cmd.append(c.string())
            else:
                cmd.append(p)

        gdb.execute(" ".join(cmd))
        return


class GefRunCommand(gdb.Command):
    """Override GDB run commands with the context from GEF.
    Simple wrapper for GDB run command to use arguments set from `gef set args`. """
    _cmdline_ = "gef run"
    _syntax_ = "{:s} [GDB_RUN_ARGUMENTS]".format(_cmdline_)
    _category_ = "99. GEF Maintenance Command"

    def __init__(self, *args, **kwargs):
        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_FILENAME, False)
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()
        if is_alive():
            gdb.execute("continue")
            return

        argv = args.split()
        gdb.execute("gef set args {:s}".format(" ".join(argv)))
        gdb.execute("run")
        return


class GefAlias(gdb.Command):
    """Simple aliasing wrapper because GDB doesn't do what it should."""
    _category_ = "99. GEF Maintenance Command"

    def __init__(self, alias, command, repeat=False, completer_class=gdb.COMPLETE_NONE, command_class=gdb.COMMAND_NONE):
        p = command.split()
        if not p:
            return

        if list(filter(lambda x: x._alias == alias, __aliases__)):
            return

        self._command = command
        self._alias = alias
        self._repeat = repeat
        c = command.split()[0]
        r = self.lookup_command(c)
        self.__doc__ = "Alias for '{}'".format(Color.greenify(command))
        if r is not None:
            _instance = r[2]
            self.__doc__ += ": {}".format(_instance.__doc__)

            if hasattr(_instance, "complete"):
                self.complete = _instance.complete

        super().__init__(alias, command_class, completer_class=completer_class)
        __aliases__.append(self)
        return

    def invoke(self, args, from_tty):
        if not self._repeat:
            self.dont_repeat()
        gdb.execute("{} {}".format(self._command, args), from_tty=from_tty)
        return

    def lookup_command(self, cmd):
        global __gef__
        for _name, _class, _instance in __gef__.loaded_commands:
            if cmd == _name:
                return _name, _class, _instance
        return None


@register_command
class AliasesCommand(GenericCommand):
    """Base command to add, remove, or list aliases."""
    _cmdline_ = "aliases"
    _syntax_ = "{:s} (add|rm|ls)".format(_cmdline_)
    _category_ = "99. GEF Maintenance Command"

    def __init__(self, *args, **kwargs):
        prefix = kwargs.get("prefix", True)
        super().__init__(prefix=prefix)
        return

    def do_invoke(self, argv):
        self.dont_repeat()
        self.usage()
        return


@register_command
class AliasesAddCommand(AliasesCommand):
    """Command to add aliases."""
    _cmdline_ = "aliases add"
    _syntax_ = "{:s} [ALIAS] [COMMAND]".format(_cmdline_)
    _example_ = "{:s} scope telescope".format(_cmdline_)
    _category_ = "99. GEF Maintenance Command"

    def __init__(self):
        super().__init__(prefix=False)
        return

    def do_invoke(self, argv):
        self.dont_repeat()
        if (len(argv) < 2):
            self.usage()
            return
        GefAlias(argv[0], " ".join(argv[1:]))
        return


@register_command
class AliasesRmCommand(AliasesCommand):
    """Command to remove aliases."""
    _cmdline_ = "aliases rm"
    _syntax_ = "{:s} [ALIAS]".format(_cmdline_)
    _category_ = "99. GEF Maintenance Command"

    def __init__(self):
        super().__init__(prefix=False)
        return

    def do_invoke(self, argv):
        self.dont_repeat()
        global __aliases__
        if len(argv) != 1:
            self.usage()
            return
        try:
            alias_to_remove = next(filter(lambda x: x._alias == argv[0], __aliases__))
            __aliases__.remove(alias_to_remove)
        except (ValueError, StopIteration):
            err("{0} not found in aliases.".format(argv[0]))
            return
        gef_print("You must reload GEF for alias removals to apply.")
        return


@register_command
class AliasesListCommand(AliasesCommand):
    """Command to list aliases."""
    _cmdline_ = "aliases ls"
    _syntax_ = _cmdline_
    _category_ = "99. GEF Maintenance Command"

    def __init__(self):
        super().__init__(prefix=False)
        return

    def do_invoke(self, argv):
        self.dont_repeat()

        ok("Aliases defined:")
        for a in __aliases__:
            gef_print("{:30s} {} {}".format(a._alias, RIGHT_ARROW, a._command))
        return


def __gef_prompt__(current_prompt):
    """GEF custom prompt function."""
    if get_gef_setting("gef.readline_compat") is True:
        return GEF_PROMPT
    if get_gef_setting("gef.disable_color") is True:
        return GEF_PROMPT
    if is_alive():
        return GEF_PROMPT_ON
    return GEF_PROMPT_OFF


def main():
    if sys.version_info[0] == 2:
        err("GEF has dropped Python2 support for GDB when it reached EOL on 2020/01/01.")
        err("If you require GEF for GDB+Python2, use https://github.com/hugsy/gef-legacy.")
        return

    if GDB_VERSION < GDB_MIN_VERSION:
        err("You're using an old version of GDB. GEF will not work correctly. "
            "Consider updating to GDB {} or higher.".format(".".join(map(str, GDB_MIN_VERSION))))
        return

    try:
        pyenv = which("pyenv")
        PYENV_ROOT = gef_pystring(subprocess.check_output([pyenv, "root"]).strip())
        PYENV_VERSION = gef_pystring(subprocess.check_output([pyenv, "version-name"]).strip())
        site_packages_dir = os.path.join(PYENV_ROOT, "versions", PYENV_VERSION, "lib",
                                         "python{}".format(PYENV_VERSION[:3]), "site-packages")
        site.addsitedir(site_packages_dir)
    except FileNotFoundError:
        pass

    # When using a Python virtual environment, GDB still loads the system-installed Python
    # so GEF doesn't load site-packages dir from environment
    # In order to fix it, from the shell with venv activated we run the python binary,
    # take and parse its path, add the path to the current python process using sys.path.extend

    try:
        pythonbin = which("python3")
        cmds = [pythonbin, '-c', 'import os, sys;print((sys.prefix))']
        PREFIX = gef_pystring(subprocess.check_output(cmds)).strip("\\n")
        if PREFIX != sys.base_prefix:
            cmds = [pythonbin, "-c", "import os, sys;print(os.linesep.join(sys.path).strip())"]
            SITE_PACKAGES_DIRS = subprocess.check_output(cmds).decode("utf-8").split()
            sys.path.extend(SITE_PACKAGES_DIRS)
    except FileNotFoundError:
        pass

    # create tmp dir
    if not os.path.exists(GEF_TEMP_DIR):
        os.mkdir(GEF_TEMP_DIR)

    # setup prompt
    gdb.prompt_hook = __gef_prompt__

    # setup config
    gdb.execute("set confirm off")
    gdb.execute("set verbose off")
    gdb.execute("set pagination off")
    gdb.execute("set print elements 0")

    # gdb history
    gdb.execute("set history save on")
    gdb.execute("set history filename ~/.gdb_history")

    # gdb input and output bases
    gdb.execute("set output-radix 0x10")

    # pretty print
    gdb.execute("set print pretty on")

    # array print
    gdb.execute("set print array on")
    gdb.execute("set print array-indexes on")

    try:
        # this will raise a gdb.error unless we're on x86
        gdb.execute("set disassembly-flavor intel")
    except gdb.error:
        # we can safely ignore this
        pass

    # SIGALRM will simply display a message, but gdb won't forward the signal to the process
    gdb.execute("handle SIGALRM print nopass")

    # SIGSEGV/SIGTERM/SIG32(for thread creation)
    gdb.execute("handle SIGSEGV print nopass")
    gdb.execute("handle SIGTERM print nopass")
    gdb.execute("handle SIG32 nostop")

    # demangle
    gdb.execute("set print asm-demangle on")

    # frame args
    gdb.execute("set print frame-arguments all")

    # object/vtbl
    gdb.execute("set print object on")
    gdb.execute("set print vtbl on")

    # load GEF
    global __gef__
    __gef__ = GefCommand()
    __gef__.setup()

    gdb.execute("save gdb-index {}".format(get_gef_setting("gef.tempdir")))

    # gdb events configuration
    gef_on_continue_hook(continue_handler)
    gef_on_stop_hook(hook_stop_handler)
    gef_on_new_hook(new_objfile_handler)
    gef_on_exit_hook(exit_handler)
    gef_on_memchanged_hook(memchanged_handler)
    gef_on_regchanged_hook(regchanged_handler)

    if gdb.current_progspace().filename is not None:
        # if here, we are sourcing gef from a gdb session already attached
        # we must force a call to the new_objfile handler (see issue #278)
        new_objfile_handler(None)
    return


if __name__ == "__main__":
    main()
